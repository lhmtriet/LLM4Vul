processed_func,target,flaw_line_index,flaw_line
"fn default() -> SecretKey {
        let mut elem = Scalar::default();
        let overflowed = elem.set_b32(
            &[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
              0x00,0x00,0x00,0x00,0x00,0x01]
        );
        debug_assert!(!overflowed);
        debug_assert!(!elem.is_zero());
        SecretKey(elem)
    }",0,,
"fn on_initialize(_: T::BlockNumber) -> Weight {
			Pending::<T>::kill();

			// If the digest contain an existing ethereum block(encoded as PreLog), If contains,
			// execute the imported block firstly and disable transact dispatch function.
			if let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {
				let PreLog::Block(block) = log;

				for transaction in block.transactions {
					let source = Self::recover_signer(&transaction).expect(
						""pre-block transaction signature invalid; the block cannot be built"",
					);

					Self::do_transact(source, transaction).expect(
						""pre-block transaction verification failed; the block cannot be built"",
					);
				}
			}

			0
		}",1,13,"					Self::do_transact(source, transaction).expect("
"fn detect_invalid_last_symbol_every_possible_two_symbols() {
        let mut base64_to_bytes = ::std::collections::HashMap::new();

        for b in 0_u16..256 {
            let mut b64 = vec![0_u8; 4];
            assert_eq!(4, encode_config_slice(&[b as u8], STANDARD, &mut b64[..]));
            let mut v = ::std::vec::Vec::with_capacity(1);
            v.push(b as u8);

            assert!(base64_to_bytes.insert(b64, v).is_none());
        }

        // every possible combination of symbols must either decode to 1 byte or get InvalidLastSymbol

        let mut symbols = [0_u8; 4];
        for &s1 in STANDARD.char_set.encode_table().iter() {
            symbols[0] = s1;
            for &s2 in STANDARD.char_set.encode_table().iter() {
                symbols[1] = s2;
                symbols[2] = PAD_BYTE;
                symbols[3] = PAD_BYTE;

                match base64_to_bytes.get(&symbols[..]) {
                    Some(bytes) => {
                        assert_eq!(Ok(bytes.to_vec()), decode_config(&symbols, STANDARD))
                    }
                    None => assert_eq!(
                        Err(DecodeError::InvalidLastSymbol(1, s2)),
                        decode_config(&symbols[..], STANDARD)
                    ),
                }
            }
        }
    }",0,,
"fn test_load_elf_rodata() {
    // checks that the program loads the correct rodata offset with both
    // borrowed and owned rodata
    for optimize_rodata in [false, true] {
        let config = Config {
            optimize_rodata,
            ..Config::default()
        };
        test_interpreter_and_jit_elf!(
            ""tests/elfs/rodata.so"",
            config,
            [],
            (),
            0,
            { |_vm, res: Result| { res.unwrap() == 42 } },
            3
        );
    }
}",0,,
"async fn accept(&mut self) -> TResult<SslStream<TcpStream>> {
        let mut backoff = 1;
        loop {
            match self.base.listener.accept().await {
                // We don't need the bindaddr
                // We get the encrypted stream which we need to decrypt
                // by using the acceptor
                Ok((stream, _)) => {
                    let ssl = Ssl::new(self.acceptor.context())?;
                    let mut stream = SslStream::new(ssl, stream)?;
                    Pin::new(&mut stream).accept().await?;
                    return Ok(stream);
                }
                Err(e) => {
                    if backoff > 64 {
                        // Too many retries, goodbye user
                        return Err(e.into());
                    }
                }
            }
            // Wait for the `backoff` duration
            time::sleep(Duration::from_secs(backoff)).await;
            // We're using exponential backoff
            backoff *= 2;
        }
    }",0,,
"fn test_tcp_port80_nomatch_proto() {
    test_interpreter_and_jit_asm!(
        PROG_TCP_PORT_80,
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x06, //
            0x07, 0x08, 0x09, 0x0a, 0x08, 0x00, 0x45, 0x00, //
            0x00, 0x56, 0x00, 0x01, 0x00, 0x00, 0x40, 0x11, //
            0xf9, 0x4d, 0xc0, 0xa8, 0x00, 0x01, 0xc0, 0xa8, //
            0x00, 0x02, 0x27, 0x10, 0x00, 0x50, 0x00, 0x00, //
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02, //
            0x20, 0x00, 0xc5, 0x18, 0x00, 0x00, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        9
    );
}",0,,
"pub fn new(tunables: &Tunables, features: &WasmFeatures) -> Self {
        Self {
            result: ModuleTranslation::default(),
            results: Vec::with_capacity(1),
            in_progress: Vec::new(),
            modules_to_be: 1,
            types: Default::default(),
            tunables: tunables.clone(),
            features: *features,
            first_module: true,
            interned_func_types: Default::default(),
        }
    }",0,,
"fn test_dynamic_stack_frames_empty() {
    let config = Config {
        dynamic_stack_frames: true,
        ..Config::default()
    };

    // Check that unless explicitly resized the stack doesn't grow
    test_interpreter_and_jit_asm!(
        ""
        call foo
        exit
        foo:
        mov r0, r10
        exit"",
        config,
        [],
        (),
        0,
        { |_vm, res: Result| res.unwrap() == ebpf::MM_STACK_START + config.stack_size() as u64 },
        4
    );
}",0,,
"fn show_rru(&self, mb_rru: Option<&RealRegUniverse>) -> String {
        use std::fmt::Write;

        let mut s = String::new();
        write!(&mut s, ""VCode_ShowWithRRU {{{{\n"").unwrap();
        write!(&mut s, ""  Entry block: {}\n"", self.entry).unwrap();

        let mut state = Default::default();
        let mut safepoint_idx = 0;
        for i in 0..self.num_blocks() {
            let block = i as BlockIndex;

            write!(&mut s, ""Block {}:\n"", block).unwrap();
            if let Some(bb) = self.bindex_to_bb(block) {
                write!(&mut s, ""  (original IR block: {})\n"", bb).unwrap();
            }
            for succ in self.succs(block) {
                write!(&mut s, ""  (successor: Block {})\n"", succ.get()).unwrap();
            }
            let (start, end) = self.block_ranges[block as usize];
            write!(&mut s, ""  (instruction range: {} .. {})\n"", start, end).unwrap();
            for inst in start..end {
                if safepoint_idx < self.safepoint_insns.len()
                    && self.safepoint_insns[safepoint_idx] == inst
                {
                    write!(
                        &mut s,
                        ""      (safepoint: slots {:?} with EmitState {:?})\n"",
                        self.safepoint_slots[safepoint_idx], state,
                    )
                    .unwrap();
                    safepoint_idx += 1;
                }
                write!(
                    &mut s,
                    ""  Inst {}:   {}\n"",
                    inst,
                    self.insts[inst as usize].pretty_print(mb_rru, &mut state)
                )
                .unwrap();
            }
        }

        write!(&mut s, ""}}}}\n"").unwrap();

        s
    }",0,,
"pub(crate) fn comes_from_same_store(&self, store: &StoreOpaque) -> bool {
        match self {
            Val::FuncRef(Some(f)) => f.comes_from_same_store(store),
            Val::FuncRef(None) => true,

            // Integers, floats, vectors, and `externref`s have no association
            // with any particular store, so they're always considered as ""yes I
            // came from that store"",
            Val::I32(_)
            | Val::I64(_)
            | Val::F32(_)
            | Val::F64(_)
            | Val::V128(_)
            | Val::ExternRef(_) => true,
        }
    }",0,,
"fn test_ldxh() {
    test_interpreter_and_jit_asm!(
        ""
        ldxh r0, [r1+2]
        exit"",
        [0xaa, 0xbb, 0x11, 0x22, 0xcc, 0xdd],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2211 } },
        2
    );
}",0,,
"    fn take(&self, count: usize) -> Self {
        let tokens = &self.tokens[..count];

        Input { source: self.source, tokens }
    }",1,3,"        Input { source: self.source, tokens }"
"    fn mul(self, other: &'a Scalar) -> Scalar {
        let mut ret = Scalar::default();
        ret.mul_in_place(self, other);
        ret
    }
}

impl<'a> MulAssign<&'a Scalar> for Scalar {
    fn mul_assign(&mut self, other: &'a Scalar) {
        let mut ret = Scalar::default();
        ret.mul_in_place(self, other);
        *self = ret;
    }",0,,
"fn test_err_dynamic_stack_ptr_overflow() {
    let config = Config {
        dynamic_stack_frames: true,
        ..Config::default()
    };

    // See the comment in CallFrames::resize_stack() for the reason why it's
    // safe to let the stack pointer overflow

    // stack_ptr -= stack_ptr + 1
    test_interpreter_and_jit_asm!(
        ""
        sub r11, 0x7FFFFFFF
        sub r11, 0x7FFFFFFF
        sub r11, 0x7FFFFFFF
        sub r11, 0x7FFFFFFF
        sub r11, 0x14005
        call foo
        exit
        foo:
        stb [r10], 0
        exit"",
        config,
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, region)
                    if access_type == AccessType::Store && pc == 29 + 7 && vm_addr == u64::MAX && len == 1 && region == ""unknown""
                )
            }
        },
        7
    );
}",0,,
"fn test_mod32() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 5748
        mod32 r0, 92
        mov32 r1, 13
        mod32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x5 } },
        5
    );
}",0,,
"fn clone(&self) -> VMExternRef {
        self.extern_data().increment_ref_count();
        VMExternRef(self.0)
    }",0,,
"pub fn ty(&self) -> ValType {
        match self {
            Val::I32(_) => ValType::I32,
            Val::I64(_) => ValType::I64,
            Val::F32(_) => ValType::F32,
            Val::F64(_) => ValType::F64,
            Val::ExternRef(_) => ValType::ExternRef,
            Val::FuncRef(_) => ValType::FuncRef,
            Val::V128(_) => ValType::V128,
        }
    }",0,,
"    fn func_liveouts(&self) -> RegallocSet<RealReg> {
        self.liveouts.clone()
    }",0,,
"fn diff(
    minus_file: Option<&PathBuf>,
    plus_file: Option<&PathBuf>,
    config: &config::Config,
    writer: &mut dyn Write,
) -> i32 {
    use std::io::BufReader;
    let die = || {
        eprintln!(
            ""\
The main way to use delta is to configure it as the pager for git: \
see https://github.com/dandavison/delta#configuration. \
You can also use delta to diff two files: `delta file_A file_B`.""
        );
        process::exit(config.error_exit_code);
    };
    let diff_command = ""git"";
    let minus_file = minus_file.unwrap_or_else(die);
    let plus_file = plus_file.unwrap_or_else(die);
    let mut diff_process = process::Command::new(PathBuf::from(diff_command))
        .args(&[""diff"", ""--no-index""])
        .args(&[minus_file, plus_file])
        .stdout(process::Stdio::piped())
        .spawn()
        .unwrap_or_else(|err| {
            eprintln!(""Failed to execute the command '{}': {}"", diff_command, err);
            process::exit(config.error_exit_code);
        });

    let exit_code = diff_process
        .wait()
        .unwrap_or_else(|_| {
            delta_unreachable(&format!(""'{}' process not running."", diff_command));
        })
        .code()
        .unwrap_or_else(|| {
            eprintln!(""'{}' process terminated without exit status."", diff_command);
            process::exit(config.error_exit_code);
        });

    if let Err(error) = delta(
        BufReader::new(diff_process.stdout.unwrap()).byte_lines(),
        writer,
        &config,
    ) {
        match error.kind() {
            ErrorKind::BrokenPipe => process::exit(0),
            _ => {
                eprintln!(""{}"", error);
                process::exit(config.error_exit_code);
            }
        }
    };
    exit_code
}",1,19,    let mut diff_process = process::Command::new(PathBuf::from(diff_command))
"fn is_cold(&self, address: H160) -> bool {
		self.substate
			.recursive_is_cold(&|a| a.accessed_addresses.contains(&address))
	}",0,,
"fn test_div64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xc
        lsh r0, 32
        mov r1, 4
        div r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x300000000 } },
        5
    );
}",0,,
"    pub fn from_mode(
        mode: PagingMode,
        pager: Option<String>,
        config: &config::Config,
    ) -> Result<Self> {
        use self::PagingMode::*;
        Ok(match mode {
            Always => OutputType::try_pager(false, pager, config)?,
            QuitIfOneScreen => OutputType::try_pager(true, pager, config)?,
            _ => OutputType::stdout(),
        })
    }",0,,
"pub fn parse_cmd(cmd_str: &str, _sender_address: AccountAddress) -> Result<ast::Cmd> {
    let stripped_string = &strip_comments(cmd_str);
    let parser = syntax::CmdParser::new();
    match parser.parse(stripped_string) {
        Ok(cmd) => Ok(cmd),
        Err(e) => handle_error(e, cmd_str),
    }
}",1,"1,5","    let stripped_string = &strip_comments(cmd_str);/~/        Err(e) => handle_error(e, cmd_str),"
"    pub fn sqr(&self) -> Scalar {
        let mut ret = Scalar::default();
        ret.sqr_in_place(self);
        ret
    }",0,,
"    fn num_filled_in_bump_chunk(&self) -> usize {
        let next = unsafe { *self.alloc.next.get() };
        let bytes_unused = (self.alloc.end.as_ptr() as usize) - (next.as_ptr() as usize);
        let slots_unused = bytes_unused / mem::size_of::<TableElem>();
        self.alloc.chunk.len().saturating_sub(slots_unused)
    }",0,,
"	fn requests_to_confirm(&self) -> Result<Vec<ConfirmationRequest>, Error> {
		Ok(self.signer.requests()
			.into_iter()
			.map(Into::into)
			.collect()
		)
	}",0,,
"pub fn parse_script_or_module(s: &str) -> Result<ast::ScriptOrModule> {
    let stripped_string = &strip_comments(s);
    let parser = syntax::ScriptOrModuleParser::new();
    match parser.parse(stripped_string) {
        Ok(result) => Ok(result),
        Err(e) => handle_error(e, s),
    }
}",0,,
"pub fn new(report: &'static str, stat: f64) -> Self {
            JSONReportBlock {
                report: report.to_owned(),
                stat,
            }
        }
    }

    /// Run the benchmark tool
    pub fn runner() {
        let cfg_layout = load_yaml!(""./cli.yml"");
        let matches = App::from_yaml(cfg_layout).get_matches();
        let mut host = match matches.value_of(""host"") {
            Some(h) => h.to_owned(),
            None => ""127.0.0.1"".to_owned(),
        };
        host.push(':');
        match matches.value_of(""port"") {
            Some(p) => match p.parse::<u16>() {
                Ok(p) => host.push_str(&p.to_string()),
                Err(_) => {
                    eprintln!(""ERROR: Invalid port"");
                    std::process::exit(0x100);
                }
            },
            None => host.push_str(""2003""),
        }",0,,
"pub fn lookup_frame_info(&self, text_offset: usize) -> Option<FrameInfo> {
        let (index, _func_offset) = self.module.func_by_text_offset(text_offset)?;
        let info = self.module.func_info(index);
        let instr = wasmtime_environ::lookup_file_pos(self.module.address_map_data(), text_offset);

        // In debug mode for now assert that we found a mapping for `pc` within
        // the function, because otherwise something is buggy along the way and
        // not accounting for all the instructions. This isn't super critical
        // though so we can omit this check in release mode.
        debug_assert!(
            instr.is_some(),
            ""failed to find instruction for {:#x}"",
            text_offset
        );

        let instr = instr.unwrap_or(info.start_srcloc);

        // Use our wasm-relative pc to symbolize this frame. If there's a
        // symbolication context (dwarf debug info) available then we can try to
        // look this up there.
        //
        // Note that dwarf pcs are code-section-relative, hence the subtraction
        // from the location of `instr`. Also note that all errors are ignored
        // here for now since technically wasm modules can always have any
        // custom section contents.
        let mut symbols = Vec::new();

        if let Some(s) = &self.module.symbolize_context().ok().and_then(|c| c) {
            if let Some(offset) = instr.file_offset() {
                let to_lookup = u64::from(offset) - s.code_section_offset();
                if let Ok(mut frames) = s.addr2line().find_frames(to_lookup) {
                    while let Ok(Some(frame)) = frames.next() {
                        symbols.push(FrameSymbol {
                            name: frame
                                .function
                                .as_ref()
                                .and_then(|l| l.raw_name().ok())
                                .map(|s| s.to_string()),
                            file: frame
                                .location
                                .as_ref()
                                .and_then(|l| l.file)
                                .map(|s| s.to_string()),
                            line: frame.location.as_ref().and_then(|l| l.line),
                            column: frame.location.as_ref().and_then(|l| l.column),
                        });
                    }
                }
            }
        }

        let module = self.module.module();
        let index = module.func_index(index);

        Some(FrameInfo {
            module_name: module.name.clone(),
            func_index: index.index() as u32,
            func_name: module.func_names.get(&index).cloned(),
            instr,
            func_start: info.start_srcloc,
            symbols,
        })
    }",0,,
"pub fn test_expected_reachability(&mut self, reachability: Vec<(bool, bool)>) {
        self.expected_reachability = Some(ExpectedReachability {
            reachability,
            before_idx: 0,
            after_idx: 0,
        });
    }",0,,
"pub fn cadd_bit(&mut self, mut bit: usize, flag: bool) {
        let mut t: u64;
        debug_assert!(bit < 256);
        bit += if flag { 0 } else { usize::max_value() } & 0x100;
        t = (self.0[0] as u64) + ((if (bit >> 5) == 0 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[0] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[1] as u64) + ((if (bit >> 5) == 1 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[1] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[2] as u64) + ((if (bit >> 5) == 2 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[2] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[3] as u64) + ((if (bit >> 5) == 3 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[3] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[4] as u64) + ((if (bit >> 5) == 4 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[4] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[5] as u64) + ((if (bit >> 5) == 5 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[5] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[6] as u64) + ((if (bit >> 5) == 6 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[6] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[7] as u64) + ((if (bit >> 5) == 7 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[7] = (t & 0xFFFFFFFF) as u32;
        debug_assert!((t >> 32) == 0);
        debug_assert!(!self.check_overflow());
    }",0,,
"fn test_ldxh_same_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        sth [r0], 0x1234
        ldxh r0, [r0]
        exit"",
        [0xff, 0xff],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1234 } },
        4
    );
}",0,,
"fn apply_validated_transaction(
		source: H160,
		transaction: Transaction,
	) -> DispatchResultWithPostInfo {
		let (to, _, info) = Self::execute(source, &transaction, None)?;

		let pending = Pending::<T>::get();
		let transaction_hash = transaction.hash();
		let transaction_index = pending.len() as u32;

		let (reason, status, used_gas, dest) = match info {
			CallOrCreateInfo::Call(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: None,
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				to,
			),
			CallOrCreateInfo::Create(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: Some(info.value),
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				Some(info.value),
			),
		};

		let receipt = {
			let status_code: u8 = match reason {
				ExitReason::Succeed(_) => 1,
				_ => 0,
			};
			let logs_bloom = status.logs_bloom;
			let logs = status.clone().logs;
			let cumulative_gas_used = if let Some((_, _, receipt)) = pending.last() {
				match receipt {
					Receipt::Legacy(d) | Receipt::EIP2930(d) | Receipt::EIP1559(d) => {
						d.used_gas.saturating_add(used_gas)
					}
				}
			} else {
				used_gas
			};
			match &transaction {
				Transaction::Legacy(_) => Receipt::Legacy(ethereum::EIP658ReceiptData {
					status_code,
					used_gas: cumulative_gas_used,
					logs_bloom,
					logs,
				}),
				Transaction::EIP2930(_) => Receipt::EIP2930(ethereum::EIP2930ReceiptData {
					status_code,
					used_gas: cumulative_gas_used,
					logs_bloom,
					logs,
				}),
				Transaction::EIP1559(_) => Receipt::EIP1559(ethereum::EIP2930ReceiptData {
					status_code,
					used_gas: cumulative_gas_used,
					logs_bloom,
					logs,
				}),
			}
		};

		Pending::<T>::append((transaction, status, receipt));

		Self::deposit_event(Event::Executed(
			source,
			dest.unwrap_or_default(),
			transaction_hash,
			reason,
		));

		Ok(PostDispatchInfo {
			actual_weight: Some(T::GasWeightMapping::gas_to_weight(
				used_gas.unique_saturated_into(),
			)),
			pays_fee: Pays::No,
		})
	}",0,,
"pub fn parse(p: u8) -> Result<RecoveryId, Error> {
        if p < 4 {
            Ok(RecoveryId(p))
        } else {
            Err(Error::InvalidRecoveryId)
        }
    }",0,,
"    fn event_set(&self) -> mio::Ready {
        let rd = self.tls_session.wants_read();
        let wr = self.tls_session.wants_write();

        if rd && wr {
            mio::Ready::readable() | mio::Ready::writable()
        } else if wr {
            mio::Ready::writable()
        } else {
            mio::Ready::readable()
        }
    }",0,,
"fn c_repeat_range(
        &mut self,
        expr: &Hir,
        greedy: bool,
        min: u32,
        max: u32,
    ) -> ResultOrEmpty {
        let (min, max) = (u32_to_usize(min), u32_to_usize(max));
        debug_assert!(min <= max);
        let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;
        if min == max {
            return Ok(patch_concat);
        }
        // Same reasoning as in c_repeat_range_min_or_more (we know that min <
        // max at this point).
        let patch_concat = patch_concat.unwrap_or(self.next_inst());
        let initial_entry = patch_concat.entry;
        // It is much simpler to compile, e.g., `a{2,5}` as:
        //
        //     aaa?a?a?
        //
        // But you end up with a sequence of instructions like this:
        //
        //     0: 'a'
        //     1: 'a',
        //     2: split(3, 4)
        //     3: 'a'
        //     4: split(5, 6)
        //     5: 'a'
        //     6: split(7, 8)
        //     7: 'a'
        //     8: MATCH
        //
        // This is *incredibly* inefficient because the splits end
        // up forming a chain, which has to be resolved everything a
        // transition is followed.
        let mut holes = vec![];
        let mut prev_hole = patch_concat.hole;
        for _ in min..max {
            self.fill_to_next(prev_hole);
            let split = self.push_split_hole();
            let Patch { hole, entry } = match self.c(expr)? {
                Some(p) => p,
                None => return self.pop_split_hole(),
            };
            prev_hole = hole;
            if greedy {
                holes.push(self.fill_split(split, Some(entry), None));
            } else {
                holes.push(self.fill_split(split, None, Some(entry)));
            }
        }
        holes.push(prev_hole);
        Ok(Some(Patch { hole: Hole::Many(holes), entry: initial_entry }))
    }",0,,
"pub fn as_raw(&self) -> *mut u8 {
        let ptr = self.0.cast::<u8>().as_ptr();
        ptr
    }",0,,
"pub fn native_version() -> NativeVersion {
	NativeVersion {
		runtime_version: VERSION,
		can_author_with: Default::default(),
	}
}",0,,
"fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, ""VCode_Debug {{"")?;
        writeln!(f, ""  Entry block: {}"", self.entry)?;

        for block in 0..self.num_blocks() {
            writeln!(f, ""Block {}:"", block,)?;
            for succ in self.succs(block as BlockIndex) {
                writeln!(f, ""  (successor: Block {})"", succ.get())?;
            }
            let (start, end) = self.block_ranges[block];
            writeln!(f, ""  (instruction range: {} .. {})"", start, end)?;
            for inst in start..end {
                writeln!(f, ""  Inst {}: {:?}"", inst, self.insts[inst as usize])?;
            }
        }

        writeln!(f, ""}}"")?;
        Ok(())
    }",0,,
"fn test_err_unresolved_elf() {
    let mut syscall_registry = SyscallRegistry::default();
    test_interpreter_and_jit!(register, syscall_registry, b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call);
    let mut file = File::open(""tests/elfs/unresolved_syscall.so"").unwrap();
    let mut elf = Vec::new();
    file.read_to_end(&mut elf).unwrap();
    let config = Config {
        reject_broken_elfs: true,
        ..Config::default()
    };
    assert!(
        matches!(Executable::<UserError, TestInstructionMeter>::from_elf(&elf, None, config, syscall_registry), Err(EbpfError::ElfError(ElfError::UnresolvedSymbol(symbol, pc, offset))) if symbol == ""log_64"" && pc == 550 && offset == 4168)
    );
}",0,,
"pub fn parse_program(program_str: &str) -> Result<ast::Program> {
    let stripped_string = &strip_comments(program_str);
    let parser = syntax::ProgramParser::new();
    match parser.parse(stripped_string) {
        Ok(program) => Ok(program),
        Err(e) => handle_error(e, program_str),
    }
}",1,"1,5","    let stripped_string = &strip_comments(program_str);/~/        Err(e) => handle_error(e, program_str),"
"pub fn compile(mut self, exprs: &[Hir]) -> result::Result<Program, Error> {
        debug_assert!(!exprs.is_empty());
        self.num_exprs = exprs.len();
        if exprs.len() == 1 {
            self.compile_one(&exprs[0])
        } else {
            self.compile_many(exprs)
        }
    }",0,,
"fn test_symbol_relocation() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, r10
        sub64 r1, 0x1
        mov64 r2, 0x1
        syscall BpfSyscallString
        mov64 r0, 0x0
        exit"",
        [72, 101, 108, 108, 111],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        6
    );
}",0,,
"    fn entry_block(&self) -> BlockIx {
        BlockIx::new(self.entry)
    }",0,,
"pub fn current_block() -> Option<ethereum::BlockV0> {
		CurrentBlock::<T>::get()
	}",0,,
"pub fn new(limit: usize) -> Self {
		Self {
			data: Vec::new(),
			effective_len: U256::zero(),
			limit,
		}
	}",0,,
"fn fill(&mut self, goto: InstPtr) {
        let maybeinst = match *self {
            MaybeInst::Split => MaybeInst::Split1(goto),
            MaybeInst::Uncompiled(ref inst) => {
                MaybeInst::Compiled(inst.fill(goto))
            }
            MaybeInst::Split1(goto1) => {
                MaybeInst::Compiled(Inst::Split(InstSplit {
                    goto1: goto1,
                    goto2: goto,
                }))
            }
            MaybeInst::Split2(goto2) => {
                MaybeInst::Compiled(Inst::Split(InstSplit {
                    goto1: goto,
                    goto2: goto2,
                }))
            }
            _ => unreachable!(
                ""not all instructions were compiled! \
                 found uncompiled instruction: {:?}"",
                self
            ),
        };
        *self = maybeinst;
    }",0,,
"fn test_arsh32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0xf8
        lsh32 r0, 28
        arsh32 r0, 16
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xffff8000 } },
        4
    );
}",0,,
"    pub const fn new(signal: broadcast::Receiver<()>) -> Self {
        Terminator {
            // Don't terminate on creation!
            terminate: false,
            signal,
        }
    }",0,,
"    fn from(ty: MemoryType) -> ExternType {
        ExternType::Memory(ty)
    }",0,,
"fn test_syscall_string() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r2, 0x5
        syscall BpfSyscallString
        mov64 r0, 0x0
        exit"",
        [72, 101, 108, 108, 111],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        4
    );
}",0,,
"pub fn dapps<F: Fetch + Clone>(
		remote: Remote,
		ui_address: Option<(String, u16)>,
		dapps_path: PathBuf,
		extra_dapps: Vec<PathBuf>,
		dapps_domain: String,
		registrar: Arc<ContractClient>,
		sync_status: Arc<SyncStatus>,
		web_proxy_tokens: Arc<WebProxyTokens>,
		fetch: F,
	) -> Self {
		let content_fetcher = Arc::new(apps::fetcher::ContentFetcher::new(
			hash_fetch::urlhint::URLHintContract::new(registrar),
			sync_status,
			remote.clone(),
			fetch.clone(),
		).embeddable_on(ui_address.clone()).allow_dapps(true));
		let endpoints = apps::all_endpoints(
			dapps_path,
			extra_dapps,
			dapps_domain.clone(),
			ui_address.clone(),
			web_proxy_tokens,
			remote.clone(),
			fetch.clone(),
		);

		let special = {
			let mut special = special_endpoints(content_fetcher.clone());
			special.insert(router::SpecialEndpoint::Home, Some(apps::ui_redirection(ui_address.clone())));
			special
		};

		let router = router::Router::new(
			content_fetcher,
			Some(endpoints.clone()),
			special,
			ui_address,
			dapps_domain,
		);

		Middleware {
			router: router,
			endpoints: endpoints,
		}
	}",0,,
"fn test_mul32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 3
        mul32 r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xc } },
        3
    );
}",0,,
"    pub fn has_yielded<A: Any>(&self) -> bool {
        match self {
            RunResult::Yielded(yv) => yv.is::<A>(),
            _ => false,
        }
    }",0,,
"fn test_err_div64_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        div r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,,
"pub fn set_hostcall_stack_reservation(&mut self) {
        let slot = self
            .alloc
            .slot
            .as_ref()
            .expect(""reachable instance has a slot"");

        let reservation = slot.limits.hostcall_reservation;

        // The `.stack` field is a pointer to the lowest address of the stack - the start of its
        // allocation. Because the stack grows downward, this is the end of the stack space. So the
        // limit we'll need to check for hostcalls is some reserved space upwards from here, to
        // meet some guest stack pointer early.
        self.get_instance_implicits_mut().stack_limit = slot.stack as u64 + reservation as u64;
    }",0,,
"	fn default() -> Self {
		Self::Undefined
	}",0,,
"fn sock_send(command: &str) -> std::io::Result<()> {
    let mut stream = UnixStream::connect(""/tmp/swhkd.sock"")?;
    stream.write_all(command.as_bytes())?;
    Ok(())
}",0,,
"fn test_exit() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        2
    );
}",0,,
"pub fn heap_u32_mut(&mut self) -> &mut [u32] {
        unsafe { self.alloc.heap_u32_mut() }
    }",0,,
"    pub fn value_labels_ranges(&self) -> ValueLabelsRanges {
        if !self.has_value_labels {
            return ValueLabelsRanges::default();
        }

        let layout_info = &self.insts_layout.borrow();
        debug::compute(&self.insts, &*layout_info)
    }",0,,
"    pub fn run_start(&mut self) -> Result<(), Error> {
        if let Some(start) = self.module.get_start_func()? {
            if !self.is_not_started() {
                return Err(Error::StartAlreadyRun);
            }
            self.run_func(start, &[], false, None)?;
        }
        Ok(())
    }",0,,
"    fn drop(&mut self) {
        if let OutputType::Pager(ref mut command) = *self {
            let _ = command.wait();
        }
    }",0,,
"pub fn check_device_is_keyboard(device: &Device) -> bool {
    if device.supported_keys().map_or(false, |keys| keys.contains(Key::KEY_ENTER)) {
        if device.name() == Some(""swhkd virtual output"") {
            return false;
        }
        log::debug!(""Keyboard: {}"", device.name().unwrap(),);
        true
    } else {
        log::trace!(""Other: {}"", device.name().unwrap(),);
        false
    }
}",0,,
"    fn drop(&mut self) {
        if let OutputType::Pager(ref mut command) = *self {
            let _ = command.wait();
        }
    }",0,,
"    pub fn symbols(&self) -> &[FrameSymbol] {
        &self.symbols
    }",0,,
"fn round_to_page_size(value: usize, page_size: usize) -> usize {
    (value + page_size - 1) / page_size * page_size
}",0,,
"fn test_err_callx_oob_low() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r0, 0x3
        callx r0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::CallOutsideTextSegment(pc, target_pc)
                    if pc == 30 && target_pc == 0
                )
            }
        },
        2
    );
}",0,,
"pub fn minimum(&self) -> u32 {
        self.ty.minimum
    }",0,,
"fn test_frame_info() -> Result<(), anyhow::Error> {
    use crate::*;
    let mut store = Store::<()>::default();
    let module = Module::new(
        store.engine(),
        r#""
            (module
                (func (export ""add"") (param $x i32) (param $y i32) (result i32) (i32.add (local.get $x) (local.get $y)))
                (func (export ""sub"") (param $x i32) (param $y i32) (result i32) (i32.sub (local.get $x) (local.get $y)))
                (func (export ""mul"") (param $x i32) (param $y i32) (result i32) (i32.mul (local.get $x) (local.get $y)))
                (func (export ""div_s"") (param $x i32) (param $y i32) (result i32) (i32.div_s (local.get $x) (local.get $y)))
                (func (export ""div_u"") (param $x i32) (param $y i32) (result i32) (i32.div_u (local.get $x) (local.get $y)))
                (func (export ""rem_s"") (param $x i32) (param $y i32) (result i32) (i32.rem_s (local.get $x) (local.get $y)))
                (func (export ""rem_u"") (param $x i32) (param $y i32) (result i32) (i32.rem_u (local.get $x) (local.get $y)))
            )
         ""#,
    )?;
    // Create an instance to ensure the frame information is registered.
    Instance::new(&mut store, &module, &[])?;

    GlobalModuleRegistry::with(|modules| {
        for (i, alloc) in module.compiled_module().finished_functions() {
            let (start, end) = unsafe {
                let ptr = (*alloc).as_ptr();
                let len = (*alloc).len();
                (ptr as usize, ptr as usize + len)
            };
            for pc in start..end {
                let (frame, _, _) = modules.lookup_frame_info(pc).unwrap();
                assert!(
                    frame.func_index() == i.as_u32(),
                    ""lookup of {:#x} returned {}, expected {}"",
                    pc,
                    frame.func_index(),
                    i.as_u32()
                );
            }
        }
    });
    Ok(())
}",0,,
"	pub fn service(middleware: &Option<Middleware>) -> Option<Arc<rpc_apis::DappsService>> {
		middleware.as_ref().map(|m| Arc::new(DappsServiceWrapper {
			endpoints: m.endpoints()
		}) as Arc<rpc_apis::DappsService>)
	}",0,,
"pub fn new_ui(enabled: bool, deps: Dependencies) -> Result<Option<Middleware>, String> {
	if !enabled {
		return Ok(None);
	}

	server::ui_middleware(
		deps,
		rpc::DAPPS_DOMAIN.into(),
	).map(Some)
}",0,,
"pub fn resize_offset(&mut self, offset: U256, len: U256) -> Result<(), ExitError> {
		if len == U256::zero() {
			return Ok(())
		}

		if let Some(end) = offset.checked_add(len) {
			self.resize_end(end)
		} else {
			Err(ExitError::InvalidRange)
		}
	}",0,,
"fn test_parse_less_version_wrong_program() {
    let output = b""more from util-linux 2.34"";

    assert_eq!(None, parse_less_version(output));
}",0,,
"    pub fn call(&self, mut store: impl AsContextMut, params: &[Val]) -> Result<Box<[Val]>> {
        assert!(
            !store.as_context().async_support(),
            ""must use `call_async` when async support is enabled on the config"",
        );
        let my_ty = self.ty(&store);
        self.call_impl(&mut store.as_context_mut(), my_ty, params)
    }",0,,
"    fn try_from(ty: wasmparser::TableType) -> WasmResult<Table> {
        Ok(Table {
            wasm_ty: ty.element_type.try_into()?,
            minimum: ty.initial,
            maximum: ty.maximum,
        })
    }",0,,
"    fn new() -> KeyboardState {
        KeyboardState { state_modifiers: HashSet::new(), state_keysyms: AttributeSet::new() }
    }",0,,
"fn validate_transaction_in_pool(
		origin: H160,
		transaction: &Transaction,
	) -> TransactionValidity {
		let transaction_data: TransactionData = transaction.into();
		let transaction_nonce = transaction_data.nonce;

		let (base_fee, _) = T::FeeCalculator::min_gas_price();
		let (who, _) = pallet_evm::Pallet::<T>::account_basic(&origin);

		let _ = CheckEvmTransaction::<InvalidTransactionWrapper>::new(
			CheckEvmTransactionConfig {
				evm_config: T::config(),
				block_gas_limit: T::BlockGasLimit::get(),
				base_fee,
				chain_id: T::ChainId::get(),
				is_transactional: true,
			},
			transaction_data.clone().into(),
		)
		.validate_in_pool_for(&who)
		.and_then(|v| v.with_chain_id())
		.and_then(|v| v.with_base_fee())
		.and_then(|v| v.with_balance_for(&who))
		.map_err(|e| e.0)?;

		let priority = match (
			transaction_data.gas_price,
			transaction_data.max_fee_per_gas,
			transaction_data.max_priority_fee_per_gas,
		) {
			// Legacy or EIP-2930 transaction.
			// Handle priority here. On legacy transaction everything in gas_price except
			// the current base_fee is considered a tip to the miner and thus the priority.
			(Some(gas_price), None, None) => {
				gas_price.saturating_sub(base_fee).unique_saturated_into()
			}
			// EIP-1559 transaction without tip.
			(None, Some(_), None) => 0,
			// EIP-1559 transaction with tip.
			(None, Some(max_fee_per_gas), Some(max_priority_fee_per_gas)) => max_fee_per_gas
				.saturating_sub(base_fee)
				.min(max_priority_fee_per_gas)
				.unique_saturated_into(),
			// Unreachable because already validated. Gracefully handle.
			_ => return Err(InvalidTransaction::Payment.into()),
		};

		// The tag provides and requires must be filled correctly according to the nonce.
		let mut builder = ValidTransactionBuilder::default()
			.and_provides((origin, transaction_nonce))
			.priority(priority);

		// In the context of the pool, a transaction with
		// too high a nonce is still considered valid
		if transaction_nonce > who.nonce {
			if let Some(prev_nonce) = transaction_nonce.checked_sub(1.into()) {
				builder = builder.and_requires((origin, prev_nonce))
			}
		}

		builder.build()
	}",0,,
"    pub(crate) unsafe fn from_caller_checked_anyfunc(
        store: &mut StoreOpaque,
        anyfunc: *mut VMCallerCheckedAnyfunc,
    ) -> Option<Self> {
        let anyfunc = NonNull::new(anyfunc)?;
        debug_assert!(anyfunc.as_ref().type_index != VMSharedSignatureIndex::default());
        let export = ExportFunction { anyfunc };
        Some(Func::from_wasmtime_function(export, store))
    }",0,,
"    pub fn remove_embed_ctx<T: Any>(&mut self) -> Option<T> {
        self.embed_ctx.remove::<T>()
    }",0,,
"pub fn run_func_idx(
        &mut self,
        table_idx: u32,
        func_idx: u32,
        args: &[Val],
    ) -> Result<RunResult, Error> {
        let func = self.module.get_func_from_idx(table_idx, func_idx)?;
        Ok(self.run_func(func, &args, false, None)?.unwrap())
    }",0,,
"fn test_jset_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0x7
        mov32 r2, 0x8
        jset r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0x9
        jset r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,,
"fn test_jne_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xb
        jne r1, 0xb, +4
        mov32 r0, 1
        mov32 r1, 0xa
        jne r1, 0xb, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"fn withdraw_fee(
		who: &H160,
		fee: U256,
	) -> Result<Self::LiquidityInfo, Error<T>> {
		EVMCurrencyAdapter::<<T as Config>::Currency, ()>::withdraw_fee(who, fee)
	}",0,,
"    pub fn ensure_sigstack_installed(&mut self, ensure: bool) {
        self.ensure_sigstack_installed = ensure;
    }",0,,
"    fn iter_indices(&self) -> Self::Iter {
        self.iter_elements().enumerate()
    }",0,,
"pub fn execute(
		from: H160,
		input: Vec<u8>,
		value: U256,
		gas_limit: U256,
		gas_price: Option<U256>,
		nonce: Option<U256>,
		action: TransactionAction,
		config: Option<evm::Config>,
	) -> Result<(Option<H160>, Option<H160>, CallOrCreateInfo), DispatchError> {
		match action {
			ethereum::TransactionAction::Call(target) => {
				let res = T::Runner::call(
					from,
					target,
					input.clone(),
					value,
					gas_limit.low_u64(),
					gas_price,
					nonce,
					config.as_ref().unwrap_or(T::config()),
				)
				.map_err(Into::into)?;

				Ok((Some(target), None, CallOrCreateInfo::Call(res)))
			}
			ethereum::TransactionAction::Create => {
				let res = T::Runner::create(
					from,
					input.clone(),
					value,
					gas_limit.low_u64(),
					gas_price,
					nonce,
					config.as_ref().unwrap_or(T::config()),
				)
				.map_err(Into::into)?;

				Ok((None, Some(res.value), CallOrCreateInfo::Create(res)))
			}
		}
	}",0,,
"    pub fn new_insecure_only(base: BaseListener) -> Result<Self, String> {
        log::info!(""Server started on: skyhash://{}"", bindaddr!(base));
        Ok(MultiListener::InsecureOnly(Listener { base }))
    }",0,,
"fn from(val: i64) -> Val {
        Val::I64(val)
    }",0,,
"fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {
		self.substate.log(address, topics, data)
	}",0,,
"fn test_sth() {
    test_interpreter_and_jit_asm!(
        ""
        sth [r1+2], 0x2211
        ldxh r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2211 } },
        3
    );
}",0,,
"    pub(crate) fn unwrap(self) -> RunResult {
        match self {
            InternalRunResult::Normal(result) => result,
            InternalRunResult::BoundExpired => panic!(""should not have had a runtime bound""),
        }
    }",0,,
"fn test_load_elf_empty_noro() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/noro.so"",
        config,
        [],
        (
            b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        8
    );
}",0,,
"fn try_back_read(&mut self) {
        if self.back.is_none() {
            return;
        }

        // Try a non-blocking read.
        let mut buf = [0u8; 1024];
        let back = self.back.as_mut().unwrap();
        let rc = try_read(back.read(&mut buf));

        if rc.is_err() {
            error!(""backend read failed: {:?}"", rc);
            self.closing = true;
            return;
        }

        let maybe_len = rc.unwrap();

        // If we have a successful but empty read, that's an EOF.
        // Otherwise, we shove the data into the TLS session.
        match maybe_len {
            Some(len) if len == 0 => {
                debug!(""back eof"");
                self.closing = true;
            }
            Some(len) => {
                self.tls_session.write_all(&buf[..len]).unwrap();
            }
            None => {}
        };
    }",0,,
"    pub fn func_name(&self) -> Option<&str> {
        self.func_name.as_deref()
    }",0,,
"fn strip_first_last(s: &str) -> &str {
    &s[1..s.len() - 1]
}",0,,
"fn show_config(config: &config::Config, writer: &mut dyn Write) -> std::io::Result<()> {
    // styles first
    writeln!(
        writer,
        ""    commit-style                  = {commit_style}
    file-style                    = {file_style}
    hunk-header-style             = {hunk_header_style}
    minus-style                   = {minus_style}
    minus-non-emph-style          = {minus_non_emph_style}
    minus-emph-style              = {minus_emph_style}
    minus-empty-line-marker-style = {minus_empty_line_marker_style}
    zero-style                    = {zero_style}
    plus-style                    = {plus_style}
    plus-non-emph-style           = {plus_non_emph_style}
    plus-emph-style               = {plus_emph_style}
    plus-empty-line-marker-style  = {plus_empty_line_marker_style}
    whitespace-error-style        = {whitespace_error_style}"",
        commit_style = config.commit_style.to_painted_string(),
        file_style = config.file_style.to_painted_string(),
        hunk_header_style = config.hunk_header_style.to_painted_string(),
        minus_emph_style = config.minus_emph_style.to_painted_string(),
        minus_empty_line_marker_style = config.minus_empty_line_marker_style.to_painted_string(),
        minus_non_emph_style = config.minus_non_emph_style.to_painted_string(),
        minus_style = config.minus_style.to_painted_string(),
        plus_emph_style = config.plus_emph_style.to_painted_string(),
        plus_empty_line_marker_style = config.plus_empty_line_marker_style.to_painted_string(),
        plus_non_emph_style = config.plus_non_emph_style.to_painted_string(),
        plus_style = config.plus_style.to_painted_string(),
        whitespace_error_style = config.whitespace_error_style.to_painted_string(),
        zero_style = config.zero_style.to_painted_string(),
    )?;
    // Everything else
    writeln!(
        writer,
        ""    true-color                    = {true_color}
    file-added-label              = {file_added_label}
    file-modified-label           = {file_modified_label}
    file-removed-label            = {file_removed_label}
    file-renamed-label            = {file_renamed_label}"",
        true_color = config.true_color,
        file_added_label = format_option_value(&config.file_added_label),
        file_modified_label = format_option_value(&config.file_modified_label),
        file_removed_label = format_option_value(&config.file_removed_label),
        file_renamed_label = format_option_value(&config.file_renamed_label),
    )?;
    writeln!(
        writer,
        ""    hyperlinks                    = {hyperlinks}"",
        hyperlinks = config.hyperlinks
    )?;
    if config.hyperlinks {
        writeln!(
            writer,
            ""    hyperlinks-file-link-format   = {hyperlinks_file_link_format}"",
            hyperlinks_file_link_format = format_option_value(&config.hyperlinks_file_link_format),
        )?
    }
    writeln!(
        writer,
        ""    inspect-raw-lines             = {inspect_raw_lines}
    keep-plus-minus-markers       = {keep_plus_minus_markers}"",
        inspect_raw_lines = match config.inspect_raw_lines {
            cli::InspectRawLines::True => ""true"",
            cli::InspectRawLines::False => ""false"",
        },
        keep_plus_minus_markers = config.keep_plus_minus_markers,
    )?;
    writeln!(
        writer,
        ""    line-numbers                  = {line_numbers}"",
        line_numbers = config.line_numbers
    )?;
    if config.line_numbers {
        writeln!(
            writer,
            ""    line-numbers-minus-style      = {line_numbers_minus_style}
    line-numbers-zero-style       = {line_numbers_zero_style}
    line-numbers-plus-style       = {line_numbers_plus_style}
    line-numbers-left-style       = {line_numbers_left_style}
    line-numbers-right-style      = {line_numbers_right_style}
    line-numbers-left-format      = {line_numbers_left_format}
    line-numbers-right-format     = {line_numbers_right_format}"",
            line_numbers_minus_style = config.line_numbers_minus_style.to_painted_string(),
            line_numbers_zero_style = config.line_numbers_zero_style.to_painted_string(),
            line_numbers_plus_style = config.line_numbers_plus_style.to_painted_string(),
            line_numbers_left_style = config.line_numbers_left_style.to_painted_string(),
            line_numbers_right_style = config.line_numbers_right_style.to_painted_string(),
            line_numbers_left_format = format_option_value(&config.line_numbers_left_format),
            line_numbers_right_format = format_option_value(&config.line_numbers_right_format),
        )?
    }
    writeln!(
        writer,
        ""    max-line-distance             = {max_line_distance}
    max-line-length               = {max_line_length}
    navigate                      = {navigate}
    navigate-regexp               = {navigate_regexp}
    pager                         = {pager}
    paging                        = {paging_mode}
    side-by-side                  = {side_by_side}
    syntax-theme                  = {syntax_theme}
    width                         = {width}
    tabs                          = {tab_width}
    word-diff-regex               = {tokenization_regex}"",
        max_line_distance = config.max_line_distance,
        max_line_length = config.max_line_length,
        navigate = config.navigate,
        navigate_regexp = match &config.navigate_regexp {
            None => """".to_string(),
            Some(s) => s.to_string(),
        },
        pager = config.pager.clone().unwrap_or_else(|| ""none"".to_string()),
        paging_mode = match config.paging_mode {
            PagingMode::Always => ""always"",
            PagingMode::Never => ""never"",
            PagingMode::QuitIfOneScreen => ""auto"",
        },
        side_by_side = config.side_by_side,
        syntax_theme = config
            .syntax_theme
            .clone()
            .map(|t| t.name.unwrap_or_else(|| ""none"".to_string()))
            .unwrap_or_else(|| ""none"".to_string()),
        width = match config.decorations_width {
            cli::Width::Fixed(width) => width.to_string(),
            cli::Width::Variable => ""variable"".to_string(),
        },
        tab_width = config.tab_width,
        tokenization_regex = format_option_value(&config.tokenization_regex.to_string()),
    )?;
    Ok(())
}",0,,
"    pub fn resume(&mut self) -> Result<RunResult, Error> {
        self.resume_with_val(EmptyYieldVal)
    }",0,,
"    pub fn new(content: ValType, mutability: Mutability) -> GlobalType {
        GlobalType {
            content,
            mutability,
        }
    }",0,,
"fn smoke_test_gc() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (import """" """" (func $do_gc))
                (func $recursive (export ""func"") (param i32 externref) (result externref)
                    local.get 0
                    i32.eqz
                    if (result externref)
                        call $do_gc
                        local.get 1
                    else
                        local.get 0
                        i32.const 1
                        i32.sub
                        local.get 1
                        call $recursive
                    end
                )
            )
        ""#,
    )?;

    let do_gc = Func::wrap(&mut store, |mut caller: Caller<'_, _>| {
        // Do a GC with `externref`s on the stack in Wasm frames.
        caller.gc();
    });
    let instance = Instance::new(&mut store, &module, &[do_gc.into()])?;
    let func = instance.get_func(&mut store, ""func"").unwrap();

    let inner_dropped = Arc::new(AtomicBool::new(false));
    let r = ExternRef::new(SetFlagOnDrop(inner_dropped.clone()));
    {
        let args = [Val::I32(5), Val::ExternRef(Some(r.clone()))];
        func.call(&mut store, &args)?;
    }

    // Still held alive by the `VMExternRefActivationsTable` (potentially in
    // multiple slots within the table) and by this `r` local.
    assert!(r.strong_count() >= 2);

    // Doing a GC should see that there aren't any `externref`s on the stack in
    // Wasm frames anymore.
    store.gc();
    assert_eq!(r.strong_count(), 1);

    // Dropping `r` should drop the inner `SetFlagOnDrop` value.
    drop(r);
    assert!(inner_dropped.load(SeqCst));

    Ok(())
}",0,,
"fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ValType::I32 => write!(f, ""i32""),
            ValType::I64 => write!(f, ""i64""),
            ValType::F32 => write!(f, ""f32""),
            ValType::F64 => write!(f, ""f64""),
            ValType::V128 => write!(f, ""v128""),
            ValType::ExternRef => write!(f, ""externref""),
            ValType::FuncRef => write!(f, ""funcref""),
        }
    }",0,,
"pub fn tweak_mul_assign(&mut self, tweak: &SecretKey) -> Result<(), Error> {
        if tweak.0.is_zero() {
            return Err(Error::TweakOutOfRange);
        }

        let mut r = Jacobian::default();
        let zero = Scalar::from_int(0);
        let pt = Jacobian::from_ge(&self.0);
        ECMULT_CONTEXT.ecmult(&mut r, &pt, &tweak.0, &zero);

        self.0.set_gej(&r);
        Ok(())
    }",0,,
"    fn try_from(ty: wasmparser::FuncType) -> Result<Self, Self::Error> {
        Ok(Self {
            params: ty
                .params
                .into_vec()
                .into_iter()
                .map(WasmType::try_from)
                .collect::<Result<_, Self::Error>>()?,
            returns: ty
                .returns
                .into_vec()
                .into_iter()
                .map(WasmType::try_from)
                .collect::<Result<_, Self::Error>>()?,
        })
    }",1,"1,2,3,4,5,6,7,8,9,10,11,12,13,14","        Ok(Self {/~/            params: ty/~/                .params/~/                .into_vec()/~/                .into_iter()/~/                .map(WasmType::try_from)/~/                .collect::<Result<_, Self::Error>>()?,/~/            returns: ty/~/                .returns/~/                .into_vec()/~/                .into_iter()/~/                .map(WasmType::try_from)/~/                .collect::<Result<_, Self::Error>>()?,/~/        })"
"    fn alloc(&self) -> &Alloc {
        &self.alloc
    }",0,,
"fn gee_i_sure_hope_refcounting_is_atomic() -> anyhow::Result<()> {
    let mut config = Config::new();
    config.wasm_reference_types(true);
    config.epoch_interruption(true);
    let engine = Engine::new(&config)?;
    let mut store = Store::new(&engine, ());
    let module = Module::new(
        &engine,
        r#""
            (module
                (global (mut externref) (ref.null extern))
                (table 1 externref)

                (func (export ""run"") (param externref)
                    local.get 0
                    global.set 0
                    i32.const 0
                    local.get 0
                    table.set 0
                    loop
                        global.get 0
                        global.set 0

                        i32.const 0
                        i32.const 0
                        table.get
                        table.set

                        local.get 0
                        call $f

                        br 0
                    end
                )

                (func $f (param externref))
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;

    let flag = Arc::new(AtomicBool::new(false));
    let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
    let externref2 = externref.clone();

    let child = std::thread::spawn(move || run.call(&mut store, Some(externref2)));

    for _ in 0..10000 {
        drop(externref.clone());
    }
    engine.increment_epoch();

    assert!(child.join().unwrap().is_err());
    assert!(!flag.load(SeqCst));
    assert_eq!(externref.strong_count(), 1);
    drop(externref);
    assert!(flag.load(SeqCst));

    Ok(())
}",0,,
"fn show_syntax_themes() -> std::io::Result<()> {
    let mut opt = cli::Opt::from_args();
    let assets = HighlightingAssets::new();
    let mut output_type = OutputType::from_mode(
        PagingMode::QuitIfOneScreen,
        None,
        &config::Config::from(cli::Opt::default()),
    )
    .unwrap();
    let mut writer = output_type.handle().unwrap();
    opt.computed.syntax_set = assets.syntax_set;

    let stdin_data = if !atty::is(atty::Stream::Stdin) {
        let mut buf = Vec::new();
        io::stdin().lock().read_to_end(&mut buf)?;
        if !buf.is_empty() {
            Some(buf)
        } else {
            None
        }
    } else {
        None
    };

    if !(opt.dark || opt.light) {
        _show_syntax_themes(opt.clone(), false, &mut writer, stdin_data.as_ref())?;
        _show_syntax_themes(opt, true, &mut writer, stdin_data.as_ref())?;
    } else if opt.light {
        _show_syntax_themes(opt, true, &mut writer, stdin_data.as_ref())?;
    } else {
        _show_syntax_themes(opt, false, &mut writer, stdin_data.as_ref())?
    };
    Ok(())
}",0,,
"    pub fn from_mode(
        paging_mode: PagingMode,
        wrapping_mode: WrappingMode,
        pager: Option<&str>,
    ) -> Result<Self> {
        use self::PagingMode::*;
        Ok(match paging_mode {
            Always => OutputType::try_pager(SingleScreenAction::Nothing, wrapping_mode, pager)?,
            QuitIfOneScreen => {
                OutputType::try_pager(SingleScreenAction::Quit, wrapping_mode, pager)?
            }
            _ => OutputType::stdout(),
        })
    }",0,,
"fn set_range(&mut self, start: u8, end: u8) {
        debug_assert!(start <= end);
        if start > 0 {
            self.0[start as usize - 1] = true;
        }
        self.0[end as usize] = true;
    }",0,,
"pub fn data(&self) -> &Vec<u8> {
		&self.data
	}",0,,
"fn c_alternate(&mut self, exprs: &[Hir]) -> ResultOrEmpty {
        debug_assert!(
            exprs.len() >= 2,
            ""alternates must have at least 2 exprs""
        );

        // Initial entry point is always the first split.
        let first_split_entry = self.insts.len();

        // Save up all of the holes from each alternate. They will all get
        // patched to point to the same location.
        let mut holes = vec![];

        // true indicates that the hole is a split where we want to fill
        // the second branch.
        let mut prev_hole = (Hole::None, false);
        for e in &exprs[0..exprs.len() - 1] {
            if prev_hole.1 {
                let next = self.insts.len();
                self.fill_split(prev_hole.0, None, Some(next));
            } else {
                self.fill_to_next(prev_hole.0);
            }
            let split = self.push_split_hole();
            if let Some(Patch { hole, entry }) = self.c(e)? {
                holes.push(hole);
                prev_hole = (self.fill_split(split, Some(entry), None), false);
            } else {
                let (split1, split2) = split.dup_one();
                holes.push(split1);
                prev_hole = (split2, true);
            }
        }
        if let Some(Patch { hole, entry }) = self.c(&exprs[exprs.len() - 1])? {
            holes.push(hole);
            if prev_hole.1 {
                self.fill_split(prev_hole.0, None, Some(entry));
            } else {
                self.fill(prev_hole.0, entry);
            }
        } else {
            // We ignore prev_hole.1. When it's true, it means we have two
            // empty branches both pushing prev_hole.0 into holes, so both
            // branches will go to the same place anyway.
            holes.push(prev_hole.0);
        }
        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))
    }",0,,
"fn test_large_inputs() {
		let input = hex::decode(
			""0000000000000000000000000000000000000000000000000000000000000020\
			0000000000000000000000000000000000000000000000000000000000000020\
			0000000000000000000000000000000000000000000000000000000000000020\
			000000000000000000000000000000000000000000000000000000000000EA5F\
			0000000000000000000000000000000000000000000000000000000000000015\
			0000000000000000000000000000000000000000000000000000000000003874"",
		)
		.expect(""Decode failed"");

		// 59999 ^ 21 % 14452 = 10055

		let cost: u64 = 100000;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(precompile_result) => {
				assert_eq!(precompile_result.output.len(), 32); // should be same length as mod
				let result = BigUint::from_bytes_be(&precompile_result.output[..]);
				let expected = BigUint::parse_bytes(b""10055"", 10).unwrap();
				assert_eq!(result, expected);
			}
			Err(_) => {
				panic!(""Modexp::execute() returned error""); // TODO: how to pass error on?
			}
		}
	}",0,,
"    pub fn get_num_func_imports(&self) -> usize {
        self.info.imported_funcs.len()
    }",0,,
"pub fn parse(p: &[u8; util::SECRET_KEY_SIZE]) -> Result<SecretKey, Error> {
        let mut elem = Scalar::default();
        if !elem.set_b32(p) && !elem.is_zero() {
            Ok(SecretKey(elem))
        } else {
            Err(Error::InvalidSecretKey)
        }
    }",0,,
"fn strip_first_last(s: &str) -> &str {
    &s[1..s.len() - 1]
}",0,,
"    pub fn get_embed_ctx<T: Any>(&self) -> Option<Result<Ref<'_, T>, BorrowError>> {
        self.embed_ctx.try_get::<T>()
    }

    /// Get a mutable reference to a context value of a particular type, if it exists.
    pub fn get_embed_ctx_mut<T: Any>(&self) -> Option<Result<RefMut<'_, T>, BorrowMutError>> {
        self.embed_ctx.try_get_mut::<T>()
    }",0,,
"pub fn line(&self) -> Option<u32> {
        self.line
    }",0,,
"fn test_show_syntax_themes() {
        let opt = integration_test_utils::make_options_from_args(&[]);

        let mut writer = Cursor::new(vec![0; 1024]);
        _show_syntax_themes(opt, true, &mut writer, None).unwrap();
        let mut s = String::new();
        writer.seek(SeekFrom::Start(0)).unwrap();
        writer.read_to_string(&mut s).unwrap();
        let s = ansi::strip_ansi_codes(&s);
        assert!(s.contains(""\nTheme: gruvbox-light\n""));
        println!(""{}"", s);
        assert!(s.contains(""\nfn print_cube(num: f64) {\n""));
    }",0,,
"pub fn combine(keys: &[PublicKey]) -> Result<Self, Error> {
        let mut qj = Jacobian::default();
        qj.set_infinity();

        for key in keys {
            qj = qj.add_ge(&key.0);
        }

        if qj.is_infinity() {
            return Err(Error::InvalidPublicKey);
        }

        let q = Affine::from_gej(&qj);
        Ok(PublicKey(q))
    }",0,,
"pub fn effective_len(&self) -> U256 {
		self.effective_len
	}",0,,
"pub fn check_array<T>(user_buf: *const T, count: usize) -> Result<()> {
        let checked_len = count
            .checked_mul(size_of::<T>())
            .ok_or_else(|| errno!(EINVAL, ""the array is too long""))?;
        if !is_inside_user_space(user_buf as *const u8, checked_len) {
            return_errno!(EFAULT, ""the whole buffer is not in the user space"");
        }
        Ok(())
    }",0,,
"pub fn try_insert(&mut self, externref: VMExternRef) -> Result<(), VMExternRef> {
        unsafe {
            let next = *self.alloc.next.get();
            if next == self.alloc.end {
                return Err(externref);
            }

            debug_assert!(
                (*next.as_ref().get()).is_none(),
                ""slots >= the `next` bump finger are always `None`""
            );
            ptr::write(next.as_ptr(), UnsafeCell::new(Some(externref)));

            let next = NonNull::new_unchecked(next.as_ptr().add(1));
            debug_assert!(next <= self.alloc.end);
            *self.alloc.next.get() = next;

            Ok(())
        }
    }",0,,
"    pub fn call(&self, mut store: impl AsContextMut, params: &[Val]) -> Result<Box<[Val]>> {
        assert!(
            !store.as_context().async_support(),
            ""must use `call_async` when async support is enabled on the config"",
        );
        let my_ty = self.ty(&store);
        self.call_impl(&mut store.as_context_mut(), my_ty, params)
    }",0,,
"pub fn check_ptr<T>(user_ptr: *const T) -> Result<()> {
        if !is_inside_user_space(user_ptr as *const u8, size_of::<T>()) {
            return_errno!(EFAULT, ""pointer is not in the user space"");
        }
        Ok(())
    }",0,,
"fn c(&mut self, expr: &Hir) -> ResultOrEmpty {
        use crate::prog;
        use regex_syntax::hir::HirKind::*;

        self.check_size()?;
        match *expr.kind() {
            Empty => Ok(None),
            Literal(hir::Literal::Unicode(c)) => self.c_char(c),
            Literal(hir::Literal::Byte(b)) => {
                assert!(self.compiled.uses_bytes());
                self.c_byte(b)
            }
            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),
            Class(hir::Class::Bytes(ref cls)) => {
                if self.compiled.uses_bytes() {
                    self.c_class_bytes(cls.ranges())
                } else {
                    assert!(cls.is_all_ascii());
                    let mut char_ranges = vec![];
                    for r in cls.iter() {
                        let (s, e) = (r.start() as char, r.end() as char);
                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));
                    }
                    self.c_class(&char_ranges)
                }
            }
            Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::EndLine)
            }
            Anchor(hir::Anchor::StartLine) => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::StartLine)
            }
            Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::StartLine)
            }
            Anchor(hir::Anchor::EndLine) => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::EndLine)
            }
            Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {
                self.c_empty_look(prog::EmptyLook::EndText)
            }
            Anchor(hir::Anchor::StartText) => {
                self.c_empty_look(prog::EmptyLook::StartText)
            }
            Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {
                self.c_empty_look(prog::EmptyLook::StartText)
            }
            Anchor(hir::Anchor::EndText) => {
                self.c_empty_look(prog::EmptyLook::EndText)
            }
            WordBoundary(hir::WordBoundary::Unicode) => {
                if !cfg!(feature = ""unicode-perl"") {
                    return Err(Error::Syntax(
                        ""Unicode word boundaries are unavailable when \
                         the unicode-perl feature is disabled""
                            .to_string(),
                    ));
                }
                self.compiled.has_unicode_word_boundary = true;
                self.byte_classes.set_word_boundary();
                // We also make sure that all ASCII bytes are in a different
                // class from non-ASCII bytes. Otherwise, it's possible for
                // ASCII bytes to get lumped into the same class as non-ASCII
                // bytes. This in turn may cause the lazy DFA to falsely start
                // when it sees an ASCII byte that maps to a byte class with
                // non-ASCII bytes. This ensures that never happens.
                self.byte_classes.set_range(0, 0x7F);
                self.c_empty_look(prog::EmptyLook::WordBoundary)
            }
            WordBoundary(hir::WordBoundary::UnicodeNegate) => {
                if !cfg!(feature = ""unicode-perl"") {
                    return Err(Error::Syntax(
                        ""Unicode word boundaries are unavailable when \
                         the unicode-perl feature is disabled""
                            .to_string(),
                    ));
                }
                self.compiled.has_unicode_word_boundary = true;
                self.byte_classes.set_word_boundary();
                // See comments above for why we set the ASCII range here.
                self.byte_classes.set_range(0, 0x7F);
                self.c_empty_look(prog::EmptyLook::NotWordBoundary)
            }
            WordBoundary(hir::WordBoundary::Ascii) => {
                self.byte_classes.set_word_boundary();
                self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)
            }
            WordBoundary(hir::WordBoundary::AsciiNegate) => {
                self.byte_classes.set_word_boundary();
                self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)
            }
            Group(ref g) => match g.kind {
                hir::GroupKind::NonCapturing => self.c(&g.hir),
                hir::GroupKind::CaptureIndex(index) => {
                    if index as usize >= self.compiled.captures.len() {
                        self.compiled.captures.push(None);
                    }
                    self.c_capture(2 * index as usize, &g.hir)
                }
                hir::GroupKind::CaptureName { index, ref name } => {
                    if index as usize >= self.compiled.captures.len() {
                        let n = name.to_string();
                        self.compiled.captures.push(Some(n.clone()));
                        self.capture_name_idx.insert(n, index as usize);
                    }
                    self.c_capture(2 * index as usize, &g.hir)
                }
            },
            Concat(ref es) => {
                if self.compiled.is_reverse {
                    self.c_concat(es.iter().rev())
                } else {
                    self.c_concat(es)
                }
            }
            Alternation(ref es) => self.c_alternate(&**es),
            Repetition(ref rep) => self.c_repeat(rep),
        }
    }",1,6,"            Empty => Ok(None),"
"    fn from(ty: FuncType) -> ExternType {
        ExternType::Func(ty)
    }",0,,
"fn test_tight_infinite_loop_conditional() {
    test_interpreter_and_jit_asm!(
        ""
        jsge r0, r0, -1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 30 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,,
"fn calculate_gas_cost(
	base_length: u64,
	exp_length: u64,
	mod_length: u64,
	exponent: &BigUint,
) -> u64 {
	fn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {
		let max_length = max(base_length, mod_length);
		let mut words = max_length / 8;
		if max_length % 8 > 0 {
			words += 1;
		}

		// TODO: prevent/handle overflow
		words * words
	}

	fn calculate_iteration_count(exp_length: u64, exponent: &BigUint) -> u64 {
		let mut iteration_count: u64 = 0;

		if exp_length <= 32 && exponent.is_zero() {
			iteration_count = 0;
		} else if exp_length <= 32 {
			iteration_count = exponent.bits() - 1;
		} else if exp_length > 32 {
			// construct BigUint to represent (2^256) - 1
			let bytes: [u8; 32] = [0xFF; 32];
			let max_256_bit_uint = BigUint::from_bytes_be(&bytes);

			iteration_count =
				(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);
		}

		max(iteration_count, 1)
	}

	let multiplication_complexity = calculate_multiplication_complexity(base_length, mod_length);
	let iteration_count = calculate_iteration_count(exp_length, exponent);
	let gas = max(
		MIN_GAS_COST,
		multiplication_complexity * iteration_count / 3,
	);

	gas
}",1,"13,30",// TODO: prevent/handle overflow/~/				(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);
"fn parse_test_sig(input: syn::ItemFn, rand: u16) -> TokenStream {
    for attr in &input.attrs {
        if attr.path.is_ident(""test"") {
            let msg = ""second test attribute is supplied"";
            return syn::Error::new_spanned(&attr, msg)
                .to_compile_error()
                .into();
        }
    }

    if !input.sig.inputs.is_empty() {
        let msg = ""the test function cannot accept arguments"";
        return syn::Error::new_spanned(&input.sig.inputs, msg)
            .to_compile_error()
            .into();
    }
    parse_dbtest(input, rand).unwrap_or_else(|e| e.to_compile_error().into())
}",0,,
"	fn is_major_importing(&self) -> bool;
}

impl<F> SyncStatus for F where F: Fn() -> bool + Send + Sync {
	fn is_major_importing(&self) -> bool { self() }
}",0,,
"    fn next_inst(&self) -> Patch {
        Patch { hole: Hole::None, entry: self.insts.len() }
    }",0,,
"fn parse_test_module(args: TokenStream, item: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(item as syn::ItemMod);
    let content = match input.content {
        Some((_, c)) => c,
        None => {
            return syn::Error::new_spanned(&input, ""Couldn't get the module content"")
                .to_compile_error()
                .into()
        }
    };
    let args = syn::parse_macro_input!(args as syn::AttributeArgs);
    let mut skips = Vec::new();
    for arg in args {
        match arg {
            syn::NestedMeta::Meta(syn::Meta::NameValue(namevalue)) => {
                let ident = namevalue.path.get_ident();
                if ident.is_none() {
                    let msg = ""Must have specified ident"";
                    return syn::Error::new_spanned(namevalue, msg)
                        .to_compile_error()
                        .into();
                }
                match ident.unwrap().to_string().to_lowercase().as_str() {
                    ""skip"" => {
                        let skip_lit = namevalue.lit.clone();
                        let span = skip_lit.span();
                        skips = match parse_string(skip_lit, span, ""skip"") {
                            Ok(s) => s,
                            Err(_) => {
                                return syn::Error::new_spanned(
                                    namevalue,
                                    ""Expected a value for argument `skip`"",
                                )
                                .to_compile_error()
                                .into();
                            }
                        }
                        .split_whitespace()
                        .map(|val| val.to_string())
                        .collect();
                    }
                    x => {
                        let msg = format!(""Unknown attribute {} is specified; expected `skip`"", x);
                        return syn::Error::new_spanned(namevalue, msg)
                            .to_compile_error()
                            .into();
                    }
                }
            }
            _ => (),
        }
    }
    let modname = &input.ident;
    if modname.to_string() != ""__private"" {
        return syn::Error::new_spanned(
            modname,
            ""By convention, all the modules using the `dbtest` macro have to be called `__private`"",
        )
        .to_compile_error()
        .into();
    }
    let mut rng = thread_rng();
    let mut in_set = HashSet::<u16>::new();

    let mut result = quote! {};
    for item in content {
        /*
        Since standard (non-root) users can only access ports greater than 1024
        we will set the limit to (1024, 65535)
        However, for Windows, several ports in the range [49670, 50293] and ports {5357, 7680} are taken
        over by Hyper-V, which is why we'll prevent attempts to bind to them, if
        the OS is Windows.
        */
        let mut rand: u16 = rng.gen_range(1025, 65535);
        #[cfg(not(target_os = ""windows""))]
        {
            while in_set.contains(&rand) {
                rand = rng.gen_range(1025, 65535);
            }
        }
        #[cfg(target_os = ""windows"")]
        {
            in_set.insert(5357);
            in_set.insert(7680);
            while in_set.contains(&rand) || (rand >= 49670 && rand <= 50293) {
                rand = rng.gen_range(1025, 65535);
            }
        }
        in_set.insert(rand);
        match item {
            // We just care about functions, so parse functions and ignore everything
            // else
            syn::Item::Fn(function) => {
                if skips.contains(&function.sig.ident.to_string()) {
                    result = quote! {
                        #result
                        #function
                    };
                    continue;
                }
                let inp = parse_test_sig(function, rand);
                let __tok: syn::ItemFn = syn::parse_macro_input!(inp as syn::ItemFn);
                let tok = quote! {
                    #__tok
                };
                result = quote! {
                    #result
                    #tok
                };
            }
            token => {
                result = quote! {
                    #result
                    #token
                };
            }
        }
    }
    result.into()
}",1,"73,77,85","let mut rand: u16 = rng.gen_range(1025, 65535);/~/                rand = rng.gen_range(1025, 65535);/~/                rand = rng.gen_range(1025, 65535);"
"    fn save_translator(&self, translator: FuncTranslator) {
        self.translators.lock().unwrap().push(translator);
    }",0,,
"    pub fn inv(&self) -> Scalar {
        let mut ret = Scalar::default();
        ret.inv_in_place(self);
        ret
    }",0,,
"pub fn dbtest(args: TokenStream, item: TokenStream) -> TokenStream {
    parse_test_module(args, item)
}",0,,
"fn new<E: UserDefinedError>(pc: usize, code_size: usize) -> Result<Self, EbpfError<E>> {
        #[cfg(target_os = ""windows"")]
        {
            Ok(Self {
                page_size: 0,
                pc_section: &mut [],
                text_section: &mut [],
            })
        }
        #[cfg(not(target_os = ""windows""))]
        unsafe {
            let page_size = libc::sysconf(libc::_SC_PAGESIZE) as usize;
            let pc_loc_table_size = round_to_page_size(pc * 8, page_size);
            let over_allocated_code_size = round_to_page_size(code_size, page_size);
            let mut raw: *mut libc::c_void = std::ptr::null_mut();
            libc_error_guard!(mmap, &mut raw, pc_loc_table_size + over_allocated_code_size, libc::PROT_READ | libc::PROT_WRITE, libc::MAP_ANONYMOUS | libc::MAP_PRIVATE, 0, 0);
            Ok(Self {
                page_size,
                pc_section: std::slice::from_raw_parts_mut(raw as *mut u64, pc),
                text_section: std::slice::from_raw_parts_mut(raw.add(pc_loc_table_size) as *mut u8, over_allocated_code_size),
            })
        }
    }",0,,
"	fn exit_revert(&mut self) -> Result<(), ExitError> {
		self.substate.exit_revert()
	}",0,,
"    pub fn size_limit(mut self, size_limit: usize) -> Self {
        self.size_limit = size_limit;
        self
    }",0,,
"    fn pop_split_hole(&mut self) -> ResultOrEmpty {
        self.insts.pop();
        Ok(None)
    }",0,,
"    fn get_num_vregs(&self) -> usize {
        self.vreg_types.len()
    }",0,,
"    fn push_compiled(&mut self, inst: Inst) {
        self.insts.push(MaybeInst::Compiled(inst));
    }",0,,
"    fn push_hole(&mut self, inst: InstHole) -> Hole {
        let hole = self.insts.len();
        self.insts.push(MaybeInst::Uncompiled(inst));
        Hole::One(hole)
    }",0,,
"pub(super) fn parse_group<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    fn parse_capture<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (Capture<'i>, Span)> {
        map(pair(Token::Colon, opt(Token::Identifier)), |((_, span1), name)| {
            (Capture::new(name.map(|(s, _)| s)), span1)
        })(input)
    }",0,,
"pub fn new(size: usize, host: &String) -> Netpool {
            assert!(size > 0);
            let (sender, receiver) = mpsc::channel();
            let receiver = Arc::new(Mutex::new(receiver));
            let mut workers = Vec::with_capacity(size);
            for _ in 0..size {
                workers.push(Worker::new(Arc::clone(&receiver), host.to_owned()));
            }
            Netpool { workers, sender }
        }",0,,
"    fn memory_growing(&mut self, current: usize, desired: usize, _maximum: Option<usize>) -> bool {
        self.alloc(desired - current)
    }",0,,
"fn do_tls_read(&mut self) {
        // Read some TLS data.
        let rc = self.tls_session.read_tls(&mut self.socket);
        if rc.is_err() {
            let err = rc.unwrap_err();

            if let io::ErrorKind::WouldBlock = err.kind() {
                return;
            }

            error!(""read error {:?}"", err);
            self.closing = true;
            return;
        }

        if rc.unwrap() == 0 {
            debug!(""eof"");
            self.closing = true;
            return;
        }

        // Process newly-received TLS messages.
        let processed = self.tls_session.process_new_packets();
        if processed.is_err() {
            error!(""cannot process packet: {:?}"", processed);

            // last gasp write to send any alerts
            self.do_tls_write_and_handle_error();

            self.closing = true;
            return;
        }
    }",0,,
"pub fn parse_rpc(p: u8) -> Result<RecoveryId, Error> {
        if p >= 27 && p < 27 + 4 {
            RecoveryId::parse(p - 27)
        } else {
            Err(Error::InvalidRecoveryId)
        }
    }",0,,
"    fn take_split(&self, count: usize) -> (Self, Self) {
        let (left, right) = self.tokens.split_at(count);

        (Input { source: self.source, tokens: left }, Input { source: self.source, tokens: right })
    }",1,3,"        (Input { source: self.source, tokens: left }, Input { source: self.source, tokens: right })"
"fn global_drops_externref() -> anyhow::Result<()> {
    test_engine(&Engine::default())?;

    if !skip_pooling_allocator_tests() {
        test_engine(&Engine::new(
            Config::new().allocation_strategy(InstanceAllocationStrategy::pooling()),
        )?)?;
    }

    return Ok(());

    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Global::new(
            &mut store,
            GlobalType::new(ValType::ExternRef, Mutability::Const),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
                (module
                    (global (mut externref) (ref.null extern))

                    (func (export ""run"") (param externref)
                        local.get 0
                        global.set 0
                    )
                )
            ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }
}",0,,
"fn is_reftype(ty: Type) -> bool {
    ty == types::R64 || ty == types::R32
}",0,,
"pub fn is_high(&self) -> bool {
        let mut yes: bool = false;
        let mut no: bool = false;
        no = no || (self.0[7] < SECP256K1_N_H_7);
        yes = yes || ((self.0[7] > SECP256K1_N_H_7) & !no);
        no = no || ((self.0[6] < SECP256K1_N_H_6) & !yes); /* No need for a > check. */
        no = no || ((self.0[5] < SECP256K1_N_H_5) & !yes); /* No need for a > check. */
        no = no || ((self.0[4] < SECP256K1_N_H_4) & !yes); /* No need for a > check. */
        no = no || ((self.0[3] < SECP256K1_N_H_3) & !yes);
        yes = yes || ((self.0[3] > SECP256K1_N_H_3) && !no);
        no = no || ((self.0[2] < SECP256K1_N_H_2) && !yes);
        yes = yes || ((self.0[2] > SECP256K1_N_H_2) && !no);
        no = no || ((self.0[1] < SECP256K1_N_H_1) && !yes);
        yes = yes || ((self.0[1] > SECP256K1_N_H_1) && !no);
        yes = yes || ((self.0[0] >= SECP256K1_N_H_0) && !no);
        return yes;
    }",0,,
"fn is_storage_cold(&self, address: H160, key: H256) -> bool {
		self.substate
			.recursive_is_cold(&|a: &Accessed| a.accessed_storage.contains(&(address, key)))
	}",0,,
"    fn clone(&self) -> TypedFunc<Params, Results> {
        *self
    }",0,,
"	fn registrar(&self) -> Result<Address, String> {
		self.client.engine().additional_params().get(""registrar"")
			 .ok_or_else(|| ""Registrar not defined."".into())
			 .and_then(|registrar| {
				 registrar.parse().map_err(|e| format!(""Invalid registrar address: {:?}"", e))
			 })
	}",0,,
"    fn from(val: Func) -> Val {
        Val::FuncRef(Some(val))
    }",0,,
"fn drop(&mut self) {
            self.0.fetch_add(1, SeqCst);
        }",0,,
"pub(super) fn parse_special_char<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, char> {
    try_map(
        Token::Identifier,
        |(s, _)| {
            Ok(match s {
                ""n"" => '\n',
                ""r"" => '\r',
                ""t"" => '\t',
                ""a"" => '\u{07}',
                ""e"" => '\u{1B}',
                ""f"" => '\u{0C}',
                _ => return Err(ParseErrorKind::Incomplete),
            })
        },
        nom::Err::Error,
    )(input)
}",0,,
"    pub fn uninterruptable<T, F: FnOnce() -> T>(&mut self, f: F) -> T {
        self.kill_state.begin_hostcall();
        let res = f();
        let stop_reason = self.kill_state.end_hostcall();

        if let Some(termination_details) = stop_reason {
            // TODO: once we have unwinding, panic here instead so we unwind host frames
            unsafe {
                self.terminate(termination_details);
            }
        }

        res
    }",0,,
"fn random_filename() -> String {
	use ::rand::Rng;
	let mut rng = ::rand::OsRng::new().unwrap();
	rng.gen_ascii_chars().take(12).collect()
}",0,,
"fn table_next_is_at_correct_offset() {
        let table = VMExternRefActivationsTable::new();

        let table_ptr = &table as *const _;
        let next_ptr = &table.alloc.next as *const _;

        let actual_offset = (next_ptr as usize) - (table_ptr as usize);

        let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {
            ptr: 8,
            num_signature_ids: 0,
            num_imported_functions: 0,
            num_imported_tables: 0,
            num_imported_memories: 0,
            num_imported_globals: 0,
            num_defined_functions: 0,
            num_defined_tables: 0,
            num_defined_memories: 0,
            num_defined_globals: 0,
        });
        assert_eq!(
            offsets.vm_extern_ref_activation_table_next() as usize,
            actual_offset
        );
    }",0,,
"fn test_be32_high() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1]
        be32 r0
        exit"",
        [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11223344 } },
        3
    );
}",0,,
"	fn call(&self, address: Address, data: Bytes) -> BoxFuture<Bytes, String> {
		self.client.call_contract(BlockId::Latest, address, data)
			.into_future()
			.boxed()
	}",0,,
"fn recover_signer(transaction: &Transaction) -> Option<H160> {
		let mut sig = [0u8; 65];
		let mut msg = [0u8; 32];
		match transaction {
			Transaction::Legacy(t) => {
				sig[0..32].copy_from_slice(&t.signature.r()[..]);
				sig[32..64].copy_from_slice(&t.signature.s()[..]);
				sig[64] = t.signature.standard_v();
				msg.copy_from_slice(
					&ethereum::LegacyTransactionMessage::from(t.clone()).hash()[..],
				);
			}
			Transaction::EIP2930(t) => {
				sig[0..32].copy_from_slice(&t.r[..]);
				sig[32..64].copy_from_slice(&t.s[..]);
				sig[64] = t.odd_y_parity as u8;
				msg.copy_from_slice(
					&ethereum::EIP2930TransactionMessage::from(t.clone()).hash()[..],
				);
			}
			Transaction::EIP1559(t) => {
				sig[0..32].copy_from_slice(&t.r[..]);
				sig[32..64].copy_from_slice(&t.s[..]);
				sig[64] = t.odd_y_parity as u8;
				msg.copy_from_slice(
					&ethereum::EIP1559TransactionMessage::from(t.clone()).hash()[..],
				);
			}
		}
		let pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;
		Some(H160::from(H256::from(sp_io::hashing::keccak_256(&pubkey))))
	}",0,,
"fn check_before(&mut self, reachable: bool) {
        assert_eq!(reachable, self.reachability[self.before_idx].0);
        self.before_idx += 1;
    }",0,,
"pub fn func_index(&self) -> u32 {
        self.func_index
    }",0,,
"fn decode_chunk_precise(
    input: &[u8],
    index_at_start_of_input: usize,
    decode_table: &[u8; 256],
    output: &mut [u8],
) -> Result<(), DecodeError> {
    let mut tmp_buf = [0_u8; 8];

    decode_chunk(
        input,
        index_at_start_of_input,
        decode_table,
        &mut tmp_buf[..],
    )?;

    output[0..6].copy_from_slice(&tmp_buf[0..6]);

    Ok(())
}",0,,
"fn drop(&mut self) {
        let data = self.extern_data();

        // Note that the memory orderings here also match the standard library
        // itself. Documentation is more available in the implementation of
        // `Arc`, but the general idea is that this is a special pattern allowed
        // by the C standard with atomic orderings where we ""release"" for all
        // the decrements and only the final decrementer performs an acquire
        // fence. This properly ensures that the final thread, which actually
        // destroys the data, sees all the updates from all other threads.
        if data.ref_count.fetch_sub(1, Ordering::Release) != 1 {
            return;
        }
        atomic::fence(Ordering::Acquire);

        // Drop our live reference to `data` before we drop it itself.
        drop(data);
        unsafe {
            VMExternData::drop_and_dealloc(self.0);
        }
    }",0,,
"fn _assert_send_sync() {
    fn _assert<T: Send + Sync>() {}
    _assert::<VMExternRefActivationsTable>();
    _assert::<VMExternRef>();
}",0,,
"    fn deref(&self) -> &Self::Target {
        unsafe { self.inst.as_ref() }
    }",0,,
"fn reference_type(wasm_ty: cranelift_wasm::WasmType, pointer_type: ir::Type) -> ir::Type {
    match wasm_ty {
        cranelift_wasm::WasmType::FuncRef => pointer_type,
        cranelift_wasm::WasmType::ExternRef => match pointer_type {
            ir::types::I32 => ir::types::R32,
            ir::types::I64 => ir::types::R64,
            _ => panic!(""unsupported pointer type""),
        },
        _ => panic!(""unsupported Wasm reference type""),
    }
}",0,,
"fn test_load_elf_empty_rodata() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/empty_rodata.so"",
        config,
        [],
        (
            b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        8
    );
}",0,,
"    fn from(ty: ModuleType) -> ExternType {
        ExternType::Module(ty)
    }",0,,
"fn c_repeat_range_min_or_more(
        &mut self,
        expr: &Hir,
        greedy: bool,
        min: u32,
    ) -> ResultOrEmpty {
        let min = u32_to_usize(min);
        // Using next_inst() is ok, because we can't return it (concat would
        // have to return Some(_) while c_repeat_range_min_or_more returns
        // None).
        let patch_concat = self
            .c_concat(iter::repeat(expr).take(min))?
            .unwrap_or(self.next_inst());
        if let Some(patch_rep) = self.c_repeat_zero_or_more(expr, greedy)? {
            self.fill(patch_concat.hole, patch_rep.entry);
            Ok(Some(Patch { hole: patch_rep.hole, entry: patch_concat.entry }))
        } else {
            Ok(None)
        }
    }",0,,
"pub fn migrate_block_v0_to_v2() -> Weight {
		let db_weights = T::DbWeight::get();
		let mut weight: Weight = db_weights.read;
		let item = b""CurrentBlock"";
		let block_v0 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV0>(
			Self::name().as_bytes(),
			item,
			&[],
		);
		if let Some(block_v0) = block_v0 {
			weight = weight.saturating_add(db_weights.write);
			let block_v2: ethereum::BlockV2 = block_v0.into();
			frame_support::storage::migration::put_storage_value::<ethereum::BlockV2>(
				Self::name().as_bytes(),
				item,
				&[],
				block_v2,
			);
		}
		weight
	}",0,,
"fn f64_equal(a: u64, b: u64) -> bool {
    let a = f64::from_bits(a);
    let b = f64::from_bits(b);
    a == b || (a.is_nan() && b.is_nan())
}",0,,
"    fn is_ret(&self, insn: InstIx) -> bool {
        match self.insts[insn.get() as usize].is_term() {
            MachTerminator::Ret => true,
            _ => false,
        }
    }",0,,
"pub fn clone_cstring_safely(out_ptr: *const c_char) -> Result<CString> {
        if out_ptr.is_null() {
            return_errno!(EINVAL, ""NULL address is invalid"");
        }

        let cstr = unsafe { CStr::from_ptr(out_ptr) };
        let cstring = CString::from(cstr);
        if !is_inside_user_space(out_ptr as *const u8, cstring.as_bytes().len()) {
            return_errno!(EFAULT, ""the whole buffer is not in the user space"");
        }
        Ok(cstring)
    }",1,7,"if !is_inside_user_space(out_ptr as *const u8, cstring.as_bytes().len()) {"
"fn test_stxh() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r2, 0x2211
        stxh [r1+2], r2
        ldxh r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2211 } },
        4
    );
}",0,,
"pub fn is_even(&self) -> bool {
        return self.0[0] & 1 == 0;
    }",0,,
"    pub(crate) unsafe fn from_caller_checked_anyfunc(
        store: &mut StoreOpaque,
        anyfunc: *mut VMCallerCheckedAnyfunc,
    ) -> Option<Self> {
        let anyfunc = NonNull::new(anyfunc)?;
        debug_assert!(anyfunc.as_ref().type_index != VMSharedSignatureIndex::default());
        let export = ExportFunction { anyfunc };
        Some(Func::from_wasmtime_function(export, store))
    }",0,,
"    pub fn expect_yielded(self, msg: &str) -> YieldedVal {
        self.yielded().expect(msg)
    }",0,,
"    pub(crate) fn wasmtime_table(&self) -> &Table {
        &self.ty
    }",0,,
"	pub fn queue(&self) -> Arc<ConfirmationsQueue> {
		self.queue.clone()
	}",0,,
"fn extern_data(&self) -> &VMExternData {
        unsafe { self.0.as_ref() }
    }",0,,
"fn test_jsle_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -1
        mov r2, -2
        mov32 r3, 0
        jsle r1, r2, +1
        jsle r1, r3, +1
        exit
        mov32 r0, 1
        mov r1, r2
        jsle r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        10
    );
}",0,,
"fn test_err_div32_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        div32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,,
"	fn exit_discard(&mut self) -> Result<(), ExitError> {
		self.substate.exit_discard()
	}",0,,
"pub(super) fn parse_code_point<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (char, Span)> {
    alt((
        try_map(
            Token::CodePoint,
            |(s, span)| {
                let hex = &s[2..];
                if hex.len() > 6 {
                    Err(ParseErrorKind::CodePoint(CodePointError::Invalid))
                } else {
                    u32::from_str_radix(hex, 16)
                        .ok()
                        .and_then(|n| char::try_from(n).ok())
                        .map(|c| (c, span))
                        .ok_or(ParseErrorKind::CodePoint(CodePointError::Invalid))
                }
            },
            nom::Err::Failure,
        ),
        try_map(
            Token::Identifier,
            |(str, span)| {
                if let Some(rest) = str.strip_prefix('U') {
                    if let Ok(n) = u32::from_str_radix(rest, 16) {
                        if let Ok(c) = char::try_from(n) {
                            return Ok((c, span));
                        } else {
                            return Err(ParseErrorKind::CodePoint(CodePointError::Invalid));
                        }
                    }
                }
                Err(ParseErrorKind::ExpectedToken(Token::CodePoint))
            },
            nom::Err::Error,
        ),
    ))(input)
}",0,,
"fn c_class(&mut self, ranges: &[hir::ClassUnicodeRange]) -> ResultOrEmpty {
        use std::mem::size_of;

        assert!(!ranges.is_empty());
        if self.compiled.uses_bytes() {
            Ok(Some(CompileClass { c: self, ranges: ranges }.compile()?))
        } else {
            let ranges: Vec<(char, char)> =
                ranges.iter().map(|r| (r.start(), r.end())).collect();
            let hole = if ranges.len() == 1 && ranges[0].0 == ranges[0].1 {
                self.push_hole(InstHole::Char { c: ranges[0].0 })
            } else {
                self.extra_inst_bytes +=
                    ranges.len() * (size_of::<char>() * 2);
                self.push_hole(InstHole::Ranges { ranges: ranges })
            };
            Ok(Some(Patch { hole: hole, entry: self.insts.len() - 1 }))
        }
    }",0,,
"fn test_reloc_64_relative_data_pre_sbfv2() {
    // Before https://github.com/solana-labs/llvm-project/pull/35, we used to
    // generate invalid R_BPF_64_RELATIVE relocations in sections other than
    // .text.
    //
    // This test checks that the old behaviour is maintained for backwards
    // compatibility when dealing with non-sbfv2 files. See also Elf::relocate().
    //
    // The program returns the address of the first .rodata byte.
    // [ 1] .text             PROGBITS        00000000000000e8 0000e8 000020 00  AX  0   0  8
    // [ 2] .rodata           PROGBITS        0000000000000108 000108 000019 01 AMS  0   0  1
    //
    // 00000000000001f8 <FILE>:
    // 63:       00 00 00 00 08 01 00 00
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative_data_pre_sbfv2.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x108 } },
        3
    );
}",0,,
"    fn clear(&mut self) {
        self.dense.clear();
    }",0,,
"pub async fn run(
    listener: TcpListener,
    bgsave_cfg: BGSave,
    snapshot_cfg: SnapshotConfig,
    sig: impl Future,
    restore_filepath: Option<PathBuf>,
) {
    let (signal, _) = broadcast::channel(1);
    let (terminate_tx, terminate_rx) = mpsc::channel(1);
    let db = match CoreDB::new(bgsave_cfg, snapshot_cfg, restore_filepath) {
        Ok(d) => d,
        Err(e) => {
            eprintln!(""ERROR: {}"", e);
            process::exit(0x100);
        }
    };
    match fs::create_dir_all(&*DIR_REMOTE_SNAPSHOT) {
        Ok(_) => (),
        Err(e) => match e.kind() {
            ErrorKind::AlreadyExists => (),
            _ => {
                log::error!(""Failed to create snapshot directories: '{}'"", e);
                process::exit(0x100);
            }
        },
    }
    log::info!(
        ""Started server on terrapipe://{}"",
        listener
            .local_addr()
            .expect(""The local address couldn't be fetched. Please file a bug report"")
    );
    let mut server = Listener {
        listener,
        db,
        climit: Arc::new(Semaphore::new(50000)),
        signal,
        terminate_tx,
        terminate_rx,
    };
    tokio::select! {
        _ = server.run() => {}
        _ = sig => {
            log::info!(""Signalling all workers to shut down"");
        }
    }
    let Listener {
        mut terminate_rx,
        terminate_tx,
        signal,
        db,
        ..
    } = server;
    if let Ok(_) = db.flush_db() {
        log::info!(""Successfully saved data to disk"");
        ()
    } else {
        log::error!(""Failed to flush data to disk"");
        loop {
            // Keep looping until we successfully write the in-memory table to disk
            log::warn!(""Press enter to try again..."");
            io::stdout().flush().unwrap();
            io::stdin().read(&mut [0]).unwrap();
            if let Ok(_) = db.flush_db() {
                log::info!(""Successfully saved data to disk"");
                break;
            } else {
                continue;
            }
        }
    }
    drop(signal);
    drop(terminate_tx);
    let _ = terminate_rx.recv().await;
    terminal::write_info(""Goodbye :)\n"").unwrap();
}",0,,
"pub fn new<T>(
        mut store: impl AsContextMut<Data = T>,
        ty: FuncType,
        func: impl Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + 'static,
    ) -> Self {
        let store = store.as_context_mut().0;

        // part of this unsafety is about matching the `T` to a `Store<T>`,
        // which is done through the `AsContextMut` bound above.
        unsafe {
            let host = HostFunc::new(store.engine(), ty, func);
            host.into_func(store)
        }
    }

    /// Creates a new host-defined WebAssembly function which, when called,
    /// will run the asynchronous computation defined by `func` to completion
    /// and then return the result to WebAssembly.
    ///
    /// This function is the asynchronous analogue of [`Func::new`] and much of
    /// that documentation applies to this as well. The key difference is that
    /// `func` returns a future instead of simply a `Result`. Note that the
    /// returned future can close over any of the arguments, but it cannot close
    /// over the state of the closure itself. It's recommended to store any
    /// necessary async state in the `T` of the [`Store<T>`](crate::Store) which
    /// can be accessed through [`Caller::data`] or [`Caller::data_mut`].
    ///
    /// For more information on `Send + Sync + 'static`, see
    /// [`Func::wrap`](#why-send--sync--static).
    ///
    /// # Panics
    ///
    /// This function will panic if `store` is not associated with an [async
    /// config](crate::Config::async_support).
    ///
    /// # Examples
    ///
    /// ```
    /// # use wasmtime::*;
    /// # fn main() -> anyhow::Result<()> {
    /// // Simulate some application-specific state as well as asynchronous
    /// // functions to query that state.
    /// struct MyDatabase {
    ///     // ...
    /// }
    ///
    /// impl MyDatabase {
    ///     async fn get_row_count(&self) -> u32 {
    ///         // ...
    /// #       100
    ///     }
    /// }
    ///
    /// let my_database = MyDatabase {
    ///     // ...
    /// };
    ///
    /// // Using `new_async` we can hook up into calling our async
    /// // `get_row_count` function.
    /// let engine = Engine::new(Config::new().async_support(true))?;
    /// let mut store = Store::new(&engine, MyDatabase {
    ///     // ...
    /// });
    /// let get_row_count_type = wasmtime::FuncType::new(
    ///     None,
    ///     Some(wasmtime::ValType::I32),
    /// );
    /// let get = Func::new_async(&mut store, get_row_count_type, |caller, _params, results| {
    ///     Box::new(async move {
    ///         let count = caller.data().get_row_count().await;
    ///         results[0] = Val::I32(count as i32);
    ///         Ok(())
    ///     })
    /// });
    /// // ...
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(all(feature = ""async"", feature = ""cranelift""))]
    #[cfg_attr(nightlydoc, doc(cfg(all(feature = ""async"", feature = ""cranelift""))))]
    pub fn new_async<T, F>(store: impl AsContextMut<Data = T>, ty: FuncType, func: F) -> Func
    where
        F: for<'a> Fn(
                Caller<'a, T>,
                &'a [Val],
                &'a mut [Val],
            ) -> Box<dyn Future<Output = Result<(), Trap>> + Send + 'a>
            + Send
            + Sync
            + 'static,
    {
        assert!(
            store.as_context().async_support(),
            ""cannot use `new_async` without enabling async support in the config""
        );
        Func::new(store, ty, move |mut caller, params, results| {
            let async_cx = caller.store.as_context_mut().0.async_cx();
            let mut future = Pin::from(func(caller, params, results));
            match unsafe { async_cx.block_on(future.as_mut()) } {
                Ok(Ok(())) => Ok(()),
                Ok(Err(trap)) | Err(trap) => Err(trap),
            }
        })
    }",0,,
"fn test_show_config() {
        let config = integration_test_utils::make_config_from_args(&[]);
        let mut writer = Cursor::new(vec![0; 1024]);
        show_config(&config, &mut writer).unwrap();
        let mut s = String::new();
        writer.seek(SeekFrom::Start(0)).unwrap();
        writer.read_to_string(&mut s).unwrap();
        let s = ansi::strip_ansi_codes(&s);
        assert!(s.contains(""    commit-style                  = raw\n""));
        assert!(s.contains(r""    word-diff-regex               = '\w+'""));
    }",0,,
"pub fn wrap<T, Params, Results>(
        mut store: impl AsContextMut<Data = T>,
        func: impl IntoFunc<T, Params, Results>,
    ) -> Func {
        let store = store.as_context_mut().0;
        // part of this unsafety is about matching the `T` to a `Store<T>`,
        // which is done through the `AsContextMut` bound above.
        unsafe {
            let host = HostFunc::wrap(store.engine(), func);
            host.into_func(store)
        }
    }",0,,
"fn seal<E: UserDefinedError>(&mut self, text_section_usage: usize) -> Result<(), EbpfError<E>> {
        if self.page_size > 0 {
            let raw = self.pc_section.as_ptr() as *mut u8;
            let pc_loc_table_size = round_to_page_size(self.pc_section.len() * 8, self.page_size);
            let over_allocated_code_size = round_to_page_size(self.text_section.len(), self.page_size);
            let code_size = round_to_page_size(text_section_usage, self.page_size);
            #[cfg(not(target_os = ""windows""))]
            unsafe {
                if over_allocated_code_size > code_size {
                    libc_error_guard!(munmap, raw.add(pc_loc_table_size).add(code_size) as *mut _, over_allocated_code_size - code_size);
                }
                std::ptr::write_bytes(raw.add(pc_loc_table_size).add(text_section_usage), 0xcc, code_size - text_section_usage); // Fill with debugger traps
                self.text_section = std::slice::from_raw_parts_mut(raw.add(pc_loc_table_size), text_section_usage);
                libc_error_guard!(mprotect, self.pc_section.as_mut_ptr() as *mut _, pc_loc_table_size, libc::PROT_READ);
                libc_error_guard!(mprotect, self.text_section.as_mut_ptr() as *mut _, code_size, libc::PROT_EXEC | libc::PROT_READ);
            }
        }
        Ok(())
    }",0,,
"pub fn maximum(&self) -> Option<u32> {
        self.ty.maximum
    }",0,,
"pub fn recover(message: &Message, signature: &Signature, recovery_id: &RecoveryId) -> Result<PublicKey, Error> {
    ECMULT_CONTEXT.recover_raw(&signature.r, &signature.s, recovery_id.0, &message.0).map(|v| PublicKey(v))
}",0,,
"fn calc(reqs: usize, time: u128) -> f64 {
        reqs as f64 / (time as f64 / 1_000_000_000 as f64)
    }",0,,
"fn open_back(mode: &ServerMode) -> Option<TcpStream> {
    match *mode {
        ServerMode::Forward(ref port) => {
            let addr = net::SocketAddrV4::new(net::Ipv4Addr::new(127, 0, 0, 1), *port);
            let conn = TcpStream::connect(&net::SocketAddr::V4(addr)).unwrap();
            Some(conn)
        }
        _ => None,
    }
}",0,,
"fn drop(&mut self) {
            self.live_refs.fetch_sub(1, SeqCst);
        }",0,,
"pub fn is_num(&self) -> bool {
        match self {
            ValType::I32 | ValType::I64 | ValType::F32 | ValType::F64 => true,
            _ => false,
        }
    }",0,,
"pub fn set_command_line_args() -> Command<'static> {
    let app = Command::new(""swhkd"")
        .version(env!(""CARGO_PKG_VERSION""))
        .author(env!(""CARGO_PKG_AUTHORS""))
        .about(""Simple Wayland HotKey Daemon"")
        .arg(
            arg!(-c --config <CONFIG_FILE_PATH>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom config file path.""),
        )
        .arg(
            arg!(-C --cooldown <COOLDOWN_IN_MS>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom repeat cooldown duration. Default is 250ms.""),
        )
        .arg(arg!(-d - -debug).required(false).help(""Enable debug mode.""));
    app
}",0,,
"    pub fn reverse(mut self, yes: bool) -> Self {
        self.compiled.is_reverse = yes;
        self
    }",0,,
"pub fn b32(&self) -> [u8; 32] {
        let mut bin = [0u8; 32];
        self.fill_b32(&mut bin);
        bin
    }",0,,
"fn test_mov() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r1, 1
        mov32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        3
    );
}",0,,
"fn test_err_ldabsb_oob() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsb 0x33
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 29 && vm_addr == 0x400000033 && len == 1 && name == ""input""
                )
            }
        },
        1
    );
}",0,,
"pub fn _list_syntax_themes_for_humans(writer: &mut dyn Write) -> std::io::Result<()> {
    let assets = HighlightingAssets::new();
    let themes = &assets.theme_set.themes;

    writeln!(writer, ""Light themes:"")?;
    for (theme, _) in themes.iter().filter(|(t, _)| is_light_syntax_theme(*t)) {
        writeln!(writer, ""    {}"", theme)?;
    }
    writeln!(writer, ""\nDark themes:"")?;
    for (theme, _) in themes.iter().filter(|(t, _)| !is_light_syntax_theme(*t)) {
        writeln!(writer, ""    {}"", theme)?;
    }
    writeln!(
        writer,
        ""\nUse delta --show-syntax-themes to demo the themes.""
    )?;
    Ok(())
}",0,,
"fn fill_split(&mut self, goto1: InstPtr, goto2: InstPtr) {
        let filled = match *self {
            MaybeInst::Split => {
                Inst::Split(InstSplit { goto1: goto1, goto2: goto2 })
            }
            _ => unreachable!(
                ""must be called on Split instruction, \
                 instead it was called on: {:?}"",
                self
            ),
        };
        *self = MaybeInst::Compiled(filled);
    }",0,,
"fn test_mov_large() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r1, -1
        mov32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xffffffff } },
        3
    );
}",0,,
"fn from_str<T: FromStr>(s: &str) -> Result<T, ParseErrorKind> {
    str::parse(s).map_err(|_| ParseErrorKind::Number(NumberError::TooLarge))
}",0,,
"fn test_div32_high_divisor() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 12
        lddw r1, 0x100000004
        div32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3 } },
        4
    );
}",0,,
"pub fn fetch_xdg_config_path() -> std::path::PathBuf {
    let config_file_path: std::path::PathBuf = match env::var(""XDG_CONFIG_HOME"") {
        Ok(val) => {
            log::debug!(""XDG_CONFIG_HOME exists: {:#?}"", val);
            Path::new(&val).join(""swhkd/swhkdrc"")
        }
        Err(_) => {
            log::error!(""XDG_CONFIG_HOME has not been set."");
            Path::new(""/etc/swhkd/swhkdrc"").to_path_buf()
        }
    };
    config_file_path
}",0,,
"    pub(crate) fn with<R>(f: impl FnOnce(&GlobalModuleRegistry) -> R) -> R {
        f(&GLOBAL_MODULES.read().unwrap())
    }",0,,
"fn get_spillslot_size(&self, regclass: RegClass, _: VirtualReg) -> u32 {
        self.abi.get_spillslot_size(regclass)
    }",0,,
"fn test_err_sdiv32_overflow_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x80
        lsh r0, 24
        sdiv32 r0, -1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideOverflow(pc) if pc == 31)
        },
        3
    );
}",0,,
"fn try_pager(
        quit_if_one_screen: bool,
        pager_from_config: Option<String>,
        config: &config::Config,
    ) -> Result<Self> {
        let mut replace_arguments_to_less = false;

        let pager_from_env = match (
            env::var(""DELTA_PAGER""),
            env::var(""BAT_PAGER""),
            env::var(""PAGER""),
        ) {
            (Ok(delta_pager), _, _) => Some(delta_pager),
            (_, Ok(bat_pager), _) => Some(bat_pager),
            (_, _, Ok(pager)) => {
                // less needs to be called with the '-R' option in order to properly interpret ANSI
                // color sequences. If someone has set PAGER=""less -F"", we therefore need to
                // overwrite the arguments and add '-R'.
                // We only do this for PAGER, since it is used in other contexts.
                replace_arguments_to_less = true;
                Some(pager)
            }
            _ => None,
        };

        if pager_from_config.is_some() {
            replace_arguments_to_less = false;
        }

        let pager = pager_from_config
            .or(pager_from_env)
            .unwrap_or_else(|| String::from(""less""));

        let pagerflags =
            shell_words::split(&pager).chain_err(|| ""Could not parse pager command."")?;

        match pagerflags.split_first() {
            Some((pager_name, args)) => {
                let pager_path = PathBuf::from(pager_name);

                let is_less = pager_path.file_stem() == Some(&OsString::from(""less""));

                let mut process = if is_less {
                    let mut p = Command::new(&pager_path);
                    if args.is_empty() || replace_arguments_to_less {
                        p.args(vec![""--RAW-CONTROL-CHARS""]);

                        // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older
                        // versions of 'less'. Unfortunately, it also breaks mouse-wheel support.
                        //
                        // See: http://www.greenwoodsoftware.com/less/news.530.html
                        //
                        // For newer versions (530 or 558 on Windows), we omit '--no-init' as it
                        // is not needed anymore.
                        match retrieve_less_version() {
                            None => {
                                p.arg(""--no-init"");
                            }
                            Some(version)
                                if (version < 530 || (cfg!(windows) && version < 558)) =>
                            {
                                p.arg(""--no-init"");
                            }
                            _ => {}
                        }

                        if quit_if_one_screen {
                            p.arg(""--quit-if-one-screen"");
                        }
                    } else {
                        p.args(args);
                    }
                    p.env(""LESSCHARSET"", ""UTF-8"");
                    p
                } else {
                    if pager_path.file_stem() == Some(&OsString::from(""delta"")) {
                        eprintln!(
                            ""\
It looks like you have set delta as the value of $PAGER. \
This would result in a non-terminating recursion. \
delta is not an appropriate value for $PAGER \
(but it is an appropriate value for $GIT_PAGER).""
                        );
                        std::process::exit(1);
                    }
                    let mut p = Command::new(&pager_path);
                    p.args(args);
                    p
                };
                if is_less && config.navigate {
                    if let Ok(hist_file) =
                        navigate::copy_less_hist_file_and_append_navigate_regexp(config)
                    {
                        process.env(""LESSHISTFILE"", hist_file);
                        if config.show_themes {
                            process.arg(""+n"");
                        }
                    }
                }
                Ok(process
                    .env(""LESSANSIENDCHARS"", ""mK"")
                    .stdin(Stdio::piped())
                    .spawn()
                    .map(OutputType::Pager)
                    .unwrap_or_else(|_| OutputType::stdout()))
            }
            None => Ok(OutputType::stdout()),
        }
    }",1,"36,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,75,76,77,78,79,80,81,82,83,84,85,86,87,89,90,91,92,93,94,95,96,97,99,100,101,102,103,104,106,107","match pagerflags.split_first() {/~/                let mut process = if is_less {/~/                    let mut p = Command::new(&pager_path);/~/                    if args.is_empty() || replace_arguments_to_less {/~/                        p.args(vec![""--RAW-CONTROL-CHARS""]);/~//~/                        // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older/~/                        // versions of 'less'. Unfortunately, it also breaks mouse-wheel support./~/                        ///~/                        // See: http://www.greenwoodsoftware.com/less/news.530.html/~/                        ///~/                        // For newer versions (530 or 558 on Windows), we omit '--no-init' as it/~/                        // is not needed anymore./~/                        match retrieve_less_version() {/~/                            None => {/~/                                p.arg(""--no-init"");/~/                            }/~/                            Some(version)/~/                                if (version < 530 || (cfg!(windows) && version < 558)) =>/~/                            {/~/                                p.arg(""--no-init"");/~/                            }/~/                            _ => {}/~/                        }/~//~/                        if quit_if_one_screen {/~/                            p.arg(""--quit-if-one-screen"");/~/                        }/~/                    } else {/~/                        p.args(args);/~/                    }/~/                    p.env(""LESSCHARSET"", ""UTF-8"");/~/                    p/~/                    if pager_path.file_stem() == Some(&OsString::from(""delta"")) {/~/                        eprintln!(/~/                            ""\/~/It looks like you have set delta as the value of $PAGER. \/~/This would result in a non-terminating recursion. \/~/delta is not an appropriate value for $PAGER \/~/(but it is an appropriate value for $GIT_PAGER).""/~/                        );/~/                        std::process::exit(1);/~/                    }/~/                    let mut p = Command::new(&pager_path);/~/                    p.args(args);/~/                    p/~/                if is_less && config.navigate {/~/                    if let Ok(hist_file) =/~/                        navigate::copy_less_hist_file_and_append_navigate_regexp(config)/~/                    {/~/                        process.env(""LESSHISTFILE"", hist_file);/~/                        if config.show_themes {/~/                            process.arg(""+n"");/~/                        }/~/                    }/~/                Ok(process/~/                    .env(""LESSANSIENDCHARS"", ""mK"")/~/                    .stdin(Stdio::piped())/~/                    .spawn()/~/                    .map(OutputType::Pager)/~/                    .unwrap_or_else(|_| OutputType::stdout()))/~/            None => Ok(OutputType::stdout()),/~/        }"
"fn indirect_signature(isa: &dyn TargetIsa, wasm: &WasmFuncType) -> ir::Signature {
    let mut sig = blank_sig(isa, wasmtime_call_conv(isa));
    push_types(isa, &mut sig, wasm);
    return sig;
}",0,,
"fn apply(source: H160, transaction: Transaction) -> DispatchResultWithPostInfo {
		Pallet::<T>::apply_validated_transaction(source, transaction)
	}",0,,
"fn func_signature(
    isa: &dyn TargetIsa,
    translation: &ModuleTranslation,
    types: &TypeTables,
    index: FuncIndex,
) -> ir::Signature {
    let call_conv = match translation.module.defined_func_index(index) {
        // If this is a defined function in the module and it's never possibly
        // exported, then we can optimize this function to use the fastest
        // calling convention since it's purely an internal implementation
        // detail of the module itself.
        Some(idx) if !translation.escaped_funcs.contains(&idx) => CallConv::Fast,

        // ... otherwise if it's an imported function or if it's a possibly
        // exported function then we use the default ABI wasmtime would
        // otherwise select.
        _ => wasmtime_call_conv(isa),
    };
    let mut sig = blank_sig(isa, call_conv);
    push_types(
        isa,
        &mut sig,
        &types.wasm_signatures[translation.module.functions[index]],
    );
    return sig;
}",0,,
"pub(crate) fn skip_pooling_allocator_tests() -> bool {
    // There are a couple of issues when running the pooling allocator tests under QEMU:
    // - high memory usage that may exceed the limits imposed by the environment (e.g. CI)
    // - https://github.com/bytecodealliance/wasmtime/pull/2518#issuecomment-747280133
    std::env::var(""WASMTIME_TEST_NO_HOG_MEMORY"").is_ok()
}",0,,
"    pub fn data_mut(&mut self) -> &mut T {
        self.inner.data_mut()
    }",0,,
"pub unsafe fn clone_from_raw(ptr: *mut u8) -> Self {
        debug_assert!(!ptr.is_null());
        let x = VMExternRef(NonNull::new_unchecked(ptr).cast());
        x.extern_data().increment_ref_count();
        x
    }",0,,
"fn drop(&mut self) {
            self.0.store(true, SeqCst);
        }",0,,
"fn many_live_refs() -> anyhow::Result<()> {
    let mut wat = r#""
        (module
            ;; Make new `externref`s.
            (import """" ""make_ref"" (func $make_ref (result externref)))

            ;; Observe an `externref` so it is kept live.
            (import """" ""observe_ref"" (func $observe_ref (param externref)))

            (func (export ""many_live_refs"")
    ""#
    .to_string();

    // This is more than the initial `VMExternRefActivationsTable` capacity, so
    // it will need to allocate additional bump chunks.
    const NUM_LIVE_REFS: usize = 1024;

    // Push `externref`s onto the stack.
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $make_ref)\n"");
    }

    // Pop `externref`s from the stack. Because we pass each of them to a
    // function call here, they are all live references for the duration of
    // their lifetimes.
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $observe_ref)\n"");
    }

    wat.push_str(
        ""
            ) ;; func
        ) ;; module
        "",
    );

    let (mut store, module) = ref_types_module(&wat)?;

    let live_refs = Arc::new(AtomicUsize::new(0));

    let make_ref = Func::wrap(&mut store, {
        let live_refs = live_refs.clone();
        move || Some(ExternRef::new(CountLiveRefs::new(live_refs.clone())))
    });

    let observe_ref = Func::wrap(&mut store, |r: Option<ExternRef>| {
        let r = r.unwrap();
        let r = r.data().downcast_ref::<CountLiveRefs>().unwrap();
        assert!(r.live_refs.load(SeqCst) > 0);
    });

    let instance = Instance::new(&mut store, &module, &[make_ref.into(), observe_ref.into()])?;
    let many_live_refs = instance.get_func(&mut store, ""many_live_refs"").unwrap();

    many_live_refs.call(&mut store, &[], &mut [])?;

    store.gc();
    assert_eq!(live_refs.load(SeqCst), 0);

    return Ok(());

    struct CountLiveRefs {
        live_refs: Arc<AtomicUsize>,
    }

    impl CountLiveRefs {
        fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }
    }

    impl Drop for CountLiveRefs {
        fn drop(&mut self) {
            self.live_refs.fetch_sub(1, SeqCst);
        }
    }
}",1,36,"    let (mut store, module) = ref_types_module(&wat)?;"
"    pub fn file(&self) -> Option<&str> {
        self.file.as_deref()
    }",0,,
"fn reset_storage(&mut self, address: H160) {
		let _ = <AccountStorages<T>>::remove_prefix(address, None);
	}",0,,
"pub fn parse(p: &[u8; util::MESSAGE_SIZE]) -> Message {
        let mut m = Scalar::default();

        // Okay for message to overflow.
        let _ = m.set_b32(p);

        Message(m)
    }",0,,
"fn test_syscall_parameter_on_stack() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, r10
        add64 r1, -0x100
        mov64 r2, 0x1
        syscall BpfSyscallString
        mov64 r0, 0x0
        exit"",
        [],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        6
    );
}",0,,
"    pub fn end_bb(&mut self) {
        let start_idx = self.block_start;
        let end_idx = self.vcode.insts.len() as InsnIndex;
        self.block_start = end_idx;
        // Add the instruction index range to the list of blocks.
        self.vcode.block_ranges.push((start_idx, end_idx));
        // End the successors list.
        let succ_end = self.vcode.block_succs.len();
        self.vcode
            .block_succ_range
            .push((self.succ_start, succ_end));
        self.succ_start = succ_end;
    }",0,,
"pub fn set_command_line_args() -> Command<'static> {
    let app = Command::new(""swhkd"")
        .version(env!(""CARGO_PKG_VERSION""))
        .author(env!(""CARGO_PKG_AUTHORS""))
        .about(""Simple Wayland HotKey Daemon"")
        .arg(
            arg!(-c --config <CONFIG_FILE_PATH>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom config file path.""),
        )
        .arg(
            arg!(-C --cooldown <COOLDOWN_IN_MS>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom repeat cooldown duration. Default is 250ms.""),
        )
        .arg(arg!(-d - -debug).required(false).help(""Enable debug mode.""));
    app
}",0,,
"fn test_arsh32_high_shift() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 8
        lddw r1, 0x100000001
        arsh32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x4 } },
        4
    );
}",0,,
"fn from(ty: wasmparser::MemoryType) -> Memory {
        Memory {
            minimum: ty.initial,
            maximum: ty.maximum,
            shared: ty.shared,
            memory64: ty.memory64,
        }
    }",0,,
"fn test_err_bpf_to_bpf_too_deep() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/multiple_file.so"",
        config,
        [config.max_call_depth as u8],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::CallDepthExceeded(pc, depth)
                    if pc == 55 && depth == config.max_call_depth
                )
            }
        },
        176
    );
}",0,,
"fn test_tcp_port80_nomatch_ethertype() {
    test_interpreter_and_jit_asm!(
        PROG_TCP_PORT_80,
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x06, //
            0x07, 0x08, 0x09, 0x0a, 0x08, 0x01, 0x45, 0x00, //
            0x00, 0x56, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, //
            0xf9, 0x4d, 0xc0, 0xa8, 0x00, 0x01, 0xc0, 0xa8, //
            0x00, 0x02, 0x27, 0x10, 0x00, 0x50, 0x00, 0x00, //
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02, //
            0x20, 0x00, 0xc5, 0x18, 0x00, 0x00, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        7
    );
}",0,,
"pub fn resize_end(&mut self, mut end: U256) -> Result<(), ExitError> {
		while end % U256::from(32) != U256::zero() {
			end = match end.checked_add(U256::one()) {
				Some(end) => end,
				None => return Err(ExitError::InvalidRange)
			};
		}

		self.effective_len = max(self.effective_len, end);
		Ok(())
	}",0,,
"    pub fn inv_var(&self) -> Scalar {
        self.inv()
    }",0,,
"	pub fn ui_middleware(
		_deps: Dependencies,
		_dapps_domain: String,
	) -> Result<Middleware, String> {
		Err(""Your Parity version has been compiled without UI support."".into())
	}",0,,
"fn test_jle_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 5
        jle r1, 4, +1
        jle r1, 6, +1
        exit
        jle r1, 5, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"    fn from(ty: InstanceType) -> ExternType {
        ExternType::Instance(ty)
    }",0,,
"pub fn new(minimum: u32, maximum: Option<u32>) -> MemoryType {
        MemoryType {
            ty: Memory {
                memory64: false,
                shared: false,
                minimum: minimum.into(),
                maximum: maximum.map(|i| i.into()),
            },
        }
    }",0,,
"fn test_reloc_64_relative_data() {
    // Tests the correctness of R_BPF_64_RELATIVE relocations in sections other
    // than .text. The program returns the address of the first .rodata byte.
    // [ 1] .text             PROGBITS        00000000000000e8 0000e8 000020 00  AX  0   0  8
    // [ 2] .rodata           PROGBITS        0000000000000108 000108 000019 01 AMS  0   0  1
    //
    // 00000000000001f8 <FILE>:
    // 63:       08 01 00 00 00 00 00 00
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative_data.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x108 } },
        3
    );
}",0,,
"fn test_tight_infinite_recursion() {
    test_interpreter_and_jit_asm!(
        ""
        entrypoint:
        mov64 r3, 0x41414141
        call entrypoint
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 31 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,,
"fn parse_less_version(output: &[u8]) -> Option<usize> {
    if output.starts_with(b""less "") {
        let version = std::str::from_utf8(&output[5..]).ok()?;
        let end = version.find(|c: char| !c.is_ascii_digit())?;
        version[..end].parse::<usize>().ok()
    } else {
        None
    }
}",0,,
"    pub const fn is_termination_signal(&self) -> bool {
        self.terminate
    }",0,,
"pub fn retrieve_less_version(less_path: &dyn AsRef<OsStr>) -> Option<usize> {
    let cmd = Command::new(less_path).arg(""--version"").output().ok()?;
    parse_less_version(&cmd.stdout)
}",1,1,"    let cmd = Command::new(less_path).arg(""--version"").output().ok()?;"
"fn find_unescaped_quote(input: &str) -> Option<usize> {
    let mut s = input;

    loop {
        match s.find(|c| c == '\\' || c == '""') {
            Some(n) => {
                if s.as_bytes()[n] == b'""' {
                    return Some(n + (input.len() - s.len()));
                } else if n + 2 <= s.len() {
                    s = &s[n + 2..];
                } else {
                    return None;
                }
            }
            None => return None,
        }
    }
}",0,,
"    fn c_repeat(&mut self, rep: &hir::Repetition) -> ResultOrEmpty {
        use regex_syntax::hir::RepetitionKind::*;
        match rep.kind {
            ZeroOrOne => self.c_repeat_zero_or_one(&rep.hir, rep.greedy),
            ZeroOrMore => self.c_repeat_zero_or_more(&rep.hir, rep.greedy),
            OneOrMore => self.c_repeat_one_or_more(&rep.hir, rep.greedy),
            Range(hir::RepetitionRange::Exactly(min_max)) => {
                self.c_repeat_range(&rep.hir, rep.greedy, min_max, min_max)
            }
            Range(hir::RepetitionRange::AtLeast(min)) => {
                self.c_repeat_range_min_or_more(&rep.hir, rep.greedy, min)
            }
            Range(hir::RepetitionRange::Bounded(min, max)) => {
                self.c_repeat_range(&rep.hir, rep.greedy, min, max)
            }
        }
    }",0,,
"fn recover_signer(transaction: &Transaction) -> Option<H160> {
		let mut sig = [0u8; 65];
		let mut msg = [0u8; 32];
		sig[0..32].copy_from_slice(&transaction.signature.r()[..]);
		sig[32..64].copy_from_slice(&transaction.signature.s()[..]);
		sig[64] = transaction.signature.standard_v();
		msg.copy_from_slice(&LegacyTransactionMessage::from(transaction.clone()).hash()[..]);

		let pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;
		Some(H160::from(H256::from_slice(
			Keccak256::digest(&pubkey).as_slice(),
		)))
	}",0,,
"fn test_err_sdiv64_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        sdiv r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,,
"fn test_div32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x10000000c
        div32 r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3 } },
        3
    );
}",0,,
"fn test_reloc_64_64() {
    // Tests the correctness of R_BPF_64_64 relocations. The program returns the
    // address of the entrypoint.
    //   [ 1] .text             PROGBITS        00000000000000e8 0000e8 000018 00  AX  0   0  8
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_64.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0xe8 } },
        2
    );
}",0,,
"fn test_load_elf_rodata_high_vaddr() {
    test_interpreter_and_jit_elf!(
        ""tests/elfs/rodata_high_vaddr.so"",
        [1],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 42 } },
        3
    );
}",0,,
"fn test_alu32_logic() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 1
        mov32 r2, 2
        mov32 r3, 3
        mov32 r4, 4
        mov32 r5, 5
        mov32 r6, 6
        mov32 r7, 7
        mov32 r8, 8
        or32 r0, r5
        or32 r0, 0xa0
        and32 r0, 0xa3
        mov32 r9, 0x91
        and32 r0, r9
        lsh32 r0, 22
        lsh32 r0, r8
        rsh32 r0, 19
        rsh32 r0, r7
        xor32 r0, 0x03
        xor32 r0, r2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11 } },
        21
    );
}",0,,
"    pub fn yielded(self) -> Result<YieldedVal, Error> {
        match self {
            RunResult::Returned(_) => Err(Error::InstanceNotYielded),
            RunResult::Yielded(yv) => Ok(yv),
        }
    }",0,,
"pub fn parse_compressed(p: &[u8; util::COMPRESSED_PUBLIC_KEY_SIZE]) -> Result<PublicKey, Error> {
        use util::{TAG_PUBKEY_EVEN, TAG_PUBKEY_ODD};

        if !(p[0] == TAG_PUBKEY_EVEN || p[0] == TAG_PUBKEY_ODD) {
            return Err(Error::InvalidPublicKey);
        }
        let mut x = Field::default();
        if !x.set_b32(array_ref!(p, 1, 32)) {
            return Err(Error::InvalidPublicKey);
        }
        let mut elem = Affine::default();
        elem.set_xo_var(&x, p[0] == TAG_PUBKEY_ODD);
        if elem.is_infinity() {
            return Err(Error::InvalidPublicKey);
        }
        if elem.is_valid_var() {
            return Ok(PublicKey(elem));
        } else {
            return Err(Error::InvalidPublicKey);
        }
    }",0,,
"fn on_finalize(n: T::BlockNumber) {
			<Pallet<T>>::store_block(
				fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
				U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(
					frame_system::Pallet::<T>::block_number(),
				)),
			);
			// move block hash pruning window by one block
			let block_hash_count = T::BlockHashCount::get();
			let to_remove = n
				.saturating_sub(block_hash_count)
				.saturating_sub(One::one());
			// keep genesis hash
			if !to_remove.is_zero() {
				<BlockHash<T>>::remove(U256::from(
					UniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),
				));
			}
		}",0,,
"    pub async fn receive_signal(&mut self) {
        // The server may have already been terminated
        // In that event, just return
        if self.terminate {
            return;
        }
        let _ = self.signal.recv().await;
        self.terminate = true;
    }",0,,
"    pub fn can_resume(&self) -> bool {
        self.is_yielded()
    }",0,,
"pub fn check_mut_ptr<T>(user_ptr: *mut T) -> Result<()> {
        // The user space is both readable and writable on SGX1.
        // TODO: Fine-tune the checking on SGX2.
        check_ptr(user_ptr)
    }",0,,
"fn compile(mut self) -> Result {
        let mut holes = vec![];
        let mut initial_entry = None;
        let mut last_split = Hole::None;
        let mut utf8_seqs = self.c.utf8_seqs.take().unwrap();
        self.c.suffix_cache.clear();

        for (i, range) in self.ranges.iter().enumerate() {
            let is_last_range = i + 1 == self.ranges.len();
            utf8_seqs.reset(range.start(), range.end());
            let mut it = (&mut utf8_seqs).peekable();
            loop {
                let utf8_seq = match it.next() {
                    None => break,
                    Some(utf8_seq) => utf8_seq,
                };
                if is_last_range && it.peek().is_none() {
                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;
                    holes.push(hole);
                    self.c.fill(last_split, entry);
                    last_split = Hole::None;
                    if initial_entry.is_none() {
                        initial_entry = Some(entry);
                    }
                } else {
                    if initial_entry.is_none() {
                        initial_entry = Some(self.c.insts.len());
                    }
                    self.c.fill_to_next(last_split);
                    last_split = self.c.push_split_hole();
                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;
                    holes.push(hole);
                    last_split =
                        self.c.fill_split(last_split, Some(entry), None);
                }
            }
        }
        self.c.utf8_seqs = Some(utf8_seqs);
        Ok(Patch { hole: Hole::Many(holes), entry: initial_entry.unwrap() })
    }",0,,
"    pub fn add_named_import(&mut self, module: &str, field: Option<&str>, ty: ExternType) {
        self.imports
            .push((module.to_string(), field.map(|f| f.to_string()), ty));
    }",0,,
"pub fn copy_large(
		&mut self,
		memory_offset: U256,
		data_offset: U256,
		len: U256,
		data: &[u8]
	) -> Result<(), ExitFatal> {
		let memory_offset = if memory_offset > U256::from(usize::max_value()) {
			return Err(ExitFatal::NotSupported)
		} else {
			memory_offset.as_usize()
		};

		let ulen = if len > U256::from(usize::max_value()) {
			return Err(ExitFatal::NotSupported)
		} else {
			len.as_usize()
		};

		let data = if let Some(end) = data_offset.checked_add(len) {
			if end > U256::from(usize::max_value()) {
				&[]
			} else {
				let data_offset = data_offset.as_usize();
				let end = end.as_usize();

				if data_offset > data.len() {
					&[]
				} else {
					&data[data_offset..min(end, data.len())]
				}
			}
		} else {
			&[]
		};

		self.set(memory_offset, data, Some(ulen))
	}",0,,
"    fn gen_reload(
        &self,
        to_reg: Writable<RealReg>,
        from_slot: SpillSlot,
        _: Option<VirtualReg>,
    ) -> I {
        self.abi.gen_reload(to_reg, from_slot)
    }",0,,
"fn test_mul64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x40000001
        mov r1, 4
        mul r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x100000004 } },
        4
    );
}",0,,
"    fn is_closed(&self) -> bool {
        self.closed
    }",0,,
"    fn from(e: RepetitionError) -> Self {
        ParseErrorKind::Repetition(e)
    }",0,,
"pub fn verify(message: &Message, signature: &Signature, pubkey: &PublicKey) -> bool {
    ECMULT_CONTEXT.verify_raw(&signature.r, &signature.s, &pubkey.0, &message.0)
}",0,,
"fn block_hash(number: u32) -> H256 {
		BlockHash::<T>::get(U256::from(number))
	}",0,,
"pub(crate) fn from_wasm_type(ty: &WasmType) -> Self {
        match ty {
            WasmType::I32 => Self::I32,
            WasmType::I64 => Self::I64,
            WasmType::F32 => Self::F32,
            WasmType::F64 => Self::F64,
            WasmType::V128 => Self::V128,
            WasmType::FuncRef => Self::FuncRef,
            WasmType::ExternRef => Self::ExternRef,
            WasmType::ExnRef => unimplemented!(),
        }
    }",0,,
"fn test_stxw() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r2, 0x44332211
        stxw [r1+2], r2
        ldxw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x44332211 } },
        4
    );
}",0,,
"    fn state(&self) -> &State {
        &self.state
    }",0,,
"fn test_early_exit() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 3
        exit
        mov r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3 } },
        2
    );
}",0,,
"    fn get_func_type(&self, func_index: FuncIndex) -> TypeIndex {
        self.info.functions[func_index].entity
    }",0,,
"fn fill_split(
        &mut self,
        hole: Hole,
        goto1: Option<InstPtr>,
        goto2: Option<InstPtr>,
    ) -> Hole {
        match hole {
            Hole::None => Hole::None,
            Hole::One(pc) => match (goto1, goto2) {
                (Some(goto1), Some(goto2)) => {
                    self.insts[pc].fill_split(goto1, goto2);
                    Hole::None
                }
                (Some(goto1), None) => {
                    self.insts[pc].half_fill_split_goto1(goto1);
                    Hole::One(pc)
                }
                (None, Some(goto2)) => {
                    self.insts[pc].half_fill_split_goto2(goto2);
                    Hole::One(pc)
                }
                (None, None) => unreachable!(
                    ""at least one of the split \
                     holes must be filled""
                ),
            },
            Hole::Many(holes) => {
                let mut new_holes = vec![];
                for hole in holes {
                    new_holes.push(self.fill_split(hole, goto1, goto2));
                }
                if new_holes.is_empty() {
                    Hole::None
                } else if new_holes.len() == 1 {
                    new_holes.pop().unwrap()
                } else {
                    Hole::Many(new_holes)
                }
            }
        }
    }",0,,
"    fn gen_move(&self, to_reg: Writable<RealReg>, from_reg: RealReg, vreg: VirtualReg) -> I {
        let ty = self.vreg_type(vreg);
        I::gen_move(to_reg.map(|r| r.to_reg()), from_reg.to_reg(), ty)
    }",0,,
"pub fn eq(a: &Self, b: &Self) -> bool {
        ptr::eq(a.0.as_ptr() as *const _, b.0.as_ptr() as *const _)
    }",0,,
"pub fn parse_der(p: &[u8]) -> Result<Signature, Error> {
        let mut decoder = der::Decoder::new(p);

        decoder.read_constructed_sequence()?;
        let rlen = decoder.read_len()?;

        if rlen != decoder.remaining_len() {
            return Err(Error::InvalidSignature);
        }

        let r = decoder.read_integer()?;
        let s = decoder.read_integer()?;

        if decoder.remaining_len() != 0 {
            return Err(Error::InvalidSignature);
        }

        Ok(Signature { r, s })
    }",0,,
"pub fn fetch_xdg_config_path() -> std::path::PathBuf {
    let config_file_path: std::path::PathBuf = match env::var(""XDG_CONFIG_HOME"") {
        Ok(val) => {
            log::debug!(""XDG_CONFIG_HOME exists: {:#?}"", val);
            Path::new(&val).join(""swhkd/swhkdrc"")
        }
        Err(_) => {
            log::error!(""XDG_CONFIG_HOME has not been set."");
            Path::new(""/etc/swhkd/swhkdrc"").to_path_buf()
        }
    };
    config_file_path
}",0,,
"fn test_err_ldxdw_oob() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1+6]
        exit"",
        [
            0xaa, 0xbb, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, //
            0x77, 0x88, 0xcc, 0xdd, //
        ],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 29 && vm_addr == 0x400000006 && len == 8 && name == ""input""
                )
            }
        },
        1
    );
}",0,,
"    pub(crate) fn is_pager(&self) -> bool {
        false
    }",0,,
"fn detect_invalid_last_symbol_one_byte() {
        // 0xFF -> ""/w=="", so all letters > w, 0-9, and '+', '/' should get InvalidLastSymbol

        assert!(decode(""/w=="").is_ok());
        // trailing 01
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'x')), decode(""/x==""));
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'z')), decode(""/z==""));
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'0')), decode(""/0==""));
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'9')), decode(""/9==""));
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'+')), decode(""/+==""));
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'/')), decode(""//==""));

        // also works when there are 2 quads in the last block
        assert_eq!(
            Err(DecodeError::InvalidLastSymbol(5, b'x')),
            decode(""AAAA/x=="")
        );
    }",0,,
"fn test_relative_call() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/relative_call.so"",
        config,
        [1],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 2 } },
        14
    );
}",0,,
"pub fn generate_web_proxy_access_token(&self) -> String {
		let token = random_string(16);
		let mut tokens = self.web_proxy_tokens.lock();
		tokens.prune();
		tokens.insert(token.clone(), ());
		token
	}",1,"0,4","	pub fn generate_web_proxy_access_token(&self) -> String {/~/		tokens.insert(token.clone(), ());"
"fn test_ldabsh() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsh 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x4433 } },
        2
    );
}",0,,
"fn test_sdiv64_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xc
        lsh r0, 32
        sdiv r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x300000000 } },
        4
    );
}",0,,
"async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = set_command_line_args().get_matches();
    env::set_var(""RUST_LOG"", ""swhkd=warn"");

    if args.is_present(""debug"") {
        env::set_var(""RUST_LOG"", ""swhkd=trace"");
    }

    env_logger::init();
    log::trace!(""Logger initialized."");

    let pidfile: String = String::from(""/tmp/swhkd.pid"");
    if Path::new(&pidfile).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pidfile);
        let swhkd_pid = match fs::read_to_string(&pidfile) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Swhkd is already running!"");
                log::error!(""pid of existing swhkd process: {}"", pid.to_string());
                log::error!(""To close the existing swhkd process, run `sudo killall swhkd`"");
                exit(1);
            }
        }
    }

    match fs::write(&pidfile, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pidfile, e);
            exit(1);
        }
    }

    if check_user_permissions().is_err() {
        exit(1);
    }

    let load_config = || {
        seteuid(env::var(""PKEXEC_UID"").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.
        let config_file_path: std::path::PathBuf = if args.is_present(""config"") {
            Path::new(args.value_of(""config"").unwrap()).to_path_buf()
        } else {
            fetch_xdg_config_path()
        };

        log::debug!(""Using config file path: {:#?}"", config_file_path);

        if !config_file_path.exists() {
            log::error!(""{:#?} doesn't exist"", config_file_path);
            exit(1);
        }

        let hotkeys = match config::load(&config_file_path) {
            Err(e) => {
                log::error!(""Config Error: {}"", e);
                exit(1);
            }
            Ok(out) => out,
        };

        for hotkey in &hotkeys {
            log::debug!(""hotkey: {:#?}"", hotkey);
        }

        hotkeys
    };

    let mut hotkeys = load_config();
    seteuid(0); // Escalating back to root after reading config file.
    log::trace!(""Attempting to find all keyboard file descriptors."");
    let keyboard_devices: Vec<Device> =
        evdev::enumerate().filter(check_device_is_keyboard).collect();

    let mut uinput_device = match uinput::create_uinput_device() {
        Ok(dev) => dev,
        Err(e) => {
            log::error!(""Err: {:#?}"", e);
            exit(1);
        }
    };

    if keyboard_devices.is_empty() {
        log::error!(""No valid keyboard device was detected!"");
        exit(1);
    }
    log::debug!(""{} Keyboard device(s) detected."", keyboard_devices.len());

    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTALT, config::Modifier::Alt),
        (Key::KEY_RIGHTALT, config::Modifier::Alt),
        (Key::KEY_LEFTCTRL, config::Modifier::Control),
        (Key::KEY_RIGHTCTRL, config::Modifier::Control),
        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),
        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),
    ]);

    let repeat_cooldown_duration: u64 = if args.is_present(""cooldown"") {
        args.value_of(""cooldown"").unwrap().parse::<u64>().unwrap()
    } else {
        250
    };

    let mut signals = Signals::new(&[
        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,
        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,
    ])?;

    let mut execution_is_paused = false;
    let mut last_hotkey: Option<config::Hotkey> = None;
    let mut pending_release: bool = false;
    let mut keyboard_states: Vec<KeyboardState> = Vec::new();
    let mut keyboard_stream_map = StreamMap::new();

    for (i, mut device) in keyboard_devices.into_iter().enumerate() {
        let _ = device.grab();
        keyboard_stream_map.insert(i, device.into_event_stream()?);
        keyboard_states.push(KeyboardState::new());
    }

    // The initial sleep duration is never read because last_hotkey is initialized to None
    let hotkey_repeat_timer = sleep(Duration::from_millis(0));
    tokio::pin!(hotkey_repeat_timer);

    loop {
        select! {
            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {
                let hotkey = last_hotkey.clone().unwrap();
                if hotkey.keybinding.on_release {
                    continue;
                }
                send_command(hotkey.clone());
                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
            }

            Some(signal) = signals.next() => {
                match signal {
                    SIGUSR1 => {
                        execution_is_paused = true;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                    }

                    SIGUSR2 => {
                        execution_is_paused = false;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.grab();
                        }
                    }

                    SIGHUP => {
                        hotkeys = load_config();
                    }

                    SIGINT => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                        log::warn!(""Received SIGINT signal, exiting..."");
                        exit(1);
                    }

                    _ => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }

                        log::warn!(""Received signal: {:#?}"", signal);
                        log::warn!(""Exiting..."");
                        exit(1);
                    }
                }
            }

            Some((i, Ok(event))) = keyboard_stream_map.next() => {
                let keyboard_state = &mut keyboard_states[i];

                let key = match event.kind() {
                    InputEventKind::Key(keycode) => keycode,
                    _ => continue
                };

                match event.value() {
                    // Key press
                    1 => {
                        if let Some(modifier) = modifiers_map.get(&key) {
                            keyboard_state.state_modifiers.insert(*modifier);
                        } else {
                            keyboard_state.state_keysyms.insert(key);
                        }
                    }

                    // Key release
                    0 => {
                        if last_hotkey.is_some() && pending_release {
                            pending_release = false;
                            send_command(last_hotkey.clone().unwrap());
                            last_hotkey = None;
                        }
                        if let Some(modifier) = modifiers_map.get(&key) {
                            if let Some(hotkey) = &last_hotkey {
                                if hotkey.modifiers().contains(modifier) {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_modifiers.remove(modifier);
                        } else if keyboard_state.state_keysyms.contains(key) {
                            if let Some(hotkey) = &last_hotkey {
                                if key == hotkey.keysym() {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_keysyms.remove(key);
                        }
                    }

                    _ => {}
                }

                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()
                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())
                    .collect();

                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {
                    hotkey.keysym().code() == event.code() &&
                    keyboard_state.state_modifiers
                        .iter()
                        .all(|x| hotkey.modifiers().contains(x)) &&
                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                    && !hotkey.is_send()
                        });

                // Don't emit event to virtual device if it's from a valid hotkey
                if !event_in_hotkeys {
                    uinput_device.emit(&[event]).unwrap();
                }

                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {
                    continue;
                }

                log::debug!(""state_modifiers: {:#?}"", keyboard_state.state_modifiers);
                log::debug!(""state_keysyms: {:#?}"", keyboard_state.state_keysyms);
                log::debug!(""hotkey: {:#?}"", possible_hotkeys);

                for hotkey in possible_hotkeys {
                    // this should check if state_modifiers and hotkey.modifiers have the same elements
                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))
                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                        && keyboard_state.state_keysyms.contains(hotkey.keysym())
                    {
                        last_hotkey = Some(hotkey.clone());
                        if pending_release { break; }
                        if hotkey.is_on_release() {
                            pending_release = true;
                            break;
                        }
                        send_command(hotkey.clone());
                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
                        break;
                    }
                }
            }
        }
    }
}",1,"57,58,59,60,61","if !config_file_path.exists() {/~/            log::error!(""{:#?} doesn't exist"", config_file_path);/~/            exit(1);/~/        }/~/"
"fn sqr_512(&self, l: &mut [u32; 16]) {
        let (mut c0, mut c1, mut c2): (u32, u32, u32) = (0, 0, 0);
        define_ops!(c0, c1, c2);

        /* l[0..15] = a[0..7]^2. */
        muladd_fast!(self.0[0], self.0[0]);
        l[0] = extract_fast!();
        muladd2!(self.0[0], self.0[1]);
        l[1] = extract!();
        muladd2!(self.0[0], self.0[2]);
        muladd!(self.0[1], self.0[1]);
        l[2] = extract!();
        muladd2!(self.0[0], self.0[3]);
        muladd2!(self.0[1], self.0[2]);
        l[3] = extract!();
        muladd2!(self.0[0], self.0[4]);
        muladd2!(self.0[1], self.0[3]);
        muladd!(self.0[2], self.0[2]);
        l[4] = extract!();
        muladd2!(self.0[0], self.0[5]);
        muladd2!(self.0[1], self.0[4]);
        muladd2!(self.0[2], self.0[3]);
        l[5] = extract!();
        muladd2!(self.0[0], self.0[6]);
        muladd2!(self.0[1], self.0[5]);
        muladd2!(self.0[2], self.0[4]);
        muladd!(self.0[3], self.0[3]);
        l[6] = extract!();
        muladd2!(self.0[0], self.0[7]);
        muladd2!(self.0[1], self.0[6]);
        muladd2!(self.0[2], self.0[5]);
        muladd2!(self.0[3], self.0[4]);
        l[7] = extract!();
        muladd2!(self.0[1], self.0[7]);
        muladd2!(self.0[2], self.0[6]);
        muladd2!(self.0[3], self.0[5]);
        muladd!(self.0[4], self.0[4]);
        l[8] = extract!();
        muladd2!(self.0[2], self.0[7]);
        muladd2!(self.0[3], self.0[6]);
        muladd2!(self.0[4], self.0[5]);
        l[9] = extract!();
        muladd2!(self.0[3], self.0[7]);
        muladd2!(self.0[4], self.0[6]);
        muladd!(self.0[5], self.0[5]);
        l[10] = extract!();
        muladd2!(self.0[4], self.0[7]);
        muladd2!(self.0[5], self.0[6]);
        l[11] = extract!();
        muladd2!(self.0[5], self.0[7]);
        muladd!(self.0[6], self.0[6]);
        l[12] = extract!();
        muladd2!(self.0[6], self.0[7]);
        l[13] = extract!();
        muladd_fast!(self.0[7], self.0[7]);
        l[14] = extract_fast!();
        debug_assert!(c1 == 0);
        l[15] = c0;
    }",0,,
"fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }",0,,
"pub fn new_instance_handle(
    instance: *mut Instance,
    module: Arc<dyn Module>,
    alloc: Alloc,
    embed_ctx: CtxMap,
) -> Result<InstanceHandle, Error> {
    let inst = NonNull::new(instance)
        .ok_or_else(|| lucet_format_err!(""instance pointer is null; this is a bug""))?;

    lucet_ensure!(
        unsafe { inst.as_ref().magic } != LUCET_INSTANCE_MAGIC,
        ""created a new instance handle in memory with existing instance magic; this is a bug""
    );

    let mut handle = InstanceHandle {
        inst,
        needs_inst_drop: false,
    };

    let inst = Instance::new(alloc, module, embed_ctx);

    unsafe {
        // this is wildly unsafe! you must be very careful to not let the drop impls run on the
        // uninitialized fields; see
        // <https://doc.rust-lang.org/std/mem/fn.forget.html#use-case-1>

        // write the whole struct into place over the uninitialized page
        ptr::write(&mut *handle, inst);
    };

    handle.needs_inst_drop = true;

    handle.reset()?;

    Ok(handle)
}",0,,
"fn run_system_command(command: &str) {
    match Command::new(""sh"")
        .arg(""-c"")
        .arg(command)
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
    {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Failed to execute {}"", command);
            log::error!(""Error, {}"", e);
        }
    }
}",0,,
"pub fn parse_slice(p: &[u8]) -> Result<Signature, Error> {
        if p.len() != util::SIGNATURE_SIZE {
            return Err(Error::InvalidInputLength);
        }

        let mut a = [0; util::SIGNATURE_SIZE];
        a.copy_from_slice(p);
        Ok(Self::parse(&a))
    }",0,,
"fn test_ldabsdw() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsdw 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xaa99887766554433 } },
        2
    );
}",0,,
"fn test_mul128() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        mov r2, 30
        mov r3, 0
        mov r4, 20
        mov r5, 0
        mul64 r3, r4
        mul64 r5, r2
        add64 r5, r3
        mov64 r0, r2
        rsh64 r0, 0x20
        mov64 r3, r4
        rsh64 r3, 0x20
        mov64 r6, r3
        mul64 r6, r0
        add64 r5, r6
        lsh64 r4, 0x20
        rsh64 r4, 0x20
        mov64 r6, r4
        mul64 r6, r0
        lsh64 r2, 0x20
        rsh64 r2, 0x20
        mul64 r4, r2
        mov64 r0, r4
        rsh64 r0, 0x20
        add64 r0, r6
        mov64 r6, r0
        rsh64 r6, 0x20
        add64 r5, r6
        mul64 r3, r2
        lsh64 r0, 0x20
        rsh64 r0, 0x20
        add64 r0, r3
        mov64 r2, r0
        rsh64 r2, 0x20
        add64 r5, r2
        stxdw [r1+0x8], r5
        lsh64 r0, 0x20
        lsh64 r4, 0x20
        rsh64 r4, 0x20
        or64 r0, r4
        stxdw [r1+0x0], r0
        exit"",
        [0; 16],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 600 } },
        42
    );
}",0,,
"    fn alloc(&self) -> &Alloc;
    fn alloc_mut(&mut self) -> &mut Alloc;
    fn module(&self) -> &dyn Module;
    fn state(&self) -> &State;
    fn valid_magic(&self) -> bool;
}

impl InstanceInternal for Instance {
    /// Get a reference to the instance's `Alloc`.
    fn alloc(&self) -> &Alloc {
        &self.alloc
    }

    /// Get a mutable reference to the instance's `Alloc`.
    fn alloc_mut(&mut self) -> &mut Alloc {
        &mut self.alloc
    }

    /// Get a reference to the instance's `Module`.
    fn module(&self) -> &dyn Module {
        self.module.deref()
    }

    /// Get a reference to the instance's `State`.
    fn state(&self) -> &State {
        &self.state
    }

    /// Check whether the instance magic is valid.
    fn valid_magic(&self) -> bool {
        self.magic == LUCET_INSTANCE_MAGIC
    }
}",0,,
"	fn subscribe_pending(&self, _meta: Self::Metadata, sub: Subscriber<Vec<ConfirmationRequest>>) {
		self.subscribers.lock().push(sub)
	}",0,,
"pub async fn mksnap(handle: &CoreDB, con: &mut Connection, act: ActionGroup) -> TResult<()> {
    let howmany = act.howmany();
    if howmany == 0 {
        if !handle.is_snapshot_enabled() {
            // Since snapshotting is disabled, we can't create a snapshot!
            // We'll just return an error returning the same
            let error = ""err-snapshot-disabled"";
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(error.to_string()));
            return con.write_response(error).await;
        }
        // We will just follow the standard convention of creating snapshots
        let mut was_engine_error = false;
        let mut snap_result = None;
        let mut engine_was_busy = false;
        {
            let snaphandle = handle.snapcfg.clone();
            let snapstatus = (*snaphandle)
                .as_ref()
                .unwrap_or_else(|| unsafe { unreachable_unchecked() });
            let snapengine = SnapshotEngine::new(snapstatus.max, &handle, None);
            if snapengine.is_err() {
                was_engine_error = true;
            } else {
                if snapstatus.is_busy() {
                    engine_was_busy = true;
                } else {
                    let mut snapengine =
                        snapengine.unwrap_or_else(|_| unsafe { unreachable_unchecked() });

                    snap_result = snapengine.mksnap();
                }
            }
        }
        if was_engine_error {
            return con
                .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                .await;
        }
        if engine_was_busy {
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(""err-snapshot-busy"".to_owned()));
            return con.write_response(error).await;
        }
        if let Some(succeeded) = snap_result {
            if succeeded {
                // Snapshotting succeeded, return Okay
                return con
                    .write_response(responses::fresp::R_OKAY.to_owned())
                    .await;
            } else {
                // Nope, something happened while creating a snapshot
                // return a server error
                return con
                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                    .await;
            }
        } else {
            // We shouldn't ever reach here if all our logic is correct
            // but if we do, something is wrong with the runtime
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(""err-access-after-termsig"".to_owned()));
            return con.write_response(error).await;
        }
    } else {
        if howmany == 1 {
            // This means that the user wants to create a 'named' snapshot
            let snapname = act
                .get_ref()
                .get(1)
                .unwrap_or_else(|| unsafe { unreachable_unchecked() });
            let mut path = PathBuf::from(DIR_SNAPSHOT);
            path.push(""remote"");
            path.push(snapname.to_owned() + "".snapshot"");
            let failed;
            {
                match diskstore::flush_data(&path, &handle.acquire_read().get_ref()) {
                    Ok(_) => failed = false,
                    Err(e) => {
                        log::error!(""Error while creating snapshot: {}"", e);
                        failed = true;
                    }
                }
            }
            if failed {
                return con
                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                    .await;
            } else {
                return con
                    .write_response(responses::fresp::R_OKAY.to_owned())
                    .await;
            }
        } else {
            return con
                .write_response(responses::fresp::R_ACTION_ERR.to_owned())
                .await;
        }
    }
}",1,99,}
"fn assert_same_export_func_result(
        lhs: &Result<Box<[Val]>, Trap>,
        rhs: &Result<Box<[Val]>, Trap>,
        func_name: &str,
    ) {
        let fail = || {
            panic!(
                ""differential fuzzing failed: exported func {} returned two \
                 different results: {:?} != {:?}"",
                func_name, lhs, rhs
            )
        };

        match (lhs, rhs) {
            (Err(_), Err(_)) => {}
            (Ok(lhs), Ok(rhs)) => {
                if lhs.len() != rhs.len() {
                    fail();
                }
                for (lhs, rhs) in lhs.iter().zip(rhs.iter()) {
                    match (lhs, rhs) {
                        (Val::I32(lhs), Val::I32(rhs)) if lhs == rhs => continue,
                        (Val::I64(lhs), Val::I64(rhs)) if lhs == rhs => continue,
                        (Val::V128(lhs), Val::V128(rhs)) if lhs == rhs => continue,
                        (Val::F32(lhs), Val::F32(rhs)) if f32_equal(*lhs, *rhs) => continue,
                        (Val::F64(lhs), Val::F64(rhs)) if f64_equal(*lhs, *rhs) => continue,
                        (Val::ExternRef(_), Val::ExternRef(_))
                        | (Val::FuncRef(_), Val::FuncRef(_)) => continue,
                        _ => fail(),
                    }
                }
            }
            _ => fail(),
        }
    }",0,,
"pub fn grow_memory(&mut self, additional_pages: u32) -> Result<u32, Error> {
        let additional_bytes = additional_pages
            .checked_mul(WASM_PAGE_SIZE)
            .ok_or_else(|| lucet_format_err!(""additional pages larger than wasm address space"",))?;
        let orig_len = self
            .alloc
            .expand_heap(additional_bytes, self.module.as_ref())?;
        Ok(orig_len / WASM_PAGE_SIZE)
    }",0,,
"    pub async fn finish_with_termsig(self) {
        match self {
            MultiListener::InsecureOnly(server) => server.base.release_self().await,
            MultiListener::SecureOnly(server) => server.base.release_self().await,
            MultiListener::Multi(insecure, secure) => {
                insecure.base.release_self().await;
                secure.base.release_self().await;
            }
        }
    }",0,,
"    pub fn with_capacity(expected_num_constants: usize) -> Self {
        Self {
            constants: PrimaryMap::with_capacity(expected_num_constants),
            pool_uses: HashMap::with_capacity(expected_num_constants),
            well_known_uses: HashMap::new(),
        }
    }",0,,
"fn test_err_sdiv64_overflow_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x80
        lsh r0, 56
        sdiv r0, -1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideOverflow(pc) if pc == 31)
        },
        3
    );
}",0,,
"	pub fn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {
		CurrentTransactionStatuses::<T>::get()
	}",0,,
"fn decode_helper(
    input: &[u8],
    num_chunks: usize,
    config: Config,
    output: &mut [u8],
) -> Result<usize, DecodeError> {
    let char_set = config.char_set;
    let decode_table = char_set.decode_table();

    let remainder_len = input.len() % INPUT_CHUNK_LEN;

    // Because the fast decode loop writes in groups of 8 bytes (unrolled to
    // CHUNKS_PER_FAST_LOOP_BLOCK times 8 bytes, where possible) and outputs 8 bytes at a time (of
    // which only 6 are valid data), we need to be sure that we stop using the fast decode loop
    // soon enough that there will always be 2 more bytes of valid data written after that loop.
    let trailing_bytes_to_skip = match remainder_len {
        // if input is a multiple of the chunk size, ignore the last chunk as it may have padding,
        // and the fast decode logic cannot handle padding
        0 => INPUT_CHUNK_LEN,
        // 1 and 5 trailing bytes are illegal: can't decode 6 bits of input into a byte
        1 | 5 => {
            // trailing whitespace is so common that it's worth it to check the last byte to
            // possibly return a better error message
            if let Some(b) = input.last() {
                if *b != PAD_BYTE && decode_table[*b as usize] == tables::INVALID_VALUE {
                    return Err(DecodeError::InvalidByte(input.len() - 1, *b));
                }
            }

            return Err(DecodeError::InvalidLength);
        }
        // This will decode to one output byte, which isn't enough to overwrite the 2 extra bytes
        // written by the fast decode loop. So, we have to ignore both these 2 bytes and the
        // previous chunk.
        2 => INPUT_CHUNK_LEN + 2,
        // If this is 3 unpadded chars, then it would actually decode to 2 bytes. However, if this
        // is an erroneous 2 chars + 1 pad char that would decode to 1 byte, then it should fail
        // with an error, not panic from going past the bounds of the output slice, so we let it
        // use stage 3 + 4.
        3 => INPUT_CHUNK_LEN + 3,
        // This can also decode to one output byte because it may be 2 input chars + 2 padding
        // chars, which would decode to 1 byte.
        4 => INPUT_CHUNK_LEN + 4,
        // Everything else is a legal decode len (given that we don't require padding), and will
        // decode to at least 2 bytes of output.
        _ => remainder_len,
    };

    // rounded up to include partial chunks
    let mut remaining_chunks = num_chunks;

    let mut input_index = 0;
    let mut output_index = 0;

    {
        let length_of_fast_decode_chunks = input.len().saturating_sub(trailing_bytes_to_skip);

        // Fast loop, stage 1
        // manual unroll to CHUNKS_PER_FAST_LOOP_BLOCK of u64s to amortize slice bounds checks
        if let Some(max_start_index) = length_of_fast_decode_chunks.checked_sub(INPUT_BLOCK_LEN) {
            while input_index <= max_start_index {
                let input_slice = &input[input_index..(input_index + INPUT_BLOCK_LEN)];
                let output_slice = &mut output[output_index..(output_index + DECODED_BLOCK_LEN)];

                decode_chunk(
                    &input_slice[0..],
                    input_index,
                    decode_table,
                    &mut output_slice[0..],
                )?;
                decode_chunk(
                    &input_slice[8..],
                    input_index + 8,
                    decode_table,
                    &mut output_slice[6..],
                )?;
                decode_chunk(
                    &input_slice[16..],
                    input_index + 16,
                    decode_table,
                    &mut output_slice[12..],
                )?;
                decode_chunk(
                    &input_slice[24..],
                    input_index + 24,
                    decode_table,
                    &mut output_slice[18..],
                )?;

                input_index += INPUT_BLOCK_LEN;
                output_index += DECODED_BLOCK_LEN - DECODED_CHUNK_SUFFIX;
                remaining_chunks -= CHUNKS_PER_FAST_LOOP_BLOCK;
            }
        }

        // Fast loop, stage 2 (aka still pretty fast loop)
        // 8 bytes at a time for whatever we didn't do in stage 1.
        if let Some(max_start_index) = length_of_fast_decode_chunks.checked_sub(INPUT_CHUNK_LEN) {
            while input_index < max_start_index {
                decode_chunk(
                    &input[input_index..(input_index + INPUT_CHUNK_LEN)],
                    input_index,
                    decode_table,
                    &mut output
                        [output_index..(output_index + DECODED_CHUNK_LEN + DECODED_CHUNK_SUFFIX)],
                )?;

                output_index += DECODED_CHUNK_LEN;
                input_index += INPUT_CHUNK_LEN;
                remaining_chunks -= 1;
            }
        }
    }

    // Stage 3
    // If input length was such that a chunk had to be deferred until after the fast loop
    // because decoding it would have produced 2 trailing bytes that wouldn't then be
    // overwritten, we decode that chunk here. This way is slower but doesn't write the 2
    // trailing bytes.
    // However, we still need to avoid the last chunk (partial or complete) because it could
    // have padding, so we always do 1 fewer to avoid the last chunk.
    for _ in 1..remaining_chunks {
        decode_chunk_precise(
            &input[input_index..],
            input_index,
            decode_table,
            &mut output[output_index..(output_index + DECODED_CHUNK_LEN)],
        )?;

        input_index += INPUT_CHUNK_LEN;
        output_index += DECODED_CHUNK_LEN;
    }

    // always have one more (possibly partial) block of 8 input
    debug_assert!(input.len() - input_index > 1 || input.is_empty());
    debug_assert!(input.len() - input_index <= 8);

    // Stage 4
    // Finally, decode any leftovers that aren't a complete input block of 8 bytes.
    // Use a u64 as a stack-resident 8 byte buffer.
    let mut leftover_bits: u64 = 0;
    let mut morsels_in_leftover = 0;
    let mut padding_bytes = 0;
    let mut first_padding_index: usize = 0;
    let mut last_symbol = 0_u8;
    let start_of_leftovers = input_index;
    for (i, b) in input[start_of_leftovers..].iter().enumerate() {
        // '=' padding
        if *b == PAD_BYTE {
            // There can be bad padding in a few ways:
            // 1 - Padding with non-padding characters after it
            // 2 - Padding after zero or one non-padding characters before it
            //     in the current quad.
            // 3 - More than two characters of padding. If 3 or 4 padding chars
            //     are in the same quad, that implies it will be caught by #2.
            //     If it spreads from one quad to another, it will be caught by
            //     #2 in the second quad.

            if i % 4 < 2 {
                // Check for case #2.
                let bad_padding_index = start_of_leftovers
                    + if padding_bytes > 0 {
                        // If we've already seen padding, report the first padding index.
                        // This is to be consistent with the faster logic above: it will report an
                        // error on the first padding character (since it doesn't expect to see
                        // anything but actual encoded data).
                        first_padding_index
                    } else {
                        // haven't seen padding before, just use where we are now
                        i
                    };
                return Err(DecodeError::InvalidByte(bad_padding_index, *b));
            }

            if padding_bytes == 0 {
                first_padding_index = i;
            }

            padding_bytes += 1;
            continue;
        }

        // Check for case #1.
        // To make '=' handling consistent with the main loop, don't allow
        // non-suffix '=' in trailing chunk either. Report error as first
        // erroneous padding.
        if padding_bytes > 0 {
            return Err(DecodeError::InvalidByte(
                start_of_leftovers + first_padding_index,
                PAD_BYTE,
            ));
        }
        last_symbol = *b;

        // can use up to 8 * 6 = 48 bits of the u64, if last chunk has no padding.
        // To minimize shifts, pack the leftovers from left to right.
        let shift = 64 - (morsels_in_leftover + 1) * 6;
        // tables are all 256 elements, lookup with a u8 index always succeeds
        let morsel = decode_table[*b as usize];
        if morsel == tables::INVALID_VALUE {
            return Err(DecodeError::InvalidByte(start_of_leftovers + i, *b));
        }

        leftover_bits |= (morsel as u64) << shift;
        morsels_in_leftover += 1;
    }

    let leftover_bits_ready_to_append = match morsels_in_leftover {
        0 => 0,
        2 => 8,
        3 => 16,
        4 => 24,
        6 => 32,
        7 => 40,
        8 => 48,
        _ => unreachable!(
            ""Impossible: must only have 0 to 8 input bytes in last chunk, with no invalid lengths""
        ),
    };

    // if there are bits set outside the bits we care about, last symbol encodes trailing bits that
    // will not be included in the output
    let mask = !0 >> leftover_bits_ready_to_append;
    if !config.decode_allow_trailing_bits && (leftover_bits & mask) != 0 {
        // last morsel is at `morsels_in_leftover` - 1
        return Err(DecodeError::InvalidLastSymbol(
            start_of_leftovers + morsels_in_leftover - 1,
            last_symbol,
        ));
    }

    let mut leftover_bits_appended_to_buf = 0;
    while leftover_bits_appended_to_buf < leftover_bits_ready_to_append {
        // `as` simply truncates the higher bits, which is what we want here
        let selected_bits = (leftover_bits >> (56 - leftover_bits_appended_to_buf)) as u8;
        output[output_index] = selected_bits;
        output_index += 1;

        leftover_bits_appended_to_buf += 8;
    }

    Ok(output_index)
}",0,,
"pub fn maximum(&self) -> Option<u64> {
        self.ty.maximum
    }",0,,
"fn test_mul64_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x40000001
        mul r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x100000004 } },
        3
    );
}",0,,
"pub fn random<R: Rng>(rng: &mut R) -> SecretKey {
        loop {
            let mut ret = [0u8; util::SECRET_KEY_SIZE];
            rng.fill_bytes(&mut ret);

            match Self::parse(&ret) {
                Ok(key) => return key,
                Err(_) => (),
            }
        }
    }",0,,
"fn build(&self) {
			<Pallet<T>>::store_block(false, U256::zero());
			frame_support::storage::unhashed::put::<EthereumStorageSchema>(
				PALLET_ETHEREUM_SCHEMA,
				&EthereumStorageSchema::V3,
			);
		}",0,,
"fn get() -> H256 {
		let version = T::Version::get().state_version();
		H256::decode(&mut &sp_io::storage::root(version)[..])
			.expect(""Node is configured to use the same hash; qed"")
	}",0,,
"    pub fn check_heap<T>(&self, ptr: *const T, len: usize) -> bool {
        self.alloc.mem_in_heap(ptr, len)
    }",0,,
"pub(crate) fn to_wasm_type(&self) -> WasmType {
        match self {
            Self::I32 => WasmType::I32,
            Self::I64 => WasmType::I64,
            Self::F32 => WasmType::F32,
            Self::F64 => WasmType::F64,
            Self::V128 => WasmType::V128,
            Self::FuncRef => WasmType::FuncRef,
            Self::ExternRef => WasmType::ExternRef,
        }
    }",0,,
"    fn dup_one(self) -> (Self, Self) {
        match self {
            Hole::One(pc) => (Hole::One(pc), Hole::One(pc)),
            Hole::None | Hole::Many(_) => {
                unreachable!(""must be called on single hole"")
            }
        }
    }",0,,
"    pub fn set_entry(&mut self, block: BlockIndex) {
        self.vcode.entry = block;
    }",0,,
"		fn list_dapps(&self) -> Vec<rpc_apis::LocalDapp> {
			self.endpoints.list()
				.into_iter()
				.map(|app| rpc_apis::LocalDapp {
					id: app.id,
					name: app.name,
					description: app.description,
					version: app.version,
					author: app.author,
					icon_url: app.icon_url,
				})
				.collect()
		}",0,,
"fn test_jsgt_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        mov r2, -1
        jsgt r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0
        jsgt r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,,
"pub(super) fn parse_code_point<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (char, Span)> {
    alt((
        try_map(
            Token::CodePoint,
            |(s, span)| {
                let hex = &s[2..];
                if hex.len() > 6 {
                    Err(ParseErrorKind::CodePoint(CodePointError::Invalid))
                } else {
                    u32::from_str_radix(hex, 16)
                        .ok()
                        .and_then(|n| char::try_from(n).ok())
                        .map(|c| (c, span))
                        .ok_or(ParseErrorKind::CodePoint(CodePointError::Invalid))
                }
            },
            nom::Err::Failure,
        ),
        try_map(
            Token::Identifier,
            |(str, span)| {
                if let Some(rest) = str.strip_prefix('U') {
                    if let Ok(n) = u32::from_str_radix(rest, 16) {
                        if let Ok(c) = char::try_from(n) {
                            return Ok((c, span));
                        } else {
                            return Err(ParseErrorKind::CodePoint(CodePointError::Invalid));
                        }
                    }
                }
                Err(ParseErrorKind::ExpectedToken(Token::CodePoint))
            },
            nom::Err::Error,
        ),
    ))(input)
}",0,,
"    fn sweep(&mut self) {
        // Sweep our bump chunk.
        let num_filled = self.num_filled_in_bump_chunk();
        unsafe {
            *self.alloc.next.get() = self.alloc.end;
        }
        for slot in self.alloc.chunk.iter().take(num_filled) {
            unsafe {
                *slot.get() = None;
            }
        }
        debug_assert!(
            self.alloc
                .chunk
                .iter()
                .all(|slot| unsafe { (*slot.get()).as_ref().is_none() }),
            ""after sweeping the bump chunk, all slots should be `None`""
        );

        // Reset our `next` finger to the start of the bump allocation chunk.
        unsafe {
            let next = self.alloc.chunk.as_ptr() as *mut TableElem;
            debug_assert!(!next.is_null());
            *self.alloc.next.get() = NonNull::new_unchecked(next);
        }

        // The current `precise_stack_roots` becomes our new over-appoximated
        // set for the next GC cycle.
        mem::swap(
            &mut self.precise_stack_roots,
            &mut self.over_approximated_stack_roots,
        );

        // And finally, the new `precise_stack_roots` should be cleared and
        // remain empty until the next GC cycle.
        //
        // Note that this may run arbitrary code as we run externref
        // destructors. Because of our `&mut` borrow above on this table,
        // though, we're guaranteed that nothing will touch this table.
        self.precise_stack_roots.clear();
    }",0,,
"pub fn cmp(a: &Self, b: &Self) -> cmp::Ordering {
        let a = a.0.as_ptr() as usize;
        let b = b.0.as_ptr() as usize;
        a.cmp(&b)
    }",0,,
"    pub fn element(&self) -> ValType {
        ValType::from_wasm_type(&self.ty.wasm_ty)
    }",0,,
"fn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>> {
		if fee.is_zero() {
			return Ok(None);
		}
		let account_id = T::AddressMapping::into_account_id(*who);
		let imbalance = C::withdraw(
			&account_id,
			fee.low_u128().unique_saturated_into(),
			WithdrawReasons::FEE,
			ExistenceRequirement::AllowDeath,
		)
		.map_err(|_| Error::<T>::BalanceLow)?;
		Ok(Some(imbalance))
	}",1,7,"fee.low_u128().unique_saturated_into(),"
"fn test_parse_less_version_487() {
    let output = b""less 487 (GNU regular expressions)
Copyright (C) 1984-2016  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Homepage: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(487), parse_less_version(output));
}",0,,
"    pub(crate) fn is_wasm_pc(pc: usize) -> bool {
        let modules = GLOBAL_MODULES.read().unwrap();

        match modules.module(pc) {
            Some((entry, text_offset)) => {
                wasmtime_environ::lookup_file_pos(entry.module.address_map_data(), text_offset)
                    .is_some()
            }
            None => false,
        }
    }",0,,
"fn test_bpf_to_bpf_pass_stack_reference() {
    test_interpreter_and_jit_elf!(
        ""tests/elfs/pass_stack_reference.so"",
        [],
        (),
        0,
        { |_vm, res: Result| res.unwrap() == 42 },
        29
    );
}",0,,
"pub fn tweak_mul_assign(&mut self, tweak: &SecretKey) -> Result<(), Error> {
        if tweak.0.is_zero() {
            return Err(Error::TweakOutOfRange);
        }

        self.0 *= &tweak.0;
        Ok(())
    }",0,,
"    fn from(val: ExternRef) -> Val {
        Val::ExternRef(Some(val))
    }",0,,
"fn test_err_dynamic_jmp_lddw() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r8, 0x1
        lsh64 r8, 0x20
        or64 r8, 0x28
        callx r8
        lddw r0, 0x1122334455667788
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 34
                )
            }
        },
        5
    );
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x1
        lsh64 r1, 0x20
        or64 r1, 0x38
        callx r1
        mov r0, r0
        mov r0, r0
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 36
                )
            }
        },
        5
    );
    test_interpreter_and_jit_asm!(
        ""
        lddw r1, 0x100000038
        callx r1
        mov r0, r0
        mov r0, r0
        exit
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 36
                )
            }
        },
        3
    );
}",0,,
"pub fn read8<R>(reader: &mut R) -> Result<u8, io::Error> where R: io::Read {
    let mut buf = [0u8; 1];
    reader.read_exact(&mut buf).and(Ok(buf[0]))
}",0,,
"fn instantiate_with_dummy(store: &mut Store<StoreLimits>, module: &Module) -> Option<Instance> {
    // Creation of imports can fail due to resource limit constraints, and then
    // instantiation can naturally fail for a number of reasons as well. Bundle
    // the two steps together to match on the error below.
    let instance =
        dummy::dummy_linker(store, module).and_then(|l| l.instantiate(&mut *store, module));

    let e = match instance {
        Ok(i) => return Some(i),
        Err(e) => e,
    };

    // If the instantiation hit OOM for some reason then that's ok, it's
    // expected that fuzz-generated programs try to allocate lots of
    // stuff.
    if store.data().oom {
        return None;
    }

    // Allow traps which can happen normally with `unreachable` or a
    // timeout or such
    if e.downcast_ref::<Trap>().is_some() {
        return None;
    }

    let string = e.to_string();
    // Also allow errors related to fuel consumption
    if string.contains(""all fuel consumed"")
        // Currently we instantiate with a `Linker` which can't instantiate
        // every single module under the sun due to using name-based resolution
        // rather than positional-based resolution
        || string.contains(""incompatible import type"")
    {
        return None;
    }

    // Everything else should be a bug in the fuzzer or a bug in wasmtime
    panic!(""failed to instantiate {:?}"", e);
}",0,,
"fn test_parse_less_version_529() {
    let output = b""less 529 (Spencer V8 regular expressions)
Copyright (C) 1984-2017  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Homepage: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(529), parse_less_version(output));
}",0,,
"pub fn clear(&mut self) {
        unsafe {
            core::ptr::write_volatile(&mut self.0, [0u32; 8]);
        }
    }",0,,
"fn test_jge_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xa
        mov32 r2, 0xb
        jge r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0xb
        jge r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,,
"pub fn parse_module(modules_str: &str) -> Result<ast::ModuleDefinition> {
    let stripped_string = &strip_comments(modules_str);
    let parser = syntax::ModuleParser::new();
    match parser.parse(stripped_string) {
        Ok(module) => Ok(module),
        Err(e) => handle_error(e, modules_str),
    }
}",1,"1,5","    let stripped_string = &strip_comments(modules_str);/~/        Err(e) => handle_error(e, modules_str),"
"pub fn to_wasm_binary(&self) -> Vec<u8> {
        let mut module = Module::new();

        // Import the GC function.
        let mut imports = ImportSection::new();
        imports.import("""", Some(""gc""), EntityType::Function(0));

        // Define our table.
        let mut tables = TableSection::new();
        tables.table(TableType {
            element_type: ValType::ExternRef,
            minimum: self.table_size(),
            maximum: None,
        });

        // Encode the types for all functions that we are using.
        let mut types = TypeSection::new();
        types.function(vec![], vec![]); // 0: ""gc""
        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);
        for _i in 0..self.num_params() {
            params.push(ValType::ExternRef);
        }
        let results = vec![];
        types.function(params, results); // 1: ""run""

        // Define the ""run"" function export.
        let mut functions = FunctionSection::new();
        functions.function(1);

        let mut exports = ExportSection::new();
        exports.export(""run"", Export::Function(1));

        let mut params: Vec<(u32, ValType)> = Vec::with_capacity(self.num_params() as usize);
        for _i in 0..self.num_params() {
            params.push((0, ValType::ExternRef));
        }
        let mut func = Function::new(params);

        for op in self.ops.iter().take(MAX_OPS) {
            op.insert(&mut func);
        }

        let mut code = CodeSection::new();
        code.function(&func);

        module
            .section(&types)
            .section(&imports)
            .section(&functions)
            .section(&tables)
            .section(&exports)
            .section(&code);

        module.finish()
    }",1,"15,16,17,18,19,20,21,22,23,24,30,32,33,34,35,36,39","// Encode the types for all functions that we are using./~/        let mut types = TypeSection::new();/~/        types.function(vec![], vec![]); // 0: ""gc""/~/        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);/~/        for _i in 0..self.num_params() {/~/            params.push(ValType::ExternRef);/~/        }/~/        let results = vec![];/~/        types.function(params, results); // 1: ""run""/~//~/        exports.export(""run"", Export::Function(1));/~/        let mut params: Vec<(u32, ValType)> = Vec::with_capacity(self.num_params() as usize);/~/        for _i in 0..self.num_params() {/~/            params.push((0, ValType::ExternRef));/~/        }/~/        let mut func = Function::new(params);/~/            op.insert(&mut func);"
"fn round_up_to_align(n: usize, align: usize) -> Option<usize> {
    debug_assert!(align.is_power_of_two());
    let align_minus_one = align - 1;
    Some(n.checked_add(align_minus_one)? & !align_minus_one)
}",0,,
"    fn test_diff_two_non_empty_files() {
        _do_diff_test(""/etc/group"", ""/etc/passwd"", true);
    }",0,,
"pub fn bits_var(&self, offset: usize, count: usize) -> u32 {
        debug_assert!(count < 32);
        debug_assert!(offset + count <= 256);
        if (offset + count - 1) >> 5 == offset >> 5 {
            return self.bits(offset, count);
        } else {
            debug_assert!((offset >> 5) + 1 < 8);
            return ((self.0[offset >> 5] >> (offset & 0x1f)) | (self.0[(offset >> 5) + 1] << (32 - (offset & 0x1f)))) & ((1 << count) - 1);
        }
    }",0,,
"    pub fn mutability(&self) -> Mutability {
        self.mutability
    }",0,,
"    fn do_tls_write_and_handle_error(&mut self) {
        let rc = self.tls_write();
        if rc.is_err() {
            error!(""write failed {:?}"", rc);
            self.closing = true;
            return;
        }
    }",0,,
"    fn get_insn(&self, insn: InstIx) -> &I {
        &self.insts[insn.get() as usize]
    }",0,,
"pub(crate) fn into_checked_anyfunc(
    val: Val,
    store: &mut StoreOpaque,
) -> Result<*mut wasmtime_runtime::VMCallerCheckedAnyfunc> {
    if !val.comes_from_same_store(store) {
        bail!(""cross-`Store` values are not supported"");
    }
    Ok(match val {
        Val::FuncRef(None) => ptr::null_mut(),
        Val::FuncRef(Some(f)) => f.caller_checked_anyfunc(store).as_ptr(),
        _ => bail!(""val is not funcref""),
    })
}",0,,
"    pub fn is_not_started(&self) -> bool {
        self.state.is_not_started()
    }",0,,
"fn test_list_syntax_themes_for_humans() {
        let mut writer = Cursor::new(vec![0; 512]);
        _list_syntax_themes_for_humans(&mut writer).unwrap();
        let mut s = String::new();
        writer.seek(SeekFrom::Start(0)).unwrap();
        writer.read_to_string(&mut s).unwrap();
        assert!(s.contains(""Light themes:\n""));
        assert!(s.contains(""    GitHub\n""));
        assert!(s.contains(""Dark themes:\n""));
        assert!(s.contains(""    Dracula\n""));
    }",0,,
"fn test_bounce() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 1
        mov r6, r0
        mov r7, r6
        mov r8, r7
        mov r9, r8
        mov r0, r9
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"    fn get_insn_mut(&mut self, insn: InstIx) -> &mut I {
        &mut self.insts[insn.get() as usize]
    }",0,,
"fn from(ty: wasmparser::TagType) -> Tag {
        Tag {
            ty: TypeIndex::from_u32(ty.type_index),
        }
    }",0,,
"    pub fn reset(&mut self) -> Result<(), Error> {
        self.alloc.reset_heap(self.module.as_ref())?;
        let globals = unsafe { self.alloc.globals_mut() };
        let mod_globals = self.module.globals();
        for (i, v) in mod_globals.iter().enumerate() {
            globals[i] = match v.global() {
                Global::Import { .. } => {
                    return Err(Error::Unsupported(format!(
                        ""global imports are unsupported; found: {:?}"",
                        v
                    )));
                }
                Global::Def(def) => def.init_val(),
            };
        }

        if self.module.get_start_func()?.is_some() {
            self.state = State::NotStarted;
        } else {
            self.state = State::Ready;
        }

        #[cfg(feature = ""concurrent_testpoints"")]
        {
            self.kill_state = Arc::new(KillState::new(Arc::clone(&self.lock_testpoints)));
        }
        #[cfg(not(feature = ""concurrent_testpoints""))]
        {
            self.kill_state = Arc::new(KillState::new());
        }

        Ok(())
    }",0,,
"async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = set_command_line_args().get_matches();
    env::set_var(""RUST_LOG"", ""swhkd=warn"");

    if args.is_present(""debug"") {
        env::set_var(""RUST_LOG"", ""swhkd=trace"");
    }

    env_logger::init();
    log::trace!(""Logger initialized."");

    let pidfile: String = String::from(""/tmp/swhkd.pid"");
    if Path::new(&pidfile).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pidfile);
        let swhkd_pid = match fs::read_to_string(&pidfile) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Swhkd is already running!"");
                log::error!(""pid of existing swhkd process: {}"", pid.to_string());
                log::error!(""To close the existing swhkd process, run `sudo killall swhkd`"");
                exit(1);
            }
        }
    }

    match fs::write(&pidfile, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pidfile, e);
            exit(1);
        }
    }

    if check_user_permissions().is_err() {
        exit(1);
    }

    let load_config = || {
        seteuid(env::var(""PKEXEC_UID"").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.
        let config_file_path: std::path::PathBuf = if args.is_present(""config"") {
            Path::new(args.value_of(""config"").unwrap()).to_path_buf()
        } else {
            fetch_xdg_config_path()
        };

        log::debug!(""Using config file path: {:#?}"", config_file_path);

        let hotkeys = match config::load(&config_file_path) {
            Err(e) => {
                log::error!(""Config Error: {}"", e);
                exit(1);
            }
            Ok(out) => out,
        };

        for hotkey in &hotkeys {
            log::debug!(""hotkey: {:#?}"", hotkey);
        }

        hotkeys
    };

    let mut hotkeys = load_config();
    seteuid(0); // Escalating back to root after reading config file.
    log::trace!(""Attempting to find all keyboard file descriptors."");
    let keyboard_devices: Vec<Device> =
        evdev::enumerate().filter(check_device_is_keyboard).collect();

    let mut uinput_device = match uinput::create_uinput_device() {
        Ok(dev) => dev,
        Err(e) => {
            log::error!(""Err: {:#?}"", e);
            exit(1);
        }
    };

    if keyboard_devices.is_empty() {
        log::error!(""No valid keyboard device was detected!"");
        exit(1);
    }
    log::debug!(""{} Keyboard device(s) detected."", keyboard_devices.len());

    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTALT, config::Modifier::Alt),
        (Key::KEY_RIGHTALT, config::Modifier::Alt),
        (Key::KEY_LEFTCTRL, config::Modifier::Control),
        (Key::KEY_RIGHTCTRL, config::Modifier::Control),
        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),
        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),
    ]);

    let repeat_cooldown_duration: u64 = if args.is_present(""cooldown"") {
        args.value_of(""cooldown"").unwrap().parse::<u64>().unwrap()
    } else {
        250
    };

    let mut signals = Signals::new(&[
        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,
        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,
    ])?;

    let mut execution_is_paused = false;
    let mut last_hotkey: Option<config::Hotkey> = None;
    let mut pending_release: bool = false;
    let mut keyboard_states: Vec<KeyboardState> = Vec::new();
    let mut keyboard_stream_map = StreamMap::new();

    for (i, mut device) in keyboard_devices.into_iter().enumerate() {
        let _ = device.grab();
        keyboard_stream_map.insert(i, device.into_event_stream()?);
        keyboard_states.push(KeyboardState::new());
    }

    // The initial sleep duration is never read because last_hotkey is initialized to None
    let hotkey_repeat_timer = sleep(Duration::from_millis(0));
    tokio::pin!(hotkey_repeat_timer);

    loop {
        select! {
            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {
                let hotkey = last_hotkey.clone().unwrap();
                if hotkey.keybinding.on_release {
                    continue;
                }
                send_command(hotkey.clone());
                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
            }

            Some(signal) = signals.next() => {
                match signal {
                    SIGUSR1 => {
                        execution_is_paused = true;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                    }

                    SIGUSR2 => {
                        execution_is_paused = false;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.grab();
                        }
                    }

                    SIGHUP => {
                        hotkeys = load_config();
                    }

                    SIGINT => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                        log::warn!(""Received SIGINT signal, exiting..."");
                        exit(1);
                    }

                    _ => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }

                        log::warn!(""Received signal: {:#?}"", signal);
                        log::warn!(""Exiting..."");
                        exit(1);
                    }
                }
            }

            Some((i, Ok(event))) = keyboard_stream_map.next() => {
                let keyboard_state = &mut keyboard_states[i];

                let key = match event.kind() {
                    InputEventKind::Key(keycode) => keycode,
                    _ => continue
                };

                match event.value() {
                    // Key press
                    1 => {
                        if let Some(modifier) = modifiers_map.get(&key) {
                            keyboard_state.state_modifiers.insert(*modifier);
                        } else {
                            keyboard_state.state_keysyms.insert(key);
                        }
                    }

                    // Key release
                    0 => {
                        if last_hotkey.is_some() && pending_release {
                            pending_release = false;
                            send_command(last_hotkey.clone().unwrap());
                            last_hotkey = None;
                        }
                        if let Some(modifier) = modifiers_map.get(&key) {
                            if let Some(hotkey) = &last_hotkey {
                                if hotkey.modifiers().contains(modifier) {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_modifiers.remove(modifier);
                        } else if keyboard_state.state_keysyms.contains(key) {
                            if let Some(hotkey) = &last_hotkey {
                                if key == hotkey.keysym() {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_keysyms.remove(key);
                        }
                    }

                    _ => {}
                }

                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()
                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())
                    .collect();

                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {
                    hotkey.keysym().code() == event.code() &&
                    keyboard_state.state_modifiers
                        .iter()
                        .all(|x| hotkey.modifiers().contains(x)) &&
                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                    && !hotkey.is_send()
                        });

                // Don't emit event to virtual device if it's from a valid hotkey
                if !event_in_hotkeys {
                    uinput_device.emit(&[event]).unwrap();
                }

                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {
                    continue;
                }

                log::debug!(""state_modifiers: {:#?}"", keyboard_state.state_modifiers);
                log::debug!(""state_keysyms: {:#?}"", keyboard_state.state_keysyms);
                log::debug!(""hotkey: {:#?}"", possible_hotkeys);

                for hotkey in possible_hotkeys {
                    // this should check if state_modifiers and hotkey.modifiers have the same elements
                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))
                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                        && keyboard_state.state_keysyms.contains(hotkey.keysym())
                    {
                        last_hotkey = Some(hotkey.clone());
                        if pending_release { break; }
                        if hotkey.is_on_release() {
                            pending_release = true;
                            break;
                        }
                        send_command(hotkey.clone());
                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
                        break;
                    }
                }
            }
        }
    }
}",1,"11,48","let pidfile: String = String::from(""/tmp/swhkd.pid"");/~/        seteuid(env::var(""PKEXEC_UID"").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user."
"fn test_jlt_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 5
        jlt r1, 4, +2
        jlt r1, 5, +1
        jlt r1, 6, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"fn test_tcp_port80_nomatch() {
    test_interpreter_and_jit_asm!(
        PROG_TCP_PORT_80,
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x06, //
            0x07, 0x08, 0x09, 0x0a, 0x08, 0x00, 0x45, 0x00, //
            0x00, 0x56, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, //
            0xf9, 0x4d, 0xc0, 0xa8, 0x00, 0x01, 0xc0, 0xa8, //
            0x00, 0x02, 0x00, 0x16, 0x27, 0x10, 0x00, 0x00, //
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x02, //
            0x20, 0x00, 0xc5, 0x18, 0x00, 0x00, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        18
    );
}",0,,
"pub fn minimum(&self) -> u64 {
        self.ty.minimum
    }",0,,
"fn call(&self, address: Address, data: Bytes) -> BoxFuture<Bytes, String> {
		let (header, env_info) = (self.client.best_block_header(), self.client.latest_env_info());

		let maybe_future = self.sync.with_context(move |ctx| {
			self.on_demand
				.request(ctx, on_demand::request::TransactionProof {
					tx: Transaction {
						nonce: self.client.engine().account_start_nonce(),
						action: Action::Call(address),
						gas: 50_000_000.into(),
						gas_price: 0.into(),
						value: 0.into(),
						data: data,
					}.fake_sign(Address::default()),
					header: header.into(),
					env_info: env_info,
					engine: self.client.engine().clone(),
				})
				.expect(""No back-references; therefore all back-refs valid; qed"")
				.then(|res| match res {
					Ok(Ok(executed)) => Ok(executed.output),
					Ok(Err(e)) => Err(format!(""Failed to execute transaction: {}"", e)),
					Err(_) => Err(format!(""On-demand service dropped request unexpectedly."")),
				})
		});

		match maybe_future {
			Some(fut) => fut.boxed(),
			None => future::err(""cannot query registry: network disabled"".into()).boxed(),
		}
	}",0,,
"pub fn bits(&self, offset: usize, count: usize) -> u32 {
        debug_assert!((offset + count - 1) >> 5 == offset >> 5);
        (self.0[offset >> 5] >> (offset & 0x1F)) & ((1 << count) - 1)
    }",0,,
"fn unregister(&mut self, end: usize) {
        let info = self.0.get_mut(&end).unwrap();
        info.references -= 1;
        if info.references == 0 {
            self.0.remove(&end);
        }
    }",0,,
"fn decode_into_slice_fits_in_precisely_sized_slice() {
        let mut orig_data = Vec::new();
        let mut encoded_data = String::new();
        let mut decode_buf = Vec::new();

        let input_len_range = Uniform::new(0, 1000);

        let mut rng = rand::rngs::SmallRng::from_entropy();

        for _ in 0..10_000 {
            orig_data.clear();
            encoded_data.clear();
            decode_buf.clear();

            let input_len = input_len_range.sample(&mut rng);

            for _ in 0..input_len {
                orig_data.push(rng.gen());
            }

            let config = random_config(&mut rng);
            encode_config_buf(&orig_data, config, &mut encoded_data);
            assert_encode_sanity(&encoded_data, config, input_len);

            decode_buf.resize(input_len, 0);

            // decode into the non-empty buf
            let decode_bytes_written =
                decode_config_slice(&encoded_data, config, &mut decode_buf[..]).unwrap();

            assert_eq!(orig_data.len(), decode_bytes_written);
            assert_eq!(orig_data, decode_buf);
        }
    }",0,,
"fn check_after(&mut self, reachable: bool) {
        assert_eq!(reachable, self.reachability[self.after_idx].1);
        self.after_idx += 1;
    }",0,,
"pub fn compile(wasm: &[u8], strategy: Strategy) {
    crate::init_fuzzing();

    let engine = Engine::new(&crate::fuzz_default_config(strategy).unwrap()).unwrap();
    log_wasm(wasm);
    let _ = Module::new(&engine, wasm);
}",0,,
"    pub fn new() -> ModuleType {
        ModuleType {
            imports: Vec::new(),
            exports: Vec::new(),
        }
    }",0,,
"fn f32_equal(a: u32, b: u32) -> bool {
    let a = f32::from_bits(a);
    let b = f32::from_bits(b);
    a == b || (a.is_nan() && b.is_nan())
}",0,,
"fn c_capture(&mut self, first_slot: usize, expr: &Hir) -> ResultOrEmpty {
        if self.num_exprs > 1 || self.compiled.is_dfa {
            // Don't ever compile Save instructions for regex sets because
            // they are never used. They are also never used in DFA programs
            // because DFAs can't handle captures.
            self.c(expr)
        } else {
            let entry = self.insts.len();
            let hole = self.push_hole(InstHole::Save { slot: first_slot });
            let patch = self.c(expr)?.unwrap_or(self.next_inst());
            self.fill(hole, patch.entry);
            self.fill_to_next(patch.hole);
            let hole = self.push_hole(InstHole::Save { slot: first_slot + 1 });
            Ok(Some(Patch { hole: hole, entry: entry }))
        }
    }",0,,
"fn wasm_dropping_refs() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (func (export ""drop_ref"") (param externref)
                    nop
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let drop_ref = instance.get_func(&mut store, ""drop_ref"").unwrap();

    let num_refs_dropped = Arc::new(AtomicUsize::new(0));

    // NB: 4096 is greater than the initial `VMExternRefActivationsTable`
    // capacity, so this will trigger at least one GC.
    for _ in 0..4096 {
        let r = ExternRef::new(CountDrops(num_refs_dropped.clone()));
        let args = [Val::ExternRef(Some(r))];
        drop_ref.call(&mut store, &args)?;
    }

    assert!(num_refs_dropped.load(SeqCst) > 0);

    // And after doing a final GC, all the refs should have been dropped.
    store.gc();
    assert_eq!(num_refs_dropped.load(SeqCst), 4096);

    return Ok(());

    struct CountDrops(Arc<AtomicUsize>);

    impl Drop for CountDrops {
        fn drop(&mut self) {
            self.0.fetch_add(1, SeqCst);
        }
    }
}",0,,
"pub fn native_version() -> NativeVersion {
	NativeVersion {
		runtime_version: VERSION,
		can_author_with: Default::default(),
	}
}",0,,
"pub fn new(configuration: Configuration, deps: Dependencies) -> Result<Option<Middleware>, String> {
	if !configuration.enabled {
		return Ok(None);
	}

	server::dapps_middleware(
		deps,
		configuration.dapps_path,
		configuration.extra_dapps,
		rpc::DAPPS_DOMAIN.into(),
	).map(Some)
}",0,,
"    pub(crate) fn as_wasm_func_type(&self) -> &WasmFuncType {
        &self.sig
    }",0,,
"    pub const fn new(char_set: CharacterSet, pad: bool) -> Config {
        Config {
            char_set,
            pad,
            decode_allow_trailing_bits: false,
        }
    }",0,,
"    pub fn stack_canary(&self) -> Option<usize> {
        self.stack_canary
    }",0,,
"fn verify_transaction<F>(bytes: Bytes, request: FilledTransactionRequest, process: F) -> Result<ConfirmationResponse, Error> where
		F: FnOnce(PendingTransaction) -> Result<ConfirmationResponse, Error>,
	{
		let signed_transaction = UntrustedRlp::new(&bytes.0).as_val().map_err(errors::from_rlp_error)?;
		let signed_transaction = SignedTransaction::new(signed_transaction).map_err(|e| errors::invalid_params(""Invalid signature."", e))?;
		let sender = signed_transaction.sender();

		// Verification
		let sender_matches = sender == request.from;
		let data_matches = signed_transaction.data == request.data;
		let value_matches = signed_transaction.value == request.value;
		let nonce_matches = match request.nonce {
			Some(nonce) => signed_transaction.nonce == nonce,
			None => true,
		};

		// Dispatch if everything is ok
		if sender_matches && data_matches && value_matches && nonce_matches {
			let pending_transaction = PendingTransaction::new(signed_transaction, request.condition.map(Into::into));
			process(pending_transaction)
		} else {
			let mut error = Vec::new();
			if !sender_matches { error.push(""from"") }
			if !data_matches { error.push(""data"") }
			if !value_matches { error.push(""value"") }
			if !nonce_matches { error.push(""nonce"") }

			Err(errors::invalid_params(""Sent transaction does not match the request."", error))
		}
	}",0,,
"    pub fn bindex_to_bb(&self, block: BlockIndex) -> Option<ir::Block> {
        self.block_order.lowered_order()[block as usize].orig_block()
    }",0,,
"fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Global::new(
            &mut store,
            GlobalType::new(ValType::ExternRef, Mutability::Const),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
                (module
                    (global (mut externref) (ref.null extern))

                    (func (export ""run"") (param externref)
                        local.get 0
                        global.set 0
                    )
                )
            ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }",0,,
"    fn add(self, other: Scalar) -> Scalar {
        let mut ret = Scalar::default();
        let _ = ret.add_in_place(&self, &other);
        ret
    }",0,,
"fn test_err_ldabsb_nomem() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsb 0x33
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 29 && vm_addr == 0x400000033 && len == 1 && name == ""input""
                )
            }
        },
        1
    );
}",0,,
"fn test_parse_less_version_551() {
    let output = b""less 551 (PCRE regular expressions)
Copyright (C) 1984-2019  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Home page: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(551), parse_less_version(output));
}",0,,
"fn test_ldindh() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x5
        ldindh r1, 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x9988 } },
        3
    );
}",0,,
"    fn block_insns(&self, block: BlockIx) -> Range<InstIx> {
        let (start, end) = self.block_ranges[block.get() as usize];
        Range::new(InstIx::new(start), (end - start) as usize)
    }",0,,
"fn aux(
            instance: &mut Instance,
            vmctx: &Vmctx,
            additional_pages: u32,
        ) -> Result<u32, Error> {
            // Calculate current and desired bytes
            let current_bytes = instance.alloc.heap_len();
            let additional_bytes =
                additional_pages
                    .checked_mul(WASM_PAGE_SIZE)
                    .ok_or_else(|| {
                        lucet_format_err!(""additional pages larger than wasm address space"",)
                    })? as usize;
            let desired_bytes = additional_bytes
                .checked_add(current_bytes)
                .ok_or_else(|| lucet_format_err!(""desired bytes overflow"",))?;
            // Let the limiter reject the grow
            if let Some(ref mut limiter) = instance.memory_limiter {
                if !vmctx.block_on(async move {
                    limiter.memory_growing(current_bytes, desired_bytes).await
                }) {
                    lucet_bail!(""memory limiter denied growth"");
                }
            }
            // Try the grow itself
            instance.grow_memory(additional_pages)
        }",0,,
"    fn deref(&self) -> &T {
        if cfg!(debug_assertions) {
            &self.inner
        } else {
            panic!(
                ""only deref `DebugOnly` when `cfg(debug_assertions)` or \
                 inside a `debug_assert!(..)`""
            )
        }
    }",0,,
"    pub fn handle(&mut self) -> Result<&mut dyn Write> {
        Ok(match *self {
            #[cfg(feature = ""paging"")]
            OutputType::Pager(ref mut command) => command
                .stdin
                .as_mut()
                .chain_err(|| ""Could not open stdin for pager"")?,
            OutputType::Stdout(ref mut handle) => handle,
        })
    }",0,,
"fn test_custom_entrypoint() {
    let mut file = File::open(""tests/elfs/unresolved_syscall.so"").expect(""file open failed"");
    let mut elf = Vec::new();
    file.read_to_end(&mut elf).unwrap();
    elf[24] = 80; // Move entrypoint to later in the text section
    let config = Config {
        enable_instruction_tracing: true,
        ..Config::default()
    };
    let mut syscall_registry = SyscallRegistry::default();
    test_interpreter_and_jit!(register, syscall_registry, b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call);
    let mut syscall_registry = SyscallRegistry::default();
    test_interpreter_and_jit!(register, syscall_registry, b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call);
    #[allow(unused_mut)]
    let mut executable = Executable::<UserError, TestInstructionMeter>::from_elf(
        &elf,
        None,
        config,
        syscall_registry,
    )
    .unwrap();
    test_interpreter_and_jit!(
        executable,
        [],
        syscalls::BpfSyscallContext::default(),
        { |_vm, res: Result| { res.unwrap() == 0 } },
        2
    );
}",0,,
"pub fn wrap<T, Params, Results>(
        mut store: impl AsContextMut<Data = T>,
        func: impl IntoFunc<T, Params, Results>,
    ) -> Func {
        let store = store.as_context_mut().0;
        // part of this unsafety is about matching the `T` to a `Store<T>`,
        // which is done through the `AsContextMut` bound above.
        unsafe {
            let host = HostFunc::wrap(store.engine(), func);
            host.into_func(store)
        }
    }",0,,
"fn test_jgt_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 5
        jgt r1, 6, +2
        jgt r1, 5, +1
        jgt r1, 4, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"fn execute(
		input: &[u8],
		target_gas: Option<u64>,
		_context: &Context,
		_is_static: bool,
	) -> PrecompileResult {
		if input.len() < 96 {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""input must contain at least 96 bytes"".into()),
			});
		};

		// reasonable assumption: this must fit within the Ethereum EVM's max stack size
		let max_size_big = BigUint::from_u32(1024).expect(""can't create BigUint"");

		let mut buf = [0; 32];
		buf.copy_from_slice(&input[0..32]);
		let base_len_big = BigUint::from_bytes_be(&buf);
		if base_len_big > max_size_big {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""unreasonably large base length"".into()),
			});
		}

		buf.copy_from_slice(&input[32..64]);
		let exp_len_big = BigUint::from_bytes_be(&buf);
		if exp_len_big > max_size_big {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""unreasonably large exponent length"".into()),
			});
		}

		buf.copy_from_slice(&input[64..96]);
		let mod_len_big = BigUint::from_bytes_be(&buf);
		if mod_len_big > max_size_big {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""unreasonably large exponent length"".into()),
			});
		}

		// bounds check handled above
		let base_len = base_len_big.to_usize().expect(""base_len out of bounds"");
		let exp_len = exp_len_big.to_usize().expect(""exp_len out of bounds"");
		let mod_len = mod_len_big.to_usize().expect(""mod_len out of bounds"");

		// input length should be at least 96 + user-specified length of base + exp + mod
		let total_len = base_len + exp_len + mod_len + 96;
		if input.len() < total_len {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""insufficient input size"".into()),
			});
		}

		// Gas formula allows arbitrary large exp_len when base and modulus are empty, so we need to handle empty base first.
		let (r, gas_cost) = if base_len == 0 && mod_len == 0 {
			(BigUint::zero(), MIN_GAS_COST)
		} else {
			// read the numbers themselves.
			let base_start = 96; // previous 3 32-byte fields
			let base = BigUint::from_bytes_be(&input[base_start..base_start + base_len]);

			let exp_start = base_start + base_len;
			let exponent = BigUint::from_bytes_be(&input[exp_start..exp_start + exp_len]);

			// do our gas accounting
			// TODO: we could technically avoid reading base first...
			let gas_cost =
				calculate_gas_cost(base_len as u64, exp_len as u64, mod_len as u64, &exponent);
			if let Some(gas_left) = target_gas {
				if gas_left < gas_cost {
					return Err(PrecompileFailure::Error {
						exit_status: ExitError::OutOfGas,
					});
				}
			};

			let mod_start = exp_start + exp_len;
			let modulus = BigUint::from_bytes_be(&input[mod_start..mod_start + mod_len]);

			if modulus.is_zero() || modulus.is_one() {
				(BigUint::zero(), gas_cost)
			} else {
				(base.modpow(&exponent, &modulus), gas_cost)
			}
		};

		// write output to given memory, left padded and same length as the modulus.
		let bytes = r.to_bytes_be();

		// always true except in the case of zero-length modulus, which leads to
		// output of length and value 1.
		if bytes.len() == mod_len {
			Ok(PrecompileOutput {
				exit_status: ExitSucceed::Returned,
				cost: gas_cost,
				output: bytes.to_vec(),
				logs: Default::default(),
			})
		} else if bytes.len() < mod_len {
			let mut ret = Vec::with_capacity(mod_len);
			ret.extend(core::iter::repeat(0).take(mod_len - bytes.len()));
			ret.extend_from_slice(&bytes[..]);
			Ok(PrecompileOutput {
				exit_status: ExitSucceed::Returned,
				cost: gas_cost,
				output: ret.to_vec(),
				logs: Default::default(),
			})
		} else {
			Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""failed"".into()),
			})
		}
	}",1,"36,65","				exit_status: ExitError::Other(""unreasonably large exponent length"".into()),/~/			// TODO: we could technically avoid reading base first..."
"fn confirm_request(&self, id: U256, modification: TransactionModification, pass: String)
		-> BoxFuture<ConfirmationResponse, Error>
	{
		self.confirm_internal(id, modification, move |dis, accounts, payload| {
			dispatch::execute(dis, accounts, payload, dispatch::SignWith::Password(pass))
		}).map(|v| v.into_value()).boxed()
	}",0,,
"    fn conn_event(&mut self, poll: &mut mio::Poll, event: &mio::Event) {
        let token = event.token();

        if self.connections.contains_key(&token) {
            self.connections
                .get_mut(&token)
                .unwrap()
                .ready(poll, event);

            if self.connections[&token].is_closed() {
                self.connections.remove(&token);
            }
        }
    }",0,,
"fn test_err_fixed_stack_out_of_bound() {
    let config = Config {
        dynamic_stack_frames: false,
        max_call_depth: 3,
        ..Config::default()
    };
    test_interpreter_and_jit_asm!(
        ""
        stb [r10-0x4000], 0
        exit"",
        config,
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Store && pc == 29 && vm_addr == 0x1FFFFD000 && len == 1 && name == ""program""
                )
            }
        },
        1
    );
}",0,,
"    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { self.inst.as_mut() }
    }",0,,
"    pub async fn release_self(self) {
        let Self {
            mut terminate_rx,
            terminate_tx,
            signal,
            ..
        } = self;
        drop(signal);
        drop(terminate_tx);
        let _ = terminate_rx.recv().await;
    }",0,,
"pub fn new(element: ValType, min: u32, max: Option<u32>) -> TableType {
        TableType {
            ty: Table {
                wasm_ty: element.to_wasm_type(),
                minimum: min,
                maximum: max,
            },
        }
    }",0,,
"pub fn table_size(&self) -> u32 {
        let table_size = std::cmp::max(self.table_size, TABLE_SIZE_RANGE.start);
        let table_size = std::cmp::min(table_size, TABLE_SIZE_RANGE.end);
        table_size
    }",0,,
"fn test_err_call_unresolved() {
    test_interpreter_and_jit_asm!(
        ""
        mov r1, 1
        mov r2, 2
        mov r3, 3
        mov r4, 4
        mov r5, 5
        syscall Unresolved
        mov64 r0, 0x0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::UnsupportedInstruction(pc) if pc == 34)
        },
        6
    );
}",0,,
"fn drop(&mut self) {
            self.live_refs.fetch_sub(1, SeqCst);
        }",0,,
"    fn new() -> KeyboardState {
        KeyboardState { state_modifiers: HashSet::new(), state_keysyms: AttributeSet::new() }
    }",0,,
"pub fn clone_cstrings_safely(user_ptr: *const *const c_char) -> Result<Vec<CString>> {
        let mut cstrings = Vec::new();
        if user_ptr == ptr::null() {
            return Ok(cstrings);
        }

        let mut user_ptr = user_ptr;
        loop {
            check_ptr(user_ptr)?;

            let cstr_ptr = {
                let cstr_ptr = unsafe { *user_ptr };
                if cstr_ptr == ptr::null() {
                    break;
                }
                cstr_ptr
            };
            let cstring = clone_cstring_safely(cstr_ptr)?;
            cstrings.push(cstring);

            user_ptr = unsafe { user_ptr.offset(1) };
        }
        Ok(cstrings)
    }",0,,
"    fn new(socket: TcpStream,
           token: mio::Token,
           mode: ServerMode,
           tls_session: rustls::ServerSession)
           -> Connection {
        let back = open_back(&mode);
        Connection {
            socket,
            token,
            closing: false,
            closed: false,
            mode,
            tls_session,
            back,
            sent_http_response: false,
        }
    }",0,,
"fn main() -> std::io::Result<()> {
    env::set_var(""RUST_LOG"", ""swhks=trace"");
    env_logger::init();

    let pid_file_path = String::from(""/tmp/swhks.pid"");
    let sock_file_path = String::from(""/tmp/swhkd.sock"");

    if Path::new(&pid_file_path).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pid_file_path);
        let swhkd_pid = match fs::read_to_string(&pid_file_path) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Server is already running!"");
                exit(1);
            }
        }
    }

    if Path::new(&sock_file_path).exists() {
        log::trace!(""Sockfile exists, attempting to remove it."");
        match fs::remove_file(&sock_file_path) {
            Ok(_) => {
                log::debug!(""Removed old socket file"");
            }
            Err(e) => {
                log::error!(""Error removing the socket file!: {}"", e);
                log::error!(""You can manually remove the socket file: {}"", sock_file_path);
                exit(1);
            }
        };
    }

    match fs::write(&pid_file_path, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pid_file_path, e);
            exit(1);
        }
    }

    let listener = UnixListener::bind(sock_file_path)?;
    loop {
        match listener.accept() {
            Ok((mut socket, address)) => {
                let mut response = String::new();
                socket.read_to_string(&mut response)?;
                run_system_command(&response);
                log::debug!(""Socket: {:?} Address: {:?} Response: {}"", socket, address, response);
            }
            Err(e) => log::error!(""accept function failed: {:?}"", e),
        }
    }
}",1,5,"    let sock_file_path = String::from(""/tmp/swhkd.sock"");"
"pub fn emit(
        &self,
    ) -> (
        MachBuffer<I>,
        Vec<CodeOffset>,
        Vec<(CodeOffset, CodeOffset)>,
    )
    where
        I: MachInstEmit,
    {
        let _tt = timing::vcode_emit();
        let mut buffer = MachBuffer::new();
        let mut state = I::State::new(&*self.abi);
        let cfg_metadata = self.flags().machine_code_cfg_info();
        let mut bb_starts: Vec<Option<CodeOffset>> = vec![];

        // The first M MachLabels are reserved for block indices, the next N MachLabels for
        // constants.
        buffer.reserve_labels_for_blocks(self.num_blocks() as BlockIndex);
        buffer.reserve_labels_for_constants(&self.constants);

        let mut inst_end_offsets = vec![0; self.insts.len()];
        let mut label_inst_indices = vec![0; self.num_blocks()];

        // Construct the final order we emit code in: cold blocks at the end.
        let mut final_order: SmallVec<[BlockIndex; 16]> = smallvec![];
        let mut cold_blocks: SmallVec<[BlockIndex; 16]> = smallvec![];
        for block in 0..self.num_blocks() {
            let block = block as BlockIndex;
            if self.block_order.is_cold(block) {
                cold_blocks.push(block);
            } else {
                final_order.push(block);
            }
        }
        let first_cold_block = cold_blocks.first().cloned();
        final_order.extend(cold_blocks.clone());

        // Emit blocks.
        let mut safepoint_idx = 0;
        let mut cur_srcloc = None;
        let mut last_offset = None;
        let mut start_of_cold_code = None;
        for block in final_order {
            let new_offset = I::align_basic_block(buffer.cur_offset());
            while new_offset > buffer.cur_offset() {
                // Pad with NOPs up to the aligned block offset.
                let nop = I::gen_nop((new_offset - buffer.cur_offset()) as usize);
                nop.emit(&mut buffer, &self.emit_info, &mut Default::default());
            }
            assert_eq!(buffer.cur_offset(), new_offset);

            if Some(block) == first_cold_block {
                start_of_cold_code = Some(buffer.cur_offset());
            }

            let (start, end) = self.block_ranges[block as usize];
            buffer.bind_label(MachLabel::from_block(block));
            label_inst_indices[block as usize] = start;

            if cfg_metadata {
                // Track BB starts. If we have backed up due to MachBuffer
                // branch opts, note that the removed blocks were removed.
                let cur_offset = buffer.cur_offset();
                if last_offset.is_some() && cur_offset <= last_offset.unwrap() {
                    for i in (0..bb_starts.len()).rev() {
                        if bb_starts[i].is_some() && cur_offset > bb_starts[i].unwrap() {
                            break;
                        }
                        bb_starts[i] = None;
                    }
                }
                bb_starts.push(Some(cur_offset));
                last_offset = Some(cur_offset);
            }

            for iix in start..end {
                let srcloc = self.srclocs[iix as usize];
                if cur_srcloc != Some(srcloc) {
                    if cur_srcloc.is_some() {
                        buffer.end_srcloc();
                    }
                    buffer.start_srcloc(srcloc);
                    cur_srcloc = Some(srcloc);
                }
                state.pre_sourceloc(cur_srcloc.unwrap_or(SourceLoc::default()));

                if safepoint_idx < self.safepoint_insns.len()
                    && self.safepoint_insns[safepoint_idx] == iix
                {
                    if self.safepoint_slots[safepoint_idx].len() > 0 {
                        let stack_map = self.abi.spillslots_to_stack_map(
                            &self.safepoint_slots[safepoint_idx][..],
                            &state,
                        );
                        state.pre_safepoint(stack_map);
                    }
                    safepoint_idx += 1;
                }

                self.insts[iix as usize].emit(&mut buffer, &self.emit_info, &mut state);

                if self.generate_debug_info {
                    // Buffer truncation may have happened since last inst append; trim inst-end
                    // layout info as appropriate.
                    let l = &mut inst_end_offsets[0..iix as usize];
                    for end in l.iter_mut().rev() {
                        if *end > buffer.cur_offset() {
                            *end = buffer.cur_offset();
                        } else {
                            break;
                        }
                    }
                    inst_end_offsets[iix as usize] = buffer.cur_offset();
                }
            }

            if cur_srcloc.is_some() {
                buffer.end_srcloc();
                cur_srcloc = None;
            }

            // Do we need an island? Get the worst-case size of the next BB and see if, having
            // emitted that many bytes, we will be beyond the deadline.
            if block < (self.num_blocks() - 1) as BlockIndex {
                let next_block = block + 1;
                let next_block_range = self.block_ranges[next_block as usize];
                let next_block_size = next_block_range.1 - next_block_range.0;
                let worst_case_next_bb = I::worst_case_size() * next_block_size;
                if buffer.island_needed(worst_case_next_bb) {
                    buffer.emit_island(worst_case_next_bb);
                }
            }
        }

        // Emit the constants used by the function.
        for (constant, data) in self.constants.iter() {
            let label = buffer.get_label_for_constant(constant);
            buffer.defer_constant(label, data.alignment(), data.as_slice(), u32::max_value());
        }

        if self.generate_debug_info {
            for end in inst_end_offsets.iter_mut().rev() {
                if *end > buffer.cur_offset() {
                    *end = buffer.cur_offset();
                } else {
                    break;
                }
            }
            *self.insts_layout.borrow_mut() = InstsLayoutInfo {
                inst_end_offsets,
                label_inst_indices,
                start_of_cold_code,
            };
        }

        // Create `bb_edges` and final (filtered) `bb_starts`.
        let mut final_bb_starts = vec![];
        let mut bb_edges = vec![];
        if cfg_metadata {
            for block in 0..self.num_blocks() {
                if bb_starts[block].is_none() {
                    // Block was deleted by MachBuffer; skip.
                    continue;
                }
                let from = bb_starts[block].unwrap();

                final_bb_starts.push(from);
                // Resolve each `succ` label and add edges.
                let succs = self.block_succs(BlockIx::new(block as u32));
                for succ in succs.iter() {
                    let to = buffer.resolve_label_offset(MachLabel::from_block(succ.get()));
                    bb_edges.push((from, to));
                }
            }
        }

        (buffer, final_bb_starts, bb_edges)
    }",1,"39,87,88,89,90,91,92,93,94,95,96,97","let mut safepoint_idx = 0;/~/                if safepoint_idx < self.safepoint_insns.len()/~/                    && self.safepoint_insns[safepoint_idx] == iix/~/                {/~/                    if self.safepoint_slots[safepoint_idx].len() > 0 {/~/                        let stack_map = self.abi.spillslots_to_stack_map(/~/                            &self.safepoint_slots[safepoint_idx][..],/~/                            &state,/~/                        );/~/                        state.pre_safepoint(stack_map);/~/                    }/~/                    safepoint_idx += 1;"
"fn test_mul32_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 3
        mov r1, 4
        mul32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xc } },
        4
    );
}",0,,
"	pub fn len(&self) -> usize {
		self.data.len()
	}",0,,
"fn test_jeq_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xa
        mov32 r2, 0xb
        jeq r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0xb
        jeq r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,,
"fn build(&self) {
			<Pallet<T>>::store_block(false, U256::zero());
			frame_support::storage::unhashed::put::<EthereumStorageSchema>(
				&PALLET_ETHEREUM_SCHEMA,
				&EthereumStorageSchema::V1,
			);
		}",0,,
"fn accept(&mut self, poll: &mut mio::Poll) -> bool {
        match self.server.accept() {
            Ok((socket, addr)) => {
                debug!(""Accepting new connection from {:?}"", addr);

                let tls_session = rustls::ServerSession::new(&self.tls_config);
                let mode = self.mode.clone();

                let token = mio::Token(self.next_id);
                self.next_id += 1;

                self.connections.insert(token, Connection::new(socket, token, mode, tls_session));
                self.connections[&token].register(poll);
                true
            }
            Err(e) => {
                println!(""encountered error while accepting connection; err={:?}"", e);
                false
            }
        }
    }",0,,
"pub fn new(pubkey: &PublicKey, seckey: &SecretKey) -> Result<SharedSecret, Error> {
        let inner = match ECMULT_CONTEXT.ecdh_raw(&pubkey.0, &seckey.0) {
            Some(val) => val,
            None => return Err(Error::InvalidSecretKey),
        };

        Ok(SharedSecret(inner))
    }",0,,
"fn into(self) -> u8 {
        self.0
    }",0,,
"fn validate_and_install(&self, response: fetch::Response) -> Result<ValidatorResponse, String> {
		let status = StatusCode::from_u16(response.status().to_u16());
		let is_html = response.is_html();
		let mime = response.content_type().unwrap_or(mime!(Text/Html));
		let mut handler = StreamingHandler::new(
			response,
			status,
			mime,
			self.embeddable_on.clone(),
		);
		if is_html {
			handler.set_initial_content(&format!(
				r#""<script src=""/{}/inject.js""></script><script>history.replaceState({{}}, """", ""/?{}{}/{}"")</script>""#,
				apps::UTILS_PATH,
				apps::URL_REFERER,
				apps::WEB_PATH,
				&self.referer,
			));
		}
		Ok(ValidatorResponse::Streaming(handler))
	}",0,,
"pub fn decode<T: AsRef<[u8]>>(input: T) -> Result<Vec<u8>, DecodeError> {
    decode_config(input, STANDARD)
}",0,,
"fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Table::new(
            &mut store,
            TableType::new(ValType::ExternRef, 1, None),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
            (module
                (table 1 externref)

                (func (export ""run"") (param externref)
                    i32.const 0
                    local.get 0
                    table.set 0
                )
            )
        ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }",0,,
"		pub fn transact(
			origin: OriginFor<T>,
			transaction: Transaction,
		) -> DispatchResultWithPostInfo {
			ensure_none(origin)?;

			Self::do_transact(transaction)
		}",0,,
"    pub fn module_name(&self) -> Option<&str> {
        self.module_name.as_deref()
    }",0,,
"fn run_app() -> std::io::Result<i32> {
    let assets = HighlightingAssets::new();
    let opt = cli::Opt::from_args_and_git_config(&mut git_config::GitConfig::try_create(), assets);

    if opt.list_languages {
        list_languages()?;
        return Ok(0);
    } else if opt.list_syntax_themes {
        list_syntax_themes()?;
        return Ok(0);
    } else if opt.show_syntax_themes {
        show_syntax_themes()?;
        return Ok(0);
    } else if opt.show_themes {
        show_themes(opt.dark, opt.light, opt.computed.is_light_mode)?;
        return Ok(0);
    }

    let _show_config = opt.show_config;
    let config = config::Config::from(opt);

    if _show_config {
        let stdout = io::stdout();
        let mut stdout = stdout.lock();
        show_config(&config, &mut stdout)?;
        return Ok(0);
    }

    let mut output_type =
        OutputType::from_mode(config.paging_mode, config.pager.clone(), &config).unwrap();
    let mut writer = output_type.handle().unwrap();

    if atty::is(atty::Stream::Stdin) {
        let exit_code = diff(
            config.minus_file.as_ref(),
            config.plus_file.as_ref(),
            &config,
            &mut writer,
        );
        return Ok(exit_code);
    }

    if let Err(error) = delta(io::stdin().lock().byte_lines(), &mut writer, &config) {
        match error.kind() {
            ErrorKind::BrokenPipe => return Ok(0),
            _ => eprintln!(""{}"", error),
        }
    };
    Ok(0)
}",0,,
"    unsafe fn gc_and_insert_slow(
        &mut self,
        externref: VMExternRef,
        module_info_lookup: &dyn ModuleInfoLookup,
    ) {
        gc(module_info_lookup, self);

        // Might as well insert right into the hash set, rather than the bump
        // chunk, since we are already on a slow path and we get de-duplication
        // this way.
        self.over_approximated_stack_roots
            .insert(VMExternRefWithTraits(externref));
    }",0,,
"    fn from(ty: TableType) -> ExternType {
        ExternType::Table(ty)
    }",0,,
"    pub fn params(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {
        self.sig.params.iter().map(ValType::from_wasm_type)
    }

    /// Returns the list of result types for this function.
    pub fn results(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {
        self.sig.returns.iter().map(ValType::from_wasm_type)
    }",1,"1,6",        self.sig.params.iter().map(ValType::from_wasm_type)/~/        self.sig.returns.iter().map(ValType::from_wasm_type)
"    pub(crate) fn from_wasmtime_table(table: &Table) -> TableType {
        TableType { ty: table.clone() }
    }",0,,
"	pub fn boxed(embeddable_on: Embeddable, web_proxy_tokens: Arc<WebProxyTokens>, remote: Remote, fetch: F) -> Box<Endpoint> {
		Box::new(Web {
			embeddable_on: embeddable_on,
			web_proxy_tokens: web_proxy_tokens,
			remote: remote,
			fetch: fetch,
		})
	}",0,,
"fn test_lsh64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x1
        mov r7, 4
        lsh r0, r7
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x10 } },
        4
    );
}",0,,
"    fn func_liveins(&self) -> RegallocSet<RealReg> {
        self.liveins.clone()
    }",0,,
"pub fn from_secret_key(seckey: &SecretKey) -> PublicKey {
        let mut pj = Jacobian::default();
        ECMULT_GEN_CONTEXT.ecmult_gen(&mut pj, &seckey.0);
        let mut p = Affine::default();
        p.set_gej(&pj);
        PublicKey(p)
    }",0,,
"fn recover_signer(transaction: &Transaction) -> Option<H160> {
		let mut sig = [0u8; 65];
		let mut msg = [0u8; 32];
		sig[0..32].copy_from_slice(&transaction.signature.r()[..]);
		sig[32..64].copy_from_slice(&transaction.signature.s()[..]);
		sig[64] = transaction.signature.standard_v();
		msg.copy_from_slice(&LegacyTransactionMessage::from(transaction.clone()).hash()[..]);

		let pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;
		Some(H160::from(H256::from_slice(
			Keccak256::digest(&pubkey).as_slice(),
		)))
	}",0,,
"fn incoming_plaintext(&mut self, buf: &[u8]) {
        match self.mode {
            ServerMode::Echo => {
                self.tls_session.write_all(buf).unwrap();
            }
            ServerMode::Http => {
                self.send_http_response_once();
            }
            ServerMode::Forward(_) => {
                self.back.as_mut().unwrap().write_all(buf).unwrap();
            }
        }
    }",0,,
"fn into(self) -> i32 {
        self.0 as i32
    }",0,,
"    fn position<P>(&self, predicate: P) -> Option<usize>
    where
        P: Fn(Self::Item) -> bool,
    {
        let mut iter = self.iter_elements();
        Iterator::position(&mut iter, predicate)
    }",0,,
"    pub fn is_bound_expired(&self) -> bool {
        self.state.is_bound_expired()
    }",0,,
"fn test_large_computation() {
		let input = hex::decode(
			""0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000020\
			0000000000000000000000000000000000000000000000000000000000000020\
			03\
			fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e\
			fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"",
		)
		.expect(""Decode failed"");

		let cost: u64 = 100000;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(precompile_result) => {
				assert_eq!(precompile_result.output.len(), 32); // should be same length as mod
				let result = BigUint::from_bytes_be(&precompile_result.output[..]);
				let expected = BigUint::parse_bytes(b""1"", 10).unwrap();
				assert_eq!(result, expected);
			}
			Err(_) => {
				panic!(""Modexp::execute() returned error""); // TODO: how to pass error on?
			}
		}
	}",0,,
"fn set_deleted(&mut self, address: H160) {
		self.substate.set_deleted(address)
	}",0,,
"fn store_block(post_log: bool, block_number: U256) {
		let mut transactions = Vec::new();
		let mut statuses = Vec::new();
		let mut receipts = Vec::new();
		let mut logs_bloom = Bloom::default();
		for (transaction, status, receipt) in Pending::<T>::get() {
			transactions.push(transaction);
			statuses.push(status);
			receipts.push(receipt.clone());
			Self::logs_bloom(receipt.logs.clone(), &mut logs_bloom);
		}

		let ommers = Vec::<ethereum::Header>::new();
		let receipts_root =
			ethereum::util::ordered_trie_root(receipts.iter().map(|r| rlp::encode(r)));
		let partial_header = ethereum::PartialHeader {
			parent_hash: Self::current_block_hash().unwrap_or_default(),
			beneficiary: pallet_evm::Pallet::<T>::find_author(),
			state_root: T::StateRoot::get(),
			receipts_root,
			logs_bloom,
			difficulty: U256::zero(),
			number: block_number,
			gas_limit: T::BlockGasLimit::get(),
			gas_used: receipts
				.clone()
				.into_iter()
				.fold(U256::zero(), |acc, r| acc + r.used_gas),
			timestamp: UniqueSaturatedInto::<u64>::unique_saturated_into(
				pallet_timestamp::Pallet::<T>::get(),
			),
			extra_data: Vec::new(),
			mix_hash: H256::default(),
			nonce: H64::default(),
		};
		let block = ethereum::Block::new(partial_header, transactions.clone(), ommers);

		CurrentBlock::<T>::put(block.clone());
		CurrentReceipts::<T>::put(receipts.clone());
		CurrentTransactionStatuses::<T>::put(statuses.clone());
		BlockHash::<T>::insert(block_number, block.header.hash());

		if post_log {
			let digest = DigestItem::<T::Hash>::Consensus(
				FRONTIER_ENGINE_ID,
				PostLog::Hashes(fp_consensus::Hashes::from_block(block)).encode(),
			);
			frame_system::Pallet::<T>::deposit_log(digest.into());
		}
	}",0,,
"pub fn ty(&self, store: impl AsContext) -> FuncType {
        // Signatures should always be registered in the engine's registry of
        // shared signatures, so we should be able to unwrap safely here.
        let store = store.as_context();
        let sig_index = unsafe { store[self.0].export().anyfunc.as_ref().type_index };
        FuncType::from_wasm_func_type(
            store
                .engine()
                .signatures()
                .lookup_type(sig_index)
                .expect(""signature should be registered""),
        )
    }",0,,
"pub fn check_array<T>(out_ptr: *const T, count: usize) -> Result<()> {
        let checked_len = count
            .checked_mul(size_of::<T>())
            .ok_or_else(|| errno!(EINVAL, ""the array is too long""))?;
        if !sgx_trts::trts::rsgx_raw_is_outside_enclave(out_ptr as *const u8, checked_len) {
            return_errno!(EFAULT, ""the whole buffer is not outside enclave"");
        }
        Ok(())
    }",0,,
"fn reduce(&mut self, overflow: bool) -> bool {
        let o: u64 = if overflow { 1 } else { 0 };
        let mut t: u64;
        t = (self.0[0] as u64) + o * (SECP256K1_N_C_0 as u64);
        self.0[0] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[1] as u64) + o * (SECP256K1_N_C_1 as u64);
        self.0[1] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[2] as u64) + o * (SECP256K1_N_C_2 as u64);
        self.0[2] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[3] as u64) + o * (SECP256K1_N_C_3 as u64);
        self.0[3] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[4] as u64) + o * (SECP256K1_N_C_4 as u64);
        self.0[4] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += self.0[5] as u64;
        self.0[5] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += self.0[6] as u64;
        self.0[6] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += self.0[7] as u64;
        self.0[7] = (t & 0xFFFFFFFF) as u32;
        overflow
    }",0,,
"fn read8_len() {
        let mut reader = Cursor::new([]);
        assert_err_kind!(read8(&mut reader), ErrorKind::UnexpectedEof);
        let mut reader = Cursor::new([0x01]);
        assert_ok!(read8(&mut reader), 0x01);
        let mut reader = Cursor::new([0x01, 0x02]);
        let mut buf = Vec::new();
        assert_ok!(read8(&mut reader), 0x01);
        assert_ok!(reader.read_to_end(&mut buf), 1);
        assert_eq!(buf, [0x02]);
    }",0,,
"    pub fn is_ref(&self) -> bool {
        match self {
            ValType::ExternRef | ValType::FuncRef => true,
            _ => false,
        }
    }",0,,
"fn test_load_elf() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/noop.so"",
        config,
        [],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
            b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        11
    );
}",0,,
"	pub fn is_valid_web_proxy_access_token(&self, token: &String) -> bool {
		self.web_proxy_tokens.lock().contains_key(&token)
	}",1,"0,1","	pub fn is_valid_web_proxy_access_token(&self, token: &String) -> bool {/~/		self.web_proxy_tokens.lock().contains_key(&token)"
"fn test_be32() {
    test_interpreter_and_jit_asm!(
        ""
        ldxw r0, [r1]
        be32 r0
        exit"",
        [0x11, 0x22, 0x33, 0x44],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11223344 } },
        3
    );
}",0,,
"fn test_insufficient_input() -> std::result::Result<(), PrecompileFailure> {
		let input = hex::decode(
			""0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001"",
		)
		.expect(""Decode failed"");

		let cost: u64 = 1;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(_) => {
				panic!(""Test not expected to pass"");
			}
			Err(e) => {
				assert_eq!(
					e,
					PrecompileFailure::Error {
						exit_status: ExitError::Other(""insufficient input size"".into())
					}
				);
				Ok(())
			}
		}
	}",0,,
"    pub fn returned_ref(&self) -> Result<&UntypedRetVal, Error> {
        match self {
            RunResult::Returned(rv) => Ok(rv),
            RunResult::Yielded(_) => Err(Error::InstanceNotReturned),
        }
    }",0,,
"pub fn instantiate_with_config(
    wasm: &[u8],
    known_valid: bool,
    mut config: Config,
    timeout: Timeout,
) {
    crate::init_fuzzing();

    config.interruptable(match &timeout {
        Timeout::Time(_) => true,
        _ => false,
    });
    config.consume_fuel(match &timeout {
        Timeout::Fuel(_) => true,
        _ => false,
    });
    let engine = Engine::new(&config).unwrap();
    let mut store = create_store(&engine);

    let mut timeout_state = SignalOnDrop::default();
    match timeout {
        Timeout::Fuel(fuel) => store.add_fuel(fuel).unwrap(),
        // If a timeout is requested then we spawn a helper thread to wait for
        // the requested time and then send us a signal to get interrupted. We
        // also arrange for the thread's sleep to get interrupted if we return
        // early (or the wasm returns within the time limit), which allows the
        // thread to get torn down.
        //
        // This prevents us from creating a huge number of sleeping threads if
        // this function is executed in a loop, like it does on nightly fuzzing
        // infrastructure.
        Timeout::Time(timeout) => {
            let handle = store.interrupt_handle().unwrap();
            timeout_state.spawn_timeout(timeout, move || handle.interrupt());
        }
        Timeout::None => {}
    }

    log_wasm(wasm);
    let module = match Module::new(&engine, wasm) {
        Ok(module) => module,
        Err(_) if !known_valid => return,
        Err(e) => panic!(""failed to compile module: {:?}"", e),
    };

    instantiate_with_dummy(&mut store, &module);
}",0,,
"fn run_system_command(command: &str) {
    match Command::new(""sh"")
        .arg(""-c"")
        .arg(command)
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
    {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Failed to execute {}"", command);
            log::error!(""Error, {}"", e);
        }
    }
}",0,,
"fn from(val: f64) -> Val {
        Val::F64(val.to_bits())
    }",0,,
"    fn block_succs(&self, block: BlockIx) -> Cow<[BlockIx]> {
        let (start, end) = self.block_succ_range[block.get() as usize];
        Cow::Borrowed(&self.block_succs[start..end])
    }",0,,
"fn c_byte(&mut self, b: u8) -> ResultOrEmpty {
        self.c_class_bytes(&[hir::ClassBytesRange::new(b, b)])
    }",0,,
"	pub fn ui<F: Fetch + Clone>(
		remote: Remote,
		registrar: Arc<ContractClient>,
		sync_status: Arc<SyncStatus>,
		fetch: F,
		dapps_domain: String,
	) -> Self {
		let content_fetcher = Arc::new(apps::fetcher::ContentFetcher::new(
			hash_fetch::urlhint::URLHintContract::new(registrar),
			sync_status,
			remote.clone(),
			fetch.clone(),
		).embeddable_on(None).allow_dapps(false));
		let special = {
			let mut special = special_endpoints(content_fetcher.clone());
			special.insert(router::SpecialEndpoint::Home, Some(apps::ui()));
			special
		};
		let router = router::Router::new(
			content_fetcher,
			None,
			special,
			None,
			dapps_domain,
		);

		Middleware {
			router: router,
			endpoints: Default::default(),
		}
	}",0,,
"fn touch(&mut self, _address: H160) {
		// Do nothing on touch in Substrate.
		//
		// EVM pallet considers all accounts to exist, and distinguish
		// only empty and non-empty accounts. This avoids many of the
		// subtle issues in EIP-161.
	}",0,,
"fn test_mov32_imm_large() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, -1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xffffffff } },
        2
    );
}",0,,
"	pub fn service(_: &Option<Middleware>) -> Option<Arc<rpc_apis::DappsService>> {
		None
	}",0,,
"fn test_err_syscall_string() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x0
        syscall BpfSyscallString
        mov64 r0, 0x0
        exit"",
        [72, 101, 108, 108, 111],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 0 && vm_addr == 0 && len == 0 && name == ""unknown""
                )
            }
        },
        2
    );
}",0,,
"pub fn column(&self) -> Option<u32> {
        self.column
    }",0,,
"fn test_arsh64() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        lsh r0, 63
        arsh r0, 55
        mov32 r1, 5
        arsh r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xfffffffffffffff8 } },
        6
    );
}",0,,
"fn decode_into_slice_doesnt_clobber_existing_prefix_or_suffix() {
        let mut orig_data = Vec::new();
        let mut encoded_data = String::new();
        let mut decode_buf = Vec::new();
        let mut decode_buf_copy: Vec<u8> = Vec::new();

        let input_len_range = Uniform::new(0, 1000);

        let mut rng = rand::rngs::SmallRng::from_entropy();

        for _ in 0..10_000 {
            orig_data.clear();
            encoded_data.clear();
            decode_buf.clear();
            decode_buf_copy.clear();

            let input_len = input_len_range.sample(&mut rng);

            for _ in 0..input_len {
                orig_data.push(rng.gen());
            }

            let config = random_config(&mut rng);
            encode_config_buf(&orig_data, config, &mut encoded_data);
            assert_encode_sanity(&encoded_data, config, input_len);

            // fill the buffer with random garbage, long enough to have some room before and after
            for _ in 0..5000 {
                decode_buf.push(rng.gen());
            }

            // keep a copy for later comparison
            decode_buf_copy.extend(decode_buf.iter());

            let offset = 1000;

            // decode into the non-empty buf
            let decode_bytes_written =
                decode_config_slice(&encoded_data, config, &mut decode_buf[offset..]).unwrap();

            assert_eq!(orig_data.len(), decode_bytes_written);
            assert_eq!(
                orig_data,
                &decode_buf[offset..(offset + decode_bytes_written)]
            );
            assert_eq!(&decode_buf_copy[0..offset], &decode_buf[0..offset]);
            assert_eq!(
                &decode_buf_copy[offset + decode_bytes_written..],
                &decode_buf[offset + decode_bytes_written..]
            );
        }
    }",0,,
"    pub fn contains_embed_ctx<T: Any>(&self) -> bool {
        self.embed_ctx.contains::<T>()
    }",0,,
"fn reject_request(&self, id: U256) -> Result<bool, Error> {
		let res = self.signer.request_rejected(id.into());
		Ok(res.is_some())
	}",0,,
"fn send_command(hotkey: config::Hotkey) {
    log::info!(""Hotkey pressed: {:#?}"", hotkey);
    if let Err(e) = sock_send(&hotkey.command) {
        log::error!(""Failed to send command to swhks through IPC."");
        log::error!(""Please make sure that swhks is running."");
        log::error!(""Err: {:#?}"", e)
    }
}",0,,
"fn address(address: &(String, u16)) -> String {
	format!(""{}:{}"", address.0, address.1)
}",0,,
"fn test_ldxb_all() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxb r9, [r0+0]
        lsh r9, 0
        ldxb r8, [r0+1]
        lsh r8, 4
        ldxb r7, [r0+2]
        lsh r7, 8
        ldxb r6, [r0+3]
        lsh r6, 12
        ldxb r5, [r0+4]
        lsh r5, 16
        ldxb r4, [r0+5]
        lsh r4, 20
        ldxb r3, [r0+6]
        lsh r3, 24
        ldxb r2, [r0+7]
        lsh r2, 28
        ldxb r1, [r0+8]
        lsh r1, 32
        ldxb r0, [r0+9]
        lsh r0, 36
        or r0, r1
        or r0, r2
        or r0, r3
        or r0, r4
        or r0, r5
        or r0, r6
        or r0, r7
        or r0, r8
        or r0, r9
        exit"",
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, //
            0x08, 0x09, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x9876543210 } },
        31
    );
}",0,,
"fn increment_ref_count(&self) {
        // This is only using during cloning operations, and like the standard
        // library we use `Relaxed` here. The rationale is better documented in
        // libstd's implementation of `Arc`, but the general gist is that we're
        // creating a new pointer for our own thread, so there's no need to have
        // any synchronization with orderings. The synchronization with other
        // threads with respect to orderings happens when the pointer is sent to
        // another thread.
        self.ref_count.fetch_add(1, Ordering::Relaxed);
    }",0,,
"fn test_jsge_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        jsge r1, -1, +5
        jsge r1, 0, +4
        mov32 r0, 1
        mov r1, -1
        jsge r1, -1, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,,
"    pub fn new(ty: wasmparser::GlobalType, initializer: GlobalInit) -> WasmResult<Global> {
        Ok(Global {
            wasm_ty: ty.content_type.try_into()?,
            mutability: ty.mutable,
            initializer,
        })
    }",0,,
"fn test_jlt_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        mov r1, 5
        mov r2, 4
        mov r3, 6
        jlt r1, r2, +2
        jlt r1, r1, +1
        jlt r1, r3, +1
        exit
        mov r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        9
    );
}",0,,
"    pub fn new_pem_based_ssl_connection(
        key_file: String,
        chain_file: String,
        base: BaseListener,
        tls_passfile: Option<String>,
    ) -> TResult<Self> {
        let mut acceptor_builder = SslAcceptor::mozilla_intermediate(SslMethod::tls())?;
        // cert is the same for both
        acceptor_builder.set_certificate_chain_file(chain_file)?;
        if let Some(tls_passfile) = tls_passfile {
            // first read in the private key
            let tls_private_key = fs::read(key_file).map_err(|e: IoError| {
                format!(""Failed to read TLS private key file with error: {}"", e)
            })?;
            // read the passphrase because the passphrase file stream was provided
            let tls_keyfile_stream = fs::read(tls_passfile).map_err(|e: IoError| {
                format!(
                    ""Failed to read TLS private key passphrase file with error: {}"",
                    e
                )
            })?;
            // decrypt the private key
            let pkey = Rsa::private_key_from_pem_passphrase(&tls_private_key, &tls_keyfile_stream)?;
            let pkey = PKey::from_rsa(pkey)?;
            // set the private key for the acceptor
            acceptor_builder.set_private_key(&pkey)?;
        } else {
            // no passphrase, needs interactive
            acceptor_builder.set_private_key_file(key_file, SslFiletype::PEM)?;
        }
        Ok(SslListener {
            base,
            acceptor: acceptor_builder.build(),
        })
    }",0,,
"    pub fn set_stack_canary(&mut self, canary: Option<usize>) {
        self.stack_canary = canary;
    }",0,,
"    pub(crate) fn from_wasmtime_memory(memory: &Memory) -> MemoryType {
        MemoryType { ty: memory.clone() }
    }",0,,
"pub fn set_int(&mut self, v: u32) {
        self.0 = [v, 0, 0, 0, 0, 0, 0, 0];
    }",0,,
"pub fn set_instruction_count_and_bound(&mut self, instruction_count: u64, bound: u64) {
        let implicits = self.get_instance_implicits_mut();
        let instruction_count =
            i64::try_from(instruction_count).expect(""instruction count too large"");
        let bound = i64::try_from(bound).expect(""bound too large"");
        // These two sum to `instruction_count`, which must be non-negative.
        implicits.instruction_count_bound = bound;
        implicits.instruction_count_adj = instruction_count - bound;
    }",0,,
"fn test_err_ldindb_oob() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x5
        ldindb r1, 0x33
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 30 && vm_addr == 0x400000038 && len == 1 && name == ""input""
                )
            }
        },
        2
    );
}",0,,
"		pub fn transact(
			origin: OriginFor<T>,
			transaction: Transaction,
		) -> DispatchResultWithPostInfo {
			let source = ensure_ethereum_transaction(origin)?;
			// Disable transact functionality if PreLog exist.
			ensure!(
				fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
				Error::<T>::PreLogExists,
			);

			Self::do_transact(source, transaction)
		}",1,11,"			Self::do_transact(source, transaction)"
"    fn alloc_mut(&mut self) -> &mut Alloc {
        &mut self.alloc
    }",0,,
"    fn deref(&self) -> &dyn Any {
        unsafe { self.extern_data().value_ptr.as_ref() }
    }",0,,
"fn push_types(isa: &dyn TargetIsa, sig: &mut ir::Signature, wasm: &WasmFuncType) {
    let cvt = |ty: &WasmType| ir::AbiParam::new(value_type(isa, *ty));
    sig.params.extend(wasm.params.iter().map(&cvt));
    sig.returns.extend(wasm.returns.iter().map(&cvt));
}",1,"2,3",    sig.params.extend(wasm.params.iter().map(&cvt));/~/    sig.returns.extend(wasm.returns.iter().map(&cvt));
"fn _show_syntax_themes(
    mut opt: cli::Opt,
    is_light_mode: bool,
    writer: &mut dyn Write,
    stdin: Option<&Vec<u8>>,
) -> std::io::Result<()> {
    use bytelines::ByteLines;
    use std::io::BufReader;
    let input = match stdin {
        Some(stdin_data) => &stdin_data[..],
        None => {
            b""\
diff --git a/example.rs b/example.rs
index f38589a..0f1bb83 100644
--- a/example.rs
+++ b/example.rs
@@ -1,5 +1,5 @@
-// Output the square of a number.
-fn print_square(num: f64) {
-    let result = f64::powf(num, 2.0);
-    println!(\""The square of {:.2} is {:.2}.\"", num, result);
+// Output the cube of a number.
+fn print_cube(num: f64) {
+    let result = f64::powf(num, 3.0);
+    println!(\""The cube of {:.2} is {:.2}.\"", num, result);
""
        }
    };

    opt.computed.is_light_mode = is_light_mode;
    let mut config = config::Config::from(opt);
    let title_style = ansi_term::Style::new().bold();
    let assets = HighlightingAssets::new();

    for syntax_theme in assets
        .theme_set
        .themes
        .iter()
        .filter(|(t, _)| is_light_syntax_theme(t) == is_light_mode)
        .map(|(t, _)| t)
    {
        writeln!(writer, ""\n\nTheme: {}\n"", title_style.paint(syntax_theme))?;
        config.syntax_theme = Some(assets.theme_set.themes[syntax_theme.as_str()].clone());
        if let Err(error) = delta(ByteLines::new(BufReader::new(&input[0..])), writer, &config) {
            match error.kind() {
                ErrorKind::BrokenPipe => process::exit(0),
                _ => eprintln!(""{}"", error),
            }
        };
    }
    Ok(())
}",0,,
"pub fn parse_slice(p: &[u8], format: Option<PublicKeyFormat>) -> Result<PublicKey, Error> {
        let format = match (p.len(), format) {
            (util::FULL_PUBLIC_KEY_SIZE, None) |
            (util::FULL_PUBLIC_KEY_SIZE, Some(PublicKeyFormat::Full)) =>
                PublicKeyFormat::Full,
            (util::COMPRESSED_PUBLIC_KEY_SIZE, None) |
            (util::COMPRESSED_PUBLIC_KEY_SIZE, Some(PublicKeyFormat::Compressed)) =>
                PublicKeyFormat::Compressed,
            (util::RAW_PUBLIC_KEY_SIZE, None) |
            (util::RAW_PUBLIC_KEY_SIZE, Some(PublicKeyFormat::Raw)) =>
                PublicKeyFormat::Raw,
            _ => return Err(Error::InvalidInputLength),
        };

        match format {
            PublicKeyFormat::Full => {
                let mut a = [0; util::FULL_PUBLIC_KEY_SIZE];
                a.copy_from_slice(p);
                Self::parse(&a)
            },
            PublicKeyFormat::Raw => {
                use util::TAG_PUBKEY_FULL;

                let mut a = [0; util::FULL_PUBLIC_KEY_SIZE];
                a[0] = TAG_PUBKEY_FULL;
                a[1..].copy_from_slice(p);
                Self::parse(&a)
            },
            PublicKeyFormat::Compressed => {
                let mut a = [0; util::COMPRESSED_PUBLIC_KEY_SIZE];
                a.copy_from_slice(p);
                Self::parse_compressed(&a)
            },
        }
    }",0,,
"    fn get_regs(insn: &I, collector: &mut RegUsageCollector) {
        insn.get_regs(collector)
    }",0,,
"    pub(crate) fn from_wasmtime(types: &TypeTables, ty: &EntityType) -> ExternType {
        match ty {
            EntityType::Function(idx) => {
                FuncType::from_wasm_func_type(types.wasm_signatures[*idx].clone()).into()
            }
            EntityType::Global(ty) => GlobalType::from_wasmtime_global(ty).into(),
            EntityType::Memory(ty) => MemoryType::from_wasmtime_memory(ty).into(),
            EntityType::Table(ty) => TableType::from_wasmtime_table(ty).into(),
            EntityType::Module(ty) => {
                let ty = &types.module_signatures[*ty];
                ModuleType::from_wasmtime(types, ty).into()
            }
            EntityType::Instance(ty) => {
                let ty = &types.instance_signatures[*ty];
                InstanceType::from_wasmtime(types, ty).into()
            }
            EntityType::Tag(_) => unimplemented!(""wasm tag support""),
        }
    }",0,,
"fn inc_nonce(&mut self, address: H160) {
		let account_id = T::AddressMapping::into_account_id(address);
		frame_system::Pallet::<T>::inc_account_nonce(&account_id);
	}",0,,
"fn test_tcp_port80_match() {
    test_interpreter_and_jit_asm!(
        PROG_TCP_PORT_80,
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x06, //
            0x07, 0x08, 0x09, 0x0a, 0x08, 0x00, 0x45, 0x00, //
            0x00, 0x56, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, //
            0xf9, 0x4d, 0xc0, 0xa8, 0x00, 0x01, 0xc0, 0xa8, //
            0x00, 0x02, 0x27, 0x10, 0x00, 0x50, 0x00, 0x00, //
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02, //
            0x20, 0x00, 0xc5, 0x18, 0x00, 0x00, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        17
    );
}",0,,
"fn new(server: TcpListener, mode: ServerMode, cfg: Arc<rustls::ServerConfig>) -> TlsServer {
        TlsServer {
            server,
            connections: HashMap::new(),
            next_id: 2,
            tls_config: cfg,
            mode,
        }
    }",0,,
"fn test_jle_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        mov r1, 5
        mov r2, 4
        mov r3, 6
        jle r1, r2, +2
        jle r1, r1, +1
        exit
        jle r1, r3, +1
        exit
        mov r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        9
    );
}",0,,
"    fn is_move(&self, insn: &I) -> Option<(Writable<Reg>, Reg)> {
        insn.is_move()
    }",0,,
"	pub fn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {
		CurrentTransactionStatuses::<T>::get()
	}",0,,
"fn create_store(engine: &Engine) -> Store<StoreLimits> {
    let mut store = Store::new(
        &engine,
        StoreLimits {
            // Limits tables/memories within a store to at most 1gb for now to
            // exercise some larger address but not overflow various limits.
            remaining_memory: 1 << 30,
            oom: false,
        },
    );
    store.limiter(|s| s as &mut dyn ResourceLimiter);
    return store;
}",0,,
"    pub fn init<C, E>(_unused: C) -> Box<dyn SyscallObject<UserError>> {
        Box::new(Self {})
    }",0,,
"fn strip_comments(string: &str) -> String {
    // Remove line comments
    let line_comments = Regex::new(r""(?m)//.*$"").unwrap();
    line_comments.replace_all(string, ""$1"").into_owned()
}",1,"0,1,2,3","fn strip_comments(string: &str) -> String {/~/    // Remove line comments/~/    let line_comments = Regex::new(r""(?m)//.*$"").unwrap();/~/    line_comments.replace_all(string, ""$1"").into_owned()"
"    pub fn unwrap_returned(self) -> UntypedRetVal {
        self.returned().unwrap()
    }",0,,
"fn drop(&mut self) {
        self.0.clear();
    }",0,,
"pub fn sign(message: &Message, seckey: &SecretKey) -> (Signature, RecoveryId) {
    let seckey_b32 = seckey.0.b32();
    let message_b32 = message.0.b32();

    let mut drbg = HmacDRBG::<Sha256>::new(&seckey_b32, &message_b32, &[]);
    let mut nonce = Scalar::default();
    let mut overflow;

    let result;
    loop {
        let generated = drbg.generate::<U32>(None);
        overflow = nonce.set_b32(array_ref!(generated, 0, 32));

        if !overflow && !nonce.is_zero() {
            match ECMULT_GEN_CONTEXT.sign_raw(&seckey.0, &message.0, &nonce) {
                Ok(val) => {
                    result = val;
                    break
                },
                Err(_) => (),
            }
        }
    }

    #[allow(unused_assignments)]
    {
        nonce = Scalar::default();
    }
    let (sigr, sigs, recid) = result;

    (Signature {
        r: sigr,
        s: sigs,
    }, RecoveryId(recid))
}",0,,
"fn deleted(&self, address: H160) -> bool {
		self.substate.deleted(address)
	}",0,,
"pub fn serialize(&self) -> [u8; util::FULL_PUBLIC_KEY_SIZE] {
        use util::TAG_PUBKEY_FULL;

        debug_assert!(!self.0.is_infinity());

        let mut ret = [0u8; 65];
        let mut elem = self.0.clone();

        elem.x.normalize_var();
        elem.y.normalize_var();
        elem.x.fill_b32(array_mut_ref!(ret, 1, 32));
        elem.y.fill_b32(array_mut_ref!(ret, 33, 32));
        ret[0] = TAG_PUBKEY_FULL;

        ret
    }",0,,
"    pub fn externref(&self) -> Option<Option<ExternRef>> {
        match self {
            Val::ExternRef(e) => Some(e.clone()),
            _ => None,
        }
    }",0,,
"fn test_parse_less_version_487() {
    let output = b""less 487 (GNU regular expressions)
Copyright (C) 1984-2016  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Homepage: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(487), parse_less_version(output));
}",0,,
"pub(super) fn parse_group<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    fn parse_capture<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (Capture<'i>, Span)> {
        map(pair(Token::Colon, opt(Token::Identifier)), |((_, span1), name)| {
            (Capture::new(name.map(|(s, _)| s)), span1)
        })(input)
    }",0,,
"    pub fn new_secure_only(base: BaseListener, ssl: SslOpts) -> Result<Self, String> {
        let bindaddr = bindaddr!(base);
        let slf = MultiListener::SecureOnly(
            SslListener::new_pem_based_ssl_connection(ssl.key, ssl.chain, base, ssl.passfile)
                .map_err(|e| format!(""Couldn't bind to secure port: {}"", e))?,
        );
        log::info!(""Server started on: skyhash-secure://{}"", bindaddr);
        Ok(slf)
    }",0,,
"	pub fn dapps_middleware(
		_deps: Dependencies,
		_dapps_path: PathBuf,
		_extra_dapps: Vec<PathBuf>,
		_dapps_domain: String,
	) -> Result<Middleware, String> {
		Err(""Your Parity version has been compiled without WebApps support."".into())
	}",0,,
"fn main() -> std::io::Result<()> {
    env::set_var(""RUST_LOG"", ""swhks=trace"");
    env_logger::init();

    let pid_file_path = String::from(""/tmp/swhks.pid"");
    let sock_file_path = String::from(format!(""/run/user/{}/swhkd.sock"", unistd::Uid::current()));

    if Path::new(&pid_file_path).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pid_file_path);
        let swhkd_pid = match fs::read_to_string(&pid_file_path) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Server is already running!"");
                exit(1);
            }
        }
    }

    if Path::new(&sock_file_path).exists() {
        log::trace!(""Sockfile exists, attempting to remove it."");
        match fs::remove_file(&sock_file_path) {
            Ok(_) => {
                log::debug!(""Removed old socket file"");
            }
            Err(e) => {
                log::error!(""Error removing the socket file!: {}"", e);
                log::error!(""You can manually remove the socket file: {}"", sock_file_path);
                exit(1);
            }
        };
    }

    match fs::write(&pid_file_path, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pid_file_path, e);
            exit(1);
        }
    }

    let listener = UnixListener::bind(sock_file_path)?;
    loop {
        match listener.accept() {
            Ok((mut socket, address)) => {
                let mut response = String::new();
                socket.read_to_string(&mut response)?;
                run_system_command(&response);
                log::debug!(""Socket: {:?} Address: {:?} Response: {}"", socket, address, response);
            }
            Err(e) => log::error!(""accept function failed: {:?}"", e),
        }
    }
}",1,4,"    let pid_file_path = String::from(""/tmp/swhks.pid"");"
"    pub fn build(self) -> (VCode<I>, StackmapRequestInfo) {
        // TODO: come up with an abstraction for ""vcode and auxiliary data"". The
        // auxiliary data needs to be separate from the vcode so that it can be
        // referenced as the vcode is mutated (e.g. by the register allocator).
        (self.vcode, self.stack_map_info)
    }",0,,
"pub fn call(&self, mut store: impl AsContextMut, params: Params) -> Result<Results, Trap> {
        let mut store = store.as_context_mut();
        assert!(
            !store.0.async_support(),
            ""must use `call_async` with async stores""
        );
        unsafe { self._call(&mut store, params) }
    }",0,,
"fn set_storage(&mut self, address: H160, index: H256, value: H256) {
		if value == H256::default() {
			log::debug!(
				target: ""evm"",
				""Removing storage for {:?} [index: {:?}]"",
				address,
				index,
			);
			<AccountStorages<T>>::remove(address, index);
		} else {
			log::debug!(
				target: ""evm"",
				""Updating storage for {:?} [index: {:?}, value: {:?}]"",
				address,
				index,
				value,
			);
			<AccountStorages<T>>::insert(address, index, value);
		}
	}",0,,
"fn test_tcp_sack_nomatch() {
    test_interpreter_and_jit_asm!(
        TCP_SACK_ASM,
        TCP_SACK_NOMATCH,
        (),
        0,
        { |_vm, res: Result| res.unwrap() == 0x0 },
        55
    );
}",0,,
"fn new(
            receiver: Arc<Mutex<mpsc::Receiver<WhatToDo>>>,
            host: std::string::String,
        ) -> Worker {
            let thread = thread::spawn(move || {
                let mut connection = TcpStream::connect(host).unwrap();
                loop {
                    let action = receiver.lock().unwrap().recv().unwrap();
                    match action {
                        WhatToDo::NewJob(someaction) => {
                            // We have to write something to the socket
                            connection.write_all(&someaction).unwrap();
                            // Ignore whatever we get, we don't need them
                            connection.read(&mut vec![0; 1024]).unwrap();
                        }
                        WhatToDo::Nothing => {
                            // A termination signal - just close the stream and
                            // return
                            connection.shutdown(net::Shutdown::Both).unwrap();
                            break;
                        }
                    }
                }
            });
            Worker {
                thread: Some(thread),
            }
        }",0,,
"pub fn parse(p: &[u8; util::FULL_PUBLIC_KEY_SIZE]) -> Result<PublicKey, Error> {
        use util::{TAG_PUBKEY_FULL, TAG_PUBKEY_HYBRID_EVEN, TAG_PUBKEY_HYBRID_ODD};

        if !(p[0] == TAG_PUBKEY_FULL || p[0] == TAG_PUBKEY_HYBRID_EVEN || p[0] == TAG_PUBKEY_HYBRID_ODD) {
            return Err(Error::InvalidPublicKey);
        }
        let mut x = Field::default();
        let mut y = Field::default();
        if !x.set_b32(array_ref!(p, 1, 32)) {
            return Err(Error::InvalidPublicKey);
        }
        if !y.set_b32(array_ref!(p, 33, 32)) {
            return Err(Error::InvalidPublicKey);
        }
        let mut elem = Affine::default();
        elem.set_xy(&x, &y);
        if (p[0] == TAG_PUBKEY_HYBRID_EVEN || p[0] == TAG_PUBKEY_HYBRID_ODD) &&
            (y.is_odd() != (p[0] == TAG_PUBKEY_HYBRID_ODD))
        {
            return Err(Error::InvalidPublicKey);
        }
        if elem.is_infinity() {
            return Err(Error::InvalidPublicKey);
        }
        if elem.is_valid_var() {
            return Ok(PublicKey(elem));
        } else {
            return Err(Error::InvalidPublicKey);
        }
    }",0,,
"	pub fn dapps_middleware(
		deps: Dependencies,
		dapps_path: PathBuf,
		extra_dapps: Vec<PathBuf>,
		dapps_domain: String,
	) -> Result<Middleware, String> {
		let signer = deps.signer;
		let parity_remote = parity_reactor::Remote::new(deps.remote.clone());
		let web_proxy_tokens = Arc::new(move |token| signer.is_valid_web_proxy_access_token(&token));

		Ok(parity_dapps::Middleware::dapps(
			parity_remote,
			deps.ui_address,
			dapps_path,
			extra_dapps,
			dapps_domain,
			deps.contract_client,
			deps.sync_status,
			web_proxy_tokens,
			deps.fetch,
		))
	}",1,8,		let web_proxy_tokens = Arc::new(move |token| signer.is_valid_web_proxy_access_token(&token));
"pub fn instantiate(wasm: &[u8], known_valid: bool, strategy: Strategy) {
    // Explicitly disable module linking for now since it's a breaking change to
    // pre-module-linking modules due to imports
    let mut cfg = crate::fuzz_default_config(strategy).unwrap();
    cfg.wasm_module_linking(false);
    instantiate_with_config(wasm, known_valid, cfg, Timeout::None);
}",0,,
"fn test_err_instruction_count_lddw_capped() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        lddw r1, 0x1
        mov r2, 0
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 32 && initial_insn_count == 2
                )
            }
        },
        2
    );
}",0,,
"    async fn memory_growing(&mut self, current: usize, desired: usize) -> bool;
    fn memory_grow_failed(&mut self, _error: &Error) {}",0,,
"    fn from(val: Option<ExternRef>) -> Val {
        Val::ExternRef(val)
    }",0,,
"pub fn execute(
		from: H160,
		transaction: &Transaction,
		config: Option<evm::Config>,
	) -> Result<
		(Option<H160>, Option<H160>, CallOrCreateInfo),
		DispatchErrorWithPostInfo<PostDispatchInfo>,
	> {
		let (
			input,
			value,
			gas_limit,
			max_fee_per_gas,
			max_priority_fee_per_gas,
			nonce,
			action,
			access_list,
		) = {
			match transaction {
				// max_fee_per_gas and max_priority_fee_per_gas in legacy and 2930 transactions is
				// the provided gas_price.
				Transaction::Legacy(t) => (
					t.input.clone(),
					t.value,
					t.gas_limit,
					Some(t.gas_price),
					Some(t.gas_price),
					Some(t.nonce),
					t.action,
					Vec::new(),
				),
				Transaction::EIP2930(t) => {
					let access_list: Vec<(H160, Vec<H256>)> = t
						.access_list
						.iter()
						.map(|item| (item.address, item.storage_keys.clone()))
						.collect();
					(
						t.input.clone(),
						t.value,
						t.gas_limit,
						Some(t.gas_price),
						Some(t.gas_price),
						Some(t.nonce),
						t.action,
						access_list,
					)
				}
				Transaction::EIP1559(t) => {
					let access_list: Vec<(H160, Vec<H256>)> = t
						.access_list
						.iter()
						.map(|item| (item.address, item.storage_keys.clone()))
						.collect();
					(
						t.input.clone(),
						t.value,
						t.gas_limit,
						Some(t.max_fee_per_gas),
						Some(t.max_priority_fee_per_gas),
						Some(t.nonce),
						t.action,
						access_list,
					)
				}
			}
		};

		let is_transactional = true;
		let validate = false;
		match action {
			ethereum::TransactionAction::Call(target) => {
				let res = match T::Runner::call(
					from,
					target,
					input,
					value,
					gas_limit.low_u64(),
					max_fee_per_gas,
					max_priority_fee_per_gas,
					nonce,
					access_list,
					is_transactional,
					validate,
					config.as_ref().unwrap_or_else(|| T::config()),
				) {
					Ok(res) => res,
					Err(e) => {
						return Err(DispatchErrorWithPostInfo {
							post_info: PostDispatchInfo {
								actual_weight: Some(e.weight),
								pays_fee: Pays::Yes,
							},
							error: e.error.into(),
						})
					}
				};

				Ok((Some(target), None, CallOrCreateInfo::Call(res)))
			}
			ethereum::TransactionAction::Create => {
				let res = match T::Runner::create(
					from,
					input,
					value,
					gas_limit.low_u64(),
					max_fee_per_gas,
					max_priority_fee_per_gas,
					nonce,
					access_list,
					is_transactional,
					validate,
					config.as_ref().unwrap_or_else(|| T::config()),
				) {
					Ok(res) => res,
					Err(e) => {
						return Err(DispatchErrorWithPostInfo {
							post_info: PostDispatchInfo {
								actual_weight: Some(e.weight),
								pays_fee: Pays::Yes,
							},
							error: e.error.into(),
						})
					}
				};

				Ok((None, Some(res.value), CallOrCreateInfo::Create(res)))
			}
		}
	}",1,"77,105","gas_limit.low_u64(),/~/					gas_limit.low_u64(),"
"	fn to_async_handler(&self, path: EndpointPath, control: hyper::Control) -> Box<Handler> {
		Box::new(WebHandler {
			control: control,
			state: State::Initial,
			path: path,
			remote: self.remote.clone(),
			fetch: self.fetch.clone(),
			web_proxy_tokens: self.web_proxy_tokens.clone(),
			embeddable_on: self.embeddable_on.clone(),
		})
	}",0,,
"pub fn fill_b32(&self, bin: &mut [u8; 32]) {
        bin[0] = (self.0[7] >> 24) as u8; bin[1] = (self.0[7] >> 16) as u8; bin[2] = (self.0[7] >> 8) as u8; bin[3] = (self.0[7]) as u8;
        bin[4] = (self.0[6] >> 24) as u8; bin[5] = (self.0[6] >> 16) as u8; bin[6] = (self.0[6] >> 8) as u8; bin[7] = (self.0[6]) as u8;
        bin[8] = (self.0[5] >> 24) as u8; bin[9] = (self.0[5] >> 16) as u8; bin[10] = (self.0[5] >> 8) as u8; bin[11] = (self.0[5]) as u8;
        bin[12] = (self.0[4] >> 24) as u8; bin[13] = (self.0[4] >> 16) as u8; bin[14] = (self.0[4] >> 8) as u8; bin[15] = (self.0[4]) as u8;
        bin[16] = (self.0[3] >> 24) as u8; bin[17] = (self.0[3] >> 16) as u8; bin[18] = (self.0[3] >> 8) as u8; bin[19] = (self.0[3]) as u8;
        bin[20] = (self.0[2] >> 24) as u8; bin[21] = (self.0[2] >> 16) as u8; bin[22] = (self.0[2] >> 8) as u8; bin[23] = (self.0[2]) as u8;
        bin[24] = (self.0[1] >> 24) as u8; bin[25] = (self.0[1] >> 16) as u8; bin[26] = (self.0[1] >> 8) as u8; bin[27] = (self.0[1]) as u8;
        bin[28] = (self.0[0] >> 24) as u8; bin[29] = (self.0[0] >> 16) as u8; bin[30] = (self.0[0] >> 8) as u8; bin[31] = (self.0[0]) as u8;
    }",0,,
"fn set_code(&mut self, address: H160, code: Vec<u8>) {
		log::debug!(
			target: ""evm"",
			""Inserting code ({} bytes) at {:?}"",
			code.len(),
			address
		);
		Pallet::<T>::create_account(address, code);
	}",0,,
"fn blank_sig(isa: &dyn TargetIsa, call_conv: CallConv) -> ir::Signature {
    let pointer_type = isa.pointer_type();
    let mut sig = ir::Signature::new(call_conv);
    // Add the caller/callee `vmctx` parameters.
    sig.params.push(ir::AbiParam::special(
        pointer_type,
        ir::ArgumentPurpose::VMContext,
    ));
    sig.params.push(ir::AbiParam::new(pointer_type));
    return sig;
}",0,,
"    pub fn func_env(&self) -> DummyFuncEnvironment {
        DummyFuncEnvironment::new(
            &self.info,
            self.return_mode,
            self.expected_reachability.clone(),
        )
    }",0,,
"	fn logs_bloom(logs: Vec<Log>, bloom: &mut Bloom) {
		for log in logs {
			bloom.accrue(BloomInput::Raw(&log.address[..]));
			for topic in log.topics {
				bloom.accrue(BloomInput::Raw(&topic[..]));
			}
		}
	}",0,,
"fn test_err_mod_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        mod32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,,
"fn test_rhs32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        xor r0, r0
        sub r0, 1
        rsh32 r0, 8
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x00ffffff } },
        4
    );
}",0,,
"fn default() -> Scalar {
        Scalar([0u32; 8])
    }",0,,
"fn test_bpf_to_bpf_depth() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    for i in 0..config.max_call_depth {
        test_interpreter_and_jit_elf!(
            ""tests/elfs/multiple_file.so"",
            config,
            [i as u8],
            (
                b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
            ),
            0,
            { |_vm, res: Result| { res.unwrap() == 0 } },
            if i == 0 { 4 } else { 3 + 10 * i as u64 }
        );
    }
}",0,,
"pub fn decode_config<T: AsRef<[u8]>>(input: T, config: Config) -> Result<Vec<u8>, DecodeError> {
    let mut buffer = Vec::<u8>::with_capacity(input.as_ref().len() * 4 / 3);

    decode_config_buf(input, config, &mut buffer).map(|_| buffer)
}",0,,
"fn test_le16_high() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1]
        le16 r0
        exit"",
        [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2211 } },
        3
    );
}",0,,
"    pub const fn decode_allow_trailing_bits(self, allow: bool) -> Config {
        Config {
            decode_allow_trailing_bits: allow,
            ..self
        }
    }",0,,
"pub(crate) unsafe fn drop_and_dealloc(mut data: NonNull<VMExternData>) {
        // Note: we introduce a block scope so that we drop the live
        // reference to the data before we free the heap allocation it
        // resides within after this block.
        let (alloc_ptr, layout) = {
            let data = data.as_mut();
            debug_assert_eq!(data.ref_count.load(Ordering::SeqCst), 0);

            // Same thing, but for the dropping the reference to `value` before
            // we drop it itself.
            let (layout, _) = {
                let value = data.value_ptr.as_ref();
                Self::layout_for(mem::size_of_val(value), mem::align_of_val(value))
            };

            ptr::drop_in_place(data.value_ptr.as_ptr());
            let alloc_ptr = data.value_ptr.cast::<u8>();

            (alloc_ptr, layout)
        };

        ptr::drop_in_place(data.as_ptr());
        std::alloc::dealloc(alloc_ptr.as_ptr(), layout);
    }",0,,
"fn test_parse_less_version_wrong_program() {
    let output = b""more from util-linux 2.34"";

    assert_eq!(None, parse_less_version(output));
}",0,,
"fn read16_len() {
        let mut reader = Cursor::new([]);
        assert_err_kind!(read16(&mut reader), ErrorKind::UnexpectedEof);
        let mut reader = Cursor::new([0x01]);
        assert_err_kind!(read16(&mut reader), ErrorKind::UnexpectedEof);
        let mut reader = Cursor::new([0x01, 0x02]);
        assert_ok!(read16(&mut reader), 0x0102);
        let mut reader = Cursor::new([0x01, 0x02, 0x03]);
        let mut buf = Vec::new();
        assert_ok!(read16(&mut reader), 0x0102);
        assert_ok!(reader.read_to_end(&mut buf), 1);
        assert_eq!(buf, [0x03]);
    }",0,,
"fn reset_balance(&mut self, _address: H160) {
		// Do nothing on reset balance in Substrate.
		//
		// This function exists in EVM because a design issue
		// (arguably a bug) in SELFDESTRUCT that can cause total
		// issurance to be reduced. We do not need to replicate this.
	}",0,,
"pub fn make_api_calls(api: crate::generators::api::ApiCalls) {
    use crate::generators::api::ApiCall;
    use std::collections::HashMap;

    crate::init_fuzzing();

    let mut config: Option<Config> = None;
    let mut engine: Option<Engine> = None;
    let mut store: Option<Store<StoreLimits>> = None;
    let mut modules: HashMap<usize, Module> = Default::default();
    let mut instances: HashMap<usize, Instance> = Default::default();

    for call in api.calls {
        match call {
            ApiCall::ConfigNew => {
                log::trace!(""creating config"");
                assert!(config.is_none());
                config = Some(crate::fuzz_default_config(wasmtime::Strategy::Cranelift).unwrap());
            }

            ApiCall::ConfigDebugInfo(b) => {
                log::trace!(""enabling debuginfo"");
                config.as_mut().unwrap().debug_info(b);
            }

            ApiCall::ConfigInterruptable(b) => {
                log::trace!(""enabling interruption"");
                config.as_mut().unwrap().interruptable(b);
            }

            ApiCall::EngineNew => {
                log::trace!(""creating engine"");
                assert!(engine.is_none());
                engine = Some(Engine::new(config.as_ref().unwrap()).unwrap());
            }

            ApiCall::StoreNew => {
                log::trace!(""creating store"");
                assert!(store.is_none());
                store = Some(create_store(engine.as_ref().unwrap()));
            }

            ApiCall::ModuleNew { id, wasm } => {
                log::debug!(""creating module: {}"", id);
                let wasm = wasm.module.to_bytes();
                log_wasm(&wasm);
                let module = match Module::new(engine.as_ref().unwrap(), &wasm) {
                    Ok(m) => m,
                    Err(_) => continue,
                };
                let old = modules.insert(id, module);
                assert!(old.is_none());
            }

            ApiCall::ModuleDrop { id } => {
                log::trace!(""dropping module: {}"", id);
                drop(modules.remove(&id));
            }

            ApiCall::InstanceNew { id, module } => {
                log::trace!(""instantiating module {} as {}"", module, id);
                let module = match modules.get(&module) {
                    Some(m) => m,
                    None => continue,
                };

                let store = store.as_mut().unwrap();
                if let Some(instance) = instantiate_with_dummy(store, module) {
                    instances.insert(id, instance);
                }
            }

            ApiCall::InstanceDrop { id } => {
                log::trace!(""dropping instance {}"", id);
                drop(instances.remove(&id));
            }

            ApiCall::CallExportedFunc { instance, nth } => {
                log::trace!(""calling instance export {} / {}"", instance, nth);
                let instance = match instances.get(&instance) {
                    Some(i) => i,
                    None => {
                        // Note that we aren't guaranteed to instantiate valid
                        // modules, see comments in `InstanceNew` for details on
                        // that. But the API call generator can't know if
                        // instantiation failed, so we might not actually have
                        // this instance. When that's the case, just skip the
                        // API call and keep going.
                        continue;
                    }
                };
                let store = store.as_mut().unwrap();

                let funcs = instance
                    .exports(&mut *store)
                    .filter_map(|e| match e.into_extern() {
                        Extern::Func(f) => Some(f.clone()),
                        _ => None,
                    })
                    .collect::<Vec<_>>();

                if funcs.is_empty() {
                    continue;
                }

                let nth = nth % funcs.len();
                let f = &funcs[nth];
                let ty = f.ty(&store);
                let params = dummy::dummy_values(ty.params());
                let _ = f.call(store, &params);
            }
        }
    }
}",0,,
"    fn from(val: Option<Func>) -> Val {
        Val::FuncRef(val)
    }",0,,
"fn atou16_misc() {
        assert_ok!(atou16(b""0""), 0);
        assert_ok!(atou16(b""0010""), 10);
        assert_ok!(atou16(b""9999""), 9999);
        assert_err_pat!(atou16(b""""), Error::InvalidFormat(_));
        assert_err_pat!(atou16(b""/""), Error::InvalidFormat(_));
        assert_err_pat!(atou16(b"":""), Error::InvalidFormat(_));
        assert_err_pat!(atou16(b""-1""), Error::InvalidFormat(_));
    }",0,,
"fn get() -> H256 {
		H256::decode(&mut &sp_io::storage::root()[..])
			.expect(""Node is configured to use the same hash; qed"")
	}",0,,
"fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            DecodeError::InvalidByte(index, byte) => {
                write!(f, ""Invalid byte {}, offset {}."", byte, index)
            }
            DecodeError::InvalidLength => write!(f, ""Encoded text cannot have a 6-bit remainder.""),
            DecodeError::InvalidLastSymbol(index, byte) => {
                write!(f, ""Invalid last symbol {}, offset {}."", byte, index)
            }
        }
    }",0,,
"    pub fn lookup_trampoline(&self, anyfunc: &VMCallerCheckedAnyfunc) -> Option<VMTrampoline> {
        let module = self.module(anyfunc.func_ptr.as_ptr() as usize)?;
        module.signatures.trampoline(anyfunc.type_index)
    }",0,,
"pub fn parse_script(script_str: &str) -> Result<ast::Script> {
    let stripped_string = &strip_comments(script_str);
    let parser = syntax::ScriptParser::new();
    match parser.parse(stripped_string) {
        Ok(script) => Ok(script),
        Err(e) => handle_error(e, script_str),
    }
}",1,"1,5","    let stripped_string = &strip_comments(script_str);/~/        Err(e) => handle_error(e, script_str),"
"    pub const fn is_termination_signal(&self) -> bool {
        self.terminate
    }",0,,
"fn half_fill_split_goto1(&mut self, goto1: InstPtr) {
        let half_filled = match *self {
            MaybeInst::Split => goto1,
            _ => unreachable!(
                ""must be called on Split instruction, \
                 instead it was called on: {:?}"",
                self
            ),
        };
        *self = MaybeInst::Split1(half_filled);
    }",0,,
"fn test_tight_infinite_recursion_callx() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r8, 0x1
        lsh64 r8, 0x20
        or64 r8, 0x18
        mov64 r3, 0x41414141
        callx r8
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 34 && initial_insn_count == 7
                )
            }
        },
        7
    );
}",0,,
"    pub(crate) fn stdout() -> Self {
        OutputType::Stdout(io::stdout())
    }",0,,
"pub fn read16<R>(reader: &mut R) -> Result<u16, io::Error> where R: io::Read {
    let mut buf = [0u8; 2];
    reader.read_exact(&mut buf)?;
    Ok(u16::from_be_bytes(buf))
}",0,,
"fn hash(&self, suffix: &SuffixCacheKey) -> usize {
        // Basic FNV-1a hash as described:
        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
        const FNV_PRIME: u64 = 1099511628211;
        let mut h = 14695981039346656037;
        h = (h ^ (suffix.from_inst as u64)).wrapping_mul(FNV_PRIME);
        h = (h ^ (suffix.start as u64)).wrapping_mul(FNV_PRIME);
        h = (h ^ (suffix.end as u64)).wrapping_mul(FNV_PRIME);
        (h as usize) % self.sparse.len()
    }",0,,
"fn test_alu32_arithmetic() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 1
        mov32 r2, 2
        mov32 r3, 3
        mov32 r4, 4
        mov32 r5, 5
        mov32 r6, 6
        mov32 r7, 7
        mov32 r8, 8
        mov32 r9, 9
        add32 r0, 23
        add32 r0, r7
        sub32 r0, 13
        sub32 r0, r1
        mul32 r0, 7
        mul32 r0, r3
        div32 r0, 2
        div32 r0, r4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2a } },
        19
    );
}",0,,
"pub fn pre_migrate_block_v2() -> Result<(), &'static str> {
		let item = b""CurrentBlock"";
		let block_v0 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV0>(
			Self::name().as_bytes(),
			item,
			&[],
		);
		if let Some(block_v0) = block_v0 {
			Self::set_temp_storage(block_v0.header.number, ""number"");
			Self::set_temp_storage(block_v0.header.parent_hash, ""parent_hash"");
			Self::set_temp_storage(block_v0.transactions.len() as u64, ""transaction_len"");
		}
		Ok(())
	}

	#[cfg(feature = ""try-runtime"")]
	pub fn post_migrate_block_v2() -> Result<(), &'static str> {
		let v0_number =
			Self::get_temp_storage(""number"").expect(""We stored a number; it should be there; qed"");
		let v0_parent_hash = Self::get_temp_storage(""parent_hash"")
			.expect(""We stored a parent hash; it should be there; qed"");
		let v0_transaction_len: u64 = Self::get_temp_storage(""transaction_len"")
			.expect(""We stored a transaction count; it should be there; qed"");

		let item = b""CurrentBlock"";
		let block_v2 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV2>(
			Self::name().as_bytes(),
			item,
			&[],
		);

		assert!(block_v2.is_some());

		let block_v2 = block_v2.unwrap();
		assert_eq!(block_v2.header.number, v0_number);
		assert_eq!(block_v2.header.parent_hash, v0_parent_hash);
		assert_eq!(block_v2.transactions.len() as u64, v0_transaction_len);
		Ok(())
	}",0,,
"fn call(
		source: H160,
		target: H160,
		input: Vec<u8>,
		value: U256,
		gas_limit: u64,
		max_fee_per_gas: Option<U256>,
		max_priority_fee_per_gas: Option<U256>,
		nonce: Option<U256>,
		access_list: Vec<(H160, Vec<H256>)>,
		is_transactional: bool,
		validate: bool,
		config: &evm::Config,
	) -> Result<CallInfo, RunnerError<Self::Error>> {
		if validate {
			let _ = Self::validate(
				source,
				Some(target),
				input.clone(),
				value,
				gas_limit,
				max_fee_per_gas,
				max_priority_fee_per_gas,
				nonce,
				access_list.clone(),
				is_transactional,
				config,
			)?;
		}
		let precompiles = T::PrecompilesValue::get();
		Self::execute(
			source,
			value,
			gas_limit,
			max_fee_per_gas,
			max_priority_fee_per_gas,
			config,
			&precompiles,
			is_transactional,
			|executor| executor.transact_call(source, target, value, input, gas_limit, access_list),
		)
	}",0,,
"fn validate<U: ValidateUnsigned<Call = Self::Call>>(
		&self,
		// TODO [#5006;ToDr] should source be passed to `SignedExtension`s?
		// Perhaps a change for 2.0 to avoid breaking too much APIs?
		source: TransactionSource,
		info: &DispatchInfoOf<Self::Call>,
		len: usize,
	) -> TransactionValidity {
		match &self.signed {
			CheckedSignature::Signed(id, extra) => {
				Extra::validate(extra, id, &self.function, info, len)
			}
			CheckedSignature::Unsigned => {
				let valid = Extra::validate_unsigned(&self.function, info, len)?;
				let unsigned_validation = U::validate_unsigned(source, &self.function)?;
				Ok(valid.combine_with(unsigned_validation))
			}
			CheckedSignature::SelfContained(signed_info) => {
				self.function.validate_self_contained(&signed_info).ok_or(
					TransactionValidityError::Invalid(InvalidTransaction::BadProof),
				)?
			}
		}
	}",0,,
"    fn take_translator(&self) -> FuncTranslator {
        let candidate = self.translators.lock().unwrap().pop();
        candidate.unwrap_or_else(FuncTranslator::new)
    }",0,,
"fn from(val: f32) -> Val {
        Val::F32(val.to_bits())
    }",0,,
"fn test_syscall_static() {
    test_interpreter_and_jit_elf!(
        ""tests/elfs/syscall_static.so"",
        [],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        5
    );
}",0,,
"fn _do_diff_test(file_a: &str, file_b: &str, expect_diff: bool) {
        let config = integration_test_utils::make_config_from_args(&[]);
        let mut writer = Cursor::new(vec![]);
        let exit_code = diff(
            Some(&PathBuf::from(file_a)),
            Some(&PathBuf::from(file_b)),
            &config,
            &mut writer,
        );
        assert_eq!(exit_code, if expect_diff { 1 } else { 0 });
    }",0,,
"fn test_wat_string() {
        let ops = TableOps {
            num_params: 2,
            table_size: 10,
            ops: vec![
                TableOp::Gc,
                TableOp::Get(0),
                TableOp::SetFromParam(1, 2),
                TableOp::SetFromGet(3, 4),
            ],
        };

        let expected = r#""
(module
  (type (;0;) (func))
  (type (;1;) (func (param externref externref)))
  (import """" ""gc"" (func (;0;) (type 0)))
  (func (;1;) (type 1) (param externref externref)
    call 0
    i32.const 0
    table.get 0
    drop
    i32.const 1
    local.get 2
    table.set 0
    i32.const 3
    i32.const 4
    table.get 0
    table.set 0)
  (table (;0;) 10 externref)
  (export ""run"" (func 1)))
""#;
        let actual = ops.to_wasm_binary();
        let actual = wasmprinter::print_bytes(&actual).unwrap();
        assert_eq!(actual.trim(), expected.trim());
    }",1,"2,3,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30","num_params: 2,/~/            table_size: 10,/~/  (type (;1;) (func (param externref externref)))/~/  (func (;1;) (type 1) (param externref externref)/~/    call 0/~/    i32.const 0/~/    table.get 0/~/    drop/~/    i32.const 1/~/    local.get 2/~/    table.set 0/~/    i32.const 3/~/    i32.const 4/~/    table.get 0/~/    table.set 0)/~/  (table (;0;) 10 externref)/~/  (export ""run"" (func 1)))"
"pub fn tweak_add_assign(&mut self, tweak: &SecretKey) -> Result<(), Error> {
        let v = &self.0 + &tweak.0;
        if v.is_zero() {
            return Err(Error::TweakOutOfRange);
        }
        self.0 = v;
        Ok(())
    }",0,,
"    fn add(self, other: &'a Scalar) -> Scalar {
        let mut ret = Scalar::default();
        let _ = ret.add_in_place(self, other);
        ret
    }
}

impl<'a> AddAssign<&'a Scalar> for Scalar {
    fn add_assign(&mut self, other: &'a Scalar) {
        let mut ret = Scalar::default();
        let _ = ret.add_in_place(self, other);
        *self = ret;
    }",0,,
"    fn drop(&mut self) {
        let mut info = GLOBAL_MODULES.write().unwrap();
        for end in self.modules_with_code.keys() {
            info.unregister(*end);
        }
    }",0,,
"    fn stdout() -> Self {
        OutputType::Stdout(io::stdout())
    }",0,,
"fn show_themes(dark: bool, light: bool, computed_theme_is_light: bool) -> std::io::Result<()> {
    use bytelines::ByteLines;
    use sample_diff::DIFF;
    use std::io::BufReader;
    let mut input = DIFF.to_vec();

    if !atty::is(atty::Stream::Stdin) {
        let mut buf = Vec::new();
        io::stdin().lock().read_to_end(&mut buf)?;
        if !buf.is_empty() {
            input = buf;
        }
    };

    let mut git_config = git_config::GitConfig::try_create();
    let opt = cli::Opt::from_iter_and_git_config(
        &["""", """", ""--navigate"", ""--show-themes""],
        &mut git_config,
    );
    let mut output_type =
        OutputType::from_mode(PagingMode::Always, None, &config::Config::from(opt)).unwrap();
    let title_style = ansi_term::Style::new().bold();
    let writer = output_type.handle().unwrap();

    for theme in &get_themes(git_config::GitConfig::try_create()) {
        let opt =
            cli::Opt::from_iter_and_git_config(&["""", """", ""--features"", &theme], &mut git_config);
        let is_dark_theme = opt.dark;
        let is_light_theme = opt.light;
        let config = config::Config::from(opt);

        if (!computed_theme_is_light && is_dark_theme)
            || (computed_theme_is_light && is_light_theme)
            || (dark && light)
        {
            writeln!(writer, ""\n\nTheme: {}\n"", title_style.paint(theme))?;

            if let Err(error) = delta(ByteLines::new(BufReader::new(&input[0..])), writer, &config)
            {
                match error.kind() {
                    ErrorKind::BrokenPipe => process::exit(0),
                    _ => eprintln!(""{}"", error),
                }
            }
        }
    }

    Ok(())
}",0,,
"pub async fn call_async<T>(
        &self,
        mut store: impl AsContextMut<Data = T>,
        params: Params,
    ) -> Result<Results, Trap>
    where
        T: Send,
    {
        let mut store = store.as_context_mut();
        assert!(
            store.0.async_support(),
            ""must use `call` with non-async stores""
        );
        store
            .on_fiber(|store| unsafe { self._call(store, params) })
            .await?
    }",0,,
"    fn ready(&mut self, poll: &mut mio::Poll, ev: &mio::Event) {
        // If we're readable: read some TLS.  Then
        // see if that yielded new plaintext.  Then
        // see if the backend is readable too.
        if ev.readiness().is_readable() {
            self.do_tls_read();
            self.try_plain_read();
            self.try_back_read();
        }

        if ev.readiness().is_writable() {
            self.do_tls_write_and_handle_error();
        }

        if self.closing && !self.tls_session.wants_write() {
            let _ = self.socket.shutdown(Shutdown::Both);
            self.close_back();
            self.closed = true;
        } else {
            self.reregister(poll);
        }
    }",1,14,        if self.closing && !self.tls_session.wants_write() {
"	pub fn current_receipts() -> Option<Vec<ethereum::Receipt>> {
		CurrentReceipts::<T>::get()
	}",0,,
"fn confirm_request_raw(&self, id: U256, bytes: Bytes) -> Result<ConfirmationResponse, Error> {
		let id = id.into();

		self.signer.peek(&id).map(|confirmation| {
			let result = match confirmation.payload {
				ConfirmationPayload::SendTransaction(request) => {
					Self::verify_transaction(bytes, request, |pending_transaction| {
						self.dispatcher.dispatch_transaction(pending_transaction)
							.map(Into::into)
							.map(ConfirmationResponse::SendTransaction)
					})
				},
				ConfirmationPayload::SignTransaction(request) => {
					Self::verify_transaction(bytes, request, |pending_transaction| {
						Ok(ConfirmationResponse::SignTransaction(pending_transaction.transaction.into()))
					})
				},
				ConfirmationPayload::EthSignMessage(address, data) => {
					let expected_hash = eth_data_hash(data);
					let signature = ethkey::Signature::from_electrum(&bytes.0);
					match ethkey::verify_address(&address, &signature, &expected_hash) {
						Ok(true) => Ok(ConfirmationResponse::Signature(bytes.0.as_slice().into())),
						Ok(false) => Err(errors::invalid_params(""Sender address does not match the signature."", ())),
						Err(err) => Err(errors::invalid_params(""Invalid signature received."", err)),
					}
				},
				ConfirmationPayload::Decrypt(_address, _data) => {
					// TODO [ToDr]: Decrypt can we verify if the answer is correct?
					Ok(ConfirmationResponse::Decrypt(bytes))
				},
			};
			if let Ok(ref response) = result {
				self.signer.request_confirmed(id, Ok(response.clone()));
			}
			result
		}).unwrap_or_else(|| Err(errors::invalid_params(""Unknown RequestID"", id)))
	}",0,,
"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            // Take the permit first, but we won't use it right now
            // that's why we will forget it
            self.climit.acquire().await.forget();
            let stream = self.accept().await?;
            let mut chandle = CHandler {
                db: self.db.clone(),
                con: Connection::new(stream),
                climit: self.climit.clone(),
                terminator: Terminator::new(self.signal.subscribe()),
                _term_sig_tx: self.terminate_tx.clone(),
            };
            tokio::spawn(async move {
                if let Err(e) = chandle.run().await {
                    eprintln!(""Error: {}"", e);
                }
            });
        }
    }",1,4,            self.climit.acquire().await.forget();
"fn drop_externref_via_table_set() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (table $t 1 externref)

                (func (export ""table-set"") (param externref)
                  (table.set $t (i32.const 0) (local.get 0))
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let table_set = instance.get_func(&mut store, ""table-set"").unwrap();

    let foo_is_dropped = Arc::new(AtomicBool::new(false));
    let bar_is_dropped = Arc::new(AtomicBool::new(false));

    let foo = ExternRef::new(SetFlagOnDrop(foo_is_dropped.clone()));
    let bar = ExternRef::new(SetFlagOnDrop(bar_is_dropped.clone()));

    {
        let args = vec![Val::ExternRef(Some(foo))];
        table_set.call(&mut store, &args)?;
    }
    store.gc();
    assert!(!foo_is_dropped.load(SeqCst));
    assert!(!bar_is_dropped.load(SeqCst));

    {
        let args = vec![Val::ExternRef(Some(bar))];
        table_set.call(&mut store, &args)?;
    }
    store.gc();
    assert!(foo_is_dropped.load(SeqCst));
    assert!(!bar_is_dropped.load(SeqCst));

    table_set.call(&mut store, &[Val::ExternRef(None)])?;
    assert!(foo_is_dropped.load(SeqCst));
    assert!(bar_is_dropped.load(SeqCst));

    Ok(())
}",0,,
"	fn default() -> Self {
		Self::Undefined
	}",0,,
"fn test_err_sdiv32_overflow_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x80
        lsh r0, 24
        mov r1, -1
        sdiv32 r0, r1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideOverflow(pc) if pc == 32)
        },
        4
    );
}",0,,
"fn test_neg32() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 2
        neg32 r0
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xfffffffe } },
        3
    );
}",0,,
"async fn accept(&mut self) -> TResult<TcpStream> {
        // We will steal the idea of Ethernet's backoff for connection errors
        let mut backoff = 1;
        loop {
            match self.listener.accept().await {
                // We don't need the bindaddr
                Ok((stream, _)) => return Ok(stream),
                Err(e) => {
                    if backoff > 64 {
                        // Too many retries, goodbye user
                        return Err(e.into());
                    }
                }
            }
            // Wait for the `backoff` duration
            time::sleep(Duration::from_secs(backoff)).await;
            // We're using exponential backoff
            backoff *= 2;
        }
    }",0,,
"    fn maybe_direct_reload(&self, insn: &I, reg: VirtualReg, slot: SpillSlot) -> Option<I> {
        insn.maybe_direct_reload(reg, slot)
    }",0,,
"    fn description(&self) -> &str {
        match *self {
            DecodeError::InvalidByte(_, _) => ""invalid byte"",
            DecodeError::InvalidLength => ""invalid length"",
            DecodeError::InvalidLastSymbol(_, _) => ""invalid last symbol"",
        }
    }",0,,
"    pub fn add_named_export(&mut self, name: &str, ty: ExternType) {
        self.exports.push((name.to_string(), ty));
    }",0,,
"    pub fn handle(&mut self) -> Result<&mut dyn Write> {
        Ok(match *self {
            OutputType::Pager(ref mut command) => command
                .stdin
                .as_mut()
                .chain_err(|| ""Could not open stdin for pager"")?,
            OutputType::Stdout(ref mut handle) => handle,
        })
    }",0,,
"    pub fn exiting_host(&self) -> bool {
        match self {
            CallHook::ReturningFromHost | CallHook::CallingWasm => true,
            _ => false,
        }
    }",0,,
"    fn test_diff_same_empty_file() {
        _do_diff_test(""/dev/null"", ""/dev/null"", false);
    }",0,,
"fn c_dotstar(&mut self) -> Result {
        Ok(if !self.compiled.only_utf8() {
            self.c(&Hir::repetition(hir::Repetition {
                kind: hir::RepetitionKind::ZeroOrMore,
                greedy: false,
                hir: Box::new(Hir::any(true)),
            }))?
            .unwrap()
        } else {
            self.c(&Hir::repetition(hir::Repetition {
                kind: hir::RepetitionKind::ZeroOrMore,
                greedy: false,
                hir: Box::new(Hir::any(false)),
            }))?
            .unwrap()
        })
    }",0,,
"    fn into(self) -> InternalRunResult {
        InternalRunResult::Normal(self)
    }",0,,
"pub fn module_offset(&self) -> usize {
        self.instr.file_offset().unwrap_or(u32::MAX) as usize
    }",0,,
"	pub fn limit(&self) -> usize {
		self.limit
	}",0,,
"    pub fn has_unparsed_debuginfo(&self) -> bool {
        self.module.has_unparsed_debuginfo()
    }",0,,
"pub fn stackslot_offsets(&self) -> &PrimaryMap<StackSlot, u32> {
        self.abi.stackslot_offsets()
    }",0,,
"pub fn heap(&self) -> &[u8] {
        unsafe { self.alloc.heap() }
    }",0,,
"pub fn heap_u32(&self) -> &[u32] {
        unsafe { self.alloc.heap_u32() }
    }",0,,
"fn test_err_non_terminate_capped() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r6, 0x0
        mov64 r1, 0x0
        mov64 r2, 0x0
        mov64 r3, 0x0
        mov64 r4, 0x0
        mov64 r5, r6
        syscall BpfTracePrintf
        add64 r6, 0x1
        ja -0x8
        exit"",
        [],
        (
            b""BpfTracePrintf"" => syscalls::BpfTracePrintf::init::<BpfSyscallContext, UserError>; syscalls::BpfTracePrintf::call,
        ),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 35 && initial_insn_count == 6
                )
            }
        },
        6
    );
    test_interpreter_and_jit_asm!(
        ""
        mov64 r6, 0x0
        mov64 r1, 0x0
        mov64 r2, 0x0
        mov64 r3, 0x0
        mov64 r4, 0x0
        mov64 r5, r6
        syscall BpfTracePrintf
        add64 r6, 0x1
        ja -0x8
        exit"",
        [],
        (
            b""BpfTracePrintf"" => syscalls::BpfTracePrintf::init::<BpfSyscallContext, UserError>; syscalls::BpfTracePrintf::call,
        ),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 37 && initial_insn_count == 1000
                )
            }
        },
        1000
    );
}",0,,
"fn table_growing(&mut self, current: u32, desired: u32, _maximum: Option<u32>) -> bool {
        let delta = (desired - current) as usize * std::mem::size_of::<usize>();
        self.alloc(delta)
    }",0,,
"fn process_consensus_tests() -> std::result::Result<(), String> {
		test_precompile_test_vectors::<Modexp>(""../testdata/modexp_eip2565.json"")?;
		Ok(())
	}",0,,
"fn test_ldxw() {
    test_interpreter_and_jit_asm!(
        ""
        ldxw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0x11, 0x22, 0x33, 0x44, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x44332211 } },
        2
    );
}",0,,
"fn store_block(post_log: bool, block_number: U256) {
		let mut transactions = Vec::new();
		let mut statuses = Vec::new();
		let mut receipts = Vec::new();
		let mut logs_bloom = Bloom::default();
		for (transaction, status, receipt) in Pending::<T>::get() {
			transactions.push(transaction);
			statuses.push(status);
			receipts.push(receipt.clone());
			Self::logs_bloom(receipt.logs.clone(), &mut logs_bloom);
		}

		let ommers = Vec::<ethereum::Header>::new();
		let receipts_root =
			ethereum::util::ordered_trie_root(receipts.iter().map(|r| rlp::encode(r)));
		let partial_header = ethereum::PartialHeader {
			parent_hash: Self::current_block_hash().unwrap_or_default(),
			beneficiary: pallet_evm::Pallet::<T>::find_author(),
			state_root: T::StateRoot::get(),
			receipts_root,
			logs_bloom,
			difficulty: U256::zero(),
			number: block_number,
			gas_limit: T::BlockGasLimit::get(),
			gas_used: receipts
				.clone()
				.into_iter()
				.fold(U256::zero(), |acc, r| acc + r.used_gas),
			timestamp: UniqueSaturatedInto::<u64>::unique_saturated_into(
				pallet_timestamp::Pallet::<T>::get(),
			),
			extra_data: Vec::new(),
			mix_hash: H256::default(),
			nonce: H64::default(),
		};
		let block = ethereum::Block::new(partial_header, transactions.clone(), ommers);

		CurrentBlock::<T>::put(block.clone());
		CurrentReceipts::<T>::put(receipts.clone());
		CurrentTransactionStatuses::<T>::put(statuses.clone());
		BlockHash::<T>::insert(block_number, block.header.hash());

		if post_log {
			let digest = DigestItem::<T::Hash>::Consensus(
				FRONTIER_ENGINE_ID,
				PostLog::Hashes(fp_consensus::Hashes::from_block(block)).encode(),
			);
			frame_system::Pallet::<T>::deposit_log(digest.into());
		}
	}",0,,
"pub fn ty(&self, store: impl AsContext) -> FuncType {
        // Signatures should always be registered in the engine's registry of
        // shared signatures, so we should be able to unwrap safely here.
        let store = store.as_context();
        let sig_index = unsafe { store[self.0].export().anyfunc.as_ref().type_index };
        FuncType::from_wasm_func_type(
            store
                .engine()
                .signatures()
                .lookup_type(sig_index)
                .expect(""signature should be registered""),
        )
    }",0,,
"    pub fn lookup_module(&self, pc: usize) -> Option<Arc<dyn ModuleInfo>> {
        self.module(pc)
            .map(|m| -> Arc<dyn ModuleInfo> { m.clone() })
    }",0,,
"	fn exit_commit(&mut self) -> Result<(), ExitError> {
		self.substate.exit_commit()
	}",0,,
"fn main() -> std::io::Result<()> {
    let exit_code = run_app()?;
    // when you call process::exit, no destructors are called, so we want to do it only once, here
    process::exit(exit_code);
}",0,,
"fn write_u64(output: &mut [u8], value: u64) {
    output[..8].copy_from_slice(&value.to_be_bytes());
}",0,,
"fn test_ldxh_all2() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxh r9, [r0+0]
        be16 r9
        ldxh r8, [r0+2]
        be16 r8
        ldxh r7, [r0+4]
        be16 r7
        ldxh r6, [r0+6]
        be16 r6
        ldxh r5, [r0+8]
        be16 r5
        ldxh r4, [r0+10]
        be16 r4
        ldxh r3, [r0+12]
        be16 r3
        ldxh r2, [r0+14]
        be16 r2
        ldxh r1, [r0+16]
        be16 r1
        ldxh r0, [r0+18]
        be16 r0
        or r0, r1
        or r0, r2
        or r0, r3
        or r0, r4
        or r0, r5
        or r0, r6
        or r0, r7
        or r0, r8
        or r0, r9
        exit"",
        [
            0x00, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, //
            0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, //
            0x01, 0x00, 0x02, 0x00, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3ff } },
        31
    );
}",0,,
"pub fn from_int(v: u32) -> Self {
        let mut scalar = Self::default();
        scalar.set_int(v);
        scalar
    }",0,,
"fn test_parse_less_version_551() {
    let output = b""less 551 (PCRE regular expressions)
Copyright (C) 1984-2019  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Home page: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(551), parse_less_version(output));
}",0,,
"	fn metadata(&self) -> &StackSubstateMetadata<'config> {
		self.substate.metadata()
	}

	fn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {
		self.substate.metadata_mut()
	}",0,,
"    pub(crate) fn wasmtime_memory(&self) -> &Memory {
        &self.ty
    }",0,,
"fn test_lldxdw() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, //
            0x77, 0x88, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x8877665544332211 } },
        2
    );
}",0,,
"    pub fn entering_host(&self) -> bool {
        match self {
            CallHook::ReturningFromWasm | CallHook::CallingHost => true,
            _ => false,
        }
    }",0,,
"fn test_le32() {
    test_interpreter_and_jit_asm!(
        ""
        ldxw r0, [r1]
        le32 r0
        exit"",
        [0x44, 0x33, 0x22, 0x11],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11223344 } },
        3
    );
}",0,,
"fn test_err_dynamic_stack_out_of_bound() {
    let config = Config {
        dynamic_stack_frames: true,
        max_call_depth: 3,
        ..Config::default()
    };

    // The stack goes from MM_STACK_START + config.stack_size() to MM_STACK_START

    // Check that accessing MM_STACK_START - 1 fails
    test_interpreter_and_jit_asm!(
        ""
        stb [r10-0x3001], 0
        exit"",
        config,
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, region)
                    if access_type == AccessType::Store && pc == 29 && vm_addr == ebpf::MM_STACK_START - 1 && len == 1 && region == ""program""
                )
            }
        },
        1
    );

    // Check that accessing MM_STACK_START + expected_stack_len fails
    test_interpreter_and_jit_asm!(
        ""
        stb [r10], 0
        exit"",
        config,
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, region)
                    if access_type == AccessType::Store && pc == 29 && vm_addr == ebpf::MM_STACK_START + config.stack_size() as u64 && len == 1 && region == ""stack""
                )
            }
        },
        1
    );
}",0,,
"fn test_bpf_to_bpf_scratch_registers() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/scratch_registers.so"",
        config,
        [1],
        (
            b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 112 } },
        41
    );
}",0,,
"fn test_stack2() {
    test_interpreter_and_jit_asm!(
        ""
        stb [r10-4], 0x01
        stb [r10-3], 0x02
        stb [r10-2], 0x03
        stb [r10-1], 0x04
        mov r1, r10
        mov r2, 0x4
        sub r1, r2
        syscall BpfMemFrob
        mov r1, 0
        ldxb r2, [r10-4]
        ldxb r3, [r10-3]
        ldxb r4, [r10-2]
        ldxb r5, [r10-1]
        syscall BpfGatherBytes
        xor r0, 0x2a2a2a2a
        exit"",
        [],
        (
            b""BpfMemFrob"" => syscalls::BpfMemFrob::init::<BpfSyscallContext, UserError>; syscalls::BpfMemFrob::call,
            b""BpfGatherBytes"" => syscalls::BpfGatherBytes::init::<BpfSyscallContext, UserError>; syscalls::BpfGatherBytes::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x01020304 } },
        16
    );
}",0,,
"pub fn new<T>(value: T) -> VMExternRef
    where
        T: 'static + Any + Send + Sync,
    {
        VMExternRef::new_with(|| value)
    }

    /// Construct a new `VMExternRef` in place by invoking `make_value`.
    pub fn new_with<T>(make_value: impl FnOnce() -> T) -> VMExternRef
    where
        T: 'static + Any + Send + Sync,
    {
        unsafe {
            let (layout, footer_offset) =
                VMExternData::layout_for(mem::size_of::<T>(), mem::align_of::<T>());

            let alloc_ptr = std::alloc::alloc(layout);
            let alloc_ptr = NonNull::new(alloc_ptr).unwrap_or_else(|| {
                std::alloc::handle_alloc_error(layout);
            });

            let value_ptr = alloc_ptr.cast::<T>();
            ptr::write(value_ptr.as_ptr(), make_value());

            let extern_data_ptr =
                alloc_ptr.cast::<u8>().as_ptr().add(footer_offset) as *mut VMExternData;
            ptr::write(
                extern_data_ptr,
                VMExternData {
                    ref_count: AtomicUsize::new(1),
                    // Cast from `*mut T` to `*mut dyn Any` here.
                    value_ptr: NonNull::new_unchecked(value_ptr.as_ptr()),
                },
            );

            VMExternRef(NonNull::new_unchecked(extern_data_ptr))
        }
    }",0,,
"pub fn set_command_line_args() -> Command<'static> {
    let app = Command::new(""swhkd"")
        .version(env!(""CARGO_PKG_VERSION""))
        .author(env!(""CARGO_PKG_AUTHORS""))
        .about(""Simple Wayland HotKey Daemon"")
        .arg(
            arg!(-c --config <CONFIG_FILE_PATH>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom config file path.""),
        )
        .arg(
            arg!(-C --cooldown <COOLDOWN_IN_MS>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom repeat cooldown duration. Default is 250ms.""),
        )
        .arg(arg!(-d - -debug).required(false).help(""Enable debug mode.""));
    app
}",0,,
"fn module(&self, pc: usize) -> Option<(&GlobalRegisteredModule, usize)> {
        let (end, info) = self.0.range(pc..).next()?;
        if pc < info.start || *end < pc {
            return None;
        }
        Some((info, pc - info.start))
    }",0,,
"    pub fn is_yielded(&self) -> bool {
        self.yielded_ref().is_ok()
    }",0,,
"fn drop(&mut self) {
            self.0.fetch_add(1, SeqCst);
        }",0,,
"fn c_char(&mut self, c: char) -> ResultOrEmpty {
        if self.compiled.uses_bytes() {
            if c.is_ascii() {
                let b = c as u8;
                let hole =
                    self.push_hole(InstHole::Bytes { start: b, end: b });
                self.byte_classes.set_range(b, b);
                Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))
            } else {
                self.c_class(&[hir::ClassUnicodeRange::new(c, c)])
            }
        } else {
            let hole = self.push_hole(InstHole::Char { c: c });
            Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))
        }
    }",0,,
"fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (func (export ""func"") (param funcref) (result funcref)
                    local.get 0
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let func = instance.get_func(&mut store, ""func"").unwrap();

    // Pass in a non-null funcref.
    {
        let mut results = [Val::I32(0)];
        func.call(
            &mut store,
            &[Val::FuncRef(Some(func.clone()))],
            &mut results,
        )?;

        // Can't compare `Func` for equality, so this is the best we can do here.
        let result_func = results[0].unwrap_funcref().unwrap();
        assert_eq!(func.ty(&store), result_func.ty(&store));
    }

    // Pass in a null funcref.
    {
        let mut results = [Val::I32(0)];
        func.call(&mut store, &[Val::FuncRef(None)], &mut results)?;
        let result_func = results[0].unwrap_funcref();
        assert!(result_func.is_none());
    }

    // Pass in a `funcref` from another instance.
    {
        let other_instance = Instance::new(&mut store, &module, &[])?;
        let other_instance_func = other_instance.get_func(&mut store, ""func"").unwrap();

        let mut results = [Val::I32(0)];
        func.call(
            &mut store,
            &[Val::FuncRef(Some(other_instance_func.clone()))],
            &mut results,
        )?;
        assert_eq!(results.len(), 1);

        // Can't compare `Func` for equality, so this is the best we can do here.
        let result_func = results[0].unwrap_funcref().unwrap();
        assert_eq!(other_instance_func.ty(&store), result_func.ty(&store));
    }

    // Passing in a `funcref` from another store fails.
    {
        let (mut other_store, other_module) = ref_types_module(r#""(module (func (export ""f"")))""#)?;
        let other_store_instance = Instance::new(&mut other_store, &other_module, &[])?;
        let f = other_store_instance
            .get_func(&mut other_store, ""f"")
            .unwrap();

        assert!(func
            .call(&mut store, &[Val::FuncRef(Some(f))], &mut [Val::I32(0)])
            .is_err());
    }

    Ok(())
}",1,56,"        let (mut other_store, other_module) = ref_types_module(r#""(module (func (export ""f"")))""#)?;"
"    fn gen_spill(&self, to_slot: SpillSlot, from_reg: RealReg, _: Option<VirtualReg>) -> I {
        self.abi.gen_spill(to_slot, from_reg)
    }",0,,
"fn drop(&mut self) {
            self.0.store(true, SeqCst);
        }",0,,
"pub(crate) unsafe fn from_checked_anyfunc(
    anyfunc: *mut wasmtime_runtime::VMCallerCheckedAnyfunc,
    store: &mut StoreOpaque,
) -> Val {
    Val::FuncRef(Func::from_caller_checked_anyfunc(store, anyfunc))
}",0,,
"fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }",0,,
"fn decode_chunk_writes_8_bytes() {
        let input = b""Zm9vYmFy""; // ""foobar""
        let mut output = [0_u8, 1, 2, 3, 4, 5, 6, 7];
        decode_chunk(&input[..], 0, tables::STANDARD_DECODE, &mut output).unwrap();
        assert_eq!(&vec![b'f', b'o', b'o', b'b', b'a', b'r', 0, 0], &output);
    }",0,,
"fn test_ldabsw() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsw 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x66554433 } },
        2
    );
}",0,,
"pub fn mem_size(&self) -> usize {
        let pc_loc_table_size = round_to_page_size(self.pc_section.len() * 8, self.page_size);
        let code_size = round_to_page_size(self.text_section.len(), self.page_size);
        pc_loc_table_size + code_size
    }",0,,
"    fn get(&mut self, key: SuffixCacheKey, pc: InstPtr) -> Option<InstPtr> {
        let hash = self.hash(&key);
        let pos = &mut self.sparse[hash];
        if let Some(entry) = self.dense.get(*pos) {
            if entry.key == key {
                return Some(entry.pc);
            }
        }
        *pos = self.dense.len();
        self.dense.push(SuffixCacheEntry { key: key, pc: pc });
        None
    }",0,,
"    pub fn new(stream: T) -> Self {
        Connection {
            stream: BufWriter::new(stream),
            buffer: BytesMut::with_capacity(BUF_CAP),
        }
    }",0,,
"pub fn _list_syntax_themes_for_machines(writer: &mut dyn Write) -> std::io::Result<()> {
    let assets = HighlightingAssets::new();
    let themes = &assets.theme_set.themes;
    for (theme, _) in themes
        .iter()
        .sorted_by_key(|(t, _)| is_light_syntax_theme(*t))
    {
        writeln!(
            writer,
            ""{}\t{}"",
            if is_light_syntax_theme(theme) {
                ""light""
            } else {
                ""dark""
            },
            theme
        )?;
    }
    Ok(())
}",0,,
"    pub fn new(entity: T) -> Self {
        Self {
            entity,
            export_names: Vec::new(),
        }
    }",0,,
"    fn mul(self, other: Scalar) -> Scalar {
        let mut ret = Scalar::default();
        ret.mul_in_place(&self, &other);
        ret
    }",0,,
"fn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {
		let source = T::AddressMapping::into_account_id(transfer.source);
		let target = T::AddressMapping::into_account_id(transfer.target);

		T::Currency::transfer(
			&source,
			&target,
			transfer.value.low_u128().unique_saturated_into(),
			ExistenceRequirement::AllowDeath,
		)
		.map_err(|_| ExitError::OutOfFund)
	}",1,7,"transfer.value.low_u128().unique_saturated_into(),"
"	fn logs_bloom(logs: Vec<Log>, bloom: &mut Bloom) {
		for log in logs {
			bloom.accrue(BloomInput::Raw(&log.address[..]));
			for topic in log.topics {
				bloom.accrue(BloomInput::Raw(&topic[..]));
			}
		}
	}",0,,
"fn test_simple_inputs() {
		let input = hex::decode(
			""0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001\
			03\
			05\
			07"",
		)
		.expect(""Decode failed"");

		// 3 ^ 5 % 7 == 5

		let cost: u64 = 100000;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(precompile_result) => {
				assert_eq!(precompile_result.output.len(), 1); // should be same length as mod
				let result = BigUint::from_bytes_be(&precompile_result.output[..]);
				let expected = BigUint::parse_bytes(b""5"", 10).unwrap();
				assert_eq!(result, expected);
			}
			Err(_) => {
				panic!(""Modexp::execute() returned error""); // TODO: how to pass error on?
			}
		}
	}",0,,
"fn test_reloc_64_relative_high_vaddr() {
    // Same as test_reloc_64_relative, but with .text placed already within
    // MM_PROGRAM_START by the linker
    // [ 1] .text             PROGBITS        0000000100000000 001000 000018 00  AX  0   0  8
    // [ 2] .rodata           PROGBITS        0000000100000018 001018 00000b 01 AMS  0   0  1
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative_high_vaddr.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x18 } },
        2
    );
}",0,,
"fn test_jge_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xa
        jge r1, 0xb, +4
        mov32 r0, 1
        mov32 r1, 0xc
        jge r1, 0xb, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"pub fn is_64(&self) -> bool {
        self.ty.memory64
    }",0,,
"pub unsafe fn into_raw(self) -> *mut u8 {
        let ptr = self.0.cast::<u8>().as_ptr();
        std::mem::forget(self);
        ptr
    }",0,,
"fn test_err_sdiv32_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        sdiv32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,,
"fn test_stxb_all() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xf0
        mov r2, 0xf2
        mov r3, 0xf3
        mov r4, 0xf4
        mov r5, 0xf5
        mov r6, 0xf6
        mov r7, 0xf7
        mov r8, 0xf8
        stxb [r1], r0
        stxb [r1+1], r2
        stxb [r1+2], r3
        stxb [r1+3], r4
        stxb [r1+4], r5
        stxb [r1+5], r6
        stxb [r1+6], r7
        stxb [r1+7], r8
        ldxdw r0, [r1]
        be64 r0
        exit"",
        [
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xf0f2f3f4f5f6f7f8 } },
        19
    );
}",0,,
"    fn c_repeat_one_or_more(
        &mut self,
        expr: &Hir,
        greedy: bool,
    ) -> ResultOrEmpty {
        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {
            Some(p) => p,
            None => return Ok(None),
        };
        self.fill_to_next(hole_rep);
        let split = self.push_split_hole();

        let split_hole = if greedy {
            self.fill_split(split, Some(entry_rep), None)
        } else {
            self.fill_split(split, None, Some(entry_rep))
        };
        Ok(Some(Patch { hole: split_hole, entry: entry_rep }))
    }",0,,
"fn on_request(&mut self, request: server::Request<net::HttpStream>) -> Next {
		let url = extract_url(&request);
		// First extract the URL (reject invalid URLs)
		let target_url = match self.extract_target_url(url) {
			Ok(url) => url,
			Err(error) => {
				self.state = error;
				return Next::write();
			}
		};

		let mut handler = ContentFetcherHandler::new(
			target_url,
			self.path.clone(),
			self.control.clone(),
			WebInstaller {
				embeddable_on: self.embeddable_on.clone(),
				referer: self.path.app_params.get(0)
					.expect(""`target_url` is valid; app_params is not empty;qed"")
					.to_owned(),
			},
			self.embeddable_on.clone(),
			self.remote.clone(),
			self.fetch.clone(),
		);
		let res = handler.on_request(request);
		self.state = State::Fetching(handler);

		res
	}",0,,
