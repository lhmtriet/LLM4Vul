processed_func,target,flaw_line_index,flaw_line
"pub fn heap_mut(&mut self) -> &mut [u8] {
        unsafe { self.alloc.heap_mut() }
    }",0,,
"fn call(&self, address: Address, data: Bytes) -> BoxFuture<Bytes, String> {
		let (header, env_info) = (self.client.best_block_header(), self.client.latest_env_info());

		let maybe_future = self.sync.with_context(move |ctx| {
			self.on_demand
				.request(ctx, on_demand::request::TransactionProof {
					tx: Transaction {
						nonce: self.client.engine().account_start_nonce(),
						action: Action::Call(address),
						gas: 50_000_000.into(),
						gas_price: 0.into(),
						value: 0.into(),
						data: data,
					}.fake_sign(Address::default()),
					header: header.into(),
					env_info: env_info,
					engine: self.client.engine().clone(),
				})
				.expect(""No back-references; therefore all back-refs valid; qed"")
				.then(|res| match res {
					Ok(Ok(executed)) => Ok(executed.output),
					Ok(Err(e)) => Err(format!(""Failed to execute transaction: {}"", e)),
					Err(_) => Err(format!(""On-demand service dropped request unexpectedly."")),
				})
		});

		match maybe_future {
			Some(fut) => fut.boxed(),
			None => future::err(""cannot query registry: network disabled"".into()).boxed(),
		}
	}",0,,
"    pub(crate) fn span(&self) -> Span {
        self.tokens
            .first()
            .map(|&(_, span)| span)
            .unwrap_or_else(|| (self.source.len()..self.source.len()).into())
    }",0,,
"	pub fn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {
		CurrentTransactionStatuses::<T>::get()
	}",0,,
"pub(crate) fn tokenize(mut input: &str) -> Vec<(Token, Span)> {
    let mut result = vec![];
    let mut offset = 0;

    loop {
        let input_len = input.len();
        input = input.trim_start();
        while input.starts_with('#') {
            input = input.trim_start_matches(|c| c != '\n').trim_start();
        }
        offset += input_len - input.len();

        match input.chars().next() {
            None => break,
            Some(c) => {
                let (len, token) = consume_chain! {
                    input, c;

                    if input.starts_with(""<%"") => (2, Token::BStart);
                    if input.starts_with(""%>"") => (2, Token::BEnd);
                    if input.starts_with("">>"") => (2, Token::LookAhead);
                    if input.starts_with(""<<"") => (2, Token::LookBehind);
                    if input.starts_with(""::"") => (2, Token::Backref);

                    if c == '%' => (1, Token::BWord);
                    if c == '*' => (1, Token::Star);
                    if c == '+' => (1, Token::Plus);
                    if c == '?' => (1, Token::QuestionMark);
                    if c == '|' => (1, Token::Pipe);
                    if c == ':' => (1, Token::Colon);
                    if c == ')' => (1, Token::CloseParen);
                    if c == '{' => (1, Token::OpenBrace);
                    if c == '}' => (1, Token::CloseBrace);
                    if c == ',' => (1, Token::Comma);
                    if c == '!' => (1, Token::Not);
                    if c == '[' => (1, Token::OpenBracket);
                    if c == '-' => (1, Token::Dash);
                    if c == ']' => (1, Token::CloseBracket);
                    if c == '.' => (1, Token::Dot);
                    if c == ';' => (1, Token::Semicolon);
                    if c == '=' => (1, Token::Equals);

                    if c == '\'' => match input[1..].find('\'') {
                        Some(len_inner) => (len_inner + 2, Token::String),
                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),
                    };

                    if c == '""' => match find_unescaped_quote(&input[1..]) {
                        Some(len_inner) => (len_inner + 2, Token::String),
                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),
                    };

                    if let Some(rest) = input.strip_prefix(""U+"") => {
                        match rest.find(|c: char| !c.is_ascii_hexdigit()) {
                            Some(0) => (1, Token::Error),
                            Some(len_inner) => (len_inner + 2, Token::CodePoint),
                            None => (input.len(), Token::CodePoint),
                        }
                    };

                    if matches!(c, '0'..='9') => (
                        input.find(|c: char| !matches!(c, '0'..='9')).unwrap_or(input.len()),
                        Token::Number,
                    );

                    if c.is_alphabetic() || c == '_' => (
                        input.find(|c: char| !c.is_alphanumeric() && c != '_').unwrap_or(input.len()),
                        Token::Identifier,
                    );

                    if c == '^' => (1, Token::ErrorMsg(ParseErrorMsg::Caret));
                    if c == '$' => (1, Token::ErrorMsg(ParseErrorMsg::Dollar));

                    if let Some(rest) = input.strip_prefix(""(?"") => (
                        match rest.chars().next() {
                            Some('<') => {
                                let name_len = rest.chars()
                                    .skip(1)
                                    .take_while(char::is_ascii_alphanumeric)
                                    .count();

                                if name_len > 0 && matches!(rest.chars().nth(1 + name_len), Some('>')) {
                                    4 + name_len
                                } else if let Some('=' | '!') = rest.chars().nth(1) {
                                    4
                                } else {
                                    3
                                }
                            }
                            Some('P') if matches!(rest.chars().nth(1), Some('<')) => {
                                let name_len = rest.chars()
                                    .skip(2)
                                    .take_while(char::is_ascii_alphanumeric)
                                    .count();

                                if name_len > 0 && matches!(rest.chars().nth(2 + name_len), Some('>')) {
                                    5 + name_len
                                } else {
                                    4
                                }
                            },
                            Some('>' | '!' | ':' | '=' | '(' | '|') => 3,
                            _ => 2,
                        },
                        Token::ErrorMsg(ParseErrorMsg::SpecialGroup),
                    );
                    if c == '(' => (1, Token::OpenParen);

                    if c == '\\' => {
                        if input.starts_with(""\\u{"") || input.starts_with(""\\x{"") {
                            match input[3..].find('}') {
                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashUnicode)),
                                None => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\u"") {
                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {
                                4.. => (6, Token::ErrorMsg(ParseErrorMsg::BackslashU4)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\x"") {
                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {
                                2.. => (4, Token::ErrorMsg(ParseErrorMsg::BackslashX2)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\k<"") {
                            match rest.find('>') {
                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashK)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if input.len() >= 2 {
                            (2, Token::ErrorMsg(ParseErrorMsg::Backslash))
                        } else {
                            (1, Token::Error)
                        }
                    };
                };

                let start = offset;
                offset += len;
                input = &input[len..];
                result.push((token, Span::new(start, offset)));
            }
        }
    }

    result
}",1,"129,130","} else if input.len() >= 2 {/~/                            (2, Token::ErrorMsg(ParseErrorMsg::Backslash))"
"fn main() {
    benchtool::runner();
}",1,2,}
"fn many_live_refs() -> anyhow::Result<()> {
    let mut wat = r#""
        (module
            ;; Make new `externref`s.
            (import """" ""make_ref"" (func $make_ref (result externref)))

            ;; Observe an `externref` so it is kept live.
            (import """" ""observe_ref"" (func $observe_ref (param externref)))

            (func (export ""many_live_refs"")
    ""#
    .to_string();

    
    
    const NUM_LIVE_REFS: usize = 1024;

    
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $make_ref)\n"");
    }

    
    
    
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $observe_ref)\n"");
    }

    wat.push_str(
        ""
            ) ;; func
        ) ;; module
        "",
    );

    let (mut store, module) = ref_types_module(&wat)?;

    let live_refs = Arc::new(AtomicUsize::new(0));

    let make_ref = Func::wrap(&mut store, {
        let live_refs = live_refs.clone();
        move || Some(ExternRef::new(CountLiveRefs::new(live_refs.clone())))
    });

    let observe_ref = Func::wrap(&mut store, |r: Option<ExternRef>| {
        let r = r.unwrap();
        let r = r.data().downcast_ref::<CountLiveRefs>().unwrap();
        assert!(r.live_refs.load(SeqCst) > 0);
    });

    let instance = Instance::new(&mut store, &module, &[make_ref.into(), observe_ref.into()])?;
    let many_live_refs = instance.get_func(&mut store, ""many_live_refs"").unwrap();

    many_live_refs.call(&mut store, &[], &mut [])?;

    store.gc();
    assert_eq!(live_refs.load(SeqCst), 0);

    return Ok(());

    struct CountLiveRefs {
        live_refs: Arc<AtomicUsize>,
    }

    impl CountLiveRefs {
        fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }
    }

    impl Drop for CountLiveRefs {
        fn drop(&mut self) {
            self.live_refs.fetch_sub(1, SeqCst);
        }
    }
}",1,36,"    let (mut store, module) = ref_types_module(&wat)?;"
"pub fn parse_program(program_str: &str) -> Result<ast::Program> {
    let stripped_string = &strip_comments(program_str);
    let parser = syntax::ProgramParser::new();
    match parser.parse(stripped_string) {
        Ok(program) => Ok(program),
        Err(e) => handle_error(e, program_str),
    }
}",1,"1,5","    let stripped_string = &strip_comments(program_str);/~/        Err(e) => handle_error(e, program_str),"
"fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (func (export ""func"") (param funcref) (result funcref)
                    local.get 0
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let func = instance.get_func(&mut store, ""func"").unwrap();

    
    {
        let mut results = [Val::I32(0)];
        func.call(
            &mut store,
            &[Val::FuncRef(Some(func.clone()))],
            &mut results,
        )?;

        
        let result_func = results[0].unwrap_funcref().unwrap();
        assert_eq!(func.ty(&store), result_func.ty(&store));
    }

    
    {
        let mut results = [Val::I32(0)];
        func.call(&mut store, &[Val::FuncRef(None)], &mut results)?;
        let result_func = results[0].unwrap_funcref();
        assert!(result_func.is_none());
    }

    
    {
        let other_instance = Instance::new(&mut store, &module, &[])?;
        let other_instance_func = other_instance.get_func(&mut store, ""func"").unwrap();

        let mut results = [Val::I32(0)];
        func.call(
            &mut store,
            &[Val::FuncRef(Some(other_instance_func.clone()))],
            &mut results,
        )?;
        assert_eq!(results.len(), 1);

        
        let result_func = results[0].unwrap_funcref().unwrap();
        assert_eq!(other_instance_func.ty(&store), result_func.ty(&store));
    }

    
    {
        let (mut other_store, other_module) = ref_types_module(r#""(module (func (export ""f"")))""#)?;
        let other_store_instance = Instance::new(&mut other_store, &other_module, &[])?;
        let f = other_store_instance
            .get_func(&mut other_store, ""f"")
            .unwrap();

        assert!(func
            .call(&mut store, &[Val::FuncRef(Some(f))], &mut [Val::I32(0)])
            .is_err());
    }

    Ok(())
}",1,56,"        let (mut other_store, other_module) = ref_types_module(r#""(module (func (export ""f"")))""#)?;"
"fn test_jlt_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 5
        jlt r1, 4, +2
        jlt r1, 5, +1
        jlt r1, 6, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = set_command_line_args().get_matches();
    env::set_var(""RUST_LOG"", ""swhkd=warn"");

    if args.is_present(""debug"") {
        env::set_var(""RUST_LOG"", ""swhkd=trace"");
    }

    env_logger::init();
    log::trace!(""Logger initialized."");

    let pidfile: String = String::from(""/tmp/swhkd.pid"");
    if Path::new(&pidfile).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pidfile);
        let swhkd_pid = match fs::read_to_string(&pidfile) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Swhkd is already running!"");
                log::error!(""pid of existing swhkd process: {}"", pid.to_string());
                log::error!(""To close the existing swhkd process, run `sudo killall swhkd`"");
                exit(1);
            }
        }
    }

    match fs::write(&pidfile, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pidfile, e);
            exit(1);
        }
    }

    if check_user_permissions().is_err() {
        exit(1);
    }

    let load_config = || {
        let config_file_path: std::path::PathBuf = if args.is_present(""config"") {
            Path::new(args.value_of(""config"").unwrap()).to_path_buf()
        } else {
            fetch_xdg_config_path()
        };

        log::debug!(""Using config file path: {:#?}"", config_file_path);

        if !config_file_path.exists() {
            log::error!(""{:#?} doesn't exist"", config_file_path);
            exit(1);
        }

        let hotkeys = match config::load(&config_file_path) {
            Err(e) => {
                log::error!(""Config Error: {}"", e);
                exit(1);
            }
            Ok(out) => out,
        };

        for hotkey in &hotkeys {
            log::debug!(""hotkey: {:#?}"", hotkey);
        }

        hotkeys
    };

    let mut hotkeys = load_config();

    log::trace!(""Attempting to find all keyboard file descriptors."");
    let keyboard_devices: Vec<Device> =
        evdev::enumerate().filter(check_device_is_keyboard).collect();

    let mut uinput_device = match uinput::create_uinput_device() {
        Ok(dev) => dev,
        Err(e) => {
            log::error!(""Err: {:#?}"", e);
            exit(1);
        }
    };

    if keyboard_devices.is_empty() {
        log::error!(""No valid keyboard device was detected!"");
        exit(1);
    }
    log::debug!(""{} Keyboard device(s) detected."", keyboard_devices.len());

    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTALT, config::Modifier::Alt),
        (Key::KEY_RIGHTALT, config::Modifier::Alt),
        (Key::KEY_LEFTCTRL, config::Modifier::Control),
        (Key::KEY_RIGHTCTRL, config::Modifier::Control),
        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),
        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),
    ]);

    let repeat_cooldown_duration: u64 = if args.is_present(""cooldown"") {
        args.value_of(""cooldown"").unwrap().parse::<u64>().unwrap()
    } else {
        250
    };

    let mut signals = Signals::new(&[
        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,
        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,
    ])?;

    let mut execution_is_paused = false;
    let mut last_hotkey: Option<config::Hotkey> = None;
    let mut pending_release: bool = false;
    let mut keyboard_states: Vec<KeyboardState> = Vec::new();
    let mut keyboard_stream_map = StreamMap::new();

    for (i, mut device) in keyboard_devices.into_iter().enumerate() {
        let _ = device.grab();
        keyboard_stream_map.insert(i, device.into_event_stream()?);
        keyboard_states.push(KeyboardState::new());
    }

    
    let hotkey_repeat_timer = sleep(Duration::from_millis(0));
    tokio::pin!(hotkey_repeat_timer);

    loop {
        select! {
            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {
                let hotkey = last_hotkey.clone().unwrap();
                if hotkey.keybinding.on_release {
                    continue;
                }
                send_command(hotkey.clone());
                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
            }

            Some(signal) = signals.next() => {
                match signal {
                    SIGUSR1 => {
                        execution_is_paused = true;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                    }

                    SIGUSR2 => {
                        execution_is_paused = false;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.grab();
                        }
                    }

                    SIGHUP => {
                        hotkeys = load_config();
                    }

                    SIGINT => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                        log::warn!(""Received SIGINT signal, exiting..."");
                        exit(1);
                    }

                    _ => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }

                        log::warn!(""Received signal: {:#?}"", signal);
                        log::warn!(""Exiting..."");
                        exit(1);
                    }
                }
            }

            Some((i, Ok(event))) = keyboard_stream_map.next() => {
                let keyboard_state = &mut keyboard_states[i];

                let key = match event.kind() {
                    InputEventKind::Key(keycode) => keycode,
                    _ => continue
                };

                match event.value() {
                    
                    1 => {
                        if let Some(modifier) = modifiers_map.get(&key) {
                            keyboard_state.state_modifiers.insert(*modifier);
                        } else {
                            keyboard_state.state_keysyms.insert(key);
                        }
                    }

                    
                    0 => {
                        if last_hotkey.is_some() && pending_release {
                            pending_release = false;
                            send_command(last_hotkey.clone().unwrap());
                            last_hotkey = None;
                        }
                        if let Some(modifier) = modifiers_map.get(&key) {
                            if let Some(hotkey) = &last_hotkey {
                                if hotkey.modifiers().contains(modifier) {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_modifiers.remove(modifier);
                        } else if keyboard_state.state_keysyms.contains(key) {
                            if let Some(hotkey) = &last_hotkey {
                                if key == hotkey.keysym() {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_keysyms.remove(key);
                        }
                    }

                    _ => {}
                }

                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()
                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())
                    .collect();

                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {
                    hotkey.keysym().code() == event.code() &&
                    keyboard_state.state_modifiers
                        .iter()
                        .all(|x| hotkey.modifiers().contains(x)) &&
                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                    && !hotkey.is_send()
                        });

                
                if !event_in_hotkeys {
                    uinput_device.emit(&[event]).unwrap();
                }

                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {
                    continue;
                }

                log::debug!(""state_modifiers: {:#?}"", keyboard_state.state_modifiers);
                log::debug!(""state_keysyms: {:#?}"", keyboard_state.state_keysyms);
                log::debug!(""hotkey: {:#?}"", possible_hotkeys);

                for hotkey in possible_hotkeys {
                    
                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))
                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                        && keyboard_state.state_keysyms.contains(hotkey.keysym())
                    {
                        last_hotkey = Some(hotkey.clone());
                        if pending_release { break; }
                        if hotkey.is_on_release() {
                            pending_release = true;
                            break;
                        }
                        send_command(hotkey.clone());
                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
                        break;
                    }
                }
            }
        }
    }
}",1,77,
"    pub fn new(
        params: impl IntoIterator<Item = ValType>,
        results: impl IntoIterator<Item = ValType>,
    ) -> FuncType {
        FuncType {
            sig: WasmFuncType {
                params: params.into_iter().map(|t| t.to_wasm_type()).collect(),
                returns: results.into_iter().map(|t| t.to_wasm_type()).collect(),
            },
        }
    }",1,"5,6,7,8","            sig: WasmFuncType {/~/                params: params.into_iter().map(|t| t.to_wasm_type()).collect(),/~/                returns: results.into_iter().map(|t| t.to_wasm_type()).collect(),/~/            },"
"fn test_tight_infinite_loop_conditional() {
    test_interpreter_and_jit_asm!(
        ""
        jsge r0, r0, -1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 30 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,,
"    pub fn reset(&mut self) -> Result<(), Error> {
        self.alloc.reset_heap(self.module.as_ref())?;
        let globals = unsafe { self.alloc.globals_mut() };
        let mod_globals = self.module.globals();
        for (i, v) in mod_globals.iter().enumerate() {
            globals[i] = match v.global() {
                Global::Import { .. } => {
                    return Err(Error::Unsupported(format!(
                        ""global imports are unsupported; found: {:?}"",
                        v
                    )));
                }
                Global::Def(def) => def.init_val(),
            };
        }

        if self.module.get_start_func()?.is_some() {
            self.state = State::NotStarted;
        } else {
            self.state = State::Ready;
        }

        #[cfg(feature = ""concurrent_testpoints"")]
        {
            self.kill_state = Arc::new(KillState::new(Arc::clone(&self.lock_testpoints)));
        }
        #[cfg(not(feature = ""concurrent_testpoints""))]
        {
            self.kill_state = Arc::new(KillState::new());
        }

        Ok(())
    }",0,,
"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            
            
            self.base.climit.acquire().await.unwrap().forget();
            let stream = self.accept().await?;
            let mut chandle = ConnectionHandler::new(
                self.base.db.clone(),
                Connection::new(stream),
                self.base.climit.clone(),
                Terminator::new(self.base.signal.subscribe()),
                self.base.terminate_tx.clone(),
            );
            tokio::spawn(async move {
                if let Err(e) = chandle.run().await {
                    log::error!(""Error: {}"", e);
                }
            });
        }
    }",1,5,            let stream = self.accept().await?;
"fn confirm_request_raw(&self, id: U256, bytes: Bytes) -> Result<ConfirmationResponse, Error> {
		let id = id.into();

		self.signer.peek(&id).map(|confirmation| {
			let result = match confirmation.payload {
				ConfirmationPayload::SendTransaction(request) => {
					Self::verify_transaction(bytes, request, |pending_transaction| {
						self.dispatcher.dispatch_transaction(pending_transaction)
							.map(Into::into)
							.map(ConfirmationResponse::SendTransaction)
					})
				},
				ConfirmationPayload::SignTransaction(request) => {
					Self::verify_transaction(bytes, request, |pending_transaction| {
						Ok(ConfirmationResponse::SignTransaction(pending_transaction.transaction.into()))
					})
				},
				ConfirmationPayload::EthSignMessage(address, data) => {
					let expected_hash = eth_data_hash(data);
					let signature = ethkey::Signature::from_electrum(&bytes.0);
					match ethkey::verify_address(&address, &signature, &expected_hash) {
						Ok(true) => Ok(ConfirmationResponse::Signature(bytes.0.as_slice().into())),
						Ok(false) => Err(errors::invalid_params(""Sender address does not match the signature."", ())),
						Err(err) => Err(errors::invalid_params(""Invalid signature received."", err)),
					}
				},
				ConfirmationPayload::Decrypt(_address, _data) => {
					
					Ok(ConfirmationResponse::Decrypt(bytes))
				},
			};
			if let Ok(ref response) = result {
				self.signer.request_confirmed(id, Ok(response.clone()));
			}
			result
		}).unwrap_or_else(|| Err(errors::invalid_params(""Unknown RequestID"", id)))
	}",0,,
"async fn accept(&mut self) -> TResult<TcpStream> {
        
        let mut backoff = 1;
        loop {
            match self.base.listener.accept().await {
                
                Ok((stream, _)) => return Ok(stream),
                Err(e) => {
                    if backoff > 64 {
                        
                        return Err(e.into());
                    }
                }
            }
            
            time::sleep(Duration::from_secs(backoff)).await;
            
            backoff *= 2;
        }
    }",0,,
"    pub fn size_limit(mut self, size_limit: usize) -> Self {
        self.size_limit = size_limit;
        self
    }",0,,
"    fn input_len(&self) -> usize {
        self.tokens.len()
    }",0,,
"    pub fn kill_switch(&self) -> KillSwitch {
        KillSwitch::new(Arc::downgrade(&self.kill_state))
    }",0,,
"    pub(crate) fn wasmtime_memory(&self) -> &Memory {
        &self.ty
    }",0,,
"pub async fn mksnap(handle: &CoreDB, con: &mut Connection, act: ActionGroup) -> TResult<()> {
    let howmany = act.howmany();
    if howmany == 0 {
        if !handle.is_snapshot_enabled() {
            
            
            let error = ""err-snapshot-disabled"";
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(error.to_string()));
            return con.write_response(error).await;
        }
        
        let mut was_engine_error = false;
        let mut snap_result = None;
        let mut engine_was_busy = false;
        {
            let snaphandle = handle.snapcfg.clone();
            let snapstatus = (*snaphandle)
                .as_ref()
                .unwrap_or_else(|| unsafe { unreachable_unchecked() });
            let snapengine = SnapshotEngine::new(snapstatus.max, &handle, None);
            if snapengine.is_err() {
                was_engine_error = true;
            } else {
                if snapstatus.is_busy() {
                    engine_was_busy = true;
                } else {
                    let mut snapengine =
                        snapengine.unwrap_or_else(|_| unsafe { unreachable_unchecked() });

                    snap_result = snapengine.mksnap();
                }
            }
        }
        if was_engine_error {
            return con
                .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                .await;
        }
        if engine_was_busy {
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(""err-snapshot-busy"".to_owned()));
            return con.write_response(error).await;
        }
        if let Some(succeeded) = snap_result {
            if succeeded {
                
                return con
                    .write_response(responses::fresp::R_OKAY.to_owned())
                    .await;
            } else {
                
                
                return con
                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                    .await;
            }
        } else {
            
            
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(""err-access-after-termsig"".to_owned()));
            return con.write_response(error).await;
        }
    } else {
        if howmany == 1 {
            
            let snapname = act
                .get_ref()
                .get(1)
                .unwrap_or_else(|| unsafe { unreachable_unchecked() });
            let mut path = PathBuf::from(DIR_SNAPSHOT);
            path.push(""remote"");
            path.push(snapname.to_owned() + "".snapshot"");
            let failed;
            {
                match diskstore::flush_data(&path, &handle.acquire_read().get_ref()) {
                    Ok(_) => failed = false,
                    Err(e) => {
                        log::error!(""Error while creating snapshot: {}"", e);
                        failed = true;
                    }
                }
            }
            if failed {
                return con
                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                    .await;
            } else {
                return con
                    .write_response(responses::fresp::R_OKAY.to_owned())
                    .await;
            }
        } else {
            return con
                .write_response(responses::fresp::R_ACTION_ERR.to_owned())
                .await;
        }
    }
}",1,99,}
"fn diff(
    minus_file: Option<&PathBuf>,
    plus_file: Option<&PathBuf>,
    config: &config::Config,
    writer: &mut dyn Write,
) -> i32 {
    use std::io::BufReader;
    let die = || {
        eprintln!(
            ""\
The main way to use delta is to configure it as the pager for git: \
see https://github.com/dandavison/delta#configuration. \
You can also use delta to diff two files: `delta file_A file_B`.""
        );
        process::exit(config.error_exit_code);
    };
    let diff_command = ""git"";
    let minus_file = minus_file.unwrap_or_else(die);
    let plus_file = plus_file.unwrap_or_else(die);
    let mut diff_process = process::Command::new(PathBuf::from(diff_command))
        .args(&[""diff"", ""--no-index""])
        .args(&[minus_file, plus_file])
        .stdout(process::Stdio::piped())
        .spawn()
        .unwrap_or_else(|err| {
            eprintln!(""Failed to execute the command '{}': {}"", diff_command, err);
            process::exit(config.error_exit_code);
        });

    let exit_code = diff_process
        .wait()
        .unwrap_or_else(|_| {
            delta_unreachable(&format!(""'{}' process not running."", diff_command));
        })
        .code()
        .unwrap_or_else(|| {
            eprintln!(""'{}' process terminated without exit status."", diff_command);
            process::exit(config.error_exit_code);
        });

    if let Err(error) = delta(
        BufReader::new(diff_process.stdout.unwrap()).byte_lines(),
        writer,
        &config,
    ) {
        match error.kind() {
            ErrorKind::BrokenPipe => process::exit(0),
            _ => {
                eprintln!(""{}"", error);
                process::exit(config.error_exit_code);
            }
        }
    };
    exit_code
}",1,19,    let mut diff_process = process::Command::new(PathBuf::from(diff_command))
"    fn deref_mut(&mut self) -> &mut T {
        if cfg!(debug_assertions) {
            &mut self.inner
        } else {
            panic!(
                ""only deref `DebugOnly` when `cfg(debug_assertions)` or \
                 inside a `debug_assert!(..)`""
            )
        }
    }",0,,
"fn test_wat_string() {
        let ops = TableOps {
            num_params: 2,
            table_size: 10,
            ops: vec![
                TableOp::Gc,
                TableOp::Get(0),
                TableOp::SetFromParam(1, 2),
                TableOp::SetFromGet(3, 4),
            ],
        };

        let expected = r#""
(module
  (type (;0;) (func))
  (type (;1;) (func (param externref externref)))
  (import """" ""gc"" (func (;0;) (type 0)))
  (func (;1;) (type 1) (param externref externref)
    call 0
    i32.const 0
    table.get 0
    drop
    i32.const 1
    local.get 2
    table.set 0
    i32.const 3
    i32.const 4
    table.get 0
    table.set 0)
  (table (;0;) 10 externref)
  (export ""run"" (func 1)))
""#;
        let actual = ops.to_wasm_binary();
        let actual = wasmprinter::print_bytes(&actual).unwrap();
        assert_eq!(actual.trim(), expected.trim());
    }",1,"2,3,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30","num_params: 2,/~/            table_size: 10,/~/  (type (;1;) (func (param externref externref)))/~/  (func (;1;) (type 1) (param externref externref)/~/    call 0/~/    i32.const 0/~/    table.get 0/~/    drop/~/    i32.const 1/~/    local.get 2/~/    table.set 0/~/    i32.const 3/~/    i32.const 4/~/    table.get 0/~/    table.set 0)/~/  (table (;0;) 10 externref)/~/  (export ""run"" (func 1)))"
"fn correct_and_deposit_fee(
		who: &H160,
		corrected_fee: U256,
		base_fee: U256,
		already_withdrawn: Self::LiquidityInfo,
	) -> Self::LiquidityInfo {
		if let Some(paid) = already_withdrawn {
			let account_id = T::AddressMapping::into_account_id(*who);

			
			let refund_amount = paid
				.peek()
				.saturating_sub(corrected_fee.low_u128().unique_saturated_into());
			
			
			
			let refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)
				.unwrap_or_else(|_| C::PositiveImbalance::zero());

			
			
			
			
			let refund_imbalance = if C::minimum_balance().is_zero()
				&& refund_amount > C::Balance::zero()
				&& C::total_balance(&account_id).is_zero()
			{
				
				
				match C::make_free_balance_be(&account_id, refund_amount) {
					SignedImbalance::Positive(p) => p,
					_ => C::PositiveImbalance::zero(),
				}
			} else {
				refund_imbalance
			};

			
			let adjusted_paid = paid
				.offset(refund_imbalance)
				.same()
				.unwrap_or_else(|_| C::NegativeImbalance::zero());

			let (base_fee, tip) = adjusted_paid.split(base_fee.low_u128().unique_saturated_into());
			
			OU::on_unbalanced(base_fee);
			return Some(tip);
		}
		None
	}",1,"12,43",".saturating_sub(corrected_fee.low_u128().unique_saturated_into());/~/			let (base_fee, tip) = adjusted_paid.split(base_fee.low_u128().unique_saturated_into());"
"fn from(val: f64) -> Val {
        Val::F64(val.to_bits())
    }",0,,
"pub fn new(configuration: Configuration, deps: Dependencies) -> Result<Option<Middleware>, String> {
	if !configuration.enabled {
		return Ok(None);
	}

	server::dapps_middleware(
		deps,
		configuration.dapps_path,
		configuration.extra_dapps,
		rpc::DAPPS_DOMAIN.into(),
	).map(Some)
}",0,,
"    fn take_split(&self, count: usize) -> (Self, Self) {
        let (left, right) = self.tokens.split_at(count);

        (Input { source: self.source, tokens: left }, Input { source: self.source, tokens: right })
    }",1,3,"        (Input { source: self.source, tokens: left }, Input { source: self.source, tokens: right })"
"    fn ready(&mut self, poll: &mut mio::Poll, ev: &mio::Event) {
        
        
        
        if ev.readiness().is_readable() {
            self.do_tls_read();
            self.try_plain_read();
            self.try_back_read();
        }

        if ev.readiness().is_writable() {
            self.do_tls_write_and_handle_error();
        }

        if self.closing && !self.tls_session.wants_write() {
            let _ = self.socket.shutdown(Shutdown::Both);
            self.close_back();
            self.closed = true;
        } else {
            self.reregister(poll);
        }
    }",1,14,        if self.closing && !self.tls_session.wants_write() {
"fn calculate_gas_cost(
	base_length: u64,
	exp_length: u64,
	mod_length: u64,
	exponent: &BigUint,
) -> u64 {
	fn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {
		let max_length = max(base_length, mod_length);
		let mut words = max_length / 8;
		if max_length % 8 > 0 {
			words += 1;
		}

		
		words * words
	}

	fn calculate_iteration_count(exp_length: u64, exponent: &BigUint) -> u64 {
		let mut iteration_count: u64 = 0;

		if exp_length <= 32 && exponent.is_zero() {
			iteration_count = 0;
		} else if exp_length <= 32 {
			iteration_count = exponent.bits() - 1;
		} else if exp_length > 32 {
			
			let bytes: [u8; 32] = [0xFF; 32];
			let max_256_bit_uint = BigUint::from_bytes_be(&bytes);

			iteration_count =
				(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);
		}

		max(iteration_count, 1)
	}

	let multiplication_complexity = calculate_multiplication_complexity(base_length, mod_length);
	let iteration_count = calculate_iteration_count(exp_length, exponent);
	let gas = max(
		MIN_GAS_COST,
		multiplication_complexity * iteration_count / 3,
	);

	gas
}",1,"13,30",// TODO: prevent/handle overflow/~/				(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);
"	pub fn is_valid_web_proxy_access_token(&self, token: &String) -> bool {
		self.web_proxy_tokens.lock().contains_key(&token)
	}",1,"0,1","	pub fn is_valid_web_proxy_access_token(&self, token: &String) -> bool {/~/		self.web_proxy_tokens.lock().contains_key(&token)"
"fn main() -> std::io::Result<()> {
    env::set_var(""RUST_LOG"", ""swhks=trace"");
    env_logger::init();

    let pid_file_path = String::from(""/tmp/swhks.pid"");
    let sock_file_path = String::from(""/tmp/swhkd.sock"");

    if Path::new(&pid_file_path).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pid_file_path);
        let swhkd_pid = match fs::read_to_string(&pid_file_path) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Server is already running!"");
                exit(1);
            }
        }
    }

    if Path::new(&sock_file_path).exists() {
        log::trace!(""Sockfile exists, attempting to remove it."");
        match fs::remove_file(&sock_file_path) {
            Ok(_) => {
                log::debug!(""Removed old socket file"");
            }
            Err(e) => {
                log::error!(""Error removing the socket file!: {}"", e);
                log::error!(""You can manually remove the socket file: {}"", sock_file_path);
                exit(1);
            }
        };
    }

    match fs::write(&pid_file_path, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pid_file_path, e);
            exit(1);
        }
    }

    let listener = UnixListener::bind(sock_file_path)?;
    loop {
        match listener.accept() {
            Ok((mut socket, address)) => {
                let mut response = String::new();
                socket.read_to_string(&mut response)?;
                run_system_command(&response);
                log::debug!(""Socket: {:?} Address: {:?} Response: {}"", socket, address, response);
            }
            Err(e) => log::error!(""accept function failed: {:?}"", e),
        }
    }
}",1,5,"    let sock_file_path = String::from(""/tmp/swhkd.sock"");"
"fn test_err_ldindb_nomem() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x5
        ldindb r1, 0x33
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 30 && vm_addr == 0x400000038 && len == 1 && name == ""input""
                )
            }
        },
        2
    );
}",0,,
"fn on_initialize(_: T::BlockNumber) -> Weight {
			Pending::<T>::kill();

			
			
			if let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {
				let PreLog::Block(block) = log;

				for transaction in block.transactions {
					let source = Self::recover_signer(&transaction).expect(
						""pre-block transaction signature invalid; the block cannot be built"",
					);

					Self::do_transact(source, transaction).expect(
						""pre-block transaction verification failed; the block cannot be built"",
					);
				}
			}

			0
		}",1,13,"					Self::do_transact(source, transaction).expect("
"pub(super) fn parse_code_point<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (char, Span)> {
    alt((
        try_map(
            Token::CodePoint,
            |(s, span)| {
                let hex = &s[2..];
                if hex.len() > 6 {
                    Err(ParseErrorKind::CodePoint(CodePointError::Invalid))
                } else {
                    u32::from_str_radix(hex, 16)
                        .ok()
                        .and_then(|n| char::try_from(n).ok())
                        .map(|c| (c, span))
                        .ok_or(ParseErrorKind::CodePoint(CodePointError::Invalid))
                }
            },
            nom::Err::Failure,
        ),
        try_map(
            Token::Identifier,
            |(str, span)| {
                if let Some(rest) = str.strip_prefix('U') {
                    if let Ok(n) = u32::from_str_radix(rest, 16) {
                        if let Ok(c) = char::try_from(n) {
                            return Ok((c, span));
                        } else {
                            return Err(ParseErrorKind::CodePoint(CodePointError::Invalid));
                        }
                    }
                }
                Err(ParseErrorKind::ExpectedToken(Token::CodePoint))
            },
            nom::Err::Error,
        ),
    ))(input)
}",0,,
"fn check_overflow(&self) -> bool {
        let mut yes: bool = false;
        let mut no: bool = false;
        no = no || (self.0[7] < SECP256K1_N_7); 
        no = no || (self.0[6] < SECP256K1_N_6); 
        no = no || (self.0[5] < SECP256K1_N_5); 
        no = no || (self.0[4] < SECP256K1_N_4);
        yes = yes || ((self.0[4] > SECP256K1_N_4) && !no);
        no = no || ((self.0[3] < SECP256K1_N_3) && !yes);
        yes = yes || ((self.0[3] > SECP256K1_N_3) && !no);
        no = no || ((self.0[2] < SECP256K1_N_2) && !yes);
        yes = yes || ((self.0[2] > SECP256K1_N_2) && !no);
        no = no || ((self.0[1] < SECP256K1_N_1) && !yes);
        yes = yes || ((self.0[1] > SECP256K1_N_1) && !no);
        yes = yes || ((self.0[0] >= SECP256K1_N_0) && !no);
        return yes;
    }",1,"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15",let mut yes: bool = false;/~/        let mut no: bool = false;/~/        no = no || (self.0[7] < SECP256K1_N_7); /* No need for a > check. *//~/        no = no || (self.0[6] < SECP256K1_N_6); /* No need for a > check. *//~/        no = no || (self.0[5] < SECP256K1_N_5); /* No need for a > check. *//~/        no = no || (self.0[4] < SECP256K1_N_4);/~/        yes = yes || ((self.0[4] > SECP256K1_N_4) && !no);/~/        no = no || ((self.0[3] < SECP256K1_N_3) && !yes);/~/        yes = yes || ((self.0[3] > SECP256K1_N_3) && !no);/~/        no = no || ((self.0[2] < SECP256K1_N_2) && !yes);/~/        yes = yes || ((self.0[2] > SECP256K1_N_2) && !no);/~/        no = no || ((self.0[1] < SECP256K1_N_1) && !yes);/~/        yes = yes || ((self.0[1] > SECP256K1_N_1) && !no);/~/        yes = yes || ((self.0[0] >= SECP256K1_N_0) && !no);/~/        return yes;
"pub fn new_instance_handle(
    instance: *mut Instance,
    module: Arc<dyn Module>,
    alloc: Alloc,
    embed_ctx: CtxMap,
) -> Result<InstanceHandle, Error> {
    let inst = NonNull::new(instance)
        .ok_or_else(|| lucet_format_err!(""instance pointer is null; this is a bug""))?;

    lucet_ensure!(
        unsafe { inst.as_ref().magic } != LUCET_INSTANCE_MAGIC,
        ""created a new instance handle in memory with existing instance magic; this is a bug""
    );

    let mut handle = InstanceHandle {
        inst,
        needs_inst_drop: false,
    };

    let inst = Instance::new(alloc, module, embed_ctx);

    unsafe {
        
        
        

        
        ptr::write(&mut *handle, inst);
    };

    handle.needs_inst_drop = true;

    handle.reset()?;

    Ok(handle)
}",0,,
"pub(crate) fn ref_types_module(
    source: &str,
) -> anyhow::Result<(wasmtime::Store<()>, wasmtime::Module)> {
    use wasmtime::*;

    let _ = env_logger::try_init();

    let mut config = Config::new();
    config.wasm_reference_types(true);

    let engine = Engine::new(&config)?;
    let store = Store::new(&engine, ());

    let module = Module::new(&engine, source)?;

    Ok((store, module))
}",1,11,"    let store = Store::new(&engine, ());"
"pub fn parse(p: &[u8; util::MESSAGE_SIZE]) -> Message {
        let mut m = Scalar::default();

        
        let _ = m.set_b32(p);

        Message(m)
    }",0,,
"pub fn compile(mut self, exprs: &[Hir]) -> result::Result<Program, Error> {
        debug_assert!(!exprs.is_empty());
        self.num_exprs = exprs.len();
        if exprs.len() == 1 {
            self.compile_one(&exprs[0])
        } else {
            self.compile_many(exprs)
        }
    }",0,,
"fn insert(&self, func: &mut Function) {
        match self {
            Self::Gc => {
                func.instruction(Instruction::Call(0));
            }
            Self::Get(x) => {
                func.instruction(Instruction::I32Const(*x));
                func.instruction(Instruction::TableGet { table: 0 });
                func.instruction(Instruction::Drop);
            }
            Self::SetFromParam(x, y) => {
                func.instruction(Instruction::I32Const(*x));
                func.instruction(Instruction::LocalGet(*y));
                func.instruction(Instruction::TableSet { table: 0 });
            }
            Self::SetFromGet(x, y) => {
                func.instruction(Instruction::I32Const(*x));
                func.instruction(Instruction::I32Const(*y));
                func.instruction(Instruction::TableGet { table: 0 });
                func.instruction(Instruction::TableSet { table: 0 });
            }
        }
    }",1,"0,6,11,12,16,17","fn insert(&self, func: &mut Function) {/~/                func.instruction(Instruction::I32Const(*x));/~/                func.instruction(Instruction::I32Const(*x));/~/                func.instruction(Instruction::LocalGet(*y));/~/                func.instruction(Instruction::I32Const(*x));/~/                func.instruction(Instruction::I32Const(*y));"
"pub fn verify(message: &Message, signature: &Signature, pubkey: &PublicKey) -> bool {
    ECMULT_CONTEXT.verify_raw(&signature.r, &signature.s, &pubkey.0, &message.0)
}",0,,
"fn strip_comments(string: &str) -> String {
    
    let line_comments = Regex::new(r""(?m)//.*$"").unwrap();
    line_comments.replace_all(string, ""$1"").into_owned()
}",1,"0,1,2,3","fn strip_comments(string: &str) -> String {/~/    // Remove line comments/~/    let line_comments = Regex::new(r""(?m)//.*$"").unwrap();/~/    line_comments.replace_all(string, ""$1"").into_owned()"
"fn from(ty: WasmType) -> wasmparser::Type {
        match ty {
            WasmType::I32 => wasmparser::Type::I32,
            WasmType::I64 => wasmparser::Type::I64,
            WasmType::F32 => wasmparser::Type::F32,
            WasmType::F64 => wasmparser::Type::F64,
            WasmType::V128 => wasmparser::Type::V128,
            WasmType::FuncRef => wasmparser::Type::FuncRef,
            WasmType::ExternRef => wasmparser::Type::ExternRef,
            WasmType::ExnRef => wasmparser::Type::ExnRef,
        }
    }",0,,
"fn c_alternate(&mut self, exprs: &[Hir]) -> ResultOrEmpty {
        debug_assert!(
            exprs.len() >= 2,
            ""alternates must have at least 2 exprs""
        );

        
        let first_split_entry = self.insts.len();

        
        
        let mut holes = vec![];

        
        
        let mut prev_hole = (Hole::None, false);
        for e in &exprs[0..exprs.len() - 1] {
            if prev_hole.1 {
                let next = self.insts.len();
                self.fill_split(prev_hole.0, None, Some(next));
            } else {
                self.fill_to_next(prev_hole.0);
            }
            let split = self.push_split_hole();
            if let Some(Patch { hole, entry }) = self.c(e)? {
                holes.push(hole);
                prev_hole = (self.fill_split(split, Some(entry), None), false);
            } else {
                let (split1, split2) = split.dup_one();
                holes.push(split1);
                prev_hole = (split2, true);
            }
        }
        if let Some(Patch { hole, entry }) = self.c(&exprs[exprs.len() - 1])? {
            holes.push(hole);
            if prev_hole.1 {
                self.fill_split(prev_hole.0, None, Some(entry));
            } else {
                self.fill(prev_hole.0, entry);
            }
        } else {
            
            
            
            holes.push(prev_hole.0);
        }
        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))
    }",0,,
"pub fn seteuid(uid: u32) {
    let uid = nix::unistd::Uid::from_raw(uid);
    match nix::unistd::seteuid(uid) {
        Ok(_) => log::debug!(""Dropping privileges...""),
        Err(e) => {
            log::error!(""Failed to set UID: {:#?}"", e);
            exit(1);
        }
    }
}",1,"1,5","    let uid = nix::unistd::Uid::from_raw(uid);/~/            log::error!(""Failed to set UID: {:#?}"", e);"
"fn c(&mut self, expr: &Hir) -> ResultOrEmpty {
        use crate::prog;
        use regex_syntax::hir::HirKind::*;

        self.check_size()?;
        match *expr.kind() {
            Empty => Ok(None),
            Literal(hir::Literal::Unicode(c)) => self.c_char(c),
            Literal(hir::Literal::Byte(b)) => {
                assert!(self.compiled.uses_bytes());
                self.c_byte(b)
            }
            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),
            Class(hir::Class::Bytes(ref cls)) => {
                if self.compiled.uses_bytes() {
                    self.c_class_bytes(cls.ranges())
                } else {
                    assert!(cls.is_all_ascii());
                    let mut char_ranges = vec![];
                    for r in cls.iter() {
                        let (s, e) = (r.start() as char, r.end() as char);
                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));
                    }
                    self.c_class(&char_ranges)
                }
            }
            Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::EndLine)
            }
            Anchor(hir::Anchor::StartLine) => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::StartLine)
            }
            Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::StartLine)
            }
            Anchor(hir::Anchor::EndLine) => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::EndLine)
            }
            Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {
                self.c_empty_look(prog::EmptyLook::EndText)
            }
            Anchor(hir::Anchor::StartText) => {
                self.c_empty_look(prog::EmptyLook::StartText)
            }
            Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {
                self.c_empty_look(prog::EmptyLook::StartText)
            }
            Anchor(hir::Anchor::EndText) => {
                self.c_empty_look(prog::EmptyLook::EndText)
            }
            WordBoundary(hir::WordBoundary::Unicode) => {
                if !cfg!(feature = ""unicode-perl"") {
                    return Err(Error::Syntax(
                        ""Unicode word boundaries are unavailable when \
                         the unicode-perl feature is disabled""
                            .to_string(),
                    ));
                }
                self.compiled.has_unicode_word_boundary = true;
                self.byte_classes.set_word_boundary();
                
                
                
                
                
                
                self.byte_classes.set_range(0, 0x7F);
                self.c_empty_look(prog::EmptyLook::WordBoundary)
            }
            WordBoundary(hir::WordBoundary::UnicodeNegate) => {
                if !cfg!(feature = ""unicode-perl"") {
                    return Err(Error::Syntax(
                        ""Unicode word boundaries are unavailable when \
                         the unicode-perl feature is disabled""
                            .to_string(),
                    ));
                }
                self.compiled.has_unicode_word_boundary = true;
                self.byte_classes.set_word_boundary();
                
                self.byte_classes.set_range(0, 0x7F);
                self.c_empty_look(prog::EmptyLook::NotWordBoundary)
            }
            WordBoundary(hir::WordBoundary::Ascii) => {
                self.byte_classes.set_word_boundary();
                self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)
            }
            WordBoundary(hir::WordBoundary::AsciiNegate) => {
                self.byte_classes.set_word_boundary();
                self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)
            }
            Group(ref g) => match g.kind {
                hir::GroupKind::NonCapturing => self.c(&g.hir),
                hir::GroupKind::CaptureIndex(index) => {
                    if index as usize >= self.compiled.captures.len() {
                        self.compiled.captures.push(None);
                    }
                    self.c_capture(2 * index as usize, &g.hir)
                }
                hir::GroupKind::CaptureName { index, ref name } => {
                    if index as usize >= self.compiled.captures.len() {
                        let n = name.to_string();
                        self.compiled.captures.push(Some(n.clone()));
                        self.capture_name_idx.insert(n, index as usize);
                    }
                    self.c_capture(2 * index as usize, &g.hir)
                }
            },
            Concat(ref es) => {
                if self.compiled.is_reverse {
                    self.c_concat(es.iter().rev())
                } else {
                    self.c_concat(es)
                }
            }
            Alternation(ref es) => self.c_alternate(&**es),
            Repetition(ref rep) => self.c_repeat(rep),
        }
    }",1,6,"            Empty => Ok(None),"
"pub fn parse_cmd(cmd_str: &str, _sender_address: AccountAddress) -> Result<ast::Cmd> {
    let stripped_string = &strip_comments(cmd_str);
    let parser = syntax::CmdParser::new();
    match parser.parse(stripped_string) {
        Ok(cmd) => Ok(cmd),
        Err(e) => handle_error(e, cmd_str),
    }
}",1,"1,5","    let stripped_string = &strip_comments(cmd_str);/~/        Err(e) => handle_error(e, cmd_str),"
"    fn take(&self, count: usize) -> Self {
        let tokens = &self.tokens[..count];

        Input { source: self.source, tokens }
    }",1,3,"        Input { source: self.source, tokens }"
"pub fn combine(keys: &[PublicKey]) -> Result<Self, Error> {
        let mut qj = Jacobian::default();
        qj.set_infinity();

        for key in keys {
            qj = qj.add_ge(&key.0);
        }

        if qj.is_infinity() {
            return Err(Error::InvalidPublicKey);
        }

        let q = Affine::from_gej(&qj);
        Ok(PublicKey(q))
    }",0,,
"fn test_alu64_arithmetic() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        mov r1, 1
        mov r2, 2
        mov r3, 3
        mov r4, 4
        mov r5, 5
        mov r6, 6
        mov r7, 7
        mov r8, 8
        mov r9, 9
        add r0, 23
        add r0, r7
        sub r0, 13
        sub r0, r1
        mul r0, 7
        mul r0, r3
        div r0, 2
        div r0, r4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2a } },
        19
    );
}",0,,
"pub fn retrieve_less_version() -> Option<usize> {
    let cmd = Command::new(""less"").arg(""--version"").output().ok()?;
    parse_less_version(&cmd.stdout)
}",1,"1,2","    let cmd = Command::new(""less"").arg(""--version"").output().ok()?;/~/    parse_less_version(&cmd.stdout)"
"fn strip_first_last(s: &str) -> &str {
    &s[1..s.len() - 1]
}",0,,
"fn parse_test_module(args: TokenStream, item: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(item as syn::ItemMod);
    let content = match input.content {
        Some((_, c)) => c,
        None => {
            return syn::Error::new_spanned(&input, ""Couldn't get the module content"")
                .to_compile_error()
                .into()
        }
    };
    let args = syn::parse_macro_input!(args as syn::AttributeArgs);
    let mut skips = Vec::new();
    for arg in args {
        match arg {
            syn::NestedMeta::Meta(syn::Meta::NameValue(namevalue)) => {
                let ident = namevalue.path.get_ident();
                if ident.is_none() {
                    let msg = ""Must have specified ident"";
                    return syn::Error::new_spanned(namevalue, msg)
                        .to_compile_error()
                        .into();
                }
                match ident.unwrap().to_string().to_lowercase().as_str() {
                    ""skip"" => {
                        let skip_lit = namevalue.lit.clone();
                        let span = skip_lit.span();
                        skips = match parse_string(skip_lit, span, ""skip"") {
                            Ok(s) => s,
                            Err(_) => {
                                return syn::Error::new_spanned(
                                    namevalue,
                                    ""Expected a value for argument `skip`"",
                                )
                                .to_compile_error()
                                .into();
                            }
                        }
                        .split_whitespace()
                        .map(|val| val.to_string())
                        .collect();
                    }
                    x => {
                        let msg = format!(""Unknown attribute {} is specified; expected `skip`"", x);
                        return syn::Error::new_spanned(namevalue, msg)
                            .to_compile_error()
                            .into();
                    }
                }
            }
            _ => (),
        }
    }
    let modname = &input.ident;
    if modname.to_string() != ""__private"" {
        return syn::Error::new_spanned(
            modname,
            ""By convention, all the modules using the `dbtest` macro have to be called `__private`"",
        )
        .to_compile_error()
        .into();
    }
    let mut rng = thread_rng();
    let mut in_set = HashSet::<u16>::new();

    let mut result = quote! {};
    for item in content {
        






        let mut rand: u16 = rng.gen_range(1025, 65535);
        #[cfg(not(target_os = ""windows""))]
        {
            while in_set.contains(&rand) {
                rand = rng.gen_range(1025, 65535);
            }
        }
        #[cfg(target_os = ""windows"")]
        {
            in_set.insert(5357);
            in_set.insert(7680);
            while in_set.contains(&rand) || (rand >= 49670 && rand <= 50293) {
                rand = rng.gen_range(1025, 65535);
            }
        }
        in_set.insert(rand);
        match item {
            
            
            syn::Item::Fn(function) => {
                if skips.contains(&function.sig.ident.to_string()) {
                    result = quote! {
                        #result
                        #function
                    };
                    continue;
                }
                let inp = parse_test_sig(function, rand);
                let __tok: syn::ItemFn = syn::parse_macro_input!(inp as syn::ItemFn);
                let tok = quote! {
                    #__tok
                };
                result = quote! {
                    #result
                    #tok
                };
            }
            token => {
                result = quote! {
                    #result
                    #token
                };
            }
        }
    }
    result.into()
}",1,"73,77,85","let mut rand: u16 = rng.gen_range(1025, 65535);/~/                rand = rng.gen_range(1025, 65535);/~/                rand = rng.gen_range(1025, 65535);"
"fn test_subnet() {
    test_interpreter_and_jit_asm!(
        ""
        mov r2, 0xe
        ldxh r3, [r1+12]
        jne r3, 0x81, +2
        mov r2, 0x12
        ldxh r3, [r1+16]
        and r3, 0xffff
        jne r3, 0x8, +5
        add r1, r2
        mov r0, 0x1
        ldxw r1, [r1+16]
        and r1, 0xffffff
        jeq r1, 0x1a8c0, +1
        mov r0, 0x0
        exit"",
        [
            0x00, 0x00, 0xc0, 0x9f, 0xa0, 0x97, 0x00, 0xa0, 
            0xcc, 0x3b, 0xbf, 0xfa, 0x08, 0x00, 0x45, 0x10, 
            0x00, 0x3c, 0x46, 0x3c, 0x40, 0x00, 0x40, 0x06, 
            0x73, 0x1c, 0xc0, 0xa8, 0x01, 0x02, 0xc0, 0xa8, 
            0x01, 0x01, 0x06, 0x0e, 0x00, 0x17, 0x99, 0xc5, 
            0xa0, 0xec, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 
            0x7d, 0x78, 0xe0, 0xa3, 0x00, 0x00, 0x02, 0x04, 
            0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a, 0x00, 0x9c, 
            0x27, 0x24, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 
            0x03, 0x00, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        11
    );
}",0,,
"fn extract_target_url(&self, url: Option<Url>) -> Result<String, State<F>> {
		let token_and_url = self.path.app_params.get(0)
			.map(|encoded| encoded.replace('.', """"))
			.and_then(|encoded| base32::decode(base32::Alphabet::Crockford, &encoded.to_uppercase()))
			.and_then(|data| String::from_utf8(data).ok())
			.ok_or_else(|| State::Error(ContentHandler::error(
				StatusCode::BadRequest,
				""Invalid parameter"",
				""Couldn't parse given parameter:"",
				self.path.app_params.get(0).map(String::as_str),
				self.embeddable_on.clone()
			)))?;

		let mut token_it = token_and_url.split('+');
		let token = token_it.next();
		let target_url = token_it.next();

		
		match token {
			Some(token) if self.web_proxy_tokens.is_web_proxy_token_valid(token) => {},
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, ""Invalid Access Token"", ""Invalid or old web proxy access token supplied."", Some(""Try refreshing the page.""), self.embeddable_on.clone()
				)));
			}
		}

		
		let mut target_url = match target_url {
			Some(url) if url.starts_with(""http://"") || url.starts_with(""https://"") => url.to_owned(),
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, ""Invalid Protocol"", ""Invalid protocol used."", None, self.embeddable_on.clone()
				)));
			}
		};

		if !target_url.ends_with(""/"") {
			target_url = format!(""{}/"", target_url);
		}

		
		let (path, query) = match (&url, self.path.using_dapps_domains) {
			(&Some(ref url), true) => (&url.path[..], &url.query),
			(&Some(ref url), false) => (&url.path[2..], &url.query),
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, ""Invalid URL"", ""Couldn't parse URL"", None, self.embeddable_on.clone()
				)));
			}
		};

		let query = match *query {
			Some(ref query) => format!(""?{}"", query),
			None => """".into(),
		};

		Ok(format!(""{}{}{}"", target_url, path.join(""/""), query))
	}",1,"18,19,25","		match token {/~/			Some(token) if self.web_proxy_tokens.is_web_proxy_token_valid(token) => {},/~/		}"
"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            
            
            self.base.climit.acquire().await.unwrap().forget();
            let stream = self.accept().await?;
            let mut sslhandle = ConnectionHandler::new(
                self.base.db.clone(),
                Connection::new(stream),
                self.base.climit.clone(),
                Terminator::new(self.base.signal.subscribe()),
                self.base.terminate_tx.clone(),
            );
            tokio::spawn(async move {
                if let Err(e) = sslhandle.run().await {
                    log::error!(""Error: {}"", e);
                }
            });
        }
    }",1,5,            let stream = self.accept().await?;
"    fn try_from(ty: wasmparser::FuncType) -> Result<Self, Self::Error> {
        Ok(Self {
            params: ty
                .params
                .into_vec()
                .into_iter()
                .map(WasmType::try_from)
                .collect::<Result<_, Self::Error>>()?,
            returns: ty
                .returns
                .into_vec()
                .into_iter()
                .map(WasmType::try_from)
                .collect::<Result<_, Self::Error>>()?,
        })
    }",1,"1,2,3,4,5,6,7,8,9,10,11,12,13,14","        Ok(Self {/~/            params: ty/~/                .params/~/                .into_vec()/~/                .into_iter()/~/                .map(WasmType::try_from)/~/                .collect::<Result<_, Self::Error>>()?,/~/            returns: ty/~/                .returns/~/                .into_vec()/~/                .into_iter()/~/                .map(WasmType::try_from)/~/                .collect::<Result<_, Self::Error>>()?,/~/        })"
"pub fn set_instruction_count_and_bound(&mut self, instruction_count: u64, bound: u64) {
        let implicits = self.get_instance_implicits_mut();
        let instruction_count =
            i64::try_from(instruction_count).expect(""instruction count too large"");
        let bound = i64::try_from(bound).expect(""bound too large"");
        
        implicits.instruction_count_bound = bound;
        implicits.instruction_count_adj = instruction_count - bound;
    }",0,,
"fn test_mov32_imm_large() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, -1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xffffffff } },
        2
    );
}",0,,
"pub fn parse_module(modules_str: &str) -> Result<ast::ModuleDefinition> {
    let stripped_string = &strip_comments(modules_str);
    let parser = syntax::ModuleParser::new();
    match parser.parse(stripped_string) {
        Ok(module) => Ok(module),
        Err(e) => handle_error(e, modules_str),
    }
}",1,"1,5","    let stripped_string = &strip_comments(modules_str);/~/        Err(e) => handle_error(e, modules_str),"
"fn push_types(isa: &dyn TargetIsa, sig: &mut ir::Signature, wasm: &WasmFuncType) {
    let cvt = |ty: &WasmType| ir::AbiParam::new(value_type(isa, *ty));
    sig.params.extend(wasm.params.iter().map(&cvt));
    sig.returns.extend(wasm.returns.iter().map(&cvt));
}",1,"2,3",    sig.params.extend(wasm.params.iter().map(&cvt));/~/    sig.returns.extend(wasm.returns.iter().map(&cvt));
"	fn generate_web_proxy_token(&self) -> Result<String, Error> {
		Ok(self.signer.generate_web_proxy_access_token())
	}",1,"0,1","	fn generate_web_proxy_token(&self) -> Result<String, Error> {/~/		Ok(self.signer.generate_web_proxy_access_token())"
"    fn push_split_hole(&mut self) -> Hole {
        let hole = self.insts.len();
        self.insts.push(MaybeInst::Split);
        Hole::One(hole)
    }",0,,
"fn test_ldabsh() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsh 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x4433 } },
        2
    );
}",0,,
"pub fn tweak_mul_assign(&mut self, tweak: &SecretKey) -> Result<(), Error> {
        if tweak.0.is_zero() {
            return Err(Error::TweakOutOfRange);
        }

        let mut r = Jacobian::default();
        let zero = Scalar::from_int(0);
        let pt = Jacobian::from_ge(&self.0);
        ECMULT_CONTEXT.ecmult(&mut r, &pt, &tweak.0, &zero);

        self.0.set_gej(&r);
        Ok(())
    }",0,,
"    pub(super) fn from(source: &'i str, tokens: &'b [(Token, Span)]) -> Result<Self, ParseError> {
        let error = tokens.iter().find_map(|&(t, span)| match t {
            Token::Error => Some((span, None)),
            Token::ErrorMsg(m) => Some((span, Some(m))),
            _ => None,
        });
        if let Some((span, msg)) = error {
            return match msg {
                Some(msg) => Err(ParseErrorKind::LexErrorWithMessage(msg).at(span)),
                None => Err(ParseErrorKind::UnknownToken.at(span)),
            };
        }

        Ok(Input { source, tokens })
    }",1,"0,13","    pub(super) fn from(source: &'i str, tokens: &'b [(Token, Span)]) -> Result<Self, ParseError> {/~/        Ok(Input { source, tokens })"
"fn fill_scalar_with_leading_zero(scalar: &Scalar) -> [u8; 33] {
            let mut ret = [0u8; 33];
            scalar.fill_b32(array_mut_ref!(ret, 1, 32));
            ret
        }",0,,
"fn from(val: f32) -> Val {
        Val::F32(val.to_bits())
    }",0,,
"    pub fn content(&self) -> &ValType {
        &self.content
    }",0,,
"fn enter(&mut self, gas_limit: u64, is_static: bool) {
		self.substate.enter(gas_limit, is_static)
	}",0,,
"async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = set_command_line_args().get_matches();
    env::set_var(""RUST_LOG"", ""swhkd=warn"");

    if args.is_present(""debug"") {
        env::set_var(""RUST_LOG"", ""swhkd=trace"");
    }

    env_logger::init();
    log::trace!(""Logger initialized."");

    let pidfile: String = String::from(""/tmp/swhkd.pid"");
    if Path::new(&pidfile).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pidfile);
        let swhkd_pid = match fs::read_to_string(&pidfile) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Swhkd is already running!"");
                log::error!(""pid of existing swhkd process: {}"", pid.to_string());
                log::error!(""To close the existing swhkd process, run `sudo killall swhkd`"");
                exit(1);
            }
        }
    }

    match fs::write(&pidfile, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pidfile, e);
            exit(1);
        }
    }

    if check_user_permissions().is_err() {
        exit(1);
    }

    let load_config = || {
        seteuid(env::var(""PKEXEC_UID"").unwrap().parse::<u32>().unwrap()); 
        let config_file_path: std::path::PathBuf = if args.is_present(""config"") {
            Path::new(args.value_of(""config"").unwrap()).to_path_buf()
        } else {
            fetch_xdg_config_path()
        };

        log::debug!(""Using config file path: {:#?}"", config_file_path);

        if !config_file_path.exists() {
            log::error!(""{:#?} doesn't exist"", config_file_path);
            exit(1);
        }

        let hotkeys = match config::load(&config_file_path) {
            Err(e) => {
                log::error!(""Config Error: {}"", e);
                exit(1);
            }
            Ok(out) => out,
        };

        for hotkey in &hotkeys {
            log::debug!(""hotkey: {:#?}"", hotkey);
        }

        hotkeys
    };

    let mut hotkeys = load_config();
    seteuid(0); 
    log::trace!(""Attempting to find all keyboard file descriptors."");
    let keyboard_devices: Vec<Device> =
        evdev::enumerate().filter(check_device_is_keyboard).collect();

    let mut uinput_device = match uinput::create_uinput_device() {
        Ok(dev) => dev,
        Err(e) => {
            log::error!(""Err: {:#?}"", e);
            exit(1);
        }
    };

    if keyboard_devices.is_empty() {
        log::error!(""No valid keyboard device was detected!"");
        exit(1);
    }
    log::debug!(""{} Keyboard device(s) detected."", keyboard_devices.len());

    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTALT, config::Modifier::Alt),
        (Key::KEY_RIGHTALT, config::Modifier::Alt),
        (Key::KEY_LEFTCTRL, config::Modifier::Control),
        (Key::KEY_RIGHTCTRL, config::Modifier::Control),
        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),
        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),
    ]);

    let repeat_cooldown_duration: u64 = if args.is_present(""cooldown"") {
        args.value_of(""cooldown"").unwrap().parse::<u64>().unwrap()
    } else {
        250
    };

    let mut signals = Signals::new(&[
        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,
        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,
    ])?;

    let mut execution_is_paused = false;
    let mut last_hotkey: Option<config::Hotkey> = None;
    let mut pending_release: bool = false;
    let mut keyboard_states: Vec<KeyboardState> = Vec::new();
    let mut keyboard_stream_map = StreamMap::new();

    for (i, mut device) in keyboard_devices.into_iter().enumerate() {
        let _ = device.grab();
        keyboard_stream_map.insert(i, device.into_event_stream()?);
        keyboard_states.push(KeyboardState::new());
    }

    
    let hotkey_repeat_timer = sleep(Duration::from_millis(0));
    tokio::pin!(hotkey_repeat_timer);

    loop {
        select! {
            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {
                let hotkey = last_hotkey.clone().unwrap();
                if hotkey.keybinding.on_release {
                    continue;
                }
                send_command(hotkey.clone());
                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
            }

            Some(signal) = signals.next() => {
                match signal {
                    SIGUSR1 => {
                        execution_is_paused = true;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                    }

                    SIGUSR2 => {
                        execution_is_paused = false;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.grab();
                        }
                    }

                    SIGHUP => {
                        hotkeys = load_config();
                    }

                    SIGINT => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                        log::warn!(""Received SIGINT signal, exiting..."");
                        exit(1);
                    }

                    _ => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }

                        log::warn!(""Received signal: {:#?}"", signal);
                        log::warn!(""Exiting..."");
                        exit(1);
                    }
                }
            }

            Some((i, Ok(event))) = keyboard_stream_map.next() => {
                let keyboard_state = &mut keyboard_states[i];

                let key = match event.kind() {
                    InputEventKind::Key(keycode) => keycode,
                    _ => continue
                };

                match event.value() {
                    
                    1 => {
                        if let Some(modifier) = modifiers_map.get(&key) {
                            keyboard_state.state_modifiers.insert(*modifier);
                        } else {
                            keyboard_state.state_keysyms.insert(key);
                        }
                    }

                    
                    0 => {
                        if last_hotkey.is_some() && pending_release {
                            pending_release = false;
                            send_command(last_hotkey.clone().unwrap());
                            last_hotkey = None;
                        }
                        if let Some(modifier) = modifiers_map.get(&key) {
                            if let Some(hotkey) = &last_hotkey {
                                if hotkey.modifiers().contains(modifier) {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_modifiers.remove(modifier);
                        } else if keyboard_state.state_keysyms.contains(key) {
                            if let Some(hotkey) = &last_hotkey {
                                if key == hotkey.keysym() {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_keysyms.remove(key);
                        }
                    }

                    _ => {}
                }

                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()
                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())
                    .collect();

                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {
                    hotkey.keysym().code() == event.code() &&
                    keyboard_state.state_modifiers
                        .iter()
                        .all(|x| hotkey.modifiers().contains(x)) &&
                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                    && !hotkey.is_send()
                        });

                
                if !event_in_hotkeys {
                    uinput_device.emit(&[event]).unwrap();
                }

                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {
                    continue;
                }

                log::debug!(""state_modifiers: {:#?}"", keyboard_state.state_modifiers);
                log::debug!(""state_keysyms: {:#?}"", keyboard_state.state_keysyms);
                log::debug!(""hotkey: {:#?}"", possible_hotkeys);

                for hotkey in possible_hotkeys {
                    
                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))
                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                        && keyboard_state.state_keysyms.contains(hotkey.keysym())
                    {
                        last_hotkey = Some(hotkey.clone());
                        if pending_release { break; }
                        if hotkey.is_on_release() {
                            pending_release = true;
                            break;
                        }
                        send_command(hotkey.clone());
                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
                        break;
                    }
                }
            }
        }
    }
}",1,"57,58,59,60,61","if !config_file_path.exists() {/~/            log::error!(""{:#?} doesn't exist"", config_file_path);/~/            exit(1);/~/        }/~/"
"    fn iter_elements(&self) -> Self::IterElem {
        Input { source: self.source, tokens: self.tokens }
    }",1,1,"        Input { source: self.source, tokens: self.tokens }"
"fn blocks(&self) -> Range<BlockIx> {
        Range::new(BlockIx::new(0), self.block_ranges.len())
    }",0,,
"    fn drop(&mut self) {
        if self.needs_inst_drop {
            unsafe {
                let inst = self.inst.as_mut();

                
                
                
                
                
                let region: Arc<dyn RegionInternal> = inst.alloc().region.clone();

                
                std::ptr::drop_in_place(inst);

                
                
                
                mem::drop(region);
            }
        }
    }",1,"5,7,8,9,10,15,16,17,18","                // Grab a handle to the region to ensure it outlives `inst`./~/                // This ensures that the region won't be dropped by `inst` being/~/                // dropped, which could result in `inst` being unmapped by the/~/                // Region *during* drop of the Instance's fields./~/                let region: Arc<dyn RegionInternal> = inst.alloc().region.clone();/~/                // and now we can drop what may be the last Arc<Region>. If it is/~/                // it can safely do what it needs with memory; we're not running/~/                // destructors on it anymore./~/                mem::drop(region);"
