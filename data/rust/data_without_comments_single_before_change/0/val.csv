processed_func,target,flaw_line_index,flaw_line
"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            
            
            self.base.climit.acquire().await.unwrap().forget();
            let stream = self.accept().await?;
            let mut chandle = ConnectionHandler::new(
                self.base.db.clone(),
                Connection::new(stream),
                self.base.climit.clone(),
                Terminator::new(self.base.signal.subscribe()),
                self.base.terminate_tx.clone(),
            );
            tokio::spawn(async move {
                if let Err(e) = chandle.run().await {
                    log::error!(""Error: {}"", e);
                }
            });
        }
    }",1,5,            let stream = self.accept().await?;
"    pub async fn receive_signal(&mut self) {
        
        
        if self.terminate {
            return;
        }
        let _ = self.signal.recv().await;
        self.terminate = true;
    }",0,,
"fn send_http_response_once(&mut self) {
        let response = b""HTTP/1.0 200 OK\r\nConnection: close\r\n\r\nHello world from rustls tlsserver\r\n"";
        if !self.sent_http_response {
            self.tls_session
                .write_all(response)
                .unwrap();
            self.sent_http_response = true;
            self.tls_session.send_close_notify();
        }
    }",0,,
"pub fn address(&self, address: Option<(String, u16)>) -> Option<(String, u16)> {
		match self.enabled {
			true => address,
			false => None,
		}
	}",0,,
"pub fn serialize(&self) -> [u8; util::SIGNATURE_SIZE] {
        let mut ret = [0u8; 64];
        self.r.fill_b32(array_mut_ref!(ret, 0, 32));
        self.s.fill_b32(array_mut_ref!(ret, 32, 32));
        ret
    }",0,,
"    pub const fn new(signal: broadcast::Receiver<()>) -> Self {
        Terminator {
            
            terminate: false,
            signal,
        }
    }",0,,
"fn decode_into_nonempty_vec_doesnt_clobber_existing_prefix() {
        let mut orig_data = Vec::new();
        let mut encoded_data = String::new();
        let mut decoded_with_prefix = Vec::new();
        let mut decoded_without_prefix = Vec::new();
        let mut prefix = Vec::new();

        let prefix_len_range = Uniform::new(0, 1000);
        let input_len_range = Uniform::new(0, 1000);

        let mut rng = rand::rngs::SmallRng::from_entropy();

        for _ in 0..10_000 {
            orig_data.clear();
            encoded_data.clear();
            decoded_with_prefix.clear();
            decoded_without_prefix.clear();
            prefix.clear();

            let input_len = input_len_range.sample(&mut rng);

            for _ in 0..input_len {
                orig_data.push(rng.gen());
            }

            let config = random_config(&mut rng);
            encode_config_buf(&orig_data, config, &mut encoded_data);
            assert_encode_sanity(&encoded_data, config, input_len);

            let prefix_len = prefix_len_range.sample(&mut rng);

            
            for _ in 0..prefix_len {
                prefix.push(rng.gen());
            }

            decoded_with_prefix.resize(prefix_len, 0);
            decoded_with_prefix.copy_from_slice(&prefix);

            
            decode_config_buf(&encoded_data, config, &mut decoded_with_prefix).unwrap();
            
            decode_config_buf(&encoded_data, config, &mut decoded_without_prefix).unwrap();

            assert_eq!(
                prefix_len + decoded_without_prefix.len(),
                decoded_with_prefix.len()
            );
            assert_eq!(orig_data, decoded_without_prefix);

            
            prefix.append(&mut decoded_without_prefix);

            assert_eq!(prefix, decoded_with_prefix);
        }
    }",0,,
"fn test_err_capped_before_exception() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x0
        mov64 r2, 0x0
        add64 r0, 0x0
        add64 r0, 0x0
        div64 r1, r2
        add64 r0, 0x0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 31 && initial_insn_count == 2
                )
            }
        },
        2
    );
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x0
        mov64 r2, 0x0
        add64 r0, 0x0
        add64 r0, 0x0
        syscall Unresolved
        add64 r0, 0x0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 33 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,,
"fn test_stdw() {
    test_interpreter_and_jit_asm!(
        ""
        stdw [r1+2], 0x44332211
        ldxdw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
            0xff, 0xff, 0xcc, 0xdd, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x44332211 } },
        3
    );
}",0,,
"    fn is_included_in_clobbers(&self, insn: &I) -> bool {
        insn.is_included_in_clobbers()
    }",0,,
"fn is_empty(&self, address: H160) -> bool {
		Pallet::<T>::is_account_empty(&address)
	}",0,,
"fn elements(&self, mut f: impl FnMut(&VMExternRef)) {
        for elem in self.over_approximated_stack_roots.iter() {
            f(&elem.0);
        }

        
        
        let num_filled = self.num_filled_in_bump_chunk();
        for slot in self.alloc.chunk.iter().take(num_filled) {
            if let Some(elem) = unsafe { &*slot.get() } {
                f(elem);
            }
        }
    }",0,,
"fn parse_dbtest(mut input: syn::ItemFn, rand: u16) -> Result<TokenStream, syn::Error> {
    let sig = &mut input.sig;
    let fname = sig.ident.to_string();
    let body = &input.block;
    let attrs = &input.attrs;
    let vis = &input.vis;
    let header = quote! {
        #[::core::prelude::v1::test]
    };
    if sig.asyncness.is_none() {
        let msg = ""`dbtest` functions need to be async"";
        return Err(syn::Error::new_spanned(sig.fn_token, msg));
    }
    sig.asyncness = None;
    let body = quote! {
        let asyncdb = crate::coredb::CoreDB::new(
            crate::config::BGSave::Disabled,
            crate::config::SnapshotConfig::default(),
            None
        ).unwrap();
        let addr = crate::tests::start_test_server(#rand, Some(asyncdb.clone())).await;
        let mut stream = tokio::net::TcpStream::connect(&addr).await.unwrap();
        #body
        stream.shutdown(::std::net::Shutdown::Write).unwrap();
        asyncdb.finish_db();
        drop(asyncdb);
    };
    let result = quote! {
        #header
        #(#attrs)*
        #vis #sig {
            tokio::runtime::Builder::new_multi_thread()
            .worker_threads(4)
            .thread_name(#fname)
            .thread_stack_size(3 * 1024 * 1024)
            .enable_all()
            .build()
            .unwrap()
            .block_on(async { #body });
        }
    };
    Ok(result.into())
}",1,23,        stream.shutdown(::std::net::Shutdown::Write).unwrap();
"fn test_le64() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1]
        le64 r0
        exit"",
        [0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122334455667788 } },
        3
    );
}",0,,
"    pub fn flags(&self) -> &settings::Flags {
        self.abi.flags()
    }",0,,
"    fn try_plain_read(&mut self) {
        
        let mut buf = Vec::new();

        let rc = self.tls_session.read_to_end(&mut buf);
        if rc.is_err() {
            error!(""plaintext read failed: {:?}"", rc);
            self.closing = true;
            return;
        }

        if !buf.is_empty() {
            debug!(""plaintext read {:?}"", buf.len());
            self.incoming_plaintext(&buf);
        }
    }",0,,
"	fn get_dispatch_info(&self) -> DispatchInfo {
		self.function.get_dispatch_info()
	}",0,,
"    fn tls_write(&mut self) -> io::Result<usize> {
        self.tls_session.write_tls(&mut self.socket)
    }",0,,
"    pub fn name(&self) -> Option<&str> {
        self.name.as_deref()
    }",0,,
"pub fn inv(&self) -> Self {
        SecretKey(self.0.inv())
    }",0,,
"pub(crate) fn tokenize(mut input: &str) -> Vec<(Token, Span)> {
    let mut result = vec![];
    let mut offset = 0;

    loop {
        let input_len = input.len();
        input = input.trim_start();
        while input.starts_with('#') {
            input = input.trim_start_matches(|c| c != '\n').trim_start();
        }
        offset += input_len - input.len();

        match input.chars().next() {
            None => break,
            Some(c) => {
                let (len, token) = consume_chain! {
                    input, c;

                    if input.starts_with(""<%"") => (2, Token::BStart);
                    if input.starts_with(""%>"") => (2, Token::BEnd);
                    if input.starts_with("">>"") => (2, Token::LookAhead);
                    if input.starts_with(""<<"") => (2, Token::LookBehind);
                    if input.starts_with(""::"") => (2, Token::Backref);

                    if c == '%' => (1, Token::BWord);
                    if c == '*' => (1, Token::Star);
                    if c == '+' => (1, Token::Plus);
                    if c == '?' => (1, Token::QuestionMark);
                    if c == '|' => (1, Token::Pipe);
                    if c == ':' => (1, Token::Colon);
                    if c == ')' => (1, Token::CloseParen);
                    if c == '{' => (1, Token::OpenBrace);
                    if c == '}' => (1, Token::CloseBrace);
                    if c == ',' => (1, Token::Comma);
                    if c == '!' => (1, Token::Not);
                    if c == '[' => (1, Token::OpenBracket);
                    if c == '-' => (1, Token::Dash);
                    if c == ']' => (1, Token::CloseBracket);
                    if c == '.' => (1, Token::Dot);
                    if c == ';' => (1, Token::Semicolon);
                    if c == '=' => (1, Token::Equals);

                    if c == '\'' => match input[1..].find('\'') {
                        Some(len_inner) => (len_inner + 2, Token::String),
                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),
                    };

                    if c == '""' => match find_unescaped_quote(&input[1..]) {
                        Some(len_inner) => (len_inner + 2, Token::String),
                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),
                    };

                    if let Some(rest) = input.strip_prefix(""U+"") => {
                        match rest.find(|c: char| !c.is_ascii_hexdigit()) {
                            Some(0) => (1, Token::Error),
                            Some(len_inner) => (len_inner + 2, Token::CodePoint),
                            None => (input.len(), Token::CodePoint),
                        }
                    };

                    if matches!(c, '0'..='9') => (
                        input.find(|c: char| !matches!(c, '0'..='9')).unwrap_or(input.len()),
                        Token::Number,
                    );

                    if c.is_alphabetic() || c == '_' => (
                        input.find(|c: char| !c.is_alphanumeric() && c != '_').unwrap_or(input.len()),
                        Token::Identifier,
                    );

                    if c == '^' => (1, Token::ErrorMsg(ParseErrorMsg::Caret));
                    if c == '$' => (1, Token::ErrorMsg(ParseErrorMsg::Dollar));

                    if let Some(rest) = input.strip_prefix(""(?"") => (
                        match rest.chars().next() {
                            Some('<') => {
                                let name_len = rest.chars()
                                    .skip(1)
                                    .take_while(char::is_ascii_alphanumeric)
                                    .count();

                                if name_len > 0 && matches!(rest.chars().nth(1 + name_len), Some('>')) {
                                    4 + name_len
                                } else if let Some('=' | '!') = rest.chars().nth(1) {
                                    4
                                } else {
                                    3
                                }
                            }
                            Some('P') if matches!(rest.chars().nth(1), Some('<')) => {
                                let name_len = rest.chars()
                                    .skip(2)
                                    .take_while(char::is_ascii_alphanumeric)
                                    .count();

                                if name_len > 0 && matches!(rest.chars().nth(2 + name_len), Some('>')) {
                                    5 + name_len
                                } else {
                                    4
                                }
                            },
                            Some('>' | '!' | ':' | '=' | '(' | '|') => 3,
                            _ => 2,
                        },
                        Token::ErrorMsg(ParseErrorMsg::SpecialGroup),
                    );
                    if c == '(' => (1, Token::OpenParen);

                    if c == '\\' => {
                        if input.starts_with(""\\u{"") || input.starts_with(""\\x{"") {
                            match input[3..].find('}') {
                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashUnicode)),
                                None => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\u"") {
                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {
                                4.. => (6, Token::ErrorMsg(ParseErrorMsg::BackslashU4)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\x"") {
                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {
                                2.. => (4, Token::ErrorMsg(ParseErrorMsg::BackslashX2)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\k<"") {
                            match rest.find('>') {
                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashK)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if input.len() >= 2 {
                            (2, Token::ErrorMsg(ParseErrorMsg::Backslash))
                        } else {
                            (1, Token::Error)
                        }
                    };
                };

                let start = offset;
                offset += len;
                input = &input[len..];
                result.push((token, Span::new(start, offset)));
            }
        }
    }

    result
}",1,"129,130","} else if input.len() >= 2 {/~/                            (2, Token::ErrorMsg(ParseErrorMsg::Backslash))"
"pub fn atou16(bytes: &[u8]) -> Result<u16, Error> {
    if cfg!(debug_assertions) && bytes.len() >= 5 {
        panic!(""atou16 accepts up to 4 bytes"");
    }
    if bytes.len() == 0 {
        return Err(Error::InvalidFormat(""Not a number""));
    }
    let mut n = 0;
    for &c in bytes {
        if c < ASCII_0 || ASCII_9 < c {
            return Err(Error::InvalidFormat(""Not a number""));
        }
        n = n * 10 + (c - ASCII_0) as u16;
    }
    Ok(n)
}",0,,
"    pub fn set_signal_handler<H>(&mut self, handler: H)
    where
        H: 'static
            + Fn(
                &Instance,
                &Option<TrapCode>,
                libc::c_int,
                *const siginfo_t,
                *const c_void,
            ) -> SignalBehavior,
    {
        self.signal_handler = Box::new(handler) as Box<SignalHandler>;
    }

    
    
    
    
    
    
    
    pub fn set_fatal_handler(&mut self, handler: fn(&Instance) -> !) {
        self.fatal_handler = handler;
    }

    
    
    
    
    
    
    
    
    pub fn set_c_fatal_handler(&mut self, handler: unsafe extern ""C"" fn(*mut Instance)) {
        self.c_fatal_handler = Some(handler);
    }",0,,
"    pub(crate) fn is_pager(&self) -> bool {
        matches!(self, OutputType::Pager(_))
    }",0,,
"	fn unsubscribe_pending(&self, id: SubscriptionId) -> BoxFuture<bool, Error> {
		let res = self.subscribers.lock().remove(&id).is_some();
		futures::future::ok(res).boxed()
	}",0,,
"fn test_jslt_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        jslt r1, -3, +2
        jslt r1, -2, +1
        jslt r1, -1, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"fn reduce_512(&mut self, l: &[u32; 16]) {
        let (mut c0, mut c1, mut c2): (u32, u32, u32);
        define_ops!(c0, c1, c2);

        let mut c: u64;
        let (n0, n1, n2, n3, n4, n5, n6, n7) = (l[8], l[9], l[10], l[11], l[12], l[13], l[14], l[15]);
        let (m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12): (u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32);
        let (p0, p1, p2, p3, p4, p5, p6, p7, p8): (u32, u32, u32, u32, u32, u32, u32, u32, u32);

        c0 = l[0]; c1 = 0; c2 = 0;
        muladd_fast!(n0, SECP256K1_N_C_0);
        m0 = extract_fast!();
        sumadd_fast!(l[1]);
        muladd!(n1, SECP256K1_N_C_0);
        muladd!(n0, SECP256K1_N_C_1);
        m1 = extract!();
        sumadd!(l[2]);
        muladd!(n2, SECP256K1_N_C_0);
        muladd!(n1, SECP256K1_N_C_1);
        muladd!(n0, SECP256K1_N_C_2);
        m2 = extract!();
        sumadd!(l[3]);
        muladd!(n3, SECP256K1_N_C_0);
        muladd!(n2, SECP256K1_N_C_1);
        muladd!(n1, SECP256K1_N_C_2);
        muladd!(n0, SECP256K1_N_C_3);
        m3 = extract!();
        sumadd!(l[4]);
        muladd!(n4, SECP256K1_N_C_0);
        muladd!(n3, SECP256K1_N_C_1);
        muladd!(n2, SECP256K1_N_C_2);
        muladd!(n1, SECP256K1_N_C_3);
        sumadd!(n0);
        m4 = extract!();
        sumadd!(l[5]);
        muladd!(n5, SECP256K1_N_C_0);
        muladd!(n4, SECP256K1_N_C_1);
        muladd!(n3, SECP256K1_N_C_2);
        muladd!(n2, SECP256K1_N_C_3);
        sumadd!(n1);
        m5 = extract!();
        sumadd!(l[6]);
        muladd!(n6, SECP256K1_N_C_0);
        muladd!(n5, SECP256K1_N_C_1);
        muladd!(n4, SECP256K1_N_C_2);
        muladd!(n3, SECP256K1_N_C_3);
        sumadd!(n2);
        m6 = extract!();
        sumadd!(l[7]);
        muladd!(n7, SECP256K1_N_C_0);
        muladd!(n6, SECP256K1_N_C_1);
        muladd!(n5, SECP256K1_N_C_2);
        muladd!(n4, SECP256K1_N_C_3);
        sumadd!(n3);
        m7 = extract!();
        muladd!(n7, SECP256K1_N_C_1);
        muladd!(n6, SECP256K1_N_C_2);
        muladd!(n5, SECP256K1_N_C_3);
        sumadd!(n4);
        m8 = extract!();
        muladd!(n7, SECP256K1_N_C_2);
        muladd!(n6, SECP256K1_N_C_3);
        sumadd!(n5);
        m9 = extract!();
        muladd!(n7, SECP256K1_N_C_3);
        sumadd!(n6);
        m10 = extract!();
        sumadd_fast!(n7);
        m11 = extract_fast!();
        debug_assert!(c0 <= 1);
        m12 = c0;

        
        
        c0 = m0; c1 = 0; c2 = 0;
        muladd_fast!(m8, SECP256K1_N_C_0);
        p0 = extract_fast!();
        sumadd_fast!(m1);
        muladd!(m9, SECP256K1_N_C_0);
        muladd!(m8, SECP256K1_N_C_1);
        p1 = extract!();
        sumadd!(m2);
        muladd!(m10, SECP256K1_N_C_0);
        muladd!(m9, SECP256K1_N_C_1);
        muladd!(m8, SECP256K1_N_C_2);
        p2 = extract!();
        sumadd!(m3);
        muladd!(m11, SECP256K1_N_C_0);
        muladd!(m10, SECP256K1_N_C_1);
        muladd!(m9, SECP256K1_N_C_2);
        muladd!(m8, SECP256K1_N_C_3);
        p3 = extract!();
        sumadd!(m4);
        muladd!(m12, SECP256K1_N_C_0);
        muladd!(m11, SECP256K1_N_C_1);
        muladd!(m10, SECP256K1_N_C_2);
        muladd!(m9, SECP256K1_N_C_3);
        sumadd!(m8);
        p4 = extract!();
        sumadd!(m5);
        muladd!(m12, SECP256K1_N_C_1);
        muladd!(m11, SECP256K1_N_C_2);
        muladd!(m10, SECP256K1_N_C_3);
        sumadd!(m9);
        p5 = extract!();
        sumadd!(m6);
        muladd!(m12, SECP256K1_N_C_2);
        muladd!(m11, SECP256K1_N_C_3);
        sumadd!(m10);
        p6 = extract!();
        sumadd_fast!(m7);
        muladd_fast!(m12, SECP256K1_N_C_3);
        sumadd_fast!(m11);
        p7 = extract_fast!();
        p8 = c0 + m12;
        debug_assert!(p8 <= 2);

        
        
        c = p0 as u64 + SECP256K1_N_C_0 as u64 * p8 as u64;
        self.0[0] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p1 as u64 + SECP256K1_N_C_1 as u64 * p8 as u64;
        self.0[1] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p2 as u64 + SECP256K1_N_C_2 as u64 * p8 as u64;
        self.0[2] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p3 as u64 + SECP256K1_N_C_3 as u64 * p8 as u64;
        self.0[3] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p4 as u64 + p8 as u64;
        self.0[4] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p5 as u64;
        self.0[5] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p6 as u64;
        self.0[6] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p7 as u64;
        self.0[7] = (c & 0xFFFFFFFF) as u32; c >>= 32;

        let overflow = self.check_overflow();
        debug_assert!(c + if overflow { 1 } else { 0 } <= 1);
        let _ = self.reduce(c + if overflow { 1 } else { 0 } == 1);
    }",0,,
"    pub fn set_srcloc(&mut self, srcloc: SourceLoc) {
        self.cur_srcloc = srcloc;
    }",0,,
"pub fn set_b32(&mut self, b32: &[u8; 32]) -> bool {
        self.0[0] = (b32[31] as u32) | ((b32[30] as u32) << 8) | ((b32[29] as u32) << 16) | ((b32[28] as u32) << 24);
        self.0[1] = (b32[27] as u32) | ((b32[26] as u32) << 8) | ((b32[25] as u32) << 16) | ((b32[24] as u32) << 24);
        self.0[2] = (b32[23] as u32) | ((b32[22] as u32) << 8) | ((b32[21] as u32) << 16) | ((b32[20] as u32) << 24);
        self.0[3] = (b32[19] as u32) | ((b32[18] as u32) << 8) | ((b32[17] as u32) << 16) | ((b32[16] as u32) << 24);
        self.0[4] = (b32[15] as u32) | ((b32[14] as u32) << 8) | ((b32[13] as u32) << 16) | ((b32[12] as u32) << 24);
        self.0[5] = (b32[11] as u32) | ((b32[10] as u32) << 8) | ((b32[9] as u32) << 16) | ((b32[8] as u32) << 24);
        self.0[6] = (b32[7] as u32) | ((b32[6] as u32) << 8) | ((b32[5] as u32) << 16) | ((b32[4] as u32) << 24);
        self.0[7] = (b32[3] as u32) | ((b32[2] as u32) << 8) | ((b32[1] as u32) << 16) | ((b32[0] as u32) << 24);

        let overflow = self.check_overflow();
        self.reduce(overflow)
    }",0,,
"fn _read_to_string(cursor: &mut Cursor<Vec<u8>>) -> String {
        let mut s = String::new();
        cursor.seek(SeekFrom::Start(0)).unwrap();
        cursor.read_to_string(&mut s).unwrap();
        s
    }",0,,
"    fn fill(&self, goto: InstPtr) -> Inst {
        match *self {
            InstHole::Save { slot } => {
                Inst::Save(InstSave { goto: goto, slot: slot })
            }
            InstHole::EmptyLook { look } => {
                Inst::EmptyLook(InstEmptyLook { goto: goto, look: look })
            }
            InstHole::Char { c } => Inst::Char(InstChar { goto: goto, c: c }),
            InstHole::Ranges { ref ranges } => Inst::Ranges(InstRanges {
                goto: goto,
                ranges: ranges.clone().into_boxed_slice(),
            }),
            InstHole::Bytes { start, end } => {
                Inst::Bytes(InstBytes { goto: goto, start: start, end: end })
            }
        }
    }",0,,
"    pub(crate) fn span(&self) -> Span {
        self.tokens
            .first()
            .map(|&(_, span)| span)
            .unwrap_or_else(|| (self.source.len()..self.source.len()).into())
    }",0,,
"    pub(super) fn is_empty(&self) -> bool {
        self.tokens.is_empty()
    }",0,,
"fn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {
		let max_length = max(base_length, mod_length);
		let mut words = max_length / 8;
		if max_length % 8 > 0 {
			words += 1;
		}

		
		words * words
	}",1,7,		// TODO: prevent/handle overflow
"fn test_excessive_input() -> std::result::Result<(), PrecompileFailure> {
		let input = hex::decode(
			""1000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001"",
		)
		.expect(""Decode failed"");

		let cost: u64 = 1;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(_) => {
				panic!(""Test not expected to pass"");
			}
			Err(e) => {
				assert_eq!(
					e,
					PrecompileFailure::Error {
						exit_status: ExitError::Other(""unreasonably large base length"".into())
					}
				);
				Ok(())
			}
		}
	}",0,,
"fn test_be16() {
    test_interpreter_and_jit_asm!(
        ""
        ldxh r0, [r1]
        be16 r0
        exit"",
        [0x11, 0x22],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122 } },
        3
    );
}",0,,
"pub fn is_zero(&self) -> bool {
        (self.0[0] | self.0[1] | self.0[2] | self.0[3] | self.0[4] | self.0[5] | self.0[6] | self.0[7]) == 0
    }",0,,
"fn test_jsle_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        jsle r1, -3, +1
        jsle r1, -1, +1
        exit
        mov32 r0, 1
        jsle r1, -2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"fn test_syscall_unknown_static() {
    
    
    
    
    
    
    test_interpreter_and_jit_elf!(
        ""tests/elfs/syscall_static_unknown.so"",
        [],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { matches!(res.unwrap_err(), EbpfError::UnsupportedInstruction(29)) } },
        1
    );
}",0,,
"fn test_err_static_jmp_lddw() {
    test_interpreter_and_jit_asm!(
        ""
        ja 2
        mov r0, r0
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 32
                )
            }
        },
        2
    );
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        mov r1, 0
        mov r2, 0
        lddw r0, 0x1
        ja +2
        lddw r1, 0x1
        lddw r2, 0x1
        add r1, r2
        add r0, r1
        exit
        "",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2 } },
        9
    );
    test_interpreter_and_jit_asm!(
        ""
        jeq r0, 0, 1
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 31
                )
            }
        },
        2
    );
    test_interpreter_and_jit_asm!(
        ""
        call 3
        mov r0, r0
        mov r0, r0
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 33
                )
            }
        },
        2
    );
}",0,,
"	fn generate_web_proxy_token(&self) -> Result<String, Error> {
		Ok(self.signer.generate_web_proxy_access_token())
	}",1,"0,1","	fn generate_web_proxy_token(&self) -> Result<String, Error> {/~/		Ok(self.signer.generate_web_proxy_access_token())"
"pub fn validate_transaction_in_block(
		origin: H160,
		transaction: &Transaction,
	) -> Result<(), TransactionValidityError> {
		let transaction_data: TransactionData = transaction.into();

		let (base_fee, _) = T::FeeCalculator::min_gas_price();
		let (who, _) = pallet_evm::Pallet::<T>::account_basic(&origin);

		let _ = CheckEvmTransaction::<InvalidTransactionWrapper>::new(
			CheckEvmTransactionConfig {
				evm_config: T::config(),
				block_gas_limit: T::BlockGasLimit::get(),
				base_fee,
				chain_id: T::ChainId::get(),
				is_transactional: true,
			},
			transaction_data.into(),
		)
		.validate_in_block_for(&who)
		.and_then(|v| v.with_chain_id())
		.and_then(|v| v.with_base_fee())
		.and_then(|v| v.with_balance_for(&who))
		.map_err(|e| TransactionValidityError::Invalid(e.0))?;

		Ok(())
	}",0,,
"fn test_ja() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 1
        ja +1
        mov r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        3
    );
}",0,,
"fn wasmtime_call_conv(isa: &dyn TargetIsa) -> CallConv {
    match isa.triple().default_calling_convention() {
        Ok(CallingConvention::AppleAarch64) => CallConv::WasmtimeAppleAarch64,
        Ok(CallingConvention::SystemV) | Err(()) => CallConv::WasmtimeSystemV,
        Ok(CallingConvention::WindowsFastcall) => CallConv::WasmtimeFastcall,
        Ok(unimp) => unimplemented!(""calling convention: {:?}"", unimp),
    }
}",0,,
"fn test_ldinddw() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x2
        ldinddw r1, 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xccbbaa9988776655 } },
        3
    );
}",0,,
"    pub(crate) fn at(self, span: Span) -> ParseError {
        ParseError { kind: self, span: Some(span) }
    }",0,,
"fn send_command(hotkey: config::Hotkey) {
    log::info!(""Hotkey pressed: {:#?}"", hotkey);
    if let Err(e) = sock_send(&hotkey.command) {
        log::error!(""Failed to send command to swhks through IPC."");
        log::error!(""Please make sure that swhks is running."");
        log::error!(""Err: {:#?}"", e)
    }
}",0,,
"fn block_hash(number: u32) -> H256 {
		BlockHash::<T>::get(U256::from(number))
	}",0,,
"fn lookup_stack_map(&self, pc: usize) -> Option<&StackMap> {
        let text_offset = pc - self.start;
        let (index, func_offset) = self.module.func_by_text_offset(text_offset)?;
        let info = self.module.func_info(index);

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        let index = match info
            .stack_maps
            .binary_search_by_key(&func_offset, |i| i.code_offset)
        {
            
            Ok(i) => i,

            
            
            
            
            
            Err(0) => return None,

            Err(i) => i - 1,
        };

        Some(&info.stack_maps[index].stack_map)
    }",1,"6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,51,54,55,56,57,58,60","///~/        // Because GC safepoints are technically only associated with a single/~/        // PC, we should ideally only care about `Ok(index)` values returned/~/        // from the binary search. However, safepoints are inserted right before/~/        // calls, and there are two things that can disturb the PC/offset/~/        // associated with the safepoint versus the PC we actually use to query/~/        // for the stack map:/~/        ///~/        // 1. The `backtrace` crate gives us the PC in a frame that will be/~/        //    *returned to*, and where execution will continue from, rather than/~/        //    the PC of the call we are currently at. So we would need to/~/        //    disassemble one instruction backwards to query the actual PC for/~/        //    the stack map./~/        ///~/        //    TODO: One thing we *could* do to make this a little less error/~/        //    prone, would be to assert/check that the nearest GC safepoint/~/        //    found is within `max_encoded_size(any kind of call instruction)`/~/        //    our queried PC for the target architecture./~/        ///~/        // 2. Cranelift's stack maps only handle the stack, not/~/        //    registers. However, some references that are arguments to a call/~/        //    may need to be in registers. In these cases, what Cranelift will/~/        //    do is:/~/        ///~/        //      a. spill all the live references,/~/        //      b. insert a GC safepoint for those references,/~/        //      c. reload the references into registers, and finally/~/        //      d. make the call./~/        ///~/        //    Step (c) adds drift between the GC safepoint and the location of/~/        //    the call, which is where we actually walk the stack frame and/~/        //    collect its live references./~/        ///~/        //    Luckily, the spill stack slots for the live references are still/~/        //    up to date, so we can still find all the on-stack roots./~/        //    Furthermore, we do not have a moving GC, so we don't need to worry/~/        //    whether the following code will reuse the references in registers/~/        //    (which would not have been updated to point to the moved objects)/~/        //    or reload from the stack slots (which would have been updated to/~/        //    point to the moved objects)./~//~/            // Exact hit./~/            // `Err(0)` means that the associated stack map would have been the/~/            // first element in the array if this pc had an associated stack/~/            // map, but this pc does not have an associated stack map. This can/~/            // only happen inside a Wasm frame if there are no live refs at this/~/            // pc./~/"
"fn try_read(r: io::Result<usize>) -> io::Result<Option<usize>> {
    match r {
        Ok(len) => Ok(Some(len)),
        Err(e) => {
            if e.kind() == io::ErrorKind::WouldBlock {
                Ok(None)
            } else {
                Err(e)
            }
        }
    }
}",0,,
"fn set_word_boundary(&mut self) {
        
        
        let iswb = is_word_byte;
        let mut b1: u16 = 0;
        let mut b2: u16;
        while b1 <= 255 {
            b2 = b1 + 1;
            while b2 <= 255 && iswb(b1 as u8) == iswb(b2 as u8) {
                b2 += 1;
            }
            self.set_range(b1 as u8, (b2 - 1) as u8);
            b1 = b2;
        }
    }",0,,
"fn store_block(post_log: bool, block_number: U256) {
		let mut transactions = Vec::new();
		let mut statuses = Vec::new();
		let mut receipts = Vec::new();
		let mut logs_bloom = Bloom::default();
		let mut cumulative_gas_used = U256::zero();
		for (transaction, status, receipt) in Pending::<T>::get() {
			transactions.push(transaction);
			statuses.push(status);
			receipts.push(receipt.clone());
			let (logs, used_gas) = match receipt {
				Receipt::Legacy(d) | Receipt::EIP2930(d) | Receipt::EIP1559(d) => {
					(d.logs.clone(), d.used_gas)
				}
			};
			cumulative_gas_used = used_gas;
			Self::logs_bloom(logs, &mut logs_bloom);
		}

		let ommers = Vec::<ethereum::Header>::new();
		let receipts_root = ethereum::util::ordered_trie_root(receipts.iter().map(rlp::encode));
		let partial_header = ethereum::PartialHeader {
			parent_hash: if block_number > U256::zero() {
				BlockHash::<T>::get(block_number - 1)
			} else {
				H256::default()
			},
			beneficiary: pallet_evm::Pallet::<T>::find_author(),
			state_root: T::StateRoot::get(),
			receipts_root,
			logs_bloom,
			difficulty: U256::zero(),
			number: block_number,
			gas_limit: T::BlockGasLimit::get(),
			gas_used: cumulative_gas_used,
			timestamp: UniqueSaturatedInto::<u64>::unique_saturated_into(
				pallet_timestamp::Pallet::<T>::get(),
			),
			extra_data: Vec::new(),
			mix_hash: H256::default(),
			nonce: H64::default(),
		};
		let block = ethereum::Block::new(partial_header, transactions.clone(), ommers);

		CurrentBlock::<T>::put(block.clone());
		CurrentReceipts::<T>::put(receipts.clone());
		CurrentTransactionStatuses::<T>::put(statuses.clone());
		BlockHash::<T>::insert(block_number, block.header.hash());

		if post_log {
			let digest = DigestItem::Consensus(
				FRONTIER_ENGINE_ID,
				PostLog::Hashes(fp_consensus::Hashes::from_block(block)).encode(),
			);
			frame_system::Pallet::<T>::deposit_log(digest);
		}
	}",0,,
"pub unsafe fn from_raw(ptr: *mut u8) -> Self {
        debug_assert!(!ptr.is_null());
        VMExternRef(NonNull::new_unchecked(ptr).cast())
    }",0,,
"fn test_stxb_chain() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxb r9, [r0+0]
        stxb [r0+1], r9
        ldxb r8, [r0+1]
        stxb [r0+2], r8
        ldxb r7, [r0+2]
        stxb [r0+3], r7
        ldxb r6, [r0+3]
        stxb [r0+4], r6
        ldxb r5, [r0+4]
        stxb [r0+5], r5
        ldxb r4, [r0+5]
        stxb [r0+6], r4
        ldxb r3, [r0+6]
        stxb [r0+7], r3
        ldxb r2, [r0+7]
        stxb [r0+8], r2
        ldxb r1, [r0+8]
        stxb [r0+9], r1
        ldxb r0, [r0+9]
        exit"",
        [
            0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2a } },
        21
    );
}",0,,
"fn send_command(hotkey: config::Hotkey) {
    log::info!(""Hotkey pressed: {:#?}"", hotkey);
    if let Err(e) = sock_send(&hotkey.command) {
        log::error!(""Failed to send command to swhks through IPC."");
        log::error!(""Please make sure that swhks is running."");
        log::error!(""Err: {:#?}"", e)
    }
}",0,,
"fn parse_less_version(output: &[u8]) -> Option<usize> {
    if output.starts_with(b""less "") {
        let version = std::str::from_utf8(&output[5..]).ok()?;
        let end = version.find(|c: char| !c.is_ascii_digit())?;
        version[..end].parse::<usize>().ok()
    } else {
        None
    }
}",0,,
"pub fn serialize_compressed(&self) -> [u8; util::COMPRESSED_PUBLIC_KEY_SIZE] {
        use util::{TAG_PUBKEY_ODD, TAG_PUBKEY_EVEN};

        debug_assert!(!self.0.is_infinity());

        let mut ret = [0u8; 33];
        let mut elem = self.0.clone();

        elem.x.normalize_var();
        elem.y.normalize_var();
        elem.x.fill_b32(array_mut_ref!(ret, 1, 32));
        ret[0] = if elem.y.is_odd() {
            TAG_PUBKEY_ODD
        } else {
            TAG_PUBKEY_EVEN
        };

        ret
    }",0,,
"fn many_live_refs() -> anyhow::Result<()> {
    let mut wat = r#""
        (module
            ;; Make new `externref`s.
            (import """" ""make_ref"" (func $make_ref (result externref)))

            ;; Observe an `externref` so it is kept live.
            (import """" ""observe_ref"" (func $observe_ref (param externref)))

            (func (export ""many_live_refs"")
    ""#
    .to_string();

    
    
    const NUM_LIVE_REFS: usize = 1024;

    
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $make_ref)\n"");
    }

    
    
    
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $observe_ref)\n"");
    }

    wat.push_str(
        ""
            ) ;; func
        ) ;; module
        "",
    );

    let (mut store, module) = ref_types_module(&wat)?;

    let live_refs = Arc::new(AtomicUsize::new(0));

    let make_ref = Func::wrap(&mut store, {
        let live_refs = live_refs.clone();
        move || Some(ExternRef::new(CountLiveRefs::new(live_refs.clone())))
    });

    let observe_ref = Func::wrap(&mut store, |r: Option<ExternRef>| {
        let r = r.unwrap();
        let r = r.data().downcast_ref::<CountLiveRefs>().unwrap();
        assert!(r.live_refs.load(SeqCst) > 0);
    });

    let instance = Instance::new(&mut store, &module, &[make_ref.into(), observe_ref.into()])?;
    let many_live_refs = instance.get_func(&mut store, ""many_live_refs"").unwrap();

    many_live_refs.call(&mut store, &[])?;

    store.gc();
    assert_eq!(live_refs.load(SeqCst), 0);

    return Ok(());

    struct CountLiveRefs {
        live_refs: Arc<AtomicUsize>,
    }

    impl CountLiveRefs {
        fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }
    }

    impl Drop for CountLiveRefs {
        fn drop(&mut self) {
            self.live_refs.fetch_sub(1, SeqCst);
        }
    }
}",0,,
"pub fn add_in_place(&mut self, a: &Scalar, b: &Scalar) -> bool {
        let mut overflow: u64;
        let mut t: u64 = (a.0[0] as u64) + (b.0[0] as u64);
        self.0[0] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[1] as u64) + (b.0[1] as u64);
        self.0[1] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[2] as u64) + (b.0[2] as u64);
        self.0[2] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[3] as u64) + (b.0[3] as u64);
        self.0[3] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[4] as u64) + (b.0[4] as u64);
        self.0[4] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[5] as u64) + (b.0[5] as u64);
        self.0[5] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[6] as u64) + (b.0[6] as u64);
        self.0[6] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[7] as u64) + (b.0[7] as u64);
        self.0[7] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        overflow = t + if self.check_overflow() { 1 } else { 0 };
        debug_assert!(overflow == 0 || overflow == 1);
        overflow = overflow | if self.reduce(overflow == 1) { 1 } else { 0 };
        return overflow == 1;
    }",0,,
"fn test_neg64() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 2
        neg r0
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xfffffffffffffffe } },
        3
    );
}",0,,
"fn c_class_bytes(
        &mut self,
        ranges: &[hir::ClassBytesRange],
    ) -> ResultOrEmpty {
        debug_assert!(!ranges.is_empty());

        let first_split_entry = self.insts.len();
        let mut holes = vec![];
        let mut prev_hole = Hole::None;
        for r in &ranges[0..ranges.len() - 1] {
            self.fill_to_next(prev_hole);
            let split = self.push_split_hole();
            let next = self.insts.len();
            self.byte_classes.set_range(r.start(), r.end());
            holes.push(self.push_hole(InstHole::Bytes {
                start: r.start(),
                end: r.end(),
            }));
            prev_hole = self.fill_split(split, Some(next), None);
        }
        let next = self.insts.len();
        let r = &ranges[ranges.len() - 1];
        self.byte_classes.set_range(r.start(), r.end());
        holes.push(
            self.push_hole(InstHole::Bytes { start: r.start(), end: r.end() }),
        );
        self.fill(prev_hole, next);
        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))
    }",0,,
"fn test_jslt_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        mov r2, -3
        mov r3, -1
        jslt r1, r1, +2
        jslt r1, r2, +1
        jslt r1, r3, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        9
    );
}",0,,
"fn get() -> H256 {
		H256::decode(&mut &sp_io::storage::root()[..])
			.expect(""Node is configured to use the same hash; qed"")
	}",0,,
"fn test_err_exit_capped() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x1
        lsh64 r1, 0x20
        or64 r1, 0x20
        callx r1
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count) if pc == 34 && initial_insn_count == 5
                )
            }
        },
        5
    );
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x1
        lsh64 r1, 0x20
        or64 r1, 0x20
        callx r1
        mov r0, r0
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count) if pc == 35 && initial_insn_count == 6
                )
            }
        },
        6
    );
    test_interpreter_and_jit_asm!(
        ""
        call 0
        mov r0, r0
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count) if pc == 32 && initial_insn_count == 3
                )
            }
        },
        3
    );
}",0,,
"fn integer_slice(full: &[u8; 33]) -> &[u8] {
            let mut len = 33;
            while len > 1 &&
                full[full.len() - len] == 0 &&
                full[full.len() - len + 1] < 0x80
            {
                len -= 1;
            }
            &full[(full.len() - len)..]
        }",0,,
"fn table_drops_externref() -> anyhow::Result<()> {
    test_engine(&Engine::default())?;

    if !skip_pooling_allocator_tests() {
        test_engine(&Engine::new(
            Config::new().allocation_strategy(InstanceAllocationStrategy::pooling()),
        )?)?;
    }

    return Ok(());

    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Table::new(
            &mut store,
            TableType::new(ValType::ExternRef, 1, None),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
            (module
                (table 1 externref)

                (func (export ""run"") (param externref)
                    i32.const 0
                    local.get 0
                    table.set 0
                )
            )
        ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }
}",0,,
"    pub fn dfa(mut self, yes: bool) -> Self {
        self.compiled.is_dfa = yes;
        self
    }",0,,
"    pub fn run(&mut self, entrypoint: &str, args: &[Val]) -> Result<RunResult, Error> {
        let func = self.module.get_export_func(entrypoint)?;
        Ok(self.run_func(func, &args, false, None)?.unwrap())
    }",0,,
"pub fn list_syntax_themes() -> std::io::Result<()> {
    let stdout = io::stdout();
    let mut stdout = stdout.lock();
    if atty::is(atty::Stream::Stdout) {
        _list_syntax_themes_for_humans(&mut stdout)
    } else {
        _list_syntax_themes_for_machines(&mut stdout)
    }
}",0,,
"fn test_div64_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xc
        lsh r0, 32
        div r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x300000000 } },
        4
    );
}",0,,
"fn test_list_syntax_themes_for_machines() {
        let mut writer = Cursor::new(vec![0; 512]);
        _list_syntax_themes_for_machines(&mut writer).unwrap();
        let mut s = String::new();
        writer.seek(SeekFrom::Start(0)).unwrap();
        writer.read_to_string(&mut s).unwrap();
        assert!(s.contains(""light	GitHub\n""));
        assert!(s.contains(""dark	Dracula\n""));
    }",0,,
"fn correct_and_deposit_fee(
		who: &H160,
		corrected_fee: U256,
		base_fee: U256,
		already_withdrawn: Self::LiquidityInfo,
	) -> Self::LiquidityInfo {
		if let Some(paid) = already_withdrawn {
			let account_id = T::AddressMapping::into_account_id(*who);

			
			let refund_amount = paid
				.peek()
				.saturating_sub(corrected_fee.low_u128().unique_saturated_into());
			
			
			
			let refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)
				.unwrap_or_else(|_| C::PositiveImbalance::zero());

			
			
			
			
			let refund_imbalance = if C::minimum_balance().is_zero()
				&& refund_amount > C::Balance::zero()
				&& C::total_balance(&account_id).is_zero()
			{
				
				
				match C::make_free_balance_be(&account_id, refund_amount) {
					SignedImbalance::Positive(p) => p,
					_ => C::PositiveImbalance::zero(),
				}
			} else {
				refund_imbalance
			};

			
			let adjusted_paid = paid
				.offset(refund_imbalance)
				.same()
				.unwrap_or_else(|_| C::NegativeImbalance::zero());

			let (base_fee, tip) = adjusted_paid.split(base_fee.low_u128().unique_saturated_into());
			
			OU::on_unbalanced(base_fee);
			return Some(tip);
		}
		None
	}",1,"12,43",".saturating_sub(corrected_fee.low_u128().unique_saturated_into());/~/			let (base_fee, tip) = adjusted_paid.split(base_fee.low_u128().unique_saturated_into());"
"	fn registrar(&self) -> Result<Address, String> {
		self.client.additional_params().get(""registrar"")
			 .ok_or_else(|| ""Registrar not defined."".into())
			 .and_then(|registrar| {
				 registrar.parse().map_err(|e| format!(""Invalid registrar address: {:?}"", e))
			 })
	}",0,,
"	fn default() -> Self {
		let data_dir = default_data_path();
		Configuration {
			enabled: true,
			dapps_path: replace_home(&data_dir, ""$BASE/dapps"").into(),
			extra_dapps: vec![],
		}
	}",0,,
"fn gee_i_sure_hope_refcounting_is_atomic() -> anyhow::Result<()> {
    let mut config = Config::new();
    config.wasm_reference_types(true);
    config.interruptable(true);
    let engine = Engine::new(&config)?;
    let mut store = Store::new(&engine, ());
    let module = Module::new(
        &engine,
        r#""
            (module
                (global (mut externref) (ref.null extern))
                (table 1 externref)

                (func (export ""run"") (param externref)
                    local.get 0
                    global.set 0
                    i32.const 0
                    local.get 0
                    table.set 0
                    loop
                        global.get 0
                        global.set 0

                        i32.const 0
                        i32.const 0
                        table.get
                        table.set

                        local.get 0
                        call $f

                        br 0
                    end
                )

                (func $f (param externref))
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;

    let flag = Arc::new(AtomicBool::new(false));
    let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
    let externref2 = externref.clone();
    let handle = store.interrupt_handle()?;

    let child = std::thread::spawn(move || run.call(&mut store, Some(externref2)));

    for _ in 0..10000 {
        drop(externref.clone());
    }
    handle.interrupt();

    assert!(child.join().unwrap().is_err());
    assert!(!flag.load(SeqCst));
    assert_eq!(externref.strong_count(), 1);
    drop(externref);
    assert!(flag.load(SeqCst));

    Ok(())
}",0,,
"fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Table::new(
            &mut store,
            TableType::new(ValType::ExternRef, 1, None),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
            (module
                (table 1 externref)

                (func (export ""run"") (param externref)
                    i32.const 0
                    local.get 0
                    table.set 0
                )
            )
        ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }",0,,
"fn on_finalize(n: T::BlockNumber) {
			<Pallet<T>>::store_block(
				fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
				U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(
					frame_system::Pallet::<T>::block_number(),
				)),
			);
			
			let block_hash_count = T::BlockHashCount::get();
			let to_remove = n
				.saturating_sub(block_hash_count)
				.saturating_sub(One::one());
			
			if !to_remove.is_zero() {
				<BlockHash<T>>::remove(U256::from(
					UniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),
				));
			}
		}",0,,
"fn block_hash(number: u32) -> H256 {
		BlockHash::<T>::get(U256::from(number))
	}",0,,
"    pub fn yielded_ref(&self) -> Result<&YieldedVal, Error> {
        match self {
            RunResult::Returned(_) => Err(Error::InstanceNotYielded),
            RunResult::Yielded(yv) => Ok(yv),
        }
    }",0,,
	fn is_major_importing(&self) -> bool { self() },0,,
"pub fn translate(
        mut self,
        data: &'data [u8],
    ) -> WasmResult<(usize, Vec<ModuleTranslation<'data>>, TypeTables)> {
        let mut validator = Validator::new();
        validator.wasm_features(self.features);

        for payload in Parser::new(0).parse_all(data) {
            self.translate_payload(&mut validator, payload?)?;
        }

        assert!(self.results.len() > 0);
        Ok((self.results.len() - 1, self.results, self.types))
    }",0,,
"pub fn func_offset(&self) -> usize {
        match self.instr.file_offset() {
            Some(i) => (i - self.func_start.file_offset().unwrap()) as usize,
            None => u32::MAX as usize,
        }
    }",0,,
"fn test_reloc_64_relative_data_high_vaddr() {
    
    
    
    
    
    
    
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative_data_high_vaddr.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x20 } },
        3
    );
}",0,,
"    pub fn null() -> Val {
        Val::ExternRef(None)
    }",0,,
"    fn c_repeat_zero_or_more(
        &mut self,
        expr: &Hir,
        greedy: bool,
    ) -> ResultOrEmpty {
        let split_entry = self.insts.len();
        let split = self.push_split_hole();
        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {
            Some(p) => p,
            None => return self.pop_split_hole(),
        };

        self.fill(hole_rep, split_entry);
        let split_hole = if greedy {
            self.fill_split(split, Some(entry_rep), None)
        } else {
            self.fill_split(split, None, Some(entry_rep))
        };
        Ok(Some(Patch { hole: split_hole, entry: split_entry }))
    }",0,,
"    pub fn get_func_name(&self, func_index: FuncIndex) -> Option<&str> {
        self.function_names.get(func_index).map(String::as_ref)
    }",0,,
"    pub fn vreg_type(&self, vreg: VirtualReg) -> Type {
        self.vreg_types[vreg.get_index()]
    }",0,,
"    fn register(&self, poll: &mut mio::Poll) {
        poll.register(&self.socket,
                      self.token,
                      self.event_set(),
                      mio::PollOpt::level() | mio::PollOpt::oneshot())
            .unwrap();

        if self.back.is_some() {
            poll.register(self.back.as_ref().unwrap(),
                          self.token,
                          mio::Ready::readable(),
                          mio::PollOpt::level() | mio::PollOpt::oneshot())
                .unwrap();
        }
    }",0,,
"    pub fn succs(&self, block: BlockIndex) -> &[BlockIx] {
        let (start, end) = self.block_succ_range[block as usize];
        &self.block_succs[start..end]
    }",0,,
"fn as_ref(&self) -> &[u8] {
        &self.0
    }",0,,
"	pub fn list(&self) -> Vec<apps::App> {
		self.endpoints.iter().filter_map(|(ref k, ref e)| {
			e.info().map(|ref info| apps::App::from_info(k, info))
		}).collect()
	}",0,,
"fn detect_invalid_last_symbol_every_possible_three_symbols() {
        let mut base64_to_bytes = ::std::collections::HashMap::new();

        let mut bytes = [0_u8; 2];
        for b1 in 0_u16..256 {
            bytes[0] = b1 as u8;
            for b2 in 0_u16..256 {
                bytes[1] = b2 as u8;
                let mut b64 = vec![0_u8; 4];
                assert_eq!(4, encode_config_slice(&bytes, STANDARD, &mut b64[..]));
                let mut v = ::std::vec::Vec::with_capacity(2);
                v.extend_from_slice(&bytes[..]);

                assert!(base64_to_bytes.insert(b64, v).is_none());
            }
        }

        

        let mut symbols = [0_u8; 4];
        for &s1 in STANDARD.char_set.encode_table().iter() {
            symbols[0] = s1;
            for &s2 in STANDARD.char_set.encode_table().iter() {
                symbols[1] = s2;
                for &s3 in STANDARD.char_set.encode_table().iter() {
                    symbols[2] = s3;
                    symbols[3] = PAD_BYTE;

                    match base64_to_bytes.get(&symbols[..]) {
                        Some(bytes) => {
                            assert_eq!(Ok(bytes.to_vec()), decode_config(&symbols, STANDARD))
                        }
                        None => assert_eq!(
                            Err(DecodeError::InvalidLastSymbol(2, s3)),
                            decode_config(&symbols[..], STANDARD)
                        ),
                    }
                }
            }
        }
    }",0,,
"    fn insns(&self) -> &[I] {
        &self.insts[..]
    }",0,,
"fn execute<'config, 'precompiles, F, R>(
		source: H160,
		value: U256,
		gas_limit: u64,
		max_fee_per_gas: Option<U256>,
		max_priority_fee_per_gas: Option<U256>,
		config: &'config evm::Config,
		precompiles: &'precompiles T::PrecompilesType,
		is_transactional: bool,
		f: F,
	) -> Result<ExecutionInfo<R>, RunnerError<Error<T>>>
	where
		F: FnOnce(
			&mut StackExecutor<
				'config,
				'precompiles,
				SubstrateStackState<'_, 'config, T>,
				T::PrecompilesType,
			>,
		) -> (ExitReason, R),
	{
		let (base_fee, weight) = T::FeeCalculator::min_gas_price();
		let max_fee_per_gas = match (max_fee_per_gas, is_transactional) {
			(Some(max_fee_per_gas), _) => max_fee_per_gas,
			
			
			(None, false) => Default::default(),
			
			_ => {
				return Err(RunnerError {
					error: Error::<T>::GasPriceTooLow,
					weight,
				})
			}
		};

		
		let total_fee = max_fee_per_gas
			.checked_mul(U256::from(gas_limit))
			.ok_or(RunnerError {
				error: Error::<T>::FeeOverflow,
				weight,
			})?;

		
		let fee = T::OnChargeTransaction::withdraw_fee(&source, total_fee)
			.map_err(|e| RunnerError { error: e, weight })?;

		
		let vicinity = Vicinity {
			gas_price: base_fee,
			origin: source,
		};

		let metadata = StackSubstateMetadata::new(gas_limit, config);
		let state = SubstrateStackState::new(&vicinity, metadata);
		let mut executor = StackExecutor::new_with_precompiles(state, config, precompiles);

		let (reason, retv) = f(&mut executor);

		
		let used_gas = U256::from(executor.used_gas());
		let actual_fee = if let Some(max_priority_fee) = max_priority_fee_per_gas {
			let actual_priority_fee = max_fee_per_gas
				.saturating_sub(base_fee)
				.min(max_priority_fee)
				.saturating_mul(used_gas);
			executor
				.fee(base_fee)
				.checked_add(actual_priority_fee)
				.unwrap_or_else(U256::max_value)
		} else {
			executor.fee(base_fee)
		};
		log::debug!(
			target: ""evm"",
			""Execution {:?} [source: {:?}, value: {}, gas_limit: {}, actual_fee: {}, is_transactional: {}]"",
			reason,
			source,
			value,
			gas_limit,
			actual_fee,
			is_transactional
		);
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		let actual_priority_fee = T::OnChargeTransaction::correct_and_deposit_fee(
			&source,
			
			actual_fee,
			
			executor.fee(base_fee),
			
			fee,
		);
		T::OnChargeTransaction::pay_priority_fee(actual_priority_fee);

		let state = executor.into_state();

		for address in state.substate.deletes {
			log::debug!(
				target: ""evm"",
				""Deleting account at {:?}"",
				address
			);
			Pallet::<T>::remove_account(&address)
		}

		for log in &state.substate.logs {
			log::trace!(
				target: ""evm"",
				""Inserting log for {:?}, topics ({}) {:?}, data ({}): {:?}]"",
				log.address,
				log.topics.len(),
				log.topics,
				log.data.len(),
				log.data
			);
			Pallet::<T>::deposit_event(Event::<T>::Log(Log {
				address: log.address,
				topics: log.topics.clone(),
				data: log.data.clone(),
			}));
		}

		Ok(ExecutionInfo {
			value: retv,
			exit_reason: reason,
			used_gas,
			logs: state.substate.logs,
		})
	}",0,,
"fn new_chunk(size: usize) -> Box<[UnsafeCell<Option<VMExternRef>>]> {
        assert!(size >= Self::CHUNK_SIZE);
        (0..size).map(|_| UnsafeCell::new(None)).collect()
    }",0,,
"fn test_stb() {
    test_interpreter_and_jit_asm!(
        ""
        stb [r1+2], 0x11
        ldxb r0, [r1+2]
        exit"",
        [0xaa, 0xbb, 0xff, 0xcc, 0xdd],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11 } },
        3
    );
}",0,,
"fn value_type(isa: &dyn TargetIsa, ty: WasmType) -> ir::types::Type {
    match ty {
        WasmType::I32 => ir::types::I32,
        WasmType::I64 => ir::types::I64,
        WasmType::F32 => ir::types::F32,
        WasmType::F64 => ir::types::F64,
        WasmType::V128 => ir::types::I8X16,
        WasmType::FuncRef | WasmType::ExternRef => reference_type(ty, isa.pointer_type()),
        WasmType::ExnRef => unimplemented!(),
    }
}",0,,
"fn ref_count_is_at_correct_offset() {
        let s = ""hi"";
        let s: &(dyn Any + Send + Sync) = &s as _;
        let s: *const (dyn Any + Send + Sync) = s as _;
        let s: *mut (dyn Any + Send + Sync) = s as _;

        let extern_data = VMExternData {
            ref_count: AtomicUsize::new(0),
            value_ptr: NonNull::new(s).unwrap(),
        };

        let extern_data_ptr = &extern_data as *const _;
        let ref_count_ptr = &extern_data.ref_count as *const _;

        let actual_offset = (ref_count_ptr as usize) - (extern_data_ptr as usize);

        let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {
            ptr: 8,
            num_signature_ids: 0,
            num_imported_functions: 0,
            num_imported_tables: 0,
            num_imported_memories: 0,
            num_imported_globals: 0,
            num_defined_functions: 0,
            num_defined_tables: 0,
            num_defined_memories: 0,
            num_defined_globals: 0,
        });
        assert_eq!(
            offsets.vm_extern_data_ref_count(),
            actual_offset.try_into().unwrap(),
        );
    }",0,,
"pub fn fetch_xdg_config_path() -> std::path::PathBuf {
    let config_file_path: std::path::PathBuf = match env::var(""XDG_CONFIG_HOME"") {
        Ok(val) => {
            log::debug!(""XDG_CONFIG_HOME exists: {:#?}"", val);
            Path::new(&val).join(""swhkd/swhkdrc"")
        }
        Err(_) => {
            log::error!(""XDG_CONFIG_HOME has not been set."");
            Path::new(""/etc/swhkd/swhkdrc"").to_path_buf()
        }
    };
    config_file_path
}",0,,
"pub fn spectest(fuzz_config: crate::generators::Config, test: crate::generators::SpecTest) {
    crate::init_fuzzing();
    log::debug!(""running {:?} with {:?}"", test.file, fuzz_config);
    let mut config = fuzz_config.to_wasmtime();
    config.wasm_memory64(false);
    config.wasm_reference_types(false);
    config.wasm_bulk_memory(false);
    config.wasm_module_linking(false);
    config.wasm_multi_memory(false);
    let mut store = create_store(&Engine::new(&config).unwrap());
    if fuzz_config.consume_fuel {
        store.add_fuel(u64::max_value()).unwrap();
    }
    let mut wast_context = WastContext::new(store);
    wast_context.register_spectest().unwrap();
    wast_context
        .run_buffer(test.file, test.contents.as_bytes())
        .unwrap();
}",0,,
"pub fn parse_slice(p: &[u8]) -> Result<SecretKey, Error> {
        if p.len() != util::SECRET_KEY_SIZE {
            return Err(Error::InvalidInputLength);
        }

        let mut a = [0; 32];
        a.copy_from_slice(p);
        Self::parse(&a)
    }",0,,
"fn parse_chars_or_range<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, CharGroup> {
        
        
        let span1 = input.span();
        let (input, first) = parse_string_or_char(input)?;

        if let Ok((input, _)) = Token::Dash.parse(input.clone()) {
            let span2 = input.span();
            let (input, last) = cut(parse_string_or_char)(input)?;

            let first = first.to_char().map_err(|e| nom::Err::Failure(e.at(span1)))?;
            let last = last.to_char().map_err(|e| nom::Err::Failure(e.at(span2)))?;

            let group = CharGroup::try_from_range(first, last).ok_or_else(|| {
                nom::Err::Failure(
                    ParseErrorKind::CharClass(CharClassError::DescendingRange(first, last))
                        .at(span1.join(span2)),
                )
            })?;
            Ok((input, group))
        } else {
            let group = match first {
                StringOrChar::String(s) => CharGroup::from_chars(
                    parse_quoted_text(s).map_err(|k| nom::Err::Failure(k.at(span1)))?.borrow(),
                ),
                StringOrChar::Char(c) => CharGroup::from_char(c),
            };
            Ok((input, group))
        }
    }",0,,
"pub async fn run_server(&mut self) -> TResult<()> {
        match self {
            MultiListener::SecureOnly(secure_listener) => secure_listener.run().await,
            MultiListener::InsecureOnly(insecure_listener) => insecure_listener.run().await,
            MultiListener::Multi(insecure_listener, secure_listener) => {
                let insec = insecure_listener.run();
                let sec = secure_listener.run();
                let (e1, e2) = tokio::join!(insec, sec);
                if let Err(e) = e1 {
                    log::error!(""Insecure listener failed with: {}"", e);
                }
                if let Err(e) = e2 {
                    log::error!(""Secure listener failed with: {}"", e);
                }
                Ok(())
            }
        }
    }",0,,
"    pub fn len(&self) -> usize {
        self.constants.len()
    }",0,,
"fn test_entrypoint_exit() {
    
    
    
    
    
    
    for dynamic_stack_frames in [false, true] {
        let config = Config {
            dynamic_stack_frames,
            ..Config::default()
        };

        
        
        test_interpreter_and_jit_asm!(
            ""
            entrypoint:
            call foo
            mov r0, 42
            exit
            foo:
            mov r0, 12
            exit"",
            config,
            [],
            (),
            0,
            { |_vm, res: Result| { res.unwrap() == 42 } },
            5
        );
    }
}",0,,
"    pub fn keys(&self) -> Keys<VCodeConstant> {
        self.constants.keys()
    }",0,,
"    pub fn is_terminated(&self) -> bool {
        self.state.is_terminated()
    }",0,,
"pub fn ctou32(c: u8) -> Result<u32, Error> {
    if c < ASCII_0 || ASCII_9 < c {
        return Err(Error::InvalidFormat(""Not a number""));
    }
    Ok((c - ASCII_0) as u32)
}",0,,
"fn compile_many(
        mut self,
        exprs: &[Hir],
    ) -> result::Result<Program, Error> {
        debug_assert!(exprs.len() > 1);

        self.compiled.is_anchored_start =
            exprs.iter().all(|e| e.is_anchored_start());
        self.compiled.is_anchored_end =
            exprs.iter().all(|e| e.is_anchored_end());
        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };
        if self.compiled.needs_dotstar() {
            dotstar_patch = self.c_dotstar()?;
            self.compiled.start = dotstar_patch.entry;
        } else {
            self.compiled.start = 0; 
        }
        self.fill_to_next(dotstar_patch.hole);

        let mut prev_hole = Hole::None;
        for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {
            self.fill_to_next(prev_hole);
            let split = self.push_split_hole();
            let Patch { hole, entry } =
                self.c_capture(0, expr)?.unwrap_or(self.next_inst());
            self.fill_to_next(hole);
            self.compiled.matches.push(self.insts.len());
            self.push_compiled(Inst::Match(i));
            prev_hole = self.fill_split(split, Some(entry), None);
        }
        let i = exprs.len() - 1;
        let Patch { hole, entry } =
            self.c_capture(0, &exprs[i])?.unwrap_or(self.next_inst());
        self.fill(prev_hole, entry);
        self.fill_to_next(hole);
        self.compiled.matches.push(self.insts.len());
        self.push_compiled(Inst::Match(i));
        self.compile_finish()
    }",0,,
"    pub async fn new_multi(
        ssl_base_listener: BaseListener,
        tcp_base_listener: BaseListener,
        ssl: SslOpts,
    ) -> Result<Self, String> {
        let sec_bindaddr = bindaddr!(ssl_base_listener);
        let insec_binaddr = bindaddr!(tcp_base_listener);
        let secure_listener = SslListener::new_pem_based_ssl_connection(
            ssl.key,
            ssl.chain,
            ssl_base_listener,
            ssl.passfile,
        )
        .map_err(|e| format!(""Couldn't bind to secure port: {}"", e))?;
        let insecure_listener = Listener {
            base: tcp_base_listener,
        };
        log::info!(
            ""Server started on: skyhash://{} and skyhash-secure://{}"",
            insec_binaddr,
            sec_bindaddr
        );
        Ok(MultiListener::Multi(insecure_listener, secure_listener))
    }",0,,
"fn test_call_gather_bytes() {
    test_interpreter_and_jit_asm!(
        ""
        mov r1, 1
        mov r2, 2
        mov r3, 3
        mov r4, 4
        mov r5, 5
        syscall BpfGatherBytes
        exit"",
        [],
        (
            b""BpfGatherBytes"" => syscalls::BpfGatherBytes::init::<BpfSyscallContext, UserError>; syscalls::BpfGatherBytes::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0102030405 } },
        7
    );
}",0,,
"    fn cause(&self) -> Option<&dyn error::Error> {
        None
    }",0,,
"pub fn seteuid(uid: u32) {
    let uid = nix::unistd::Uid::from_raw(uid);
    match nix::unistd::seteuid(uid) {
        Ok(_) => log::debug!(""Dropping privileges...""),
        Err(e) => {
            log::error!(""Failed to set UID: {:#?}"", e);
            exit(1);
        }
    }
}",1,"1,5","    let uid = nix::unistd::Uid::from_raw(uid);/~/            log::error!(""Failed to set UID: {:#?}"", e);"
"pub(super) fn parse_headers<T>(
    bytes: &mut BytesMut,
    ctx: ParseContext<'_>,
) -> ParseResult<T::Incoming>
where
    T: Http1Transaction,
{
    
    if bytes.is_empty() {
        return Ok(None);
    }

    let span = trace_span!(""parse_headers"");
    let _s = span.enter();
    T::parse(bytes, ctx)
}

pub(super) fn encode_headers<T>(
    enc: Encode<'_, T::Outgoing>,
    dst: &mut Vec<u8>,
) -> crate::Result<Encoder>
where
    T: Http1Transaction,
{
    let span = trace_span!(""encode_headers"");
    let _s = span.enter();
    T::encode(enc, dst)
}",0,,
"fn test_syscall_with_context() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0xAA
        mov64 r2, 0xBB
        mov64 r3, 0xCC
        mov64 r4, 0xDD
        mov64 r5, 0xEE
        syscall SyscallWithContext
        mov64 r0, 0x0
        exit"",
        [],
        (
            b""SyscallWithContext"" => syscalls::SyscallWithContext::init::< syscalls::BpfSyscallContext, UserError>; syscalls::SyscallWithContext::call
        ),
        42,
        { |vm: &EbpfVm<UserError, TestInstructionMeter>, res: Result| {
            let syscall_context_object = unsafe { &*(vm.get_syscall_context_object(syscalls::SyscallWithContext::call as usize).unwrap() as *const syscalls::SyscallWithContext) };
            assert_eq!(syscall_context_object.context, 84);
            res.unwrap() == 0
        }},
        8
    );
}",0,,
"    pub(crate) fn from_wasm_func_type(sig: WasmFuncType) -> FuncType {
        Self { sig }
    }",0,,
"    pub fn normalize_s(&mut self) {
        if self.s.is_high() {
            let s = self.s.clone();
            self.s.neg_in_place(&s);
        }
    }",0,,
"pub fn insert(&mut self, data: VCodeConstantData) -> VCodeConstant {
        match data {
            VCodeConstantData::Generated(_) => self.constants.push(data),
            VCodeConstantData::Pool(constant, _) => match self.pool_uses.get(&constant) {
                None => {
                    let vcode_constant = self.constants.push(data);
                    self.pool_uses.insert(constant, vcode_constant);
                    vcode_constant
                }
                Some(&vcode_constant) => vcode_constant,
            },
            VCodeConstantData::WellKnown(data_ref) => {
                match self.well_known_uses.get(&(data_ref as *const [u8])) {
                    None => {
                        let vcode_constant = self.constants.push(data);
                        self.well_known_uses
                            .insert(data_ref as *const [u8], vcode_constant);
                        vcode_constant
                    }
                    Some(&vcode_constant) => vcode_constant,
                }
            }
        }
    }",0,,
"fn drop(&mut self) {
        let pc_loc_table_size = round_to_page_size(self.pc_section.len() * 8, self.page_size);
        let code_size = round_to_page_size(self.text_section.len(), self.page_size);
        if pc_loc_table_size + code_size > 0 {
            #[cfg(not(target_os = ""windows""))]
            unsafe {
                libc::munmap(self.pc_section.as_ptr() as *mut _, pc_loc_table_size + code_size);
            }
        }
    }",0,,
"fn eq(&self, other: &Self) -> bool {
        VMExternRef::eq(&self.0, &other.0)
    }",0,,
"pub fn execute(&mut self, action: Vec<u8>) {
            self.sender.send(WhatToDo::NewJob(action)).unwrap();
        }",0,,
"fn drop(&mut self) {
        
        
        self.climit.add_permits(1);
    }",0,,
"	pub fn ui_middleware(
		deps: Dependencies,
		dapps_domain: String,
	) -> Result<Middleware, String> {
		let parity_remote = parity_reactor::Remote::new(deps.remote.clone());
		Ok(parity_dapps::Middleware::ui(
			parity_remote,
			deps.contract_client,
			deps.sync_status,
			deps.fetch,
			dapps_domain,
		))
	}",0,,
"pub fn clone_cstrings_safely(out_ptr: *const *const c_char) -> Result<Vec<CString>> {
        let mut cstrings = Vec::new();
        if out_ptr == ptr::null() {
            return Ok(cstrings);
        }

        let mut out_ptr = out_ptr;
        loop {
            check_ptr(out_ptr)?;

            let cstr_ptr = {
                let cstr_ptr = unsafe { *out_ptr };
                if cstr_ptr == ptr::null() {
                    break;
                }
                cstr_ptr
            };
            let cstring = clone_cstring_safely(cstr_ptr)?;
            cstrings.push(cstring);

            out_ptr = unsafe { out_ptr.offset(1) };
        }
        Ok(cstrings)
    }",0,,
"pub fn current_block_hash() -> Option<H256> {
		Self::current_block().map(|block| block.header.hash())
	}",0,,
"fn test_lddw() {
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x1122334455667788
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122334455667788 } },
        2
    );
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x0000000080000000
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x80000000 } },
        2
    );
}",0,,
"fn test_subnet() {
    test_interpreter_and_jit_asm!(
        ""
        mov r2, 0xe
        ldxh r3, [r1+12]
        jne r3, 0x81, +2
        mov r2, 0x12
        ldxh r3, [r1+16]
        and r3, 0xffff
        jne r3, 0x8, +5
        add r1, r2
        mov r0, 0x1
        ldxw r1, [r1+16]
        and r1, 0xffffff
        jeq r1, 0x1a8c0, +1
        mov r0, 0x0
        exit"",
        [
            0x00, 0x00, 0xc0, 0x9f, 0xa0, 0x97, 0x00, 0xa0, 
            0xcc, 0x3b, 0xbf, 0xfa, 0x08, 0x00, 0x45, 0x10, 
            0x00, 0x3c, 0x46, 0x3c, 0x40, 0x00, 0x40, 0x06, 
            0x73, 0x1c, 0xc0, 0xa8, 0x01, 0x02, 0xc0, 0xa8, 
            0x01, 0x01, 0x06, 0x0e, 0x00, 0x17, 0x99, 0xc5, 
            0xa0, 0xec, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 
            0x7d, 0x78, 0xe0, 0xa3, 0x00, 0x00, 0x02, 0x04, 
            0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a, 0x00, 0x9c, 
            0x27, 0x24, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 
            0x03, 0x00, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        11
    );
}",0,,
"pub fn new<T>(
        mut store: impl AsContextMut<Data = T>,
        ty: FuncType,
        func: impl Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + 'static,
    ) -> Self {
        let store = store.as_context_mut().0;

        
        
        unsafe {
            let host = HostFunc::new(store.engine(), ty, func);
            host.into_func(store)
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[cfg(all(feature = ""async"", feature = ""cranelift""))]
    #[cfg_attr(nightlydoc, doc(cfg(all(feature = ""async"", feature = ""cranelift""))))]
    pub fn new_async<T, F>(store: impl AsContextMut<Data = T>, ty: FuncType, func: F) -> Func
    where
        F: for<'a> Fn(
                Caller<'a, T>,
                &'a [Val],
                &'a mut [Val],
            ) -> Box<dyn Future<Output = Result<(), Trap>> + Send + 'a>
            + Send
            + Sync
            + 'static,
    {
        assert!(
            store.as_context().async_support(),
            ""cannot use `new_async` without enabling async support in the config""
        );
        Func::new(store, ty, move |mut caller, params, results| {
            let async_cx = caller.store.as_context_mut().0.async_cx();
            let mut future = Pin::from(func(caller, params, results));
            match unsafe { async_cx.block_on(future.as_mut()) } {
                Ok(Ok(())) => Ok(()),
                Ok(Err(trap)) | Err(trap) => Err(trap),
            }
        })
    }",0,,
"fn table_drops_externref() -> anyhow::Result<()> {
    test_engine(&Engine::default())?;

    if !skip_pooling_allocator_tests() {
        test_engine(&Engine::new(
            Config::new().allocation_strategy(InstanceAllocationStrategy::pooling()),
        )?)?;
    }

    return Ok(());

    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Table::new(
            &mut store,
            TableType::new(ValType::ExternRef, 1, None),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
            (module
                (table 1 externref)

                (func (export ""run"") (param externref)
                    i32.const 0
                    local.get 0
                    table.set 0
                )
            )
        ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }
}",0,,
"    pub unsafe fn new_unchecked(func: Func) -> TypedFunc<Params, Results> {
        TypedFunc {
            _a: marker::PhantomData,
            func,
        }
    }",0,,
"    pub fn bytes(mut self, yes: bool) -> Self {
        self.compiled.is_bytes = yes;
        self
    }",0,,
"    fn alloc(&mut self, amt: usize) -> bool {
        match self.remaining_memory.checked_sub(amt) {
            Some(mem) => {
                self.remaining_memory = mem;
                true
            }
            None => {
                self.oom = true;
                false
            }
        }
    }",0,,
"    fn new() -> KeyboardState {
        KeyboardState { state_modifiers: HashSet::new(), state_keysyms: AttributeSet::new() }
    }",0,,
"	fn on_response(&mut self, res: &mut server::Response) -> Next {
		match self.state {
			State::Initial => Next::end(),
			State::Error(ref mut handler) => handler.on_response(res),
			State::Fetching(ref mut handler) => handler.on_response(res),
		}
	}",0,,
"fn from(ty: WasmType) -> wasmparser::Type {
        match ty {
            WasmType::I32 => wasmparser::Type::I32,
            WasmType::I64 => wasmparser::Type::I64,
            WasmType::F32 => wasmparser::Type::F32,
            WasmType::F64 => wasmparser::Type::F64,
            WasmType::V128 => wasmparser::Type::V128,
            WasmType::FuncRef => wasmparser::Type::FuncRef,
            WasmType::ExternRef => wasmparser::Type::ExternRef,
            WasmType::ExnRef => wasmparser::Type::ExnRef,
        }
    }",0,,
"fn into(self) -> Affine {
        self.0
    }",0,,
"    pub(crate) fn from_wasmtime(
        types: &TypeTables,
        ty: &wasmtime_environ::ModuleSignature,
    ) -> ModuleType {
        let exports = &types.instance_signatures[ty.exports].exports;
        ModuleType {
            exports: exports
                .iter()
                .map(|(name, ty)| (name.to_string(), ExternType::from_wasmtime(types, ty)))
                .collect(),
            imports: ty
                .imports
                .iter()
                .map(|(m, ty)| (m.to_string(), None, ExternType::from_wasmtime(types, ty)))
                .collect(),
        }
    }",0,,
"pub fn frame_size(&self) -> u32 {
        self.abi.frame_size()
    }",0,,
"fn sock_send(command: &str) -> std::io::Result<()> {
    let mut stream = UnixStream::connect(""/tmp/swhkd.sock"")?;
    stream.write_all(command.as_bytes())?;
    Ok(())
}",1,1,"    let mut stream = UnixStream::connect(""/tmp/swhkd.sock"")?;"
"    fn insert_precise_stack_root(
        precise_stack_roots: &mut HashSet<VMExternRefWithTraits>,
        root: NonNull<VMExternData>,
    ) {
        let root = unsafe { VMExternRef::clone_from_raw(root.as_ptr() as *mut _) };
        precise_stack_roots.insert(VMExternRefWithTraits(root));
    }",0,,
"fn test_reloc_64_relative() {
    
    
    
    
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x100 } },
        2
    );
}",0,,
"    fn check_end(&self) {
        assert_eq!(self.before_idx, self.reachability.len());
        assert_eq!(self.after_idx, self.reachability.len());
    }",0,,
"    pub fn add_named_export(&mut self, name: &str, ty: ExternType) {
        self.exports.push((name.to_string(), ty));
    }",0,,
"fn enter(&mut self, gas_limit: u64, is_static: bool) {
		self.substate.enter(gas_limit, is_static)
	}",0,,
"fn test_be64() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1]
        be64 r0
        exit"",
        [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122334455667788 } },
        3
    );
}",0,,
"    pub fn insert_embed_ctx<T: Any>(&mut self, x: T) -> Option<T> {
        self.embed_ctx.insert(x)
    }",0,,
"pub unsafe fn instance_handle_from_raw(
    ptr: *mut Instance,
    needs_inst_drop: bool,
) -> InstanceHandle {
    InstanceHandle {
        inst: NonNull::new_unchecked(ptr),
        needs_inst_drop,
    }
}",0,,
"fn detect_invalid_last_symbol_two_bytes() {
        let decode =
            |input, forgiving| decode_config(input, STANDARD.decode_allow_trailing_bits(forgiving));

        
        assert!(decode(""iYU="", false).is_ok());
        
        assert_eq!(
            Err(DecodeError::InvalidLastSymbol(2, b'V')),
            decode(""iYV="", false)
        );
        assert_eq!(Ok(vec![137, 133]), decode(""iYV="", true));
        
        assert_eq!(
            Err(DecodeError::InvalidLastSymbol(2, b'W')),
            decode(""iYW="", false)
        );
        assert_eq!(Ok(vec![137, 133]), decode(""iYV="", true));
        
        assert_eq!(
            Err(DecodeError::InvalidLastSymbol(2, b'X')),
            decode(""iYX="", false)
        );
        assert_eq!(Ok(vec![137, 133]), decode(""iYV="", true));

        
        assert_eq!(
            Err(DecodeError::InvalidLastSymbol(6, b'X')),
            decode(""AAAAiYX="", false)
        );
        assert_eq!(Ok(vec![0, 0, 0, 137, 133]), decode(""AAAAiYX="", true));
    }",0,,
"	fn deref(&self) -> &Self::Target {
		&self.queue
	}",0,,
"fn test_ldxw_all() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxw r9, [r0+0]
        be32 r9
        ldxw r8, [r0+4]
        be32 r8
        ldxw r7, [r0+8]
        be32 r7
        ldxw r6, [r0+12]
        be32 r6
        ldxw r5, [r0+16]
        be32 r5
        ldxw r4, [r0+20]
        be32 r4
        ldxw r3, [r0+24]
        be32 r3
        ldxw r2, [r0+28]
        be32 r2
        ldxw r1, [r0+32]
        be32 r1
        ldxw r0, [r0+36]
        be32 r0
        or r0, r1
        or r0, r2
        or r0, r3
        or r0, r4
        or r0, r5
        or r0, r6
        or r0, r7
        or r0, r8
        or r0, r9
        exit"",
        [
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 
            0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 
            0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 
            0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x030f0f } },
        31
    );
}",0,,
"fn test_jset_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0x7
        jset r1, 0x8, +4
        mov32 r0, 1
        mov32 r1, 0x9
        jset r1, 0x8, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"pub fn inv_in_place(&mut self, x: &Scalar) {
        let u2 = x.sqr();
        let x2 = &u2 * x;
        let u5 = &u2 * &x2;
        let x3 = &u5 * &u2;
        let u9 = &x3 * &u2;
        let u11 = &u9 * &u2;
        let u13 = &u11 * &u2;

        let mut x6 = u13.sqr();
        x6 = x6.sqr();
        x6 *= &u11;

        let mut x8 = x6.sqr();
        x8 = x8.sqr();
        x8 *= &x2;

        let mut x14 = x8.sqr();
        for _ in 0..5 {
            x14 = x14.sqr();
        }
        x14 *= &x6;

        let mut x28 = x14.sqr();
        for _ in 0..13 {
            x28 = x28.sqr();
        }
        x28 *= &x14;

        let mut x56 = x28.sqr();
        for _ in 0..27 {
            x56 = x56.sqr();
        }
        x56 *= &x28;

        let mut x112 = x56.sqr();
        for _ in 0..55 {
            x112 = x112.sqr();
        }
        x112 *= &x56;

        let mut x126 = x112.sqr();
        for _ in 0..13 {
            x126 = x126.sqr();
        }
        x126 *= &x14;

        let mut t = x126;
        for _ in 0..3 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &u11;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u11;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..3 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &u9;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..10 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..9 {
            t = t.sqr();
        }
        t *= &x8;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &u9;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u11;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &x2;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..10 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u9;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= x;
        for _ in 0..8 {
            t = t.sqr();
        }
        *self = &t * &x6;
    }",0,,
"fn execute_generated_program(prog: &[u8]) -> bool {
    let max_instruction_count = 1024;
    let mem_size = 1024 * 1024;
    let mut bpf_functions = BTreeMap::new();
    let config = Config {
        enable_instruction_tracing: true,
        ..Config::default()
    };
    let syscall_registry = SyscallRegistry::default();
    register_bpf_function(
        &config,
        &mut bpf_functions,
        &syscall_registry,
        0,
        ""entrypoint"",
    )
    .unwrap();
    let executable = Executable::<UserError, TestInstructionMeter>::from_text_bytes(
        prog,
        Some(solana_rbpf::verifier::check),
        config,
        syscall_registry,
        bpf_functions,
    );
    let mut executable = if let Ok(executable) = executable {
        executable
    } else {
        return false;
    };
    if Executable::<UserError, TestInstructionMeter>::jit_compile(&mut executable).is_err() {
        return false;
    }
    let (instruction_count_interpreter, tracer_interpreter, result_interpreter) = {
        let mut mem = vec![0u8; mem_size];
        let mem_region = MemoryRegion::new_writable(&mut mem, ebpf::MM_INPUT_START);
        let mut vm = EbpfVm::new(&executable, &mut [], vec![mem_region]).unwrap();
        let result_interpreter = vm.execute_program_interpreted(&mut TestInstructionMeter {
            remaining: max_instruction_count,
        });
        let tracer_interpreter = vm.get_tracer().clone();
        (
            vm.get_total_instruction_count(),
            tracer_interpreter,
            result_interpreter,
        )
    };
    let mut mem = vec![0u8; mem_size];
    let mem_region = MemoryRegion::new_writable(&mut mem, ebpf::MM_INPUT_START);
    let mut vm = EbpfVm::new(&executable, &mut [], vec![mem_region]).unwrap();
    let result_jit = vm.execute_program_jit(&mut TestInstructionMeter {
        remaining: max_instruction_count,
    });
    let tracer_jit = vm.get_tracer();
    if result_interpreter != result_jit
        || !solana_rbpf::vm::Tracer::compare(&tracer_interpreter, tracer_jit)
    {
        let analysis =
            solana_rbpf::static_analysis::Analysis::from_executable(&executable).unwrap();
        println!(""result_interpreter={:?}"", result_interpreter);
        println!(""result_jit={:?}"", result_jit);
        let stdout = std::io::stdout();
        tracer_interpreter
            .write(&mut stdout.lock(), &analysis)
            .unwrap();
        tracer_jit.write(&mut stdout.lock(), &analysis).unwrap();
        panic!();
    }
    if executable.get_config().enable_instruction_meter {
        let instruction_count_jit = vm.get_total_instruction_count();
        assert_eq!(instruction_count_interpreter, instruction_count_jit);
    }
    true
}",0,,
"    fn deref_mut(&mut self) -> &mut T {
        if cfg!(debug_assertions) {
            &mut self.inner
        } else {
            panic!(
                ""only deref `DebugOnly` when `cfg(debug_assertions)` or \
                 inside a `debug_assert!(..)`""
            )
        }
    }",0,,
"fn test_err_callx_oob_high() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r0, -0x1
        lsh64 r0, 0x20
        or64 r0, 0x3
        callx r0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::CallOutsideTextSegment(pc, target_pc)
                    if pc == 32 && target_pc == 0xffffffff00000000
                )
            }
        },
        4
    );
}",0,,
"    fn valid_magic(&self) -> bool {
        self.magic == LUCET_INSTANCE_MAGIC
    }",0,,
"pub fn tweak_add_assign(&mut self, tweak: &SecretKey) -> Result<(), Error> {
        let mut r = Jacobian::default();
        let a = Jacobian::from_ge(&self.0);
        let one = Scalar::from_int(1);
        ECMULT_CONTEXT.ecmult(&mut r, &a, &one, &tweak.0);

        if r.is_infinity() {
            return Err(Error::TweakOutOfRange);
        }

        self.0.set_gej(&r);
        Ok(())
    }",0,,
"pub fn parse(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {
        let mut r = Scalar::default();
        let mut s = Scalar::default();

        
        let _ = r.set_b32(array_ref!(p, 0, 32));
        let _ = s.set_b32(array_ref!(p, 32, 32));

        Signature { r, s }
    }",0,,
"fn do_transact(transaction: Transaction) -> DispatchResultWithPostInfo {
		ensure!(
			fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
			Error::<T>::PreLogExists,
		);

		let source =
			Self::recover_signer(&transaction).ok_or_else(|| Error::<T>::InvalidSignature)?;

		let transaction_hash =
			H256::from_slice(Keccak256::digest(&rlp::encode(&transaction)).as_slice());
		let transaction_index = Pending::<T>::get().len() as u32;

		let (to, contract_address, info) = Self::execute(
			source,
			transaction.input.clone(),
			transaction.value,
			transaction.gas_limit,
			Some(transaction.gas_price),
			Some(transaction.nonce),
			transaction.action,
			None,
		)?;

		let (reason, status, used_gas, dest) = match info {
			CallOrCreateInfo::Call(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: None,
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				to,
			),
			CallOrCreateInfo::Create(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: Some(info.value),
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				Some(info.value),
			),
		};

		let receipt = ethereum::Receipt {
			state_root: match reason {
				ExitReason::Succeed(_) => H256::from_low_u64_be(1),
				ExitReason::Error(_) => H256::from_low_u64_le(0),
				ExitReason::Revert(_) => H256::from_low_u64_le(0),
				ExitReason::Fatal(_) => H256::from_low_u64_le(0),
			},
			used_gas,
			logs_bloom: status.clone().logs_bloom,
			logs: status.clone().logs,
		};

		Pending::<T>::append((transaction, status, receipt));

		Self::deposit_event(Event::Executed(
			source,
			dest.unwrap_or_default(),
			transaction_hash,
			reason,
		));
		Ok(PostDispatchInfo {
			actual_weight: Some(T::GasWeightMapping::gas_to_weight(
				used_gas.unique_saturated_into(),
			)),
			pays_fee: Pays::No,
		})
		.into()
	}",0,,
"fn num_chunks(input: &[u8]) -> usize {
    input
        .len()
        .checked_add(INPUT_CHUNK_LEN - 1)
        .expect(""Overflow when calculating number of chunks in input"")
        / INPUT_CHUNK_LEN
}",0,,
"fn test_sdiv64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xc
        lsh r0, 32
        mov r1, 4
        sdiv r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x300000000 } },
        5
    );
}",0,,
"    pub fn new(
        params: impl IntoIterator<Item = ValType>,
        results: impl IntoIterator<Item = ValType>,
    ) -> FuncType {
        FuncType {
            sig: WasmFuncType {
                params: params.into_iter().map(|t| t.to_wasm_type()).collect(),
                returns: results.into_iter().map(|t| t.to_wasm_type()).collect(),
            },
        }
    }",1,"5,6,7,8","            sig: WasmFuncType {/~/                params: params.into_iter().map(|t| t.to_wasm_type()).collect(),/~/                returns: results.into_iter().map(|t| t.to_wasm_type()).collect(),/~/            },"
"    pub fn strong_count(&self) -> usize {
        self.extern_data().ref_count.load(Ordering::SeqCst)
    }",0,,
"    fn slice_index(&self, count: usize) -> Result<usize, nom::Needed> {
        if count <= self.tokens.len() {
            Ok(count)
        } else {
            Err(nom::Needed::Size((count - self.tokens.len()).try_into().unwrap()))
        }
    }",0,,
"    fn extern_ref_is_pointer_sized_and_aligned() {
        assert_eq!(mem::size_of::<VMExternRef>(), mem::size_of::<*mut ()>());
        assert_eq!(mem::align_of::<VMExternRef>(), mem::align_of::<*mut ()>());
        assert_eq!(
            mem::size_of::<Option<VMExternRef>>(),
            mem::size_of::<*mut ()>()
        );
        assert_eq!(
            mem::align_of::<Option<VMExternRef>>(),
            mem::align_of::<*mut ()>()
        );
    }",0,,
"	fn is_web_proxy_token_valid(&self, token: &str) -> bool;
}

impl<F> WebProxyTokens for F where F: Fn(String) -> bool + Send + Sync {
	fn is_web_proxy_token_valid(&self, token: &str) -> bool { self(token.to_owned()) }
}",1,"0,3,4","	fn is_web_proxy_token_valid(&self, token: &str) -> bool;/~/impl<F> WebProxyTokens for F where F: Fn(String) -> bool + Send + Sync {/~/	fn is_web_proxy_token_valid(&self, token: &str) -> bool { self(token.to_owned()) }"
"pub fn push(&mut self, insn: I, is_safepoint: bool) {
        match insn.is_term() {
            MachTerminator::None | MachTerminator::Ret => {}
            MachTerminator::Uncond(target) => {
                self.vcode.block_succs.push(BlockIx::new(target.get()));
            }
            MachTerminator::Cond(true_branch, false_branch) => {
                self.vcode.block_succs.push(BlockIx::new(true_branch.get()));
                self.vcode
                    .block_succs
                    .push(BlockIx::new(false_branch.get()));
            }
            MachTerminator::Indirect(targets) => {
                for target in targets {
                    self.vcode.block_succs.push(BlockIx::new(target.get()));
                }
            }
        }
        if insn.defines_value_label().is_some() {
            self.vcode.has_value_labels = true;
        }
        self.vcode.insts.push(insn);
        self.vcode.srclocs.push(self.cur_srcloc);
        if is_safepoint {
            self.stack_map_info
                .safepoint_insns
                .push(InstIx::new((self.vcode.insts.len() - 1) as u32));
        }
    }",0,,
"fn from(validation_error: InvalidEvmTransactionError) -> Self {
		match validation_error {
			InvalidEvmTransactionError::GasLimitTooLow => InvalidTransactionWrapper(
				InvalidTransaction::Custom(TransactionValidationError::InvalidGasLimit as u8),
			),
			InvalidEvmTransactionError::GasLimitTooHigh => InvalidTransactionWrapper(
				InvalidTransaction::Custom(TransactionValidationError::InvalidGasLimit as u8),
			),
			InvalidEvmTransactionError::GasPriceTooLow => {
				InvalidTransactionWrapper(InvalidTransaction::Payment)
			}
			InvalidEvmTransactionError::PriorityFeeTooHigh => InvalidTransactionWrapper(
				InvalidTransaction::Custom(TransactionValidationError::MaxFeePerGasTooLow as u8),
			),
			InvalidEvmTransactionError::BalanceTooLow => {
				InvalidTransactionWrapper(InvalidTransaction::Payment)
			}
			InvalidEvmTransactionError::TxNonceTooLow => {
				InvalidTransactionWrapper(InvalidTransaction::Stale)
			}
			InvalidEvmTransactionError::TxNonceTooHigh => {
				InvalidTransactionWrapper(InvalidTransaction::Future)
			}
			InvalidEvmTransactionError::InvalidPaymentInput => {
				InvalidTransactionWrapper(InvalidTransaction::Payment)
			}
			InvalidEvmTransactionError::InvalidChainId => InvalidTransactionWrapper(
				InvalidTransaction::Custom(TransactionValidationError::InvalidChainId as u8),
			),
		}
	}",0,,
"    pub fn constants(&mut self) -> &mut VCodeConstants {
        &mut self.vcode.constants
    }",0,,
"fn insert(&self, func: &mut Function) {
        match self {
            Self::Gc => {
                func.instruction(Instruction::Call(0));
            }
            Self::Get(x) => {
                func.instruction(Instruction::I32Const(*x));
                func.instruction(Instruction::TableGet { table: 0 });
                func.instruction(Instruction::Drop);
            }
            Self::SetFromParam(x, y) => {
                func.instruction(Instruction::I32Const(*x));
                func.instruction(Instruction::LocalGet(*y));
                func.instruction(Instruction::TableSet { table: 0 });
            }
            Self::SetFromGet(x, y) => {
                func.instruction(Instruction::I32Const(*x));
                func.instruction(Instruction::I32Const(*y));
                func.instruction(Instruction::TableGet { table: 0 });
                func.instruction(Instruction::TableSet { table: 0 });
            }
        }
    }",1,"0,6,11,12,16,17","fn insert(&self, func: &mut Function) {/~/                func.instruction(Instruction::I32Const(*x));/~/                func.instruction(Instruction::I32Const(*x));/~/                func.instruction(Instruction::LocalGet(*y));/~/                func.instruction(Instruction::I32Const(*x));/~/                func.instruction(Instruction::I32Const(*y));"
"fn test_exit_without_value() {
    test_interpreter_and_jit_asm!(
        ""
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        1
    );
}",0,,
"pub fn current_block_hash() -> Option<H256> {
		Self::current_block().map(|block| block.header.hash())
	}",0,,
"fn test_stxb_all2() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        mov r1, 0xf1
        mov r9, 0xf9
        stxb [r0], r1
        stxb [r0+1], r9
        ldxh r0, [r0]
        be16 r0
        exit"",
        [0xff, 0xff],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xf1f9 } },
        8
    );
}",0,,
"    pub fn expect_returned(self, msg: &str) -> UntypedRetVal {
        self.returned().expect(msg)
    }",0,,
"fn special_endpoints(content_fetcher: Arc<apps::fetcher::Fetcher>) -> HashMap<router::SpecialEndpoint, Option<Box<endpoint::Endpoint>>> {
	let mut special = HashMap::new();
	special.insert(router::SpecialEndpoint::Rpc, None);
	special.insert(router::SpecialEndpoint::Utils, Some(apps::utils()));
	special.insert(router::SpecialEndpoint::Api, Some(api::RestApi::new(content_fetcher)));
	special
}",0,,
"    pub fn new() -> InstanceType {
        InstanceType {
            exports: Vec::new(),
        }
    }",0,,
"    fn input_len(&self) -> usize {
        self.tokens.len()
    }",0,,
"pub fn replace_insns_from_regalloc(&mut self, result: RegAllocResult<Self>) {
        
        
        self.abi.set_num_spillslots(result.num_spill_slots as usize);
        self.abi
            .set_clobbered(result.clobbered_registers.map(|r| Writable::from_reg(*r)));

        let mut final_insns = vec![];
        let mut final_block_ranges = vec![(0, 0); self.num_blocks()];
        let mut final_srclocs = vec![];
        let mut final_safepoint_insns = vec![];
        let mut safept_idx = 0;

        assert!(result.target_map.elems().len() == self.num_blocks());
        for block in 0..self.num_blocks() {
            let start = result.target_map.elems()[block].get() as usize;
            let end = if block == self.num_blocks() - 1 {
                result.insns.len()
            } else {
                result.target_map.elems()[block + 1].get() as usize
            };
            let block = block as BlockIndex;
            let final_start = final_insns.len() as InsnIndex;

            if block == self.entry {
                
                let prologue = self.abi.gen_prologue();
                let len = prologue.len();
                final_insns.extend(prologue.into_iter());
                final_srclocs.extend(iter::repeat(SourceLoc::default()).take(len));
            }

            for i in start..end {
                let insn = &result.insns[i];

                
                
                if is_redundant_move(insn) {
                    continue;
                }

                
                
                
                let orig_iix = result.orig_insn_map[InstIx::new(i as u32)];
                let srcloc = if orig_iix.is_invalid() {
                    SourceLoc::default()
                } else {
                    self.srclocs[orig_iix.get() as usize]
                };

                
                
                let is_ret = insn.is_term() == MachTerminator::Ret;
                if is_ret {
                    let epilogue = self.abi.gen_epilogue();
                    let len = epilogue.len();
                    final_insns.extend(epilogue.into_iter());
                    final_srclocs.extend(iter::repeat(srcloc).take(len));
                } else {
                    final_insns.push(insn.clone());
                    final_srclocs.push(srcloc);
                }

                
                
                if safept_idx < result.new_safepoint_insns.len()
                    && (result.new_safepoint_insns[safept_idx].get() as usize) == i
                {
                    let idx = final_insns.len() - 1;
                    final_safepoint_insns.push(idx as InsnIndex);
                    safept_idx += 1;
                }
            }

            let final_end = final_insns.len() as InsnIndex;
            final_block_ranges[block as usize] = (final_start, final_end);
        }

        debug_assert!(final_insns.len() == final_srclocs.len());

        self.insts = final_insns;
        self.srclocs = final_srclocs;
        self.block_ranges = final_block_ranges;
        self.safepoint_insns = final_safepoint_insns;

        
        
        
        self.safepoint_slots = result.stackmaps;
    }",0,,
"    fn add_assign(&mut self, other: Scalar) {
        self.add_assign(&other)
    }",0,,
"	fn pay_priority_fee(tip: Self::LiquidityInfo) {
		<EVMCurrencyAdapter::<<T as Config>::Currency, ()> as OnChargeEVMTransaction<T>>::pay_priority_fee(tip);
	}",0,,
"    pub const fn pad(self, pad: bool) -> Config {
        Config { pad, ..self }
    }",0,,
"	fn pay_priority_fee(tip: Self::LiquidityInfo) {
		
		if let Some(tip) = tip {
			let account_id = T::AddressMapping::into_account_id(<Pallet<T>>::find_author());
			let _ = C::deposit_into_existing(&account_id, tip.peek());
		}
	}",0,,
"    fn check_size(&self) -> result::Result<(), Error> {
        use std::mem::size_of;

        let size =
            self.extra_inst_bytes + (self.insts.len() * size_of::<Inst>());
        if size > self.size_limit {
            Err(Error::CompiledTooBig(self.size_limit))
        } else {
            Ok(())
        }
    }",0,,
"fn test_err_sdiv64_overflow_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x80
        lsh r0, 56
        mov r1, -1
        sdiv r0, r1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideOverflow(pc) if pc == 32)
        },
        4
    );
}",0,,
"fn get_func_name(func_index: FuncIndex) -> ir::ExternalName {
    ir::ExternalName::user(0, func_index.as_u32())
}",0,,
"fn create2(
		source: H160,
		init: Vec<u8>,
		salt: H256,
		value: U256,
		gas_limit: u64,
		max_fee_per_gas: Option<U256>,
		max_priority_fee_per_gas: Option<U256>,
		nonce: Option<U256>,
		access_list: Vec<(H160, Vec<H256>)>,
		is_transactional: bool,
		validate: bool,
		config: &evm::Config,
	) -> Result<CreateInfo, RunnerError<Self::Error>> {
		if validate {
			let _ = Self::validate(
				source,
				None,
				init.clone(),
				value,
				gas_limit,
				max_fee_per_gas,
				max_priority_fee_per_gas,
				nonce,
				access_list.clone(),
				is_transactional,
				config,
			)?;
		}
		let precompiles = T::PrecompilesValue::get();
		let code_hash = H256::from(sp_io::hashing::keccak_256(&init));
		Self::execute(
			source,
			value,
			gas_limit,
			max_fee_per_gas,
			max_priority_fee_per_gas,
			config,
			&precompiles,
			is_transactional,
			|executor| {
				let address = executor.create_address(evm::CreateScheme::Create2 {
					caller: source,
					code_hash,
					salt,
				});
				let (reason, _) =
					executor.transact_create2(source, value, init, salt, gas_limit, access_list);
				(reason, address)
			},
		)
	}",0,,
"fn test_empty_input() -> std::result::Result<(), PrecompileFailure> {
		let input: [u8; 0] = [];

		let cost: u64 = 1;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(_) => {
				panic!(""Test not expected to pass"");
			}
			Err(e) => {
				assert_eq!(
					e,
					PrecompileFailure::Error {
						exit_status: ExitError::Other(
							""input must contain at least 96 bytes"".into()
						)
					}
				);
				Ok(())
			}
		}
	}",0,,
"fn format_option_value<S>(s: S) -> String
where
    S: AsRef<str>,
{
    let s = s.as_ref();
    if s.ends_with(' ')
        || s.starts_with(' ')
        || s.contains(&['\\', '{', '}', ':'][..])
        || s.is_empty()
    {
        format!(""'{}'"", s)
    } else {
        s.to_string()
    }
}",0,,
"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            
            
            self.base.climit.acquire().await.unwrap().forget();
            let stream = self.accept().await?;
            let mut sslhandle = ConnectionHandler::new(
                self.base.db.clone(),
                Connection::new(stream),
                self.base.climit.clone(),
                Terminator::new(self.base.signal.subscribe()),
                self.base.terminate_tx.clone(),
            );
            tokio::spawn(async move {
                if let Err(e) = sslhandle.run().await {
                    log::error!(""Error: {}"", e);
                }
            });
        }
    }",1,5,            let stream = self.accept().await?;
"fn parse_string(int: syn::Lit, span: Span, field: &str) -> Result<String, syn::Error> {
    match int {
        syn::Lit::Str(s) => Ok(s.value()),
        syn::Lit::Verbatim(s) => Ok(s.to_string()),
        _ => Err(syn::Error::new(
            span,
            format!(""Failed to parse {} into a string."", field),
        )),
    }
}",0,,
"pub fn serialize_der(&self) -> der::SignatureArray {
        fn fill_scalar_with_leading_zero(scalar: &Scalar) -> [u8; 33] {
            let mut ret = [0u8; 33];
            scalar.fill_b32(array_mut_ref!(ret, 1, 32));
            ret
        }

        let r_full = fill_scalar_with_leading_zero(&self.r);
        let s_full = fill_scalar_with_leading_zero(&self.s);

        fn integer_slice(full: &[u8; 33]) -> &[u8] {
            let mut len = 33;
            while len > 1 &&
                full[full.len() - len] == 0 &&
                full[full.len() - len + 1] < 0x80
            {
                len -= 1;
            }
            &full[(full.len() - len)..]
        }

        let r = integer_slice(&r_full);
        let s = integer_slice(&s_full);

        let mut ret = der::SignatureArray::new(6 + r.len() + s.len());
        {
            let l = ret.as_mut();
            l[0] = 0x30;
            l[1] = 4 + r.len() as u8 + s.len() as u8;
            l[2] = 0x02;
            l[3] = r.len() as u8;
            l[4..(4 + r.len())].copy_from_slice(r);
            l[4 + r.len()] = 0x02;
            l[5 + r.len()] = s.len() as u8;
            l[(6 + r.len())..(6 + r.len() + s.len())].copy_from_slice(s);
        }

        ret
    }",0,,
"fn func_new_returns_wrong_store() -> anyhow::Result<()> {
    let dropped = Arc::new(AtomicBool::new(false));
    {
        let mut store1 = Store::<()>::default();
        let mut store2 = Store::<()>::default();

        let set = SetOnDrop(dropped.clone());
        let f1 = Func::wrap(&mut store1, move || drop(&set));
        let f2 = Func::new(
            &mut store2,
            FuncType::new(None, Some(ValType::FuncRef)),
            move |_, _, results| {
                results[0] = f1.clone().into();
                Ok(())
            },
        );
        assert!(f2.call(&mut store2, &[], &mut [Val::I32(0)]).is_err());
    }
    assert!(dropped.load(SeqCst));

    return Ok(());

    struct SetOnDrop(Arc<AtomicBool>);

    impl Drop for SetOnDrop {
        fn drop(&mut self) {
            self.0.store(true, SeqCst);
        }
    }
}",0,,
"fn gen_zero_len_nop(&self) -> I {
        I::gen_nop(0)
    }",0,,
"pub fn decode_config_buf<T: AsRef<[u8]>>(
    input: T,
    config: Config,
    buffer: &mut Vec<u8>,
) -> Result<(), DecodeError> {
    let input_bytes = input.as_ref();

    let starting_output_len = buffer.len();

    let num_chunks = num_chunks(input_bytes);
    let decoded_len_estimate = num_chunks
        .checked_mul(DECODED_CHUNK_LEN)
        .and_then(|p| p.checked_add(starting_output_len))
        .expect(""Overflow when calculating output buffer length"");
    buffer.resize(decoded_len_estimate, 0);

    let bytes_written;
    {
        let buffer_slice = &mut buffer.as_mut_slice()[starting_output_len..];
        bytes_written = decode_helper(input_bytes, num_chunks, config, buffer_slice)?;
    }

    buffer.truncate(starting_output_len + bytes_written);

    Ok(())
}",0,,
"    pub fn globals(&self) -> &[GlobalValue] {
        unsafe { self.alloc.globals() }
    }",0,,
"fn from_str<T: FromStr>(s: &str) -> Result<T, ParseErrorKind> {
    str::parse(s).map_err(|_| ParseErrorKind::Number(NumberError::TooLarge))
}",0,,
"    fn close_back(&mut self) {
        if self.back.is_some() {
            let back = self.back.as_mut().unwrap();
            back.shutdown(Shutdown::Both).unwrap();
        }
        self.back = None;
    }",0,,
"    pub fn is_faulted(&self) -> bool {
        self.state.is_faulted()
    }",0,,
"	pub fn new_test(is_enabled: bool) -> Self {
		SignerService::new(|| Ok(""new_token"".into()), is_enabled)
	}",0,,
"pub fn heap_mut(&mut self) -> &mut [u8] {
        unsafe { self.alloc.heap_mut() }
    }",0,,
"fn test_non_terminate_early() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r6, 0x0
        mov64 r1, 0x0
        mov64 r2, 0x0
        mov64 r3, 0x0
        mov64 r4, 0x0
        mov64 r5, r6
        syscall Unresolved
        add64 r6, 0x1
        ja -0x8
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc)
                    if pc == 35
                )
            }
        },
        7
    );
}",0,,
"    fn from(e: ParseIntError) -> Self {
        match e.kind() {
            IntErrorKind::Empty => NumberError::Empty,
            IntErrorKind::InvalidDigit => NumberError::InvalidDigit,
            IntErrorKind::PosOverflow => NumberError::TooLarge,
            IntErrorKind::NegOverflow => NumberError::TooSmall,
            IntErrorKind::Zero => NumberError::Zero,
            _ => unimplemented!(),
        }
    }",0,,
"pub fn set_instruction_bound_delta(&mut self, delta: Option<u64>) {
        let implicits = self.get_instance_implicits_mut();
        let sum = implicits.instruction_count_adj + implicits.instruction_count_bound;
        let delta = delta.unwrap_or(i64::MAX as u64);
        let delta = i64::try_from(delta).expect(""delta too large"");
        implicits.instruction_count_bound = sum.wrapping_add(delta);
        implicits.instruction_count_adj = -delta;
    }",0,,
"fn test_nested_vm_syscall() {
    let config = Config::default();
    let mut nested_vm_syscall = NestedVmSyscall {};
    let memory_mapping = MemoryMapping::new::<UserError>(vec![], &config).unwrap();
    let mut result = Ok(0);
    nested_vm_syscall.call(1, 0, 0, 0, 0, &memory_mapping, &mut result);
    assert!(result.unwrap() == 42);
    let mut result = Ok(0);
    nested_vm_syscall.call(1, 1, 0, 0, 0, &memory_mapping, &mut result);
    assert!(matches!(result.unwrap_err(),
        EbpfError::CallDepthExceeded(pc, depth)
        if pc == 33 && depth == 0
    ));
}",0,,
"pub fn current_block_hash() -> Option<H256> {
		Self::current_block().map(|block| block.header.hash())
	}",0,,
"pub fn new(
        abi: Box<dyn ABICallee<I = I>>,
        emit_info: I::Info,
        block_order: BlockLoweringOrder,
        constants: VCodeConstants,
    ) -> VCodeBuilder<I> {
        let reftype_class = I::ref_type_regclass(abi.flags());
        let vcode = VCode::new(
            abi,
            emit_info,
            block_order,
            constants,
             true,
        );
        let stack_map_info = StackmapRequestInfo {
            reftype_class,
            reftyped_vregs: vec![],
            safepoint_insns: vec![],
        };

        VCodeBuilder {
            vcode,
            stack_map_info,
            block_start: 0,
            succ_start: 0,
            cur_srcloc: SourceLoc::default(),
        }
    }",0,,
