processed_func,target,flaw_line_index,flaw_line
"fn apply_validated_transaction(
		source: H160,
		transaction: Transaction,
	) -> DispatchResultWithPostInfo {
		let (to, _, info) = Self::execute(source, &transaction, None)?;

		let pending = Pending::<T>::get();
		let transaction_hash = transaction.hash();
		let transaction_index = pending.len() as u32;

		let (reason, status, used_gas, dest) = match info {
			CallOrCreateInfo::Call(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: None,
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				to,
			),
			CallOrCreateInfo::Create(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: Some(info.value),
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				Some(info.value),
			),
		};

		let receipt = {
			let status_code: u8 = match reason {
				ExitReason::Succeed(_) => 1,
				_ => 0,
			};
			let logs_bloom = status.logs_bloom;
			let logs = status.clone().logs;
			let cumulative_gas_used = if let Some((_, _, receipt)) = pending.last() {
				match receipt {
					Receipt::Legacy(d) | Receipt::EIP2930(d) | Receipt::EIP1559(d) => {
						d.used_gas.saturating_add(used_gas)
					}
				}
			} else {
				used_gas
			};
			match &transaction {
				Transaction::Legacy(_) => Receipt::Legacy(ethereum::EIP658ReceiptData {
					status_code,
					used_gas: cumulative_gas_used,
					logs_bloom,
					logs,
				}),
				Transaction::EIP2930(_) => Receipt::EIP2930(ethereum::EIP2930ReceiptData {
					status_code,
					used_gas: cumulative_gas_used,
					logs_bloom,
					logs,
				}),
				Transaction::EIP1559(_) => Receipt::EIP1559(ethereum::EIP2930ReceiptData {
					status_code,
					used_gas: cumulative_gas_used,
					logs_bloom,
					logs,
				}),
			}
		};

		Pending::<T>::append((transaction, status, receipt));

		Self::deposit_event(Event::Executed(
			source,
			dest.unwrap_or_default(),
			transaction_hash,
			reason,
		));

		Ok(PostDispatchInfo {
			actual_weight: Some(T::GasWeightMapping::gas_to_weight(
				used_gas.unique_saturated_into(),
			)),
			pays_fee: Pays::No,
		})
	}",0,,
"    pub(crate) fn is_pager(&self) -> bool {
        false
    }",0,,
"    pub fn returned_ref(&self) -> Result<&UntypedRetVal, Error> {
        match self {
            RunResult::Returned(rv) => Ok(rv),
            RunResult::Yielded(_) => Err(Error::InstanceNotReturned),
        }
    }",0,,
"fn test_jsge_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        mov r2, -1
        mov32 r3, 0
        jsge r1, r2, +5
        jsge r1, r3, +4
        mov32 r0, 1
        mov r1, r2
        jsge r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        10
    );
}",0,,
"pub fn module_offset(&self) -> usize {
        self.instr.file_offset().unwrap_or(u32::MAX) as usize
    }",0,,
"    fn c_repeat_zero_or_more(
        &mut self,
        expr: &Hir,
        greedy: bool,
    ) -> ResultOrEmpty {
        let split_entry = self.insts.len();
        let split = self.push_split_hole();
        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {
            Some(p) => p,
            None => return self.pop_split_hole(),
        };

        self.fill(hole_rep, split_entry);
        let split_hole = if greedy {
            self.fill_split(split, Some(entry_rep), None)
        } else {
            self.fill_split(split, None, Some(entry_rep))
        };
        Ok(Some(Patch { hole: split_hole, entry: split_entry }))
    }",0,,
"fn test_neg32() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 2
        neg32 r0
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xfffffffe } },
        3
    );
}",0,,
"	fn deref(&self) -> &Self::Target {
		&self.queue
	}",0,,
"	fn is_web_proxy_token_valid(&self, token: &str) -> bool;
}

impl<F> WebProxyTokens for F where F: Fn(String) -> bool + Send + Sync {
	fn is_web_proxy_token_valid(&self, token: &str) -> bool { self(token.to_owned()) }
}",1,"0,3,4","	fn is_web_proxy_token_valid(&self, token: &str) -> bool;/~/impl<F> WebProxyTokens for F where F: Fn(String) -> bool + Send + Sync {/~/	fn is_web_proxy_token_valid(&self, token: &str) -> bool { self(token.to_owned()) }"
"pub fn new(element: ValType, min: u32, max: Option<u32>) -> TableType {
        TableType {
            ty: Table {
                wasm_ty: element.to_wasm_type(),
                minimum: min,
                maximum: max,
            },
        }
    }",0,,
"    fn mul_assign(&mut self, other: Scalar) {
        self.mul_assign(&other)
    }",0,,
"    pub fn succs(&self, block: BlockIndex) -> &[BlockIx] {
        let (start, end) = self.block_succ_range[block as usize];
        &self.block_succs[start..end]
    }",0,,
"    pub const fn new(char_set: CharacterSet, pad: bool) -> Config {
        Config {
            char_set,
            pad,
            decode_allow_trailing_bits: false,
        }
    }",0,,
"    fn iter_elements(&self) -> Self::IterElem {
        Input { source: self.source, tokens: self.tokens }
    }",1,1,"        Input { source: self.source, tokens: self.tokens }"
"pub fn parse_slice(p: &[u8]) -> Result<SecretKey, Error> {
        if p.len() != util::SECRET_KEY_SIZE {
            return Err(Error::InvalidInputLength);
        }

        let mut a = [0; 32];
        a.copy_from_slice(p);
        Self::parse(&a)
    }",0,,
"fn drop(&mut self) {
            self.0.store(true, SeqCst);
        }",0,,
"pub fn inv_in_place(&mut self, x: &Scalar) {
        let u2 = x.sqr();
        let x2 = &u2 * x;
        let u5 = &u2 * &x2;
        let x3 = &u5 * &u2;
        let u9 = &x3 * &u2;
        let u11 = &u9 * &u2;
        let u13 = &u11 * &u2;

        let mut x6 = u13.sqr();
        x6 = x6.sqr();
        x6 *= &u11;

        let mut x8 = x6.sqr();
        x8 = x8.sqr();
        x8 *= &x2;

        let mut x14 = x8.sqr();
        for _ in 0..5 {
            x14 = x14.sqr();
        }
        x14 *= &x6;

        let mut x28 = x14.sqr();
        for _ in 0..13 {
            x28 = x28.sqr();
        }
        x28 *= &x14;

        let mut x56 = x28.sqr();
        for _ in 0..27 {
            x56 = x56.sqr();
        }
        x56 *= &x28;

        let mut x112 = x56.sqr();
        for _ in 0..55 {
            x112 = x112.sqr();
        }
        x112 *= &x56;

        let mut x126 = x112.sqr();
        for _ in 0..13 {
            x126 = x126.sqr();
        }
        x126 *= &x14;

        let mut t = x126;
        for _ in 0..3 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &u11;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u11;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..3 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &u9;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..10 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..9 {
            t = t.sqr();
        }
        t *= &x8;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &u9;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u11;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &x2;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..10 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u9;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= x;
        for _ in 0..8 {
            t = t.sqr();
        }
        *self = &t * &x6;
    }",0,,
"    pub fn call(&self, mut store: impl AsContextMut, params: &[Val]) -> Result<Box<[Val]>> {
        assert!(
            !store.as_context().async_support(),
            ""must use `call_async` when async support is enabled on the config"",
        );
        let my_ty = self.ty(&store);
        self.call_impl(&mut store.as_context_mut(), my_ty, params)
    }",0,,
"pub fn hash<H>(externref: &Self, hasher: &mut H)
    where
        H: Hasher,
    {
        ptr::hash(externref.0.as_ptr() as *const _, hasher);
    }",0,,
"fn test_ldxw_all() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxw r9, [r0+0]
        be32 r9
        ldxw r8, [r0+4]
        be32 r8
        ldxw r7, [r0+8]
        be32 r7
        ldxw r6, [r0+12]
        be32 r6
        ldxw r5, [r0+16]
        be32 r5
        ldxw r4, [r0+20]
        be32 r4
        ldxw r3, [r0+24]
        be32 r3
        ldxw r2, [r0+28]
        be32 r2
        ldxw r1, [r0+32]
        be32 r1
        ldxw r0, [r0+36]
        be32 r0
        or r0, r1
        or r0, r2
        or r0, r3
        or r0, r4
        or r0, r5
        or r0, r6
        or r0, r7
        or r0, r8
        or r0, r9
        exit"",
        [
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 
            0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 
            0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 
            0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x030f0f } },
        31
    );
}",0,,
"fn test_jset_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0x7
        mov32 r2, 0x8
        jset r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0x9
        jset r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,,
"fn test_tight_infinite_loop_unconditional() {
    test_interpreter_and_jit_asm!(
        ""
        ja -1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 30 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,,
"	pub fn ui_middleware(
		deps: Dependencies,
		dapps_domain: String,
	) -> Result<Middleware, String> {
		let parity_remote = parity_reactor::Remote::new(deps.remote.clone());
		Ok(parity_dapps::Middleware::ui(
			parity_remote,
			deps.contract_client,
			deps.sync_status,
			deps.fetch,
			dapps_domain,
		))
	}",0,,
"    fn do_tls_write_and_handle_error(&mut self) {
        let rc = self.tls_write();
        if rc.is_err() {
            error!(""write failed {:?}"", rc);
            self.closing = true;
            return;
        }
    }",0,,
"    pub fn from_mode(
        mode: PagingMode,
        pager: Option<String>,
        config: &config::Config,
    ) -> Result<Self> {
        use self::PagingMode::*;
        Ok(match mode {
            Always => OutputType::try_pager(false, pager, config)?,
            QuitIfOneScreen => OutputType::try_pager(true, pager, config)?,
            _ => OutputType::stdout(),
        })
    }",0,,
"    fn from(ty: MemoryType) -> ExternType {
        ExternType::Memory(ty)
    }",0,,
"fn test_load_elf_rodata() {
    
    
    for optimize_rodata in [false, true] {
        let config = Config {
            optimize_rodata,
            ..Config::default()
        };
        test_interpreter_and_jit_elf!(
            ""tests/elfs/rodata.so"",
            config,
            [],
            (),
            0,
            { |_vm, res: Result| { res.unwrap() == 42 } },
            3
        );
    }
}",0,,
"    pub(super) fn from(source: &'i str, tokens: &'b [(Token, Span)]) -> Result<Self, ParseError> {
        let error = tokens.iter().find_map(|&(t, span)| match t {
            Token::Error => Some((span, None)),
            Token::ErrorMsg(m) => Some((span, Some(m))),
            _ => None,
        });
        if let Some((span, msg)) = error {
            return match msg {
                Some(msg) => Err(ParseErrorKind::LexErrorWithMessage(msg).at(span)),
                None => Err(ParseErrorKind::UnknownToken.at(span)),
            };
        }

        Ok(Input { source, tokens })
    }",1,"0,13","    pub(super) fn from(source: &'i str, tokens: &'b [(Token, Span)]) -> Result<Self, ParseError> {/~/        Ok(Input { source, tokens })"
"fn test_bpf_to_bpf_scratch_registers() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/scratch_registers.so"",
        config,
        [1],
        (
            b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 112 } },
        41
    );
}",0,,
"    pub fn value_labels_ranges(&self) -> ValueLabelsRanges {
        if !self.has_value_labels {
            return ValueLabelsRanges::default();
        }

        let layout_info = &self.insts_layout.borrow();
        debug::compute(&self.insts, &*layout_info)
    }",0,,
"fn test_err_callx_oob_low() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r0, 0x3
        callx r0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::CallOutsideTextSegment(pc, target_pc)
                    if pc == 30 && target_pc == 0
                )
            }
        },
        2
    );
}",0,,
"fn test_ldabsh() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsh 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x4433 } },
        2
    );
}",0,,
"fn main() -> std::io::Result<()> {
    let exit_code = run_app()?;
    
    process::exit(exit_code);
}",0,,
"fn run_system_command(command: &str) {
    match Command::new(""sh"")
        .arg(""-c"")
        .arg(command)
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
    {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Failed to execute {}"", command);
            log::error!(""Error, {}"", e);
        }
    }
}",0,,
"    pub(crate) fn unknown_index(self) -> ParseError {
        ParseError { kind: self, span: None }
    }",0,,
"pub fn translate(
        mut self,
        data: &'data [u8],
    ) -> WasmResult<(usize, Vec<ModuleTranslation<'data>>, TypeTables)> {
        let mut validator = Validator::new();
        validator.wasm_features(self.features);

        for payload in Parser::new(0).parse_all(data) {
            self.translate_payload(&mut validator, payload?)?;
        }

        assert!(self.results.len() > 0);
        Ok((self.results.len() - 1, self.results, self.types))
    }",0,,
"fn test_mul128() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        mov r2, 30
        mov r3, 0
        mov r4, 20
        mov r5, 0
        mul64 r3, r4
        mul64 r5, r2
        add64 r5, r3
        mov64 r0, r2
        rsh64 r0, 0x20
        mov64 r3, r4
        rsh64 r3, 0x20
        mov64 r6, r3
        mul64 r6, r0
        add64 r5, r6
        lsh64 r4, 0x20
        rsh64 r4, 0x20
        mov64 r6, r4
        mul64 r6, r0
        lsh64 r2, 0x20
        rsh64 r2, 0x20
        mul64 r4, r2
        mov64 r0, r4
        rsh64 r0, 0x20
        add64 r0, r6
        mov64 r6, r0
        rsh64 r6, 0x20
        add64 r5, r6
        mul64 r3, r2
        lsh64 r0, 0x20
        rsh64 r0, 0x20
        add64 r0, r3
        mov64 r2, r0
        rsh64 r2, 0x20
        add64 r5, r2
        stxdw [r1+0x8], r5
        lsh64 r0, 0x20
        lsh64 r4, 0x20
        rsh64 r4, 0x20
        or64 r0, r4
        stxdw [r1+0x0], r0
        exit"",
        [0; 16],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 600 } },
        42
    );
}",0,,
"fn test_lldxdw() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 
            0x77, 0x88, 0xcc, 0xdd, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x8877665544332211 } },
        2
    );
}",0,,
"fn test_err_unresolved_elf() {
    let mut syscall_registry = SyscallRegistry::default();
    test_interpreter_and_jit!(register, syscall_registry, b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call);
    let mut file = File::open(""tests/elfs/unresolved_syscall.so"").unwrap();
    let mut elf = Vec::new();
    file.read_to_end(&mut elf).unwrap();
    let config = Config {
        reject_broken_elfs: true,
        ..Config::default()
    };
    assert!(
        matches!(Executable::<UserError, TestInstructionMeter>::from_elf(&elf, None, config, syscall_registry), Err(EbpfError::ElfError(ElfError::UnresolvedSymbol(symbol, pc, offset))) if symbol == ""log_64"" && pc == 550 && offset == 4168)
    );
}",0,,
"fn test_err_syscall_string() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x0
        syscall BpfSyscallString
        mov64 r0, 0x0
        exit"",
        [72, 101, 108, 108, 111],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 0 && vm_addr == 0 && len == 0 && name == ""unknown""
                )
            }
        },
        2
    );
}",0,,
"	fn generate_web_proxy_token(&self) -> Result<String, Error> {
		Ok(self.signer.generate_web_proxy_access_token())
	}",1,"0,1","	fn generate_web_proxy_token(&self) -> Result<String, Error> {/~/		Ok(self.signer.generate_web_proxy_access_token())"
"fn test_ldxh_all2() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxh r9, [r0+0]
        be16 r9
        ldxh r8, [r0+2]
        be16 r8
        ldxh r7, [r0+4]
        be16 r7
        ldxh r6, [r0+6]
        be16 r6
        ldxh r5, [r0+8]
        be16 r5
        ldxh r4, [r0+10]
        be16 r4
        ldxh r3, [r0+12]
        be16 r3
        ldxh r2, [r0+14]
        be16 r2
        ldxh r1, [r0+16]
        be16 r1
        ldxh r0, [r0+18]
        be16 r0
        or r0, r1
        or r0, r2
        or r0, r3
        or r0, r4
        or r0, r5
        or r0, r6
        or r0, r7
        or r0, r8
        or r0, r9
        exit"",
        [
            0x00, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 
            0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, 
            0x01, 0x00, 0x02, 0x00, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3ff } },
        31
    );
}",0,,
"fn test_jsgt_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        mov r2, -1
        jsgt r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0
        jsgt r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,,
"fn show_config(config: &config::Config, writer: &mut dyn Write) -> std::io::Result<()> {
    
    writeln!(
        writer,
        ""    commit-style                  = {commit_style}
    file-style                    = {file_style}
    hunk-header-style             = {hunk_header_style}
    minus-style                   = {minus_style}
    minus-non-emph-style          = {minus_non_emph_style}
    minus-emph-style              = {minus_emph_style}
    minus-empty-line-marker-style = {minus_empty_line_marker_style}
    zero-style                    = {zero_style}
    plus-style                    = {plus_style}
    plus-non-emph-style           = {plus_non_emph_style}
    plus-emph-style               = {plus_emph_style}
    plus-empty-line-marker-style  = {plus_empty_line_marker_style}
    whitespace-error-style        = {whitespace_error_style}"",
        commit_style = config.commit_style.to_painted_string(),
        file_style = config.file_style.to_painted_string(),
        hunk_header_style = config.hunk_header_style.to_painted_string(),
        minus_emph_style = config.minus_emph_style.to_painted_string(),
        minus_empty_line_marker_style = config.minus_empty_line_marker_style.to_painted_string(),
        minus_non_emph_style = config.minus_non_emph_style.to_painted_string(),
        minus_style = config.minus_style.to_painted_string(),
        plus_emph_style = config.plus_emph_style.to_painted_string(),
        plus_empty_line_marker_style = config.plus_empty_line_marker_style.to_painted_string(),
        plus_non_emph_style = config.plus_non_emph_style.to_painted_string(),
        plus_style = config.plus_style.to_painted_string(),
        whitespace_error_style = config.whitespace_error_style.to_painted_string(),
        zero_style = config.zero_style.to_painted_string(),
    )?;
    
    writeln!(
        writer,
        ""    true-color                    = {true_color}
    file-added-label              = {file_added_label}
    file-modified-label           = {file_modified_label}
    file-removed-label            = {file_removed_label}
    file-renamed-label            = {file_renamed_label}"",
        true_color = config.true_color,
        file_added_label = format_option_value(&config.file_added_label),
        file_modified_label = format_option_value(&config.file_modified_label),
        file_removed_label = format_option_value(&config.file_removed_label),
        file_renamed_label = format_option_value(&config.file_renamed_label),
    )?;
    writeln!(
        writer,
        ""    hyperlinks                    = {hyperlinks}"",
        hyperlinks = config.hyperlinks
    )?;
    if config.hyperlinks {
        writeln!(
            writer,
            ""    hyperlinks-file-link-format   = {hyperlinks_file_link_format}"",
            hyperlinks_file_link_format = format_option_value(&config.hyperlinks_file_link_format),
        )?
    }
    writeln!(
        writer,
        ""    inspect-raw-lines             = {inspect_raw_lines}
    keep-plus-minus-markers       = {keep_plus_minus_markers}"",
        inspect_raw_lines = match config.inspect_raw_lines {
            cli::InspectRawLines::True => ""true"",
            cli::InspectRawLines::False => ""false"",
        },
        keep_plus_minus_markers = config.keep_plus_minus_markers,
    )?;
    writeln!(
        writer,
        ""    line-numbers                  = {line_numbers}"",
        line_numbers = config.line_numbers
    )?;
    if config.line_numbers {
        writeln!(
            writer,
            ""    line-numbers-minus-style      = {line_numbers_minus_style}
    line-numbers-zero-style       = {line_numbers_zero_style}
    line-numbers-plus-style       = {line_numbers_plus_style}
    line-numbers-left-style       = {line_numbers_left_style}
    line-numbers-right-style      = {line_numbers_right_style}
    line-numbers-left-format      = {line_numbers_left_format}
    line-numbers-right-format     = {line_numbers_right_format}"",
            line_numbers_minus_style = config.line_numbers_minus_style.to_painted_string(),
            line_numbers_zero_style = config.line_numbers_zero_style.to_painted_string(),
            line_numbers_plus_style = config.line_numbers_plus_style.to_painted_string(),
            line_numbers_left_style = config.line_numbers_left_style.to_painted_string(),
            line_numbers_right_style = config.line_numbers_right_style.to_painted_string(),
            line_numbers_left_format = format_option_value(&config.line_numbers_left_format),
            line_numbers_right_format = format_option_value(&config.line_numbers_right_format),
        )?
    }
    writeln!(
        writer,
        ""    max-line-distance             = {max_line_distance}
    max-line-length               = {max_line_length}
    navigate                      = {navigate}
    navigate-regexp               = {navigate_regexp}
    pager                         = {pager}
    paging                        = {paging_mode}
    side-by-side                  = {side_by_side}
    syntax-theme                  = {syntax_theme}
    width                         = {width}
    tabs                          = {tab_width}
    word-diff-regex               = {tokenization_regex}"",
        max_line_distance = config.max_line_distance,
        max_line_length = config.max_line_length,
        navigate = config.navigate,
        navigate_regexp = match &config.navigate_regexp {
            None => """".to_string(),
            Some(s) => s.to_string(),
        },
        pager = config.pager.clone().unwrap_or_else(|| ""none"".to_string()),
        paging_mode = match config.paging_mode {
            PagingMode::Always => ""always"",
            PagingMode::Never => ""never"",
            PagingMode::QuitIfOneScreen => ""auto"",
        },
        side_by_side = config.side_by_side,
        syntax_theme = config
            .syntax_theme
            .clone()
            .map(|t| t.name.unwrap_or_else(|| ""none"".to_string()))
            .unwrap_or_else(|| ""none"".to_string()),
        width = match config.decorations_width {
            cli::Width::Fixed(width) => width.to_string(),
            cli::Width::Variable => ""variable"".to_string(),
        },
        tab_width = config.tab_width,
        tokenization_regex = format_option_value(&config.tokenization_regex.to_string()),
    )?;
    Ok(())
}",0,,
"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            
            
            self.base.climit.acquire().await.unwrap().forget();
            let stream = self.accept().await?;
            let mut sslhandle = ConnectionHandler::new(
                self.base.db.clone(),
                Connection::new(stream),
                self.base.climit.clone(),
                Terminator::new(self.base.signal.subscribe()),
                self.base.terminate_tx.clone(),
            );
            tokio::spawn(async move {
                if let Err(e) = sslhandle.run().await {
                    log::error!(""Error: {}"", e);
                }
            });
        }
    }",1,5,            let stream = self.accept().await?;
"fn register(&mut self, start: usize, end: usize, module: &Module) {
        let info = self.0.entry(end).or_insert_with(|| GlobalRegisteredModule {
            start,
            module: module.compiled_module().clone(),
            wasm_backtrace_details_env_used: module
                .engine()
                .config()
                .wasm_backtrace_details_env_used,
            references: 0,
        });

        
        
        
        assert_eq!(info.start, start);
        info.references += 1;
    }",0,,
"pub async fn init(
        db: &Corestore,
        host: IpAddr,
        port: u16,
        semaphore: Arc<Semaphore>,
        signal: broadcast::Sender<()>,
    ) -> Result<Self, IoError> {
        let (terminate_tx, terminate_rx) = mpsc::channel(1);
        Ok(Self {
            db: db.clone(),
            listener: TcpListener::bind((host, port)).await?,
            climit: semaphore,
            signal,
            terminate_tx,
            terminate_rx,
        })
    }",0,,
"fn _do_diff_test(file_a: &str, file_b: &str, expect_diff: bool) {
        let config = integration_test_utils::make_config_from_args(&[]);
        let mut writer = Cursor::new(vec![]);
        let exit_code = diff(
            Some(&PathBuf::from(file_a)),
            Some(&PathBuf::from(file_b)),
            &config,
            &mut writer,
        );
        assert_eq!(exit_code, if expect_diff { 1 } else { 0 });
    }",0,,
"    fn entry_block(&self) -> BlockIx {
        BlockIx::new(self.entry)
    }",0,,
"fn test_wat_string() {
        let ops = TableOps {
            num_params: 2,
            table_size: 10,
            ops: vec![
                TableOp::Gc,
                TableOp::Get(0),
                TableOp::SetFromParam(1, 2),
                TableOp::SetFromGet(3, 4),
            ],
        };

        let expected = r#""
(module
  (type (;0;) (func))
  (type (;1;) (func (param externref externref)))
  (import """" ""gc"" (func (;0;) (type 0)))
  (func (;1;) (type 1) (param externref externref)
    call 0
    i32.const 0
    table.get 0
    drop
    i32.const 1
    local.get 2
    table.set 0
    i32.const 3
    i32.const 4
    table.get 0
    table.set 0)
  (table (;0;) 10 externref)
  (export ""run"" (func 1)))
""#;
        let actual = ops.to_wasm_binary();
        let actual = wasmprinter::print_bytes(&actual).unwrap();
        assert_eq!(actual.trim(), expected.trim());
    }",1,"2,3,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30","num_params: 2,/~/            table_size: 10,/~/  (type (;1;) (func (param externref externref)))/~/  (func (;1;) (type 1) (param externref externref)/~/    call 0/~/    i32.const 0/~/    table.get 0/~/    drop/~/    i32.const 1/~/    local.get 2/~/    table.set 0/~/    i32.const 3/~/    i32.const 4/~/    table.get 0/~/    table.set 0)/~/  (table (;0;) 10 externref)/~/  (export ""run"" (func 1)))"
"fn test_err_div64_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        div r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,,
"    pub fn len(&self) -> usize {
        self.constants.len()
    }",0,,
"pub fn new<T>(value: T) -> VMExternRef
    where
        T: 'static + Any + Send + Sync,
    {
        VMExternRef::new_with(|| value)
    }

    
    pub fn new_with<T>(make_value: impl FnOnce() -> T) -> VMExternRef
    where
        T: 'static + Any + Send + Sync,
    {
        unsafe {
            let (layout, footer_offset) =
                VMExternData::layout_for(mem::size_of::<T>(), mem::align_of::<T>());

            let alloc_ptr = std::alloc::alloc(layout);
            let alloc_ptr = NonNull::new(alloc_ptr).unwrap_or_else(|| {
                std::alloc::handle_alloc_error(layout);
            });

            let value_ptr = alloc_ptr.cast::<T>();
            ptr::write(value_ptr.as_ptr(), make_value());

            let extern_data_ptr =
                alloc_ptr.cast::<u8>().as_ptr().add(footer_offset) as *mut VMExternData;
            ptr::write(
                extern_data_ptr,
                VMExternData {
                    ref_count: AtomicUsize::new(1),
                    
                    value_ptr: NonNull::new_unchecked(value_ptr.as_ptr()),
                },
            );

            VMExternRef(NonNull::new_unchecked(extern_data_ptr))
        }
    }",0,,
"	pub fn dapps_middleware(
		_deps: Dependencies,
		_dapps_path: PathBuf,
		_extra_dapps: Vec<PathBuf>,
		_dapps_domain: String,
	) -> Result<Middleware, String> {
		Err(""Your Parity version has been compiled without WebApps support."".into())
	}",0,,
"	pub fn service(_: &Option<Middleware>) -> Option<Arc<rpc_apis::DappsService>> {
		None
	}",0,,
"    fn fill(&self, goto: InstPtr) -> Inst {
        match *self {
            InstHole::Save { slot } => {
                Inst::Save(InstSave { goto: goto, slot: slot })
            }
            InstHole::EmptyLook { look } => {
                Inst::EmptyLook(InstEmptyLook { goto: goto, look: look })
            }
            InstHole::Char { c } => Inst::Char(InstChar { goto: goto, c: c }),
            InstHole::Ranges { ref ranges } => Inst::Ranges(InstRanges {
                goto: goto,
                ranges: ranges.clone().into_boxed_slice(),
            }),
            InstHole::Bytes { start, end } => {
                Inst::Bytes(InstBytes { goto: goto, start: start, end: end })
            }
        }
    }",0,,
"	fn generate_token(&self) -> Result<String, Error> {
		self.signer.generate_token()
			.map_err(|e| errors::token(e))
	}",0,,
"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            
            
            self.base.climit.acquire().await.unwrap().forget();
            let stream = self.accept().await?;
            let mut chandle = ConnectionHandler::new(
                self.base.db.clone(),
                Connection::new(stream),
                self.base.climit.clone(),
                Terminator::new(self.base.signal.subscribe()),
                self.base.terminate_tx.clone(),
            );
            tokio::spawn(async move {
                if let Err(e) = chandle.run().await {
                    log::error!(""Error: {}"", e);
                }
            });
        }
    }",1,5,            let stream = self.accept().await?;
"fn on_initialize(_: T::BlockNumber) -> Weight {
			Pending::<T>::kill();

			if let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {
				let PreLog::Block(block) = log;

				for transaction in block.transactions {
					Self::do_transact(transaction).expect(
						""pre-block transaction verification failed; the block cannot be built"",
					);
				}
			}

			0
		}",0,,
"fn test_large_computation() {
		let input = hex::decode(
			""0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000020\
			0000000000000000000000000000000000000000000000000000000000000020\
			03\
			fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e\
			fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"",
		)
		.expect(""Decode failed"");

		let cost: u64 = 100000;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(precompile_result) => {
				assert_eq!(precompile_result.output.len(), 32); 
				let result = BigUint::from_bytes_be(&precompile_result.output[..]);
				let expected = BigUint::parse_bytes(b""1"", 10).unwrap();
				assert_eq!(result, expected);
			}
			Err(_) => {
				panic!(""Modexp::execute() returned error""); 
			}
		}
	}",0,,
"    pub fn expect_yielded(self, msg: &str) -> YieldedVal {
        self.yielded().expect(msg)
    }",0,,
"fn test_err_reg_stack_depth() {
    let config = Config::default();
    test_interpreter_and_jit_asm!(
        ""
        mov64 r0, 0x1
        lsh64 r0, 0x20
        callx r0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::CallDepthExceeded(pc, depth)
                    if pc == 31 && depth == config.max_call_depth
                )
            }
        },
        60
    );
}",0,,
"pub fn as_raw(&self) -> *mut u8 {
        let ptr = self.0.cast::<u8>().as_ptr();
        ptr
    }",0,,
"	fn exit_discard(&mut self) -> Result<(), ExitError> {
		self.substate.exit_discard()
	}",0,,
"fn test_jne_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xb
        mov32 r2, 0xb
        jne r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0xa
        jne r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,,
"	pub fn current_receipts() -> Option<Vec<ethereum::Receipt>> {
		CurrentReceipts::<T>::get()
	}",0,,
"    fn module(&self, pc: usize) -> Option<&Arc<RegisteredModule>> {
        let (end, info) = self.modules_with_code.range(pc..).next()?;
        if pc < info.start || *end < pc {
            return None;
        }

        Some(info)
    }",0,,
"fn seal<E: UserDefinedError>(&mut self, text_section_usage: usize) -> Result<(), EbpfError<E>> {
        if self.page_size > 0 {
            let raw = self.pc_section.as_ptr() as *mut u8;
            let pc_loc_table_size = round_to_page_size(self.pc_section.len() * 8, self.page_size);
            let over_allocated_code_size = round_to_page_size(self.text_section.len(), self.page_size);
            let code_size = round_to_page_size(text_section_usage, self.page_size);
            #[cfg(not(target_os = ""windows""))]
            unsafe {
                if over_allocated_code_size > code_size {
                    libc_error_guard!(munmap, raw.add(pc_loc_table_size).add(code_size) as *mut _, over_allocated_code_size - code_size);
                }
                std::ptr::write_bytes(raw.add(pc_loc_table_size).add(text_section_usage), 0xcc, code_size - text_section_usage); 
                self.text_section = std::slice::from_raw_parts_mut(raw.add(pc_loc_table_size), text_section_usage);
                libc_error_guard!(mprotect, self.pc_section.as_mut_ptr() as *mut _, pc_loc_table_size, libc::PROT_READ);
                libc_error_guard!(mprotect, self.text_section.as_mut_ptr() as *mut _, code_size, libc::PROT_EXEC | libc::PROT_READ);
            }
        }
        Ok(())
    }",0,,
"    fn cause(&self) -> Option<&dyn error::Error> {
        None
    }",0,,
"fn from(ty: wasmparser::TagType) -> Tag {
        Tag {
            ty: TypeIndex::from_u32(ty.type_index),
        }
    }",0,,
"pub fn wrap<T, Params, Results>(
        mut store: impl AsContextMut<Data = T>,
        func: impl IntoFunc<T, Params, Results>,
    ) -> Func {
        let store = store.as_context_mut().0;
        
        
        unsafe {
            let host = HostFunc::wrap(store.engine(), func);
            host.into_func(store)
        }
    }",0,,
"fn test_show_syntax_themes() {
        let opt = integration_test_utils::make_options_from_args(&[]);

        let mut writer = Cursor::new(vec![0; 1024]);
        _show_syntax_themes(opt, true, &mut writer, None).unwrap();
        let mut s = String::new();
        writer.seek(SeekFrom::Start(0)).unwrap();
        writer.read_to_string(&mut s).unwrap();
        let s = ansi::strip_ansi_codes(&s);
        assert!(s.contains(""\nTheme: gruvbox-light\n""));
        println!(""{}"", s);
        assert!(s.contains(""\nfn print_cube(num: f64) {\n""));
    }",0,,
"pub fn spectest(fuzz_config: crate::generators::Config, test: crate::generators::SpecTest) {
    crate::init_fuzzing();
    log::debug!(""running {:?} with {:?}"", test.file, fuzz_config);
    let mut config = fuzz_config.to_wasmtime();
    config.wasm_memory64(false);
    config.wasm_reference_types(false);
    config.wasm_bulk_memory(false);
    config.wasm_module_linking(false);
    config.wasm_multi_memory(false);
    let mut store = create_store(&Engine::new(&config).unwrap());
    if fuzz_config.consume_fuel {
        store.add_fuel(u64::max_value()).unwrap();
    }
    let mut wast_context = WastContext::new(store);
    wast_context.register_spectest().unwrap();
    wast_context
        .run_buffer(test.file, test.contents.as_bytes())
        .unwrap();
}",0,,
"fn test_arsh32_high_shift() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 8
        lddw r1, 0x100000001
        arsh32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x4 } },
        4
    );
}",0,,
"fn test_le16() {
    test_interpreter_and_jit_asm!(
        ""
        ldxh r0, [r1]
        le16 r0
        exit"",
        [0x22, 0x11],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122 } },
        3
    );
}",0,,
"fn _assert_send_sync() {
    fn _assert<T: Send + Sync>() {}
    _assert::<VMExternRefActivationsTable>();
    _assert::<VMExternRef>();
}",0,,
"fn recover_signer(transaction: &Transaction) -> Option<H160> {
		let mut sig = [0u8; 65];
		let mut msg = [0u8; 32];
		sig[0..32].copy_from_slice(&transaction.signature.r()[..]);
		sig[32..64].copy_from_slice(&transaction.signature.s()[..]);
		sig[64] = transaction.signature.standard_v();
		msg.copy_from_slice(&LegacyTransactionMessage::from(transaction.clone()).hash()[..]);

		let pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;
		Some(H160::from(H256::from_slice(
			Keccak256::digest(&pubkey).as_slice(),
		)))
	}",0,,
"fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {
		self.substate.log(address, topics, data)
	}",0,,
"fn is_reftype(ty: Type) -> bool {
    ty == types::R64 || ty == types::R32
}",0,,
"    pub fn strong_count(&self) -> usize {
        self.extern_data().ref_count.load(Ordering::SeqCst)
    }",0,,
"fn test_mul64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x40000001
        mov r1, 4
        mul r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x100000004 } },
        4
    );
}",0,,
"fn clone(&self) -> VMExternRef {
        self.extern_data().increment_ref_count();
        VMExternRef(self.0)
    }",0,,
"    fn new() -> KeyboardState {
        KeyboardState { state_modifiers: HashSet::new(), state_keysyms: AttributeSet::new() }
    }",0,,
"fn test_sth() {
    test_interpreter_and_jit_asm!(
        ""
        sth [r1+2], 0x2211
        ldxh r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xcc, 0xdd, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2211 } },
        3
    );
}",0,,
"pub fn is_empty(&self) -> bool {
		self.len() == 0
	}",0,,
"pub fn eq(a: &Self, b: &Self) -> bool {
        ptr::eq(a.0.as_ptr() as *const _, b.0.as_ptr() as *const _)
    }",0,,
"fn validate(
		source: H160,
		target: Option<H160>,
		input: Vec<u8>,
		value: U256,
		gas_limit: u64,
		max_fee_per_gas: Option<U256>,
		max_priority_fee_per_gas: Option<U256>,
		nonce: Option<U256>,
		access_list: Vec<(H160, Vec<H256>)>,
		is_transactional: bool,
		evm_config: &evm::Config,
	) -> Result<(), RunnerError<Self::Error>> {
		let (base_fee, mut weight) = T::FeeCalculator::min_gas_price();
		let (source_account, inner_weight) = Pallet::<T>::account_basic(&source);
		weight = weight.saturating_add(inner_weight);

		let _ = fp_evm::CheckEvmTransaction::<Self::Error>::new(
			fp_evm::CheckEvmTransactionConfig {
				evm_config,
				block_gas_limit: T::BlockGasLimit::get(),
				base_fee,
				chain_id: T::ChainId::get(),
				is_transactional,
			},
			fp_evm::CheckEvmTransactionInput {
				chain_id: Some(T::ChainId::get()),
				to: target,
				input,
				nonce: nonce.unwrap_or(source_account.nonce),
				gas_limit: gas_limit.into(),
				gas_price: None,
				max_fee_per_gas,
				max_priority_fee_per_gas,
				value,
				access_list,
			},
		)
		.validate_in_block_for(&source_account)
		.and_then(|v| v.with_base_fee())
		.and_then(|v| v.with_balance_for(&source_account))
		.map_err(|error| RunnerError { error, weight })?;
		Ok(())
	}",0,,
"    pub fn new(ty: wasmparser::GlobalType, initializer: GlobalInit) -> WasmResult<Global> {
        Ok(Global {
            wasm_ty: ty.content_type.try_into()?,
            mutability: ty.mutable,
            initializer,
        })
    }",0,,
"    pub fn reset(&mut self) -> Result<(), Error> {
        self.alloc.reset_heap(self.module.as_ref())?;
        let globals = unsafe { self.alloc.globals_mut() };
        let mod_globals = self.module.globals();
        for (i, v) in mod_globals.iter().enumerate() {
            globals[i] = match v.global() {
                Global::Import { .. } => {
                    return Err(Error::Unsupported(format!(
                        ""global imports are unsupported; found: {:?}"",
                        v
                    )));
                }
                Global::Def(def) => def.init_val(),
            };
        }

        if self.module.get_start_func()?.is_some() {
            self.state = State::NotStarted;
        } else {
            self.state = State::Ready;
        }

        #[cfg(feature = ""concurrent_testpoints"")]
        {
            self.kill_state = Arc::new(KillState::new(Arc::clone(&self.lock_testpoints)));
        }
        #[cfg(not(feature = ""concurrent_testpoints""))]
        {
            self.kill_state = Arc::new(KillState::new());
        }

        Ok(())
    }",0,,
"    pub(crate) fn lookup_frame_info(&self, pc: usize) -> Option<(FrameInfo, bool, bool)> {
        let (module, offset) = self.module(pc)?;
        module.lookup_frame_info(offset).map(|info| {
            (
                info,
                module.has_unparsed_debuginfo(),
                module.wasm_backtrace_details_env_used,
            )
        })
    }",0,,
"    pub fn from_mode(
        paging_mode: PagingMode,
        wrapping_mode: WrappingMode,
        pager: Option<&str>,
    ) -> Result<Self> {
        use self::PagingMode::*;
        Ok(match paging_mode {
            Always => OutputType::try_pager(SingleScreenAction::Nothing, wrapping_mode, pager)?,
            QuitIfOneScreen => {
                OutputType::try_pager(SingleScreenAction::Quit, wrapping_mode, pager)?
            }
            _ => OutputType::stdout(),
        })
    }",0,,
"fn fill_split(
        &mut self,
        hole: Hole,
        goto1: Option<InstPtr>,
        goto2: Option<InstPtr>,
    ) -> Hole {
        match hole {
            Hole::None => Hole::None,
            Hole::One(pc) => match (goto1, goto2) {
                (Some(goto1), Some(goto2)) => {
                    self.insts[pc].fill_split(goto1, goto2);
                    Hole::None
                }
                (Some(goto1), None) => {
                    self.insts[pc].half_fill_split_goto1(goto1);
                    Hole::One(pc)
                }
                (None, Some(goto2)) => {
                    self.insts[pc].half_fill_split_goto2(goto2);
                    Hole::One(pc)
                }
                (None, None) => unreachable!(
                    ""at least one of the split \
                     holes must be filled""
                ),
            },
            Hole::Many(holes) => {
                let mut new_holes = vec![];
                for hole in holes {
                    new_holes.push(self.fill_split(hole, goto1, goto2));
                }
                if new_holes.is_empty() {
                    Hole::None
                } else if new_holes.len() == 1 {
                    new_holes.pop().unwrap()
                } else {
                    Hole::Many(new_holes)
                }
            }
        }
    }",0,,
"fn test_load_elf_empty_rodata() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/empty_rodata.so"",
        config,
        [],
        (
            b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        8
    );
}",0,,
"    fn is_ret(&self, insn: InstIx) -> bool {
        match self.insts[insn.get() as usize].is_term() {
            MachTerminator::Ret => true,
            _ => false,
        }
    }",0,,
"fn test_jsge_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        jsge r1, -1, +5
        jsge r1, 0, +4
        mov32 r0, 1
        mov r1, -1
        jsge r1, -1, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,,
"fn test_be16() {
    test_interpreter_and_jit_asm!(
        ""
        ldxh r0, [r1]
        be16 r0
        exit"",
        [0x11, 0x22],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122 } },
        3
    );
}",0,,
"fn test_mul32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 3
        mul32 r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xc } },
        3
    );
}",0,,
"fn parse_test_sig(input: syn::ItemFn, rand: u16) -> TokenStream {
    for attr in &input.attrs {
        if attr.path.is_ident(""test"") {
            let msg = ""second test attribute is supplied"";
            return syn::Error::new_spanned(&attr, msg)
                .to_compile_error()
                .into();
        }
    }

    if !input.sig.inputs.is_empty() {
        let msg = ""the test function cannot accept arguments"";
        return syn::Error::new_spanned(&input.sig.inputs, msg)
            .to_compile_error()
            .into();
    }
    parse_dbtest(input, rand).unwrap_or_else(|e| e.to_compile_error().into())
}",0,,
"    fn from(ty: InstanceType) -> ExternType {
        ExternType::Instance(ty)
    }",0,,
"fn test_arsh32_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0xf8
        mov32 r1, 16
        lsh32 r0, 28
        arsh32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xffff8000 } },
        5
    );
}",0,,
"fn set_code(&mut self, address: H160, code: Vec<u8>) {
		log::debug!(
			target: ""evm"",
			""Inserting code ({} bytes) at {:?}"",
			code.len(),
			address
		);
		Pallet::<T>::create_account(address, code);
	}",0,,
"    pub fn inv(&self) -> Scalar {
        let mut ret = Scalar::default();
        ret.inv_in_place(self);
        ret
    }",0,,
"pub fn check_mut_ptr<T>(user_ptr: *mut T) -> Result<()> {
        
        
        check_ptr(user_ptr)
    }",0,,
"pub fn sign(message: &Message, seckey: &SecretKey) -> (Signature, RecoveryId) {
    let seckey_b32 = seckey.0.b32();
    let message_b32 = message.0.b32();

    let mut drbg = HmacDRBG::<Sha256>::new(&seckey_b32, &message_b32, &[]);
    let mut nonce = Scalar::default();
    let mut overflow;

    let result;
    loop {
        let generated = drbg.generate::<U32>(None);
        overflow = nonce.set_b32(array_ref!(generated, 0, 32));

        if !overflow && !nonce.is_zero() {
            match ECMULT_GEN_CONTEXT.sign_raw(&seckey.0, &message.0, &nonce) {
                Ok(val) => {
                    result = val;
                    break
                },
                Err(_) => (),
            }
        }
    }

    #[allow(unused_assignments)]
    {
        nonce = Scalar::default();
    }
    let (sigr, sigs, recid) = result;

    (Signature {
        r: sigr,
        s: sigs,
    }, RecoveryId(recid))
}",0,,
"	pub fn current_receipts() -> Option<Vec<ethereum::Receipt>> {
		CurrentReceipts::<T>::get()
	}",0,,
"    pub fn entering_host(&self) -> bool {
        match self {
            CallHook::ReturningFromWasm | CallHook::CallingHost => true,
            _ => false,
        }
    }",0,,
"    pub fn keys(&self) -> Keys<VCodeConstant> {
        self.constants.keys()
    }",0,,
"pub fn num_params(&self) -> u8 {
        let num_params = std::cmp::max(self.num_params, NUM_PARAMS_RANGE.start);
        let num_params = std::cmp::min(num_params, NUM_PARAMS_RANGE.end);
        num_params
    }",0,,
"pub fn run_func_idx(
        &mut self,
        table_idx: u32,
        func_idx: u32,
        args: &[Val],
    ) -> Result<RunResult, Error> {
        let func = self.module.get_func_from_idx(table_idx, func_idx)?;
        Ok(self.run_func(func, &args, false, None)?.unwrap())
    }",0,,
"    pub fn module_name(&self) -> Option<&str> {
        self.module_name.as_deref()
    }",0,,
"fn from(val: u128) -> Val {
        Val::V128(val)
    }",0,,
"    fn maybe_direct_reload(&self, insn: &I, reg: VirtualReg, slot: SpillSlot) -> Option<I> {
        insn.maybe_direct_reload(reg, slot)
    }",0,,
"    pub fn resume(&mut self) -> Result<RunResult, Error> {
        self.resume_with_val(EmptyYieldVal)
    }",0,,
"fn strip_first_last(s: &str) -> &str {
    &s[1..s.len() - 1]
}",0,,
"fn decode_into_nonempty_vec_doesnt_clobber_existing_prefix() {
        let mut orig_data = Vec::new();
        let mut encoded_data = String::new();
        let mut decoded_with_prefix = Vec::new();
        let mut decoded_without_prefix = Vec::new();
        let mut prefix = Vec::new();

        let prefix_len_range = Uniform::new(0, 1000);
        let input_len_range = Uniform::new(0, 1000);

        let mut rng = rand::rngs::SmallRng::from_entropy();

        for _ in 0..10_000 {
            orig_data.clear();
            encoded_data.clear();
            decoded_with_prefix.clear();
            decoded_without_prefix.clear();
            prefix.clear();

            let input_len = input_len_range.sample(&mut rng);

            for _ in 0..input_len {
                orig_data.push(rng.gen());
            }

            let config = random_config(&mut rng);
            encode_config_buf(&orig_data, config, &mut encoded_data);
            assert_encode_sanity(&encoded_data, config, input_len);

            let prefix_len = prefix_len_range.sample(&mut rng);

            
            for _ in 0..prefix_len {
                prefix.push(rng.gen());
            }

            decoded_with_prefix.resize(prefix_len, 0);
            decoded_with_prefix.copy_from_slice(&prefix);

            
            decode_config_buf(&encoded_data, config, &mut decoded_with_prefix).unwrap();
            
            decode_config_buf(&encoded_data, config, &mut decoded_without_prefix).unwrap();

            assert_eq!(
                prefix_len + decoded_without_prefix.len(),
                decoded_with_prefix.len()
            );
            assert_eq!(orig_data, decoded_without_prefix);

            
            prefix.append(&mut decoded_without_prefix);

            assert_eq!(prefix, decoded_with_prefix);
        }
    }",0,,
"    fn alloc_mut(&mut self) -> &mut Alloc {
        &mut self.alloc
    }",0,,
"fn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {
		let max_length = max(base_length, mod_length);
		let mut words = max_length / 8;
		if max_length % 8 > 0 {
			words += 1;
		}

		
		words * words
	}",1,7,		// TODO: prevent/handle overflow
"fn test_subnet() {
    test_interpreter_and_jit_asm!(
        ""
        mov r2, 0xe
        ldxh r3, [r1+12]
        jne r3, 0x81, +2
        mov r2, 0x12
        ldxh r3, [r1+16]
        and r3, 0xffff
        jne r3, 0x8, +5
        add r1, r2
        mov r0, 0x1
        ldxw r1, [r1+16]
        and r1, 0xffffff
        jeq r1, 0x1a8c0, +1
        mov r0, 0x0
        exit"",
        [
            0x00, 0x00, 0xc0, 0x9f, 0xa0, 0x97, 0x00, 0xa0, 
            0xcc, 0x3b, 0xbf, 0xfa, 0x08, 0x00, 0x45, 0x10, 
            0x00, 0x3c, 0x46, 0x3c, 0x40, 0x00, 0x40, 0x06, 
            0x73, 0x1c, 0xc0, 0xa8, 0x01, 0x02, 0xc0, 0xa8, 
            0x01, 0x01, 0x06, 0x0e, 0x00, 0x17, 0x99, 0xc5, 
            0xa0, 0xec, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, 
            0x7d, 0x78, 0xe0, 0xa3, 0x00, 0x00, 0x02, 0x04, 
            0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a, 0x00, 0x9c, 
            0x27, 0x24, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 
            0x03, 0x00, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        11
    );
}",0,,
"fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ValType::I32 => write!(f, ""i32""),
            ValType::I64 => write!(f, ""i64""),
            ValType::F32 => write!(f, ""f32""),
            ValType::F64 => write!(f, ""f64""),
            ValType::V128 => write!(f, ""v128""),
            ValType::ExternRef => write!(f, ""externref""),
            ValType::FuncRef => write!(f, ""funcref""),
        }
    }",0,,
"fn test_reloc_64_relative_data() {
    
    
    
    
    
    
    
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative_data.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x108 } },
        3
    );
}",0,,
"fn run_app() -> std::io::Result<i32> {
    let assets = HighlightingAssets::new();
    let opt = cli::Opt::from_args_and_git_config(&mut git_config::GitConfig::try_create(), assets);

    if opt.list_languages {
        list_languages()?;
        return Ok(0);
    } else if opt.list_syntax_themes {
        list_syntax_themes()?;
        return Ok(0);
    } else if opt.show_syntax_themes {
        show_syntax_themes()?;
        return Ok(0);
    } else if opt.show_themes {
        show_themes(opt.dark, opt.light, opt.computed.is_light_mode)?;
        return Ok(0);
    }

    let _show_config = opt.show_config;
    let config = config::Config::from(opt);

    if _show_config {
        let stdout = io::stdout();
        let mut stdout = stdout.lock();
        show_config(&config, &mut stdout)?;
        return Ok(0);
    }

    let mut output_type =
        OutputType::from_mode(config.paging_mode, config.pager.clone(), &config).unwrap();
    let mut writer = output_type.handle().unwrap();

    if atty::is(atty::Stream::Stdin) {
        let exit_code = diff(
            config.minus_file.as_ref(),
            config.plus_file.as_ref(),
            &config,
            &mut writer,
        );
        return Ok(exit_code);
    }

    if let Err(error) = delta(io::stdin().lock().byte_lines(), &mut writer, &config) {
        match error.kind() {
            ErrorKind::BrokenPipe => return Ok(0),
            _ => eprintln!(""{}"", error),
        }
    };
    Ok(0)
}",0,,
"pub fn execute(
		from: H160,
		transaction: &Transaction,
		config: Option<evm::Config>,
	) -> Result<
		(Option<H160>, Option<H160>, CallOrCreateInfo),
		DispatchErrorWithPostInfo<PostDispatchInfo>,
	> {
		let (
			input,
			value,
			gas_limit,
			max_fee_per_gas,
			max_priority_fee_per_gas,
			nonce,
			action,
			access_list,
		) = {
			match transaction {
				
				
				Transaction::Legacy(t) => (
					t.input.clone(),
					t.value,
					t.gas_limit,
					Some(t.gas_price),
					Some(t.gas_price),
					Some(t.nonce),
					t.action,
					Vec::new(),
				),
				Transaction::EIP2930(t) => {
					let access_list: Vec<(H160, Vec<H256>)> = t
						.access_list
						.iter()
						.map(|item| (item.address, item.storage_keys.clone()))
						.collect();
					(
						t.input.clone(),
						t.value,
						t.gas_limit,
						Some(t.gas_price),
						Some(t.gas_price),
						Some(t.nonce),
						t.action,
						access_list,
					)
				}
				Transaction::EIP1559(t) => {
					let access_list: Vec<(H160, Vec<H256>)> = t
						.access_list
						.iter()
						.map(|item| (item.address, item.storage_keys.clone()))
						.collect();
					(
						t.input.clone(),
						t.value,
						t.gas_limit,
						Some(t.max_fee_per_gas),
						Some(t.max_priority_fee_per_gas),
						Some(t.nonce),
						t.action,
						access_list,
					)
				}
			}
		};

		let is_transactional = true;
		let validate = false;
		match action {
			ethereum::TransactionAction::Call(target) => {
				let res = match T::Runner::call(
					from,
					target,
					input,
					value,
					gas_limit.low_u64(),
					max_fee_per_gas,
					max_priority_fee_per_gas,
					nonce,
					access_list,
					is_transactional,
					validate,
					config.as_ref().unwrap_or_else(|| T::config()),
				) {
					Ok(res) => res,
					Err(e) => {
						return Err(DispatchErrorWithPostInfo {
							post_info: PostDispatchInfo {
								actual_weight: Some(e.weight),
								pays_fee: Pays::Yes,
							},
							error: e.error.into(),
						})
					}
				};

				Ok((Some(target), None, CallOrCreateInfo::Call(res)))
			}
			ethereum::TransactionAction::Create => {
				let res = match T::Runner::create(
					from,
					input,
					value,
					gas_limit.low_u64(),
					max_fee_per_gas,
					max_priority_fee_per_gas,
					nonce,
					access_list,
					is_transactional,
					validate,
					config.as_ref().unwrap_or_else(|| T::config()),
				) {
					Ok(res) => res,
					Err(e) => {
						return Err(DispatchErrorWithPostInfo {
							post_info: PostDispatchInfo {
								actual_weight: Some(e.weight),
								pays_fee: Pays::Yes,
							},
							error: e.error.into(),
						})
					}
				};

				Ok((None, Some(res.value), CallOrCreateInfo::Create(res)))
			}
		}
	}",1,"77,105","gas_limit.low_u64(),/~/					gas_limit.low_u64(),"
"fn from(val: f32) -> Val {
        Val::F32(val.to_bits())
    }",0,,
"fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }",0,,
"fn reduce(&mut self, overflow: bool) -> bool {
        let o: u64 = if overflow { 1 } else { 0 };
        let mut t: u64;
        t = (self.0[0] as u64) + o * (SECP256K1_N_C_0 as u64);
        self.0[0] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[1] as u64) + o * (SECP256K1_N_C_1 as u64);
        self.0[1] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[2] as u64) + o * (SECP256K1_N_C_2 as u64);
        self.0[2] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[3] as u64) + o * (SECP256K1_N_C_3 as u64);
        self.0[3] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[4] as u64) + o * (SECP256K1_N_C_4 as u64);
        self.0[4] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += self.0[5] as u64;
        self.0[5] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += self.0[6] as u64;
        self.0[6] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += self.0[7] as u64;
        self.0[7] = (t & 0xFFFFFFFF) as u32;
        overflow
    }",0,,
"fn create2(
		source: H160,
		init: Vec<u8>,
		salt: H256,
		value: U256,
		gas_limit: u64,
		max_fee_per_gas: Option<U256>,
		max_priority_fee_per_gas: Option<U256>,
		nonce: Option<U256>,
		access_list: Vec<(H160, Vec<H256>)>,
		is_transactional: bool,
		validate: bool,
		config: &evm::Config,
	) -> Result<CreateInfo, RunnerError<Self::Error>> {
		if validate {
			let _ = Self::validate(
				source,
				None,
				init.clone(),
				value,
				gas_limit,
				max_fee_per_gas,
				max_priority_fee_per_gas,
				nonce,
				access_list.clone(),
				is_transactional,
				config,
			)?;
		}
		let precompiles = T::PrecompilesValue::get();
		let code_hash = H256::from(sp_io::hashing::keccak_256(&init));
		Self::execute(
			source,
			value,
			gas_limit,
			max_fee_per_gas,
			max_priority_fee_per_gas,
			config,
			&precompiles,
			is_transactional,
			|executor| {
				let address = executor.create_address(evm::CreateScheme::Create2 {
					caller: source,
					code_hash,
					salt,
				});
				let (reason, _) =
					executor.transact_create2(source, value, init, salt, gas_limit, access_list);
				(reason, address)
			},
		)
	}",0,,
"fn test_rsh64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x10
        mov r7, 4
        rsh r0, r7
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        4
    );
}",0,,
"pub unsafe fn clone_from_raw(ptr: *mut u8) -> Self {
        debug_assert!(!ptr.is_null());
        let x = VMExternRef(NonNull::new_unchecked(ptr).cast());
        x.extern_data().increment_ref_count();
        x
    }",0,,
"    pub fn expect_returned(self, msg: &str) -> UntypedRetVal {
        self.returned().expect(msg)
    }",0,,
"pub fn read64<R>(reader: &mut R) -> Result<u64, io::Error> where R: io::Read {
    let mut buf = [0u8; 8];
    reader.read_exact(&mut buf)?;
    Ok(u64::from_be_bytes(buf))
}",0,,
"fn test_err_dynamic_jmp_lddw() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r8, 0x1
        lsh64 r8, 0x20
        or64 r8, 0x28
        callx r8
        lddw r0, 0x1122334455667788
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 34
                )
            }
        },
        5
    );
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x1
        lsh64 r1, 0x20
        or64 r1, 0x38
        callx r1
        mov r0, r0
        mov r0, r0
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 36
                )
            }
        },
        5
    );
    test_interpreter_and_jit_asm!(
        ""
        lddw r1, 0x100000038
        callx r1
        mov r0, r0
        mov r0, r0
        exit
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 36
                )
            }
        },
        3
    );
}",0,,
"    pub fn get_func_name(&self, func_index: FuncIndex) -> Option<&str> {
        self.function_names.get(func_index).map(String::as_ref)
    }",0,,
"fn try_back_read(&mut self) {
        if self.back.is_none() {
            return;
        }

        
        let mut buf = [0u8; 1024];
        let back = self.back.as_mut().unwrap();
        let rc = try_read(back.read(&mut buf));

        if rc.is_err() {
            error!(""backend read failed: {:?}"", rc);
            self.closing = true;
            return;
        }

        let maybe_len = rc.unwrap();

        
        
        match maybe_len {
            Some(len) if len == 0 => {
                debug!(""back eof"");
                self.closing = true;
            }
            Some(len) => {
                self.tls_session.write_all(&buf[..len]).unwrap();
            }
            None => {}
        };
    }",0,,
"fn test_div64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xc
        lsh r0, 32
        mov r1, 4
        div r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x300000000 } },
        5
    );
}",0,,
"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            
            
            self.climit.acquire().await.forget();
            let stream = self.accept().await?;
            let mut chandle = CHandler {
                db: self.db.clone(),
                con: Connection::new(stream),
                climit: self.climit.clone(),
                terminator: Terminator::new(self.signal.subscribe()),
                _term_sig_tx: self.terminate_tx.clone(),
            };
            tokio::spawn(async move {
                if let Err(e) = chandle.run().await {
                    eprintln!(""Error: {}"", e);
                }
            });
        }
    }",1,4,            self.climit.acquire().await.forget();
"fn test_relative_call() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/relative_call.so"",
        config,
        [1],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 2 } },
        14
    );
}",0,,
"    pub fn diagnostic(self, source_code: &str) -> Diagnostic {
        Diagnostic::from_parse_error(self, source_code)
    }",0,,
"fn random_filename() -> String {
	use ::rand::Rng;
	let mut rng = ::rand::OsRng::new().unwrap();
	rng.gen_ascii_chars().take(12).collect()
}",0,,
"pub fn seteuid(uid: u32) {
    let uid = nix::unistd::Uid::from_raw(uid);
    match nix::unistd::seteuid(uid) {
        Ok(_) => log::debug!(""Dropping privileges...""),
        Err(e) => {
            log::error!(""Failed to set UID: {:#?}"", e);
            exit(1);
        }
    }
}",1,"1,5","    let uid = nix::unistd::Uid::from_raw(uid);/~/            log::error!(""Failed to set UID: {:#?}"", e);"
"    pub fn returned(self) -> Result<UntypedRetVal, Error> {
        match self {
            RunResult::Returned(rv) => Ok(rv),
            RunResult::Yielded(_) => Err(Error::InstanceNotReturned),
        }
    }",0,,
"fn c_char(&mut self, c: char) -> ResultOrEmpty {
        if self.compiled.uses_bytes() {
            if c.is_ascii() {
                let b = c as u8;
                let hole =
                    self.push_hole(InstHole::Bytes { start: b, end: b });
                self.byte_classes.set_range(b, b);
                Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))
            } else {
                self.c_class(&[hir::ClassUnicodeRange::new(c, c)])
            }
        } else {
            let hole = self.push_hole(InstHole::Char { c: c });
            Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))
        }
    }",0,,
"fn confirm_request_raw(&self, id: U256, bytes: Bytes) -> Result<ConfirmationResponse, Error> {
		let id = id.into();

		self.signer.peek(&id).map(|confirmation| {
			let result = match confirmation.payload {
				ConfirmationPayload::SendTransaction(request) => {
					Self::verify_transaction(bytes, request, |pending_transaction| {
						self.dispatcher.dispatch_transaction(pending_transaction)
							.map(Into::into)
							.map(ConfirmationResponse::SendTransaction)
					})
				},
				ConfirmationPayload::SignTransaction(request) => {
					Self::verify_transaction(bytes, request, |pending_transaction| {
						Ok(ConfirmationResponse::SignTransaction(pending_transaction.transaction.into()))
					})
				},
				ConfirmationPayload::EthSignMessage(address, data) => {
					let expected_hash = eth_data_hash(data);
					let signature = ethkey::Signature::from_electrum(&bytes.0);
					match ethkey::verify_address(&address, &signature, &expected_hash) {
						Ok(true) => Ok(ConfirmationResponse::Signature(bytes.0.as_slice().into())),
						Ok(false) => Err(errors::invalid_params(""Sender address does not match the signature."", ())),
						Err(err) => Err(errors::invalid_params(""Invalid signature received."", err)),
					}
				},
				ConfirmationPayload::Decrypt(_address, _data) => {
					
					Ok(ConfirmationResponse::Decrypt(bytes))
				},
			};
			if let Ok(ref response) = result {
				self.signer.request_confirmed(id, Ok(response.clone()));
			}
			result
		}).unwrap_or_else(|| Err(errors::invalid_params(""Unknown RequestID"", id)))
	}",0,,
"pub fn grow_memory_from_hostcall(
        &mut self,
        vmctx: &Vmctx,
        additional_pages: u32,
    ) -> Result<u32, Error> {
        
        fn aux(
            instance: &mut Instance,
            vmctx: &Vmctx,
            additional_pages: u32,
        ) -> Result<u32, Error> {
            
            let current_bytes = instance.alloc.heap_len();
            let additional_bytes =
                additional_pages
                    .checked_mul(WASM_PAGE_SIZE)
                    .ok_or_else(|| {
                        lucet_format_err!(""additional pages larger than wasm address space"",)
                    })? as usize;
            let desired_bytes = additional_bytes
                .checked_add(current_bytes)
                .ok_or_else(|| lucet_format_err!(""desired bytes overflow"",))?;
            
            if let Some(ref mut limiter) = instance.memory_limiter {
                if !vmctx.block_on(async move {
                    limiter.memory_growing(current_bytes, desired_bytes).await
                }) {
                    lucet_bail!(""memory limiter denied growth"");
                }
            }
            
            instance.grow_memory(additional_pages)
        }

        match aux(self, vmctx, additional_pages) {
            Ok(n) => Ok(n),
            Err(e) => {
                if let Some(ref mut limiter) = self.memory_limiter {
                    limiter.memory_grow_failed(&e);
                    Err(e)
                } else {
                    Err(e)
                }
            }
        }
    }",0,,
"pub fn is_num(&self) -> bool {
        match self {
            ValType::I32 | ValType::I64 | ValType::F32 | ValType::F64 => true,
            _ => false,
        }
    }",0,,
"    fn state(&self) -> &State {
        &self.state
    }",0,,
"pub fn try_insert(&mut self, externref: VMExternRef) -> Result<(), VMExternRef> {
        unsafe {
            let next = *self.alloc.next.get();
            if next == self.alloc.end {
                return Err(externref);
            }

            debug_assert!(
                (*next.as_ref().get()).is_none(),
                ""slots >= the `next` bump finger are always `None`""
            );
            ptr::write(next.as_ptr(), UnsafeCell::new(Some(externref)));

            let next = NonNull::new_unchecked(next.as_ptr().add(1));
            debug_assert!(next <= self.alloc.end);
            *self.alloc.next.get() = next;

            Ok(())
        }
    }",0,,
"fn instantiate_with_dummy(store: &mut Store<StoreLimits>, module: &Module) -> Option<Instance> {
    
    
    
    let instance =
        dummy::dummy_linker(store, module).and_then(|l| l.instantiate(&mut *store, module));

    let e = match instance {
        Ok(i) => return Some(i),
        Err(e) => e,
    };

    
    
    
    if store.data().oom {
        return None;
    }

    
    
    if e.downcast_ref::<Trap>().is_some() {
        return None;
    }

    let string = e.to_string();
    
    if string.contains(""all fuel consumed"")
        
        
        
        || string.contains(""incompatible import type"")
    {
        return None;
    }

    
    panic!(""failed to instantiate {:?}"", e);
}",0,,
"    fn alloc(&self) -> &Alloc;
    fn alloc_mut(&mut self) -> &mut Alloc;
    fn module(&self) -> &dyn Module;
    fn state(&self) -> &State;
    fn valid_magic(&self) -> bool;
}

impl InstanceInternal for Instance {
    
    fn alloc(&self) -> &Alloc {
        &self.alloc
    }

    
    fn alloc_mut(&mut self) -> &mut Alloc {
        &mut self.alloc
    }

    
    fn module(&self) -> &dyn Module {
        self.module.deref()
    }

    
    fn state(&self) -> &State {
        &self.state
    }

    
    fn valid_magic(&self) -> bool {
        self.magic == LUCET_INSTANCE_MAGIC
    }
}",0,,
"pub fn current_block() -> Option<ethereum::BlockV0> {
		CurrentBlock::<T>::get()
	}",0,,
"fn round_up_to_align(n: usize, align: usize) -> Option<usize> {
    debug_assert!(align.is_power_of_two());
    let align_minus_one = align - 1;
    Some(n.checked_add(align_minus_one)? & !align_minus_one)
}",0,,
"fn calc(reqs: usize, time: u128) -> f64 {
        reqs as f64 / (time as f64 / 1_000_000_000 as f64)
    }",0,,
"pub fn shr_int(&mut self, n: usize) -> u32 {
        let ret: u32;
        debug_assert!(n > 0);
        debug_assert!(n < 16);
        ret = self.0[0] & ((1 << n) - 1);
        self.0[0] = (self.0[0] >> n) + (self.0[1] << (32 - n));
        self.0[1] = (self.0[1] >> n) + (self.0[2] << (32 - n));
        self.0[2] = (self.0[2] >> n) + (self.0[3] << (32 - n));
        self.0[3] = (self.0[3] >> n) + (self.0[4] << (32 - n));
        self.0[4] = (self.0[4] >> n) + (self.0[5] << (32 - n));
        self.0[5] = (self.0[5] >> n) + (self.0[6] << (32 - n));
        self.0[6] = (self.0[6] >> n) + (self.0[7] << (32 - n));
        self.0[7] = self.0[7] >> n;
        return ret;
    }",0,,
"pub async fn run_server(&mut self) -> TResult<()> {
        match self {
            MultiListener::SecureOnly(secure_listener) => secure_listener.run().await,
            MultiListener::InsecureOnly(insecure_listener) => insecure_listener.run().await,
            MultiListener::Multi(insecure_listener, secure_listener) => {
                let insec = insecure_listener.run();
                let sec = secure_listener.run();
                let (e1, e2) = tokio::join!(insec, sec);
                if let Err(e) = e1 {
                    log::error!(""Insecure listener failed with: {}"", e);
                }
                if let Err(e) = e2 {
                    log::error!(""Secure listener failed with: {}"", e);
                }
                Ok(())
            }
        }
    }",0,,
"fn test_tcp_port80_nomatch_ethertype() {
    test_interpreter_and_jit_asm!(
        PROG_TCP_PORT_80,
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x06, 
            0x07, 0x08, 0x09, 0x0a, 0x08, 0x01, 0x45, 0x00, 
            0x00, 0x56, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 
            0xf9, 0x4d, 0xc0, 0xa8, 0x00, 0x01, 0xc0, 0xa8, 
            0x00, 0x02, 0x27, 0x10, 0x00, 0x50, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02, 
            0x20, 0x00, 0xc5, 0x18, 0x00, 0x00, 0x44, 0x44, 
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 
            0x44, 0x44, 0x44, 0x44, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        7
    );
}",0,,
"    pub const fn new(signal: broadcast::Receiver<()>) -> Self {
        Terminator {
            
            terminate: false,
            signal,
        }
    }",0,,
"fn new(server: TcpListener, mode: ServerMode, cfg: Arc<rustls::ServerConfig>) -> TlsServer {
        TlsServer {
            server,
            connections: HashMap::new(),
            next_id: 2,
            tls_config: cfg,
            mode,
        }
    }",0,,
"    fn from(ty: GlobalType) -> ExternType {
        ExternType::Global(ty)
    }",0,,
"fn strip_comments(string: &str) -> String {
    
    let line_comments = Regex::new(r""(?m)//.*$"").unwrap();
    line_comments.replace_all(string, ""$1"").into_owned()
}",1,"0,1,2,3","fn strip_comments(string: &str) -> String {/~/    // Remove line comments/~/    let line_comments = Regex::new(r""(?m)//.*$"").unwrap();/~/    line_comments.replace_all(string, ""$1"").into_owned()"
"pub fn set_command_line_args() -> Command<'static> {
    let app = Command::new(""swhkd"")
        .version(env!(""CARGO_PKG_VERSION""))
        .author(env!(""CARGO_PKG_AUTHORS""))
        .about(""Simple Wayland HotKey Daemon"")
        .arg(
            arg!(-c --config <CONFIG_FILE_PATH>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom config file path.""),
        )
        .arg(
            arg!(-C --cooldown <COOLDOWN_IN_MS>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom repeat cooldown duration. Default is 250ms.""),
        )
        .arg(arg!(-d - -debug).required(false).help(""Enable debug mode.""));
    app
}",0,,
"fn atou16_misc() {
        assert_ok!(atou16(b""0""), 0);
        assert_ok!(atou16(b""0010""), 10);
        assert_ok!(atou16(b""9999""), 9999);
        assert_err_pat!(atou16(b""""), Error::InvalidFormat(_));
        assert_err_pat!(atou16(b""/""), Error::InvalidFormat(_));
        assert_err_pat!(atou16(b"":""), Error::InvalidFormat(_));
        assert_err_pat!(atou16(b""-1""), Error::InvalidFormat(_));
    }",0,,
"pub fn maximum(&self) -> Option<u32> {
        self.ty.maximum
    }",0,,
"fn test_ldabsb() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsb 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x33 } },
        2
    );
}",0,,
"fn c_byte(&mut self, b: u8) -> ResultOrEmpty {
        self.c_class_bytes(&[hir::ClassBytesRange::new(b, b)])
    }",0,,
"    pub fn new(config: TargetFrontendConfig, return_mode: ReturnMode, debug_info: bool) -> Self {
        Self {
            info: DummyModuleInfo::new(config),
            trans: FuncTranslator::new(),
            func_bytecode_sizes: Vec::new(),
            return_mode,
            debug_info,
            module_name: None,
            function_names: SecondaryMap::new(),
            expected_reachability: None,
        }
    }",0,,
"	fn is_major_importing(&self) -> bool;
}

impl<F> SyncStatus for F where F: Fn() -> bool + Send + Sync {
	fn is_major_importing(&self) -> bool { self() }
}",0,,
"fn test_err_capped_before_exception() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x0
        mov64 r2, 0x0
        add64 r0, 0x0
        add64 r0, 0x0
        div64 r1, r2
        add64 r0, 0x0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 31 && initial_insn_count == 2
                )
            }
        },
        2
    );
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x0
        mov64 r2, 0x0
        add64 r0, 0x0
        add64 r0, 0x0
        syscall Unresolved
        add64 r0, 0x0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 33 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,,
"fn test_sdiv64_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xc
        lsh r0, 32
        sdiv r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x300000000 } },
        4
    );
}",0,,
"    fn drop(&mut self) {
        let mut info = GLOBAL_MODULES.write().unwrap();
        for end in self.modules_with_code.keys() {
            info.unregister(*end);
        }
    }",0,,
"fn test_nested_vm_syscall() {
    let config = Config::default();
    let mut nested_vm_syscall = NestedVmSyscall {};
    let memory_mapping = MemoryMapping::new::<UserError>(vec![], &config).unwrap();
    let mut result = Ok(0);
    nested_vm_syscall.call(1, 0, 0, 0, 0, &memory_mapping, &mut result);
    assert!(result.unwrap() == 42);
    let mut result = Ok(0);
    nested_vm_syscall.call(1, 1, 0, 0, 0, &memory_mapping, &mut result);
    assert!(matches!(result.unwrap_err(),
        EbpfError::CallDepthExceeded(pc, depth)
        if pc == 33 && depth == 0
    ));
}",0,,
"    pub async fn new_multi(
        ssl_base_listener: BaseListener,
        tcp_base_listener: BaseListener,
        ssl: SslOpts,
    ) -> Result<Self, String> {
        let sec_bindaddr = bindaddr!(ssl_base_listener);
        let insec_binaddr = bindaddr!(tcp_base_listener);
        let secure_listener = SslListener::new_pem_based_ssl_connection(
            ssl.key,
            ssl.chain,
            ssl_base_listener,
            ssl.passfile,
        )
        .map_err(|e| format!(""Couldn't bind to secure port: {}"", e))?;
        let insecure_listener = Listener {
            base: tcp_base_listener,
        };
        log::info!(
            ""Server started on: skyhash://{} and skyhash-secure://{}"",
            insec_binaddr,
            sec_bindaddr
        );
        Ok(MultiListener::Multi(insecure_listener, secure_listener))
    }",0,,
"fn half_fill_split_goto2(&mut self, goto2: InstPtr) {
        let half_filled = match *self {
            MaybeInst::Split => goto2,
            _ => unreachable!(
                ""must be called on Split instruction, \
                 instead it was called on: {:?}"",
                self
            ),
        };
        *self = MaybeInst::Split2(half_filled);
    }",0,,
"fn test_frame_info() -> Result<(), anyhow::Error> {
    use crate::*;
    let mut store = Store::<()>::default();
    let module = Module::new(
        store.engine(),
        r#""
            (module
                (func (export ""add"") (param $x i32) (param $y i32) (result i32) (i32.add (local.get $x) (local.get $y)))
                (func (export ""sub"") (param $x i32) (param $y i32) (result i32) (i32.sub (local.get $x) (local.get $y)))
                (func (export ""mul"") (param $x i32) (param $y i32) (result i32) (i32.mul (local.get $x) (local.get $y)))
                (func (export ""div_s"") (param $x i32) (param $y i32) (result i32) (i32.div_s (local.get $x) (local.get $y)))
                (func (export ""div_u"") (param $x i32) (param $y i32) (result i32) (i32.div_u (local.get $x) (local.get $y)))
                (func (export ""rem_s"") (param $x i32) (param $y i32) (result i32) (i32.rem_s (local.get $x) (local.get $y)))
                (func (export ""rem_u"") (param $x i32) (param $y i32) (result i32) (i32.rem_u (local.get $x) (local.get $y)))
            )
         ""#,
    )?;
    
    Instance::new(&mut store, &module, &[])?;

    GlobalModuleRegistry::with(|modules| {
        for (i, alloc) in module.compiled_module().finished_functions() {
            let (start, end) = unsafe {
                let ptr = (*alloc).as_ptr();
                let len = (*alloc).len();
                (ptr as usize, ptr as usize + len)
            };
            for pc in start..end {
                let (frame, _, _) = modules.lookup_frame_info(pc).unwrap();
                assert!(
                    frame.func_index() == i.as_u32(),
                    ""lookup of {:#x} returned {}, expected {}"",
                    pc,
                    frame.func_index(),
                    i.as_u32()
                );
            }
        }
    });
    Ok(())
}",0,,
"    fn memory_growing(&mut self, current: usize, desired: usize, _maximum: Option<usize>) -> bool {
        self.alloc(desired - current)
    }",0,,
"fn test_mov32_imm_large() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, -1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xffffffff } },
        2
    );
}",0,,
"pub(crate) unsafe fn from_checked_anyfunc(
    anyfunc: *mut wasmtime_runtime::VMCallerCheckedAnyfunc,
    store: &mut StoreOpaque,
) -> Val {
    Val::FuncRef(Func::from_caller_checked_anyfunc(store, anyfunc))
}",0,,
"fn write_u64(output: &mut [u8], value: u64) {
    output[..8].copy_from_slice(&value.to_be_bytes());
}",0,,
"fn test_tight_infinite_recursion() {
    test_interpreter_and_jit_asm!(
        ""
        entrypoint:
        mov64 r3, 0x41414141
        call entrypoint
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 31 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,,
	fn is_major_importing(&self) -> bool { self() },0,,
"fn test_arsh64() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        lsh r0, 63
        arsh r0, 55
        mov32 r1, 5
        arsh r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xfffffffffffffff8 } },
        6
    );
}",0,,
"pub fn recover(message: &Message, signature: &Signature, recovery_id: &RecoveryId) -> Result<PublicKey, Error> {
    ECMULT_CONTEXT.recover_raw(&signature.r, &signature.s, recovery_id.0, &message.0).map(|v| PublicKey(v))
}",0,,
"fn test_stxb_chain() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxb r9, [r0+0]
        stxb [r0+1], r9
        ldxb r8, [r0+1]
        stxb [r0+2], r8
        ldxb r7, [r0+2]
        stxb [r0+3], r7
        ldxb r6, [r0+3]
        stxb [r0+4], r6
        ldxb r5, [r0+4]
        stxb [r0+5], r5
        ldxb r4, [r0+5]
        stxb [r0+6], r4
        ldxb r3, [r0+6]
        stxb [r0+7], r3
        ldxb r2, [r0+7]
        stxb [r0+8], r2
        ldxb r1, [r0+8]
        stxb [r0+9], r1
        ldxb r0, [r0+9]
        exit"",
        [
            0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2a } },
        21
    );
}",0,,
"pub fn neg_in_place(&mut self, a: &Scalar) {
        let nonzero: u64 = 0xFFFFFFFF * if !a.is_zero() { 1 } else { 0 };
        let mut t: u64 = (!a.0[0]) as u64 + (SECP256K1_N_0 + 1) as u64;
        self.0[0] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[1]) as u64 + SECP256K1_N_1 as u64;
        self.0[1] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[2]) as u64 + SECP256K1_N_2 as u64;
        self.0[2] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[3]) as u64 + SECP256K1_N_3 as u64;
        self.0[3] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[4]) as u64 + SECP256K1_N_4 as u64;
        self.0[4] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[5]) as u64 + SECP256K1_N_5 as u64;
        self.0[5] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[6]) as u64 + SECP256K1_N_6 as u64;
        self.0[6] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[7]) as u64 + SECP256K1_N_7 as u64;
        self.0[7] = (t & nonzero) as u32;
    }",0,,
"	fn requests_to_confirm(&self) -> Result<Vec<ConfirmationRequest>, Error> {
		Ok(self.signer.requests()
			.into_iter()
			.map(Into::into)
			.collect()
		)
	}",0,,
"fn test_excessive_input() -> std::result::Result<(), PrecompileFailure> {
		let input = hex::decode(
			""1000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001"",
		)
		.expect(""Decode failed"");

		let cost: u64 = 1;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(_) => {
				panic!(""Test not expected to pass"");
			}
			Err(e) => {
				assert_eq!(
					e,
					PrecompileFailure::Error {
						exit_status: ExitError::Other(""unreasonably large base length"".into())
					}
				);
				Ok(())
			}
		}
	}",0,,
"    pub fn has_yielded<A: Any>(&self) -> bool {
        match self {
            RunResult::Yielded(yv) => yv.is::<A>(),
            _ => false,
        }
    }",0,,
"fn test_stw() {
    test_interpreter_and_jit_asm!(
        ""
        stw [r1+2], 0x44332211
        ldxw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xcc, 0xdd, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x44332211 } },
        3
    );
}",0,,
"    fn func_liveins(&self) -> RegallocSet<RealReg> {
        self.liveins.clone()
    }",0,,
"fn call(&self, address: Address, data: Bytes) -> BoxFuture<Bytes, String> {
		let (header, env_info) = (self.client.best_block_header(), self.client.latest_env_info());

		let maybe_future = self.sync.with_context(move |ctx| {
			self.on_demand
				.request(ctx, on_demand::request::TransactionProof {
					tx: Transaction {
						nonce: self.client.engine().account_start_nonce(),
						action: Action::Call(address),
						gas: 50_000_000.into(),
						gas_price: 0.into(),
						value: 0.into(),
						data: data,
					}.fake_sign(Address::default()),
					header: header.into(),
					env_info: env_info,
					engine: self.client.engine().clone(),
				})
				.expect(""No back-references; therefore all back-refs valid; qed"")
				.then(|res| match res {
					Ok(Ok(executed)) => Ok(executed.output),
					Ok(Err(e)) => Err(format!(""Failed to execute transaction: {}"", e)),
					Err(_) => Err(format!(""On-demand service dropped request unexpectedly."")),
				})
		});

		match maybe_future {
			Some(fut) => fut.boxed(),
			None => future::err(""cannot query registry: network disabled"".into()).boxed(),
		}
	}",0,,
"fn into(self) -> u8 {
        self.0
    }",0,,
"fn test_ldxw() {
    test_interpreter_and_jit_asm!(
        ""
        ldxw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0x11, 0x22, 0x33, 0x44, 0xcc, 0xdd, 
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x44332211 } },
        2
    );
}",0,,
"    pub(crate) fn is_pager(&self) -> bool {
        matches!(self, OutputType::Pager(_))
    }",0,,
"    pub fn init<C, E>(_unused: C) -> Box<dyn SyscallObject<UserError>> {
        Box::new(Self {})
    }",0,,
"fn accept(&mut self, poll: &mut mio::Poll) -> bool {
        match self.server.accept() {
            Ok((socket, addr)) => {
                debug!(""Accepting new connection from {:?}"", addr);

                let tls_session = rustls::ServerSession::new(&self.tls_config);
                let mode = self.mode.clone();

                let token = mio::Token(self.next_id);
                self.next_id += 1;

                self.connections.insert(token, Connection::new(socket, token, mode, tls_session));
                self.connections[&token].register(poll);
                true
            }
            Err(e) => {
                println!(""encountered error while accepting connection; err={:?}"", e);
                false
            }
        }
    }",0,,
"fn build(&self) {
			<Pallet<T>>::store_block(false, U256::zero());
			frame_support::storage::unhashed::put::<EthereumStorageSchema>(
				&PALLET_ETHEREUM_SCHEMA,
				&EthereumStorageSchema::V1,
			);
		}",0,,
"fn c_empty_look(&mut self, look: EmptyLook) -> ResultOrEmpty {
        let hole = self.push_hole(InstHole::EmptyLook { look: look });
        Ok(Some(Patch { hole: hole, entry: self.insts.len() - 1 }))
    }",0,,
"    pub fn get_num_func_imports(&self) -> usize {
        self.info.imported_funcs.len()
    }",0,,
"pub fn new_ui(enabled: bool, deps: Dependencies) -> Result<Option<Middleware>, String> {
	if !enabled {
		return Ok(None);
	}

	server::ui_middleware(
		deps,
		rpc::DAPPS_DOMAIN.into(),
	).map(Some)
}",0,,
"    fn from(ty: ModuleType) -> ExternType {
        ExternType::Module(ty)
    }",0,,
"    pub fn neg(&self) -> Scalar {
        let mut ret = Scalar::default();
        ret.neg_in_place(self);
        ret
    }",0,,
"    pub fn abi(&mut self) -> &mut dyn ABICallee<I = I> {
        &mut *self.vcode.abi
    }",0,,
"pub fn push(&mut self, insn: I, is_safepoint: bool) {
        match insn.is_term() {
            MachTerminator::None | MachTerminator::Ret => {}
            MachTerminator::Uncond(target) => {
                self.vcode.block_succs.push(BlockIx::new(target.get()));
            }
            MachTerminator::Cond(true_branch, false_branch) => {
                self.vcode.block_succs.push(BlockIx::new(true_branch.get()));
                self.vcode
                    .block_succs
                    .push(BlockIx::new(false_branch.get()));
            }
            MachTerminator::Indirect(targets) => {
                for target in targets {
                    self.vcode.block_succs.push(BlockIx::new(target.get()));
                }
            }
        }
        if insn.defines_value_label().is_some() {
            self.vcode.has_value_labels = true;
        }
        self.vcode.insts.push(insn);
        self.vcode.srclocs.push(self.cur_srcloc);
        if is_safepoint {
            self.stack_map_info
                .safepoint_insns
                .push(InstIx::new((self.vcode.insts.len() - 1) as u32));
        }
    }",0,,
"    fn reregister(&self, poll: &mut mio::Poll) {
        poll.reregister(&self.socket,
                        self.token,
                        self.event_set(),
                        mio::PollOpt::level() | mio::PollOpt::oneshot())
            .unwrap();

        if self.back.is_some() {
            poll.reregister(self.back.as_ref().unwrap(),
                            self.token,
                            mio::Ready::readable(),
                            mio::PollOpt::level() | mio::PollOpt::oneshot())
                .unwrap();
        }
    }",0,,
"    fn get(&mut self, key: SuffixCacheKey, pc: InstPtr) -> Option<InstPtr> {
        let hash = self.hash(&key);
        let pos = &mut self.sparse[hash];
        if let Some(entry) = self.dense.get(*pos) {
            if entry.key == key {
                return Some(entry.pc);
            }
        }
        *pos = self.dense.len();
        self.dense.push(SuffixCacheEntry { key: key, pc: pc });
        None
    }",0,,
"    fn take(&self, count: usize) -> Self {
        let tokens = &self.tokens[..count];

        Input { source: self.source, tokens }
    }",1,3,"        Input { source: self.source, tokens }"
"    pub fn file(&self) -> Option<&str> {
        self.file.as_deref()
    }",0,,
"fn test_jeq_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xa
        jeq r1, 0xb, +4
        mov32 r0, 1
        mov32 r1, 0xb
        jeq r1, 0xb, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,,
"pub fn read16<R>(reader: &mut R) -> Result<u16, io::Error> where R: io::Read {
    let mut buf = [0u8; 2];
    reader.read_exact(&mut buf)?;
    Ok(u16::from_be_bytes(buf))
}",0,,
