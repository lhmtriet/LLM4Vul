processed_func,target,flaw_line_index,flaw_line
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        
        var headers: HTTPHeaders = [:]

        
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        
        
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    
    
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    
    
    
    
    
    
    
    
    
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"internal static func footer(_ p1: Int) -> String {
            return L10n.tr(""Localizable"", ""participants.section.name.footer"", p1)
          }",0,,
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"    private func appendLegalHoldDisabledSystemMessageForConversationAfterReceivingMessage(at timestamp: Date) {
        appendSystemMessage(type: .legalHoldDisabled,
                            sender: ZMUser.selfUser(in: self.managedObjectContext!),
                            users: nil,
                            clients: nil,
                            timestamp: timestamp.previousNearestTimestamp)
    }",0,,
"internal static func message(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""login.sso.error.alert.message"", String(describing: p1))
            }",0,,
"    public init(buffer: ByteBuffer) throws {
        self.buffer = buffer
    }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    
    if operations.shouldCloseChannel, let context = self.context {
      
      
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"internal static func otherRemovedYou(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.other_removed_you"", String(describing: p1))
        }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"    public func decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set<UserClient>, causedBy message: ZMOTRMessage?) {
        applySecurityChanges(cause: .addedClients(clients, source: message))
    }",0,,
"  mutating func pingFired() -> Action {
    if self.shouldBlockPing {
      return .none
    } else {
      return .reply(self.generatePingFrame(code: self.pingCode, ack: false))
    }
  }",1,4,"      return .reply(self.generatePingFrame(code: self.pingCode, ack: false))"
