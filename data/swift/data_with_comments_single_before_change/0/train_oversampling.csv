processed_func,target,flaw_line_index,flaw_line
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"    private func updateLegalHoldIfNeededWithHint(from message: GenericMessage, timestamp: Date) {
        switch message.legalHoldStatus {
        case .enabled where !legalHoldStatus.denotesEnabledComplianceDevice:
            needsToVerifyLegalHold = true
            legalHoldStatus = .pendingApproval
            appendLegalHoldEnabledSystemMessageForConversationAfterReceivingMessage(at: timestamp)
            expireAllPendingMessagesBecauseOfSecurityLevelDegradation()
        case .disabled where legalHoldStatus.denotesEnabledComplianceDevice:
            needsToVerifyLegalHold = true
            legalHoldStatus = .disabled
            appendLegalHoldDisabledSystemMessageForConversationAfterReceivingMessage(at: timestamp)
        default:
            break
        }
    }",0,,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"internal static func minLength(_ p1: Int) -> String {
            return L10n.tr(""Localizable"", ""registration.password.rules.min_length"", p1)
          }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"    override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
        super.viewWillTransition(to: size, with: coordinator)
        coordinator.animate(alongsideTransition: { [updateGridViewAxis] _ in updateGridViewAxis() })
    }",0,,
"func userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {
    if let created = event as? NIOHTTP2StreamCreatedEvent {
      self.perform(operations: self.stateMachine.streamCreated(withID: created.streamID))
      self.handlePingAction(self.pingHandler.streamCreated())
      context.fireUserInboundEventTriggered(event)
    } else if let closed = event as? StreamClosedEvent {
      self.perform(operations: self.stateMachine.streamClosed(withID: closed.streamID))
      self.handlePingAction(self.pingHandler.streamClosed())
      self.mode.connectionManager?.streamClosed()
      context.fireUserInboundEventTriggered(event)
    } else if event is ChannelShouldQuiesceEvent {
      self.perform(operations: self.stateMachine.initiateGracefulShutdown())
      // Swallow this event.
    } else {
      context.fireUserInboundEventTriggered(event)
    }
  }",0,,
"internal static func noRequirements(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""registration.password.rules.no_requirements"", String(describing: p1))
          }",0,,
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"    public func handleDoubleTap(gesture: UIGestureRecognizer) {
        let location = gesture.location(in: gridView)
        toggleMaximized(view: streamView(at: location))
    }",0,,
"    private func applicationDidTransition(to appState: AppState) {
        if case .unauthenticated(let error) = appState {
            presentAlertForDeletedAccountIfNeeded(error)
        }

        if case .authenticated = appState {
            authenticatedRouter?.updateActiveCallPresentationState()

            ZClientViewController.shared?.legalHoldDisclosureController?.discloseCurrentState(cause: .appOpen)
        }

        resetSelfUserProviderIfNeeded(for: appState)
        urlActionRouter.openDeepLink(for: appState)
        appStateTransitionGroup.leave()
    }",0,,
"    internal init(io: NonBlockingFileIO, allocator: ByteBufferAllocator, request: Request) {
        self.io = io
        self.allocator = allocator
        self.request = request
    }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    private func acknowledgePrivacyChanges() {
        precondition(managedObjectContext?.zm_isUserInterfaceContext == true)

        // Downgrade the conversation to be unverified
        if securityLevel == .secureWithIgnored {
            securityLevel = .notSecure
        }

        // Accept legal hold
        if legalHoldStatus == .pendingApproval {
            legalHoldStatus = .enabled
        }

        managedObjectContext?.saveOrRollback()
    }",0,,
"    private func configureColorScheme() {
        let colorScheme = ColorScheme.default
        colorScheme.accentColor = .accent()
        colorScheme.variant = Settings.shared.colorSchemeVariant
    }",0,,
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"    private func transition(to appState: AppState, completion: @escaping () -> Void) {
        applicationWillTransition(to: appState)

        resetAuthenticationCoordinatorIfNeeded(for: appState)

        let completionBlock = { [weak self] in
            completion()
            self?.applicationDidTransition(to: appState)
        }

        switch appState {
        case .blacklisted:
            showBlacklisted(completion: completionBlock)
        case .jailbroken:
            showJailbroken(completion: completionBlock)
        case .databaseFailure:
            showDatabaseLoadingFailure(completion: completionBlock)
        case .migrating:
            showLaunchScreen(isLoading: true, completion: completionBlock)
        case .unauthenticated(error: let error):
            screenCurtain.delegate = nil
            configureUnauthenticatedAppearance()
            showUnauthenticatedFlow(error: error, completion: completionBlock)
        case .authenticated(completedRegistration: let completedRegistration):
            configureAuthenticatedAppearance()
            executeAuthenticatedBlocks()
            // TODO: [John] Avoid singleton.
            screenCurtain.delegate = ZMUserSession.shared()
            showAuthenticated(isComingFromRegistration: completedRegistration,
                              completion: completionBlock)
        case .headless:
            showLaunchScreen(completion: completionBlock)
        case .loading(account: let toAccount, from: let fromAccount):
            showSkeleton(fromAccount: fromAccount,
                         toAccount: toAccount,
                         completion: completionBlock)
        case .locked:
            // TODO: [John] Avoid singleton.
            screenCurtain.delegate = ZMUserSession.shared()
            showAppLock(completion: completionBlock)
        }
    }",0,,
"fileprivate init(fromWaitingToIdle state: WaitingToIdle) {
      self.role = state.role
      self.openStreams = 0
      self.lastPeerInitiatedStreamID = state.lastPeerInitiatedStreamID
      self.maxConcurrentStreams = state.maxConcurrentStreams
      // We won't transition to 'WaitingToIdle' unless we've seen a SETTINGS frame.
      self.hasSeenSettings = true
    }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"internal static func subtitle(_ p1: Any, _ p2: Any) -> String {
            return L10n.tr(""Localizable"", ""conversation.create.options.subtitle"", String(describing: p1), String(describing: p2))
          }",0,,
"private static func readUint16(_ buffer: UnsafePointer<UInt8>, offset: Int) -> UInt16 {
        return (UInt16(buffer[offset + 0]) << 8) | UInt16(buffer[offset + 1])
    }",0,,
"    fileprivate func timestampAfterLastMessage() -> Date {
        return timestamp(after: lastMessage) ?? Date()
    }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    private func updateSelfPreview() {
        guard
            let selfStreamId = ZMUser.selfUser()?.selfStreamId,
            let selfStream = stream(with: selfStreamId)
        else {
            return
        }

        if let view = viewCache[selfStreamId] as? SelfVideoPreviewView {
            view.stream = selfStream
            view.shouldShowActiveSpeakerFrame = configuration.shouldShowActiveSpeakerFrame
        } else {
            viewCache[selfStreamId] = SelfVideoPreviewView(
                stream: selfStream,
                isCovered: isCovered,
                shouldShowActiveSpeakerFrame: configuration.shouldShowActiveSpeakerFrame
            )
        }
    }",1,"1,2,3,4","        guard/~/            let selfStreamId = ZMUser.selfUser()?.selfStreamId,/~/            let selfStream = stream(with: selfStreamId)/~/        else {"
"    public func increaseSecurityLevelIfNeededAfterRemoving(clients: [ZMUser: Set<UserClient>]) {
        applySecurityChanges(cause: .removedClients(clients))
    }",0,,
"internal static func connectedTo(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.connected_to"", String(describing: p1))
        }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"    private func applySecurityChanges(cause: SecurityChangeCause) {
        updateLegalHoldState(cause: cause)
        updateSecurityLevel(cause: cause)
    }",0,,
"    private func streamView(at location: CGPoint) -> BaseVideoPreviewView? {
        guard let indexPath = gridView.indexPathForItem(at: location) else {
            return nil
        }
        return streamView(for: dataSource[indexPath.row].stream) as? BaseVideoPreviewView
    }",0,,
"    public func decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set<UserClient>, causedBy users: Set<ZMUser>) {
        applySecurityChanges(cause: .addedUsers(users))
    }",0,,
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"internal static func recordTip(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""conversation.input_bar.audio_message.keyboard.record_tip"", String(describing: p1))
            }",0,,
"internal static func title(_ p1: Any) -> String {
        return L10n.tr(""Localizable"", ""connection_request.title"", String(describing: p1))
      }",0,,
"    private func isMaximized(stream: Stream?) -> Bool {
        guard
            let streamId = stream?.streamId,
            let maximizedStreamId = maximizedView?.stream.streamId
        else { return false }
        
        return streamId == maximizedStreamId
    }",0,,
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"    private func streamView(for stream: Stream) -> UIView? {
        return viewCache[stream.streamId]
    }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"      self.state = .closing(.init(fromWaitingToIdle: state))
      operations.sendGoAwayFrame(lastPeerInitiatedStreamID: state.lastPeerInitiatedStreamID)
      operations.closeChannel()

    // We're either operating on streams, streams are going away, or the connection is going away
    // so we don't need to idle the connection.
    case .operating, .quiescing, .closing, .closed:
      ()
    }

    return operations
  }

  // MARK: - Shutdown Events

  /// Close the connection, this can be caused as a result of a keepalive timeout (i.e. the server
  /// has become unresponsive), we'll bin this connection as a result.
  mutating func shutdownNow() -> Operations {
    var operations = Operations.none

    switch self.state {
    case let .operating(state):
      var closing = Closing(fromOperating: state)
      closing.shouldIdle = false
      self.state = .closing(closing)
      operations.closeChannel()
      operations.sendGoAwayFrame(lastPeerInitiatedStreamID: state.lastPeerInitiatedStreamID)

    case let .waitingToIdle(state):
      // Don't idle.
      self.state = .closing(Closing(fromWaitingToIdle: state, shouldIdle: false))
      operations.closeChannel()
      operations.sendGoAwayFrame(lastPeerInitiatedStreamID: state.lastPeerInitiatedStreamID)
      operations.cancelIdleTask(state.idleTask)

    case let .quiescing(state):
      self.state = .closing(Closing(fromQuiescing: state))
      // We've already sent a GOAWAY frame if we're in this state, just close.
      operations.closeChannel()

    case .closing, .closed:
      ()
    }

    return operations
  }",0,,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"internal static func tooManyParticipantsInTheCall(_ p1: Int) -> String {
          return L10n.tr(""Localizable"", ""error.group_call.too_many_participants_in_the_call"", p1)
        }",0,,
"internal static func hoursLeft(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""guest_room.expiration.hours_left"", String(describing: p1))
        }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func groups(_ p1: Int) -> String {
              return L10n.tr(""Localizable"", ""content.system.call.missed-call.groups"", p1)
            }",0,,
"internal static func subtitleEditDate(_ p1: Any) -> String {
        return L10n.tr(""Localizable"", ""message_details.subtitle_edit_date"", String(describing: p1))
      }",0,,
"internal static func title(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""landing.custom_backend.title"", String(describing: p1))
        }",0,,
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"    init(arrayLiteral: String...) {
        self.values = arrayLiteral.map({ (s: String) -> URLQueryFragment in
            return .urlDecoded(s)
        })
        self.children = [:]
    }",0,,
"internal static func otherRenamedConvToNothing(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.other_renamed_conv_to_nothing"", String(describing: p1))
        }",0,,
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func user(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""call.status.incoming.user"", String(describing: p1))
          }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"    @objc public func appendNewPotentialGapSystemMessage(users: Set<ZMUser>?, timestamp: Date) {
        
        let previousLastMessage = lastMessage
        let systemMessage = self.appendSystemMessage(type: .potentialGap,
                                                     sender: ZMUser.selfUser(in: self.managedObjectContext!),
                                                     users: users,
                                                     clients: nil,
                                                     timestamp: timestamp)
        systemMessage.needsUpdatingUsers = true
        
        if let previousLastMessage = previousLastMessage as? ZMSystemMessage, previousLastMessage.systemMessageType == .potentialGap,
           let previousLastMessageTimestamp = previousLastMessage.serverTimestamp, previousLastMessageTimestamp <= timestamp {
            // In case the message before the new system message was also a system message of
            // the type ZMSystemMessageTypePotentialGap, we delete the old one and update the
            // users property of the new one to use old users and calculate the added / removed users
            // from the time the previous one was added
            systemMessage.users = previousLastMessage.users
            self.managedObjectContext?.delete(previousLastMessage)
        }
    }",0,,
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"internal static func removeFromFolder(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""meta.menu.remove_from_folder"", String(describing: p1))
        }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func participantsNOthers(_ p1: Any, _ p2: Int) -> String {
          return L10n.tr(""Localizable"", ""content.system.participants_n_others"", String(describing: p1), p2)
        }",0,,
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"private static func writeUint64(_ buffer: UnsafeMutablePointer<UInt8>, offset: Int, value: UInt64) {
        for i in 0...7 {
            buffer[offset + i] = UInt8((value >> (8*UInt64(7 - i))) & 0xff)
        }
    }",0,,
"internal static func knowsMore(_ p1: Any, _ p2: Int) -> String {
          return L10n.tr(""Localizable"", ""peoplepicker.suggested.knows_more"", String(describing: p1), p2)
        }",0,,
"    private func notifyVisibilityChanged() {
        NotificationCenter.default.post(
            name: .videoGridVisibilityChanged,
            object: nil,
            userInfo: [VideoGridViewController.isCoveredKey: isCovered]
        )
    }",0,,
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"    init(stringLiteral: String) {
        self.values = [.urlDecoded(stringLiteral)]
        self.children = [:]
    }",0,,
"private func updateVideoGrid(with newVideoStreams: [VideoStream]) {
        let changeSet = StagedChangeset(source: dataSource, target: newVideoStreams)

        UIView.performWithoutAnimation {
            gridView.reload(using: changeSet) { dataSource = $0 }
        }

        updateStates(with: dataSource)
        pruneCache()
    }",0,,
"    func applicationDidBecomeActive() {
        updateOverlayWindowFrame()
        teamMetadataRefresher.triggerRefreshIfNeeded()
    }",0,,
"        rootViewController.set(childViewController: AppLockModule.build(session: session),
                               completion: completion)
    }

    // MARK: - Helpers
    private func configureUnauthenticatedAppearance() {
        rootViewController.view.window?.tintColor = UIColor.Wire.primaryLabel
        ValidatedTextField.appearance(whenContainedInInstancesOf: [AuthenticationStepController.self]).tintColor = UIColor.Team.activeButton
    }",0,,
"    fileprivate func timestamp(before: ZMMessage?) -> Date? {
        guard let timestamp = before?.serverTimestamp ?? self.lastModifiedDate else { return nil }
        return timestamp.previousNearestTimestamp
    }",0,,
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"fileprivate mutating func streamClosed(_ streamID: HTTP2StreamID, logger: Logger) {
    self.openStreams -= 1

    logger.debug(""HTTP2 stream closed"", metadata: [
      MetadataKey.h2StreamID: ""\(streamID)"",
      MetadataKey.h2ActiveStreams: ""\(self.openStreams)"",
    ])
  }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func calledYou(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.call.called-you"", String(describing: p1))
          }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"fileprivate func colorPair(accentColor: UIColor) -> ColorPair {
        switch self {
        case .textForeground:
            return ColorPair(light: .graphite, dark: .white)
        case .textBackground:
            return ColorPair(light: .white, dark: .backgroundGraphite)
        case .textDimmed:
            return ColorPair(both: .lightGraphite)
        case .textPlaceholder:
            return ColorPair(both: .lightGraphiteAlpha64)
        case .separator:
            return ColorPair(light: .lightGraphiteAlpha48, dark: .lightGraphiteAlpha24)
        case .barBackground:
            return ColorPair(light: .white, dark: .backgroundLightGraphite)
        case .background:
            return ColorPair(light: .white, dark: .backgroundGraphite)
        case .contentBackground:
            return ColorPair(light: .white97, dark: .backgroundGraphite)
        case .iconNormal:
            return ColorPair(light: .graphite, dark: .white)
        case .iconSelected:
            return ColorPair(light: .white, dark: .black)
        case .iconHighlighted:
            return ColorPair(both: .white)
        case .iconShadow:
            return ColorPair(light: .blackAlpha8, dark: .blackAlpha24)
        case .iconHighlight:
            return ColorPair(light: .white, dark: .whiteAlpha16)
        case .iconBackgroundSelected:
            return ColorPair(light: accentColor, dark: .white)
        case .iconBackgroundSelectedNoAccent:
            return ColorPair(light: .graphite, dark: .white)
        case .popUpButtonOverlayShadow:
            return ColorPair(light: .blackAlpha24, dark: .black)
        case .buttonHighlighted:
            return ColorPair(light: .whiteAlpha24, dark: .blackAlpha24)
        case .buttonEmptyText:
            return ColorPair(light: accentColor, dark: .white)
        case .buttonFaded:
            return ColorPair(light: .graphiteAlpha40, dark: .whiteAlpha40)
        case .tabNormal:
            return ColorPair(light: .blackAlpha48, dark: .whiteAlpha56)
        case .tabSelected:
            return ColorPair(light: .graphite, dark: .white)
        case .tabHighlighted:
            return ColorPair(light: .lightGraphite, dark: .lightGraphiteAlpha48)
        case .backgroundOverlay:
            return ColorPair(light: .blackAlpha24, dark: .blackAlpha48)
        case .backgroundOverlayWithoutPicture:
            return ColorPair(both: .blackAlpha80)
        case .avatarBorder:
            return ColorPair(light: .blackAlpha8, dark: .whiteAlpha16)
        case .audioButtonOverlay:
            return ColorPair(both: .lightGraphiteAlpha24)
        case .placeholderBackground:
            return ColorPair(light: .lightGraphiteWhite, dark: .lightGraphiteDark)
        case .loadingDotActive:
            return ColorPair(light: .graphiteAlpha40, dark: .whiteAlpha40)
        case .loadingDotInactive:
            return ColorPair(light: .graphiteAlpha16, dark: .whiteAlpha16)
        case .paleSeparator:
            return ColorPair(both: .lightGraphiteAlpha24)
        case .listAvatarInitials:
            return ColorPair(both: .blackAlpha40)
        case .sectionBackground:
            return ColorPair(both: .clear)
        case .sectionBackgroundHighlighted:
            return ColorPair(light: .graphiteAlpha4, dark: .backgroundLightGraphite)
        case .sectionText:
            return ColorPair(light: .blackAlpha40, dark: .whiteAlpha40)
        case .tokenFieldBackground:
            return ColorPair(light: .blackAlpha4, dark: .whiteAlpha16)
        case .tokenFieldTextPlaceHolder:
            return ColorPair(light: .lightGraphite, dark: .whiteAlpha40)
        case .cellSeparator:
            return ColorPair(light: .graphiteAlpha8, dark: .whiteAlpha8)
        case .searchBarBackground:
            return ColorPair(light: .white, dark: .whiteAlpha8)
        case .iconGuest:
            return ColorPair(light: .backgroundGraphiteAlpha40, dark: .whiteAlpha64)
        case .selfMentionHighlight:
            return ColorPair(light: .amberAlpha48, dark: .amberAlpha80)
        case .cellHighlight:
            return ColorPair(light: .white97, dark: .whiteAlpha16)
        case .replyBorder:
            return ColorPair(light: UIColor(white: 233.0/255.0, alpha: 1),
                             dark: UIColor(white: 114.0/255.0, alpha: 1))
        case .replyHighlight:
            return ColorPair(light: UIColor(rgb: 0x33373A, alpha: 0.24),
                             dark: UIColor(white: 1, alpha: 0.24))

        case .secondaryAction:
            return ColorPair(light: UIColor(rgb: 0xE8ECEE), dark: .backgroundLightGraphite)
        case .secondaryActionDimmed:
            return ColorPair(light: UIColor(rgb: 0xE8ECEE, alpha: 0.24), dark: UIColor.backgroundLightGraphite.withAlphaComponent(0.24))

        case .errorIndicator:
            return ColorPair(light: UIColor(rgb: 0xE60606), dark: UIColor(rgb: 0xFC3E37))

        case .landingScreen:
            return ColorPair(light: .graphiteDark, dark: .white)

        case .utilityError:
            return ColorPair(light: UIColor(rgb: 0xE41734), dark: UIColor(rgb: 0xFC7887))
        case .utilityNeutral:
            return ColorPair(light: UIColor(rgb: 0x0772DE), dark: UIColor(rgb: 0x26BDFF))
        case .utilitySuccess:
            return ColorPair(light: UIColor(rgb: 0x148545), dark: UIColor(rgb: 0x35C763))

        case .textSecurityNotClassified:
            return ColorPair(light: .white, dark: .graphite)
        case .backgroundSecurityNotClassified:
            return ColorPair(light: .graphite, dark: .white)

        }
    }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"    private func updateSelfPreview() {
        guard
            let selfStreamId = ZMUser.selfUser()?.selfStreamId,
            let selfStream = stream(with: selfStreamId)
        else {
            return
        }

        if let view = viewCache[selfStreamId] as? SelfVideoPreviewView {
            view.stream = selfStream
            view.shouldShowActiveSpeakerFrame = configuration.shouldShowActiveSpeakerFrame
        } else {
            viewCache[selfStreamId] = SelfVideoPreviewView(
                stream: selfStream,
                isCovered: isCovered,
                shouldShowActiveSpeakerFrame: configuration.shouldShowActiveSpeakerFrame
            )
        }
    }",1,"1,2,3,4","        guard/~/            let selfStreamId = ZMUser.selfUser()?.selfStreamId,/~/            let selfStream = stream(with: selfStreamId)/~/        else {"
"internal static func verifyMessage(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""profile.devices.detail.verify_message"", String(describing: p1))
          }",0,,
"internal static func date(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""content.message.reply.original_timestamp.date"", String(describing: p1))
            }",0,,
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"fileprivate init(role: Role) {
      self.role = role
      self.openStreams = 0
      self.lastPeerInitiatedStreamID = .rootStream
      // Assumed until we know better.
      self.maxConcurrentStreams = 100
      self.hasSeenSettings = false
    }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"internal static func lowercase(_ p1: Int) -> String {
            return L10n.tr(""Localizable"", ""registration.password.rules.lowercase"", p1)
          }",0,,
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"public func role(in conversation: ConversationLike?) -> Role? {
        return participantRoles.first(where: { $0.conversation === conversation })?.role
    }",0,,
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"internal static func description(_ p1: Any) -> String {
                  return L10n.tr(""Localizable"", ""self.settings.account_section.phone_number.change.verify.description"", String(describing: p1))
                }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    func color(named: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        let colorSchemeVariant = variant ?? self.variant

        let colorPair = named.colorPair(accentColor: accentColor)
        switch colorSchemeVariant {
        case .dark:
            return colorPair.dark
        case .light:
            return colorPair.light
        }
    }",0,,
"    override func updateUserDetails() {
        userDetailsView.microphoneIconStyle = MicrophoneIconStyle(state: stream.microphoneState,
                                                                  shouldPulse: stream.isParticipantActiveSpeaker)
        
        guard let name = stream.participantName else {
            return
        }
        userDetailsView.name = name + ""user_cell.title.you_suffix"".localized
    }",0,,
"    func nameAccent(for color: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {
        return UIColor.nameColor(for: color, variant: variant)
    }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func leaving(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""voice.status.leaving"", String(describing: p1))
        }",0,,
"internal static func message(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""url_action.switch_backend.message"", String(describing: p1))
        }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"    func userDidGrantAudioPermissions() {
        sessionManager.updateCallNotificationStyleFromSettings()
    }",0,,
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"  private func now() -> NIODeadline {
    return self._testingOnlyNow ?? .now()
  }",0,,
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"    private func createLifeCycleObserverTokens() {
        sessionManagerLifeCycleObserver.createLifeCycleObserverTokens()
    }",0,,
"    public func removeParticipantAndUpdateConversationState(user: ZMUser, initiatingUser: ZMUser? = nil) {
        self.removeParticipantsAndUpdateConversationState(users: Set(arrayLiteral: user), initiatingUser: initiatingUser)
    }",0,,
"internal static func added(_ p1: Any, _ p2: Any) -> String {
              return L10n.tr(""Localizable"", ""content.system.conversation.other.added"", String(describing: p1), String(describing: p2))
            }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"        self.init(url: url, protocols: protocols)
        writeQueue.qualityOfService = writeQueueQOS
    }

    /**
     Connect to the WebSocket server on a background thread.
     */
    open func connect() {
        guard !isConnecting else { return }
        didDisconnect = false
        isConnecting = true
        createHTTPRequest()
    }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    fileprivate func appendNewAddedClientSystemMessage(cause: SecurityChangeCause) {
        var timestamp : Date?
        var affectedUsers: Set<ZMUser> = []
        var addedUsers: Set<ZMUser> = []
        var addedClients: Set<UserClient> = []
        
        switch cause {
        case .addedUsers(let users):
            affectedUsers = users
            addedUsers = users
        case .addedClients(let clients, let message):
            affectedUsers = Set(clients.compactMap(\.user))
            addedClients = clients
            if let message = message, message.conversation == self {
                timestamp = self.timestamp(before: message)
            } else {
                timestamp = clients.compactMap(\.discoveryDate).first?.previousNearestTimestamp
            }
        default:
            // unsupported cause
            return
        }
        
        guard !addedClients.isEmpty || !addedUsers.isEmpty else { return }
        
        self.appendSystemMessage(type: .newClient,
                                 sender: ZMUser.selfUser(in: self.managedObjectContext!),
                                 users: affectedUsers,
                                 addedUsers: addedUsers,
                                 clients: addedClients,
                                 timestamp: timestamp ?? timestampAfterLastMessage())
    }",0,,
"    func mainColor(color: UIColor?) -> UIColor {
        return color ?? UIColor.from(scheme: .textForeground, variant: self)
    }",0,,
"public static func configureAppearance() {
        let navigationBarTitleBaselineOffset: CGFloat = 2.5

        let attributes: [NSAttributedString.Key: Any] = [.font: UIFont.systemFont(ofSize: 11, weight: .semibold), .baselineOffset: navigationBarTitleBaselineOffset]
        let barButtonItemAppearance = UIBarButtonItem.appearance(whenContainedInInstancesOf: [DefaultNavigationBar.self])
        barButtonItemAppearance.setTitleTextAttributes(attributes, for: .normal)
        barButtonItemAppearance.setTitleTextAttributes(attributes, for: .highlighted)
        barButtonItemAppearance.setTitleTextAttributes(attributes, for: .disabled)
    }",0,,
"    class func keyboardAppearance(for variant: ColorSchemeVariant) -> UIKeyboardAppearance {
        return variant == .light ? .light : .dark
    }",0,,
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"  private func scheduleClose(in timeout: TimeAmount) {
    self.scheduledClose = self.context?.eventLoop.scheduleTask(in: timeout) {
      self.perform(operations: self.stateMachine.shutdownNow())
    }
  }",0,,
"internal static func genericMessage(_ p1: Int) -> String {
              return L10n.tr(""Localizable"", ""conversation.silenced.status.message.generic_message"", p1)
            }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"internal static func unverifiedOtherDevices(_ p1: Any, _ p2: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.unverified_other_devices"", String(describing: p1), String(describing: p2))
        }",0,,
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"internal static func otherWantedToTalk(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.other_wanted_to_talk"", String(describing: p1))
        }",0,,
"    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return dataSource.count
    }",0,,
"    public func decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set<UserClient>, causedBy message: ZMOTRMessage?) {
        applySecurityChanges(cause: .addedClients(clients, source: message))
    }",0,,
"private func resendPendingMessagesAfterPrivacyChanges() {
        enumerateReverseMessagesThatCausedDegradationUntilFirstSystemMessageOnSyncContext {
            $0.causedSecurityLevelDegradation = false
            $0.resend()
        }
    }",0,,
"internal static func resendPlaceholder(_ p1: Float) -> String {
          return L10n.tr(""Localizable"", ""registration.verify_phone_number.resend_placeholder"", p1)
        }",0,,
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"    private func setupAppStateCalculator() {
        appStateCalculator.delegate = self
    }",0,,
"    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"    public class func keyPathsForValuesAffectingActiveParticipants() -> Set<String> {
        return Set(participantRolesKeys)
    }",0,,
"internal static func instructions(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""registration.verify_email.instructions"", String(describing: p1))
        }",0,,
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"internal static func detail(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""legalhold_request.alert.detail"", String(describing: p1))
        }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    fileprivate init(fromOperating state: Operating, idleTask: Scheduled<Void>) {
      // We won't transition to this state unless we've seen a SETTINGS frame.
      assert(state.hasSeenSettings)

      self.role = state.role
      self.lastPeerInitiatedStreamID = state.lastPeerInitiatedStreamID
      self.maxConcurrentStreams = state.maxConcurrentStreams
      self.idleTask = idleTask
    }",0,,
"fileprivate mutating func streamCreated(_ streamID: HTTP2StreamID, logger: Logger) {
    self.openStreams += 1

    switch self.role {
    case .client where streamID.isServerInitiated:
      self.lastPeerInitiatedStreamID = streamID
    case .server where streamID.isClientInitiated:
      self.lastPeerInitiatedStreamID = streamID
    default:
      ()
    }

    logger.debug(""HTTP2 stream created"", metadata: [
      MetadataKey.h2StreamID: ""\(streamID)"",
      MetadataKey.h2ActiveStreams: ""\(self.openStreams)"",
    ])

    if self.openStreams == self.maxConcurrentStreams {
      logger.warning(""HTTP2 max concurrent stream limit reached"", metadata: [
        MetadataKey.h2ActiveStreams: ""\(self.openStreams)"",
      ])
    }
  }",0,,
"private func dequeueWrite(_ data: Data, code: OpCode, writeCompletion: (() -> ())? = nil) {
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            //stream isn't ready, let's wait
            guard let s = self else { return }
            guard let sOperation = operation else { return }
            var offset = 2
            let dataLength = data.count
            let frame = NSMutableData(capacity: dataLength + s.MaxFrameSize)
            let buffer = UnsafeMutableRawPointer(frame!.mutableBytes).assumingMemoryBound(to: UInt8.self)
            buffer[0] = s.FinMask | code.rawValue
            if dataLength < 126 {
                buffer[1] = CUnsignedChar(dataLength)
            } else if dataLength <= Int(UInt16.max) {
                buffer[1] = 126
                WebSocket.writeUint16(buffer, offset: offset, value: UInt16(dataLength))
                offset += MemoryLayout<UInt16>.size
            } else {
                buffer[1] = 127
                WebSocket.writeUint64(buffer, offset: offset, value: UInt64(dataLength))
                offset += MemoryLayout<UInt64>.size
            }
            buffer[1] |= s.MaskMask
            let maskKey = UnsafeMutablePointer<UInt8>(buffer + offset)
            _ = SecRandomCopyBytes(kSecRandomDefault, Int(MemoryLayout<UInt32>.size), maskKey)
            offset += MemoryLayout<UInt32>.size
            
            for i in 0..<dataLength {
                buffer[offset] = data[i] ^ maskKey[i % MemoryLayout<UInt32>.size]
                offset += 1
            }
            var total = 0
            while !sOperation.isCancelled {
                guard let outStream = s.outputStream else { break }
                let writeBuffer = UnsafeRawPointer(frame!.bytes+total).assumingMemoryBound(to: UInt8.self)
                let len = outStream.write(writeBuffer, maxLength: offset-total)
                if len < 0 {
                    var error: Error?
                    if let streamError = outStream.streamError {
                        error = streamError
                    } else {
                        let errCode = InternalErrorCode.outputStreamWriteError.rawValue
                        error = s.errorWithDetail(""output stream error during write"", code: errCode)
                    }
                    s.doDisconnect(error as NSError?)
                    break
                } else {
                    total += len
                }
                if total >= offset {
                    if let queue = self?.callbackQueue, let callback = writeCompletion {
                        queue.async {
                            callback()
                        }
                    }

                    break
                }
            }
        }
        writeQueue.addOperation(operation)
    }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    private func checkIfVerificationLevelChanged(removedUsers: Set<ZMUser>) {
        self.increaseSecurityLevelIfNeededAfterRemoving(users: removedUsers)
    }",0,,
"    open func write(ping: Data, completion: (() -> ())? = nil) {
        guard isConnected else { return }
        dequeueWrite(ping, code: .ping, writeCompletion: completion)
    }",0,,
"internal static func messageTimerChangesYou(_ p1: Any, _ p2: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.message_timer_changes-you"", String(describing: p1), String(describing: p2))
        }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func number(_ p1: Int) -> String {
            return L10n.tr(""Localizable"", ""registration.password.rules.number"", p1)
          }",0,,
"internal static func plural(_ p1: Int) -> String {
            return L10n.tr(""Localizable"", ""peoplepicker.group.title.plural"", p1)
          }",0,,
"internal static func others(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""content.system.started_conversation.truncated_people.others"", String(describing: p1))
            }",0,,
"internal static func singular(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""meta.degraded.degradation_reason_message.singular"", String(describing: p1))
          }",0,,
"    func appendSystemMessage(type: ZMSystemMessageType,
                                         sender: ZMUser,
                                         users: Set<ZMUser>?,
                                         addedUsers: Set<ZMUser> = Set(),
                                         clients: Set<UserClient>?,
                                         timestamp: Date,
                                         duration: TimeInterval? = nil,
                                         messageTimer: Double? = nil,
                                         relevantForStatus: Bool = true) -> ZMSystemMessage {
        let systemMessage = ZMSystemMessage(nonce: UUID(), managedObjectContext: managedObjectContext!)
        systemMessage.systemMessageType = type
        systemMessage.sender = sender
        systemMessage.users = users ?? Set()
        systemMessage.addedUsers = addedUsers
        systemMessage.clients = clients ?? Set()
        systemMessage.serverTimestamp = timestamp
        if let duration = duration {
            systemMessage.duration = duration
        }
        
        if let messageTimer = messageTimer {
            systemMessage.messageTimer = NSNumber(value: messageTimer)
        }
        
        systemMessage.relevantForConversationStatus = relevantForStatus
        
        self.append(systemMessage)
        
        return systemMessage
    }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    fileprivate static func fetchStartedUsingOnThisDeviceMessage(conversation: ZMConversation) -> ZMSystemMessage? {
        guard let selfClient = ZMUser.selfUser(in: conversation.managedObjectContext!).selfClient() else { return nil }
        let conversationPredicate = NSPredicate(format: ""%K == %@ OR %K == %@"", ZMMessageConversationKey, conversation, ZMMessageHiddenInConversationKey, conversation)
        let newClientPredicate = NSPredicate(format: ""%K == %d"", ZMMessageSystemMessageTypeKey, ZMSystemMessageType.newClient.rawValue)
        let containsSelfClient = NSPredicate(format: ""ANY %K == %@"", ZMMessageSystemMessageClientsKey, selfClient)
        let compound = NSCompoundPredicate(andPredicateWithSubpredicates: [conversationPredicate, newClientPredicate, containsSelfClient])
        
        let fetchRequest = ZMSystemMessage.sortedFetchRequest(with: compound)
        
        let result = conversation.managedObjectContext!.fetchOrAssert(request: fetchRequest)
        return result.first as? ZMSystemMessage
    }",0,,
"internal static func count(_ p1: Int) -> String {
          return L10n.tr(""Localizable"", ""participants.people.count"", p1)
        }",0,,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"internal static func messageReadReceiptOff(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.message_read_receipt_off"", String(describing: p1))
        }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"public func addParticipantAndSystemMessageIfMissing(_ user: ZMUser, date dateOptional: Date?) {
        let date = dateOptional ?? Date()

        guard !user.isSelfUser, !localParticipants.contains(user) else { return }
        
        zmLog.debug(""Sender: \(user.remoteIdentifier?.transportString() ?? ""n/a"") missing from participant list: \(localParticipants.map{ $0.remoteIdentifier} )"")
        
        switch conversationType {
        case .group:
            appendSystemMessage(type: .participantsAdded, sender: user, users: Set(arrayLiteral: user), clients: nil, timestamp: date)
        case .oneOnOne, .connection:
            if user.connection == nil {
                user.connection = connection ?? ZMConnection.insertNewObject(in: managedObjectContext!)
            } else if connection == nil {
                connection = user.connection
            }
            user.connection?.needsToBeUpdatedFromBackend = true
        default:
            break
        }
        
        // we will fetch the role once we fetch the entire convo metadata
        self.addParticipantAndUpdateConversationState(user: user, role: nil)
        
        // A missing user indicate that we are out of sync with the BE so we'll re-sync the conversation
        needsToBeUpdatedFromBackend = true
    }",0,,
"internal static func groupsYou(_ p1: Int) -> String {
              return L10n.tr(""Localizable"", ""content.system.call.missed-call.groups-you"", p1)
            }",0,,
"public func readFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let fileSize = attributes[.size] as? NSNumber
        else {
            return self.request.eventLoop.makeFailedFuture(Abort(.internalServerError))
        }
        return self.read(
            path: path,
            fromOffset: 0,
            byteCount:
            fileSize.intValue,
            chunkSize: chunkSize,
            onRead: onRead
        )
    }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"private func errorWithDetail(_ detail: String, code: UInt16) -> NSError {
        var details = [String: String]()
        details[NSLocalizedDescriptionKey] =  detail
        return NSError(domain: WebSocket.ErrorDomain, code: Int(code), userInfo: details)
    }",0,,
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"private func updateStates(with videoStreams: [VideoStream]) {
        videoStreams.forEach {
            let view = (streamView(for: $0.stream) as? BaseVideoPreviewView)
            view?.stream = $0.stream
            view?.shouldShowActiveSpeakerFrame = configuration.shouldShowActiveSpeakerFrame
            (view as? VideoPreviewView)?.isPaused = $0.isPaused
        }
    }",0,,
"internal static func subtitleRemoved(_ p1: Any, _ p2: Int) -> String {
            return L10n.tr(""Localizable"", ""content.system.missing_messages.subtitle_removed"", String(describing: p1), p2)
          }",0,,
"internal static func mention(_ p1: Int) -> String {
              return L10n.tr(""Localizable"", ""conversation.silenced.status.message.mention"", p1)
            }",0,,
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"internal static func fingerprintMessageUnencrypted(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""profile.devices.fingerprint_message_unencrypted"", String(describing: p1))
        }",0,,
"    private func streamView(for videoStream: VideoStream) -> OrientableView {
        let streamId = videoStream.stream.streamId

        if let streamView = viewCache[streamId] {
            return streamView
        } else {
            let view = VideoPreviewView(stream: videoStream.stream, isCovered: isCovered, shouldShowActiveSpeakerFrame: configuration.shouldShowActiveSpeakerFrame)
            viewCache[streamId] = view
            return view
        }
    }",0,,
"            if let size = data[""size""].flatMap(ProfileImageSize.init), let key = data[""key""].flatMap(AssetKey.init) {
                switch size {
                case .preview:
                    if key.stringValue != previewProfileAssetIdentifier {
                        previewProfileAssetIdentifier = key.stringValue
                    }
                case .complete:
                    if key.stringValue != completeProfileAssetIdentifier {
                        completeProfileAssetIdentifier = key.stringValue
                    }
                }
            }
        }
    }",0,,
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"internal static func message(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""conversation.input_bar.audio_message.too_long.message"", String(describing: p1))
            }",0,,
"internal static func special(_ p1: Int) -> String {
            return L10n.tr(""Localizable"", ""registration.password.rules.special"", p1)
          }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    func appStateCalculator(_: AppStateCalculator,
                            didCalculate appState: AppState,
                            completion: @escaping () -> Void) {
        enqueueTransition(to: appState, completion: completion)
    }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"internal static func uppercase(_ p1: Int) -> String {
            return L10n.tr(""Localizable"", ""registration.password.rules.uppercase"", p1)
          }",0,,
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"internal static func message(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""profile.block_dialog.message"", String(describing: p1))
        }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    private(set) var colors: [AnyHashable: Any]?

    var variant: ColorSchemeVariant = .light

    private(set) var defaultColorScheme: ColorScheme?
    var accentColor: UIColor = .red

    var keyboardAppearance: UIKeyboardAppearance {
        return ColorScheme.keyboardAppearance(for: variant)
    }",0,,
"private func processHTTP(_ buffer: UnsafePointer<UInt8>, bufferLen: Int) -> Int {
        let CRLFBytes = [UInt8(ascii: ""\r""), UInt8(ascii: ""\n""), UInt8(ascii: ""\r""), UInt8(ascii: ""\n"")]
        var k = 0
        var totalSize = 0
        for i in 0..<bufferLen {
            if buffer[i] == CRLFBytes[k] {
                k += 1
                if k == 3 {
                    totalSize = i + 1
                    break
                }
            } else {
                k = 0
            }
        }
        if totalSize > 0 {
            let code = validateResponse(buffer, bufferLen: totalSize)
            if code != 0 {
                return code
            }
            isConnecting = false
            connected = true
            didDisconnect = false
            if canDispatch {
                callbackQueue.async { [weak self] in
                    guard let s = self else { return }
                    s.onConnect?()
                    s.delegate?.websocketDidConnect(socket: s)
                    s.notificationCenter.post(name: NSNotification.Name(WebsocketDidConnectNotification), object: self)
                }
            }
            totalSize += 1 //skip the last \n
            let restSize = bufferLen - totalSize
            if restSize > 0 {
                processRawMessagesInBuffer(buffer + totalSize, bufferLen: restSize)
            }
            return 0 //success
        }
        return -1 // Was unable to find the full TCP header.
    }",0,,
"    @objc class func keyPathsForValuesAffectingIsUnderLegalHold() -> Set<String> {
        return [UserClientsKey, ""clients.deviceClass""]
    }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    public func refreshTeamData() {
        team?.refreshMetadata()
    }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"    public func updateAndSyncProfileAssetIdentifiers(previewIdentifier: String, completeIdentifier: String) {
        guard isSelfUser else { return }
        previewProfileAssetIdentifier = previewIdentifier
        completeProfileAssetIdentifier = completeIdentifier
        setLocallyModifiedKeys([ZMUser.previewProfileAssetIdentifierKey, ZMUser.completeProfileAssetIdentifierKey])
    }",0,,
"    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"internal static func message(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""login.sso.error.alert.message"", String(describing: p1))
            }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"    private func updateSelfPreview() {
        guard
            let selfStreamId = ZMUser.selfUser()?.selfStreamId,
            let selfStream = stream(with: selfStreamId)
        else {
            return
        }

        if let view = viewCache[selfStreamId] as? SelfVideoPreviewView {
            view.stream = selfStream
            view.shouldShowActiveSpeakerFrame = configuration.shouldShowActiveSpeakerFrame
        } else {
            viewCache[selfStreamId] = SelfVideoPreviewView(
                stream: selfStream,
                isCovered: isCovered,
                shouldShowActiveSpeakerFrame: configuration.shouldShowActiveSpeakerFrame
            )
        }
    }",1,"1,2,3,4","        guard/~/            let selfStreamId = ZMUser.selfUser()?.selfStreamId,/~/            let selfStream = stream(with: selfStreamId)/~/        else {"
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"    private func addHeader(_ urlRequest: CFHTTPMessage, key: String, val: String) {
        CFHTTPMessageSetHeaderFieldValue(urlRequest, key as CFString, val as CFString)
    }",0,,
"    func asUrlDecoded() throws -> String {
        switch self {
        case .urlEncoded(let encoded):
            guard let decoded = encoded.removingPercentEncoding else {
                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: [], debugDescription: ""Unable to remove percent encoding for \(encoded)""))
            }
            return decoded
        case .urlDecoded(let decoded):
            return decoded
        }
    }",0,,
"    private func applicationWillTransition(to appState: AppState) {
        appStateTransitionGroup.enter()
        configureSelfUserProviderIfNeeded(for: appState)
        configureColorScheme()
    }",0,,
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"    func reload() {
        enqueueTransition(to: .headless)
        enqueueTransition(to: appStateCalculator.appState)
    }",0,,
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"internal static func title(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""registration.email_invitation.hero.title"", String(describing: p1))
          }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    @objc public func requestPreviewProfileImage() {
        guard let moc = self.managedObjectContext, moc.zm_isUserInterfaceContext, !moc.zm_userImageCache.hasUserImage(self, size: .preview) else { return }
        
        NotificationInContext(name: .userDidRequestPreviewAsset,
                              context: moc.notificationContext,
                              object: self.objectID).post()
    }",0,,
"internal static func message(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""profile.connection_request_dialog.message"", String(describing: p1))
        }",0,,
"public func collectFile(at path: String) -> EventLoopFuture<ByteBuffer> {
        var data = self.allocator.buffer(capacity: 0)
        return self.readFile(at: path) { new in
            var new = new
            data.writeBuffer(&new)
            return self.request.eventLoop.makeSucceededFuture(())
        }.map { data }
    }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"private func updateLegalHoldState(cause: SecurityChangeCause) {
        guard !needsToVerifyLegalHold, !localParticipants.any({ $0.clients.any(\.needsToBeUpdatedFromBackend) }) else {
            // We don't update the legal hold status if we are still gathering information about which clients were added/deleted
            return
        }
        
        let detectedParticipantsUnderLegalHold = localParticipants.any(\.isUnderLegalHold)

        switch (legalHoldStatus, detectedParticipantsUnderLegalHold) {
        case (.disabled, true):
            legalHoldStatus = .pendingApproval
            appendLegalHoldEnabledSystemMessageForConversation(cause: cause)
            expireAllPendingMessagesBecauseOfSecurityLevelDegradation()

        case (.pendingApproval, false), (.enabled, false):
            legalHoldStatus = .disabled
            appendLegalHoldDisabledSystemMessageForConversation()

        default:
            // no changes required
            break
        }
    }",0,,
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"internal static func knowsOne(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""peoplepicker.suggested.knows_one"", String(describing: p1))
        }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"internal static func continuedConversation(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.continued_conversation"", String(describing: p1))
        }",0,,
"internal static func startedConversation(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""conversation.status.started_conversation"", String(describing: p1))
        }",0,,
"    public func refreshRichProfile() {
        needsRichProfileUpdate = true
    }",0,,
"    @objc public func verifyLegalHoldSubjects() {
        needsToVerifyLegalHold = true
        managedObjectContext?.saveOrRollback()
    }",0,,
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"private func stream(with streamId: AVSClient) -> Stream? {
        var stream = configuration.videoStreams.first(where: { $0.stream.streamId == streamId })?.stream

        if stream == nil && configuration.floatingVideoStream?.stream.streamId == streamId {
            stream = configuration.floatingVideoStream?.stream
        }

        return stream
    }",0,,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"    private func buildAuthenticatedRouter(account: Account, isComingFromRegistration: Bool) -> AuthenticatedRouter? {

        let needToShowDataUsagePermissionDialog = appStateCalculator.wasUnauthenticated
                                                    && !SelfUser.current.isTeamMember

        return AuthenticatedRouter(rootViewController: rootViewController,
                                   account: account,
                                   selfUser: ZMUser.selfUser(),
                                   isComingFromRegistration: isComingFromRegistration,
                                   needToShowDataUsagePermissionDialog: needToShowDataUsagePermissionDialog)
    }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"internal static func fileMessage(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""conversation.input_bar.message_preview.accessibility.file_message"", String(describing: p1))
            }",0,,
"internal static func accessibilityValue(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""conversation_list.header.self_team.accessibility_value"", String(describing: p1))
          }",0,,
"  mutating func channelInactive() -> Operations {
    var operations: Operations = .none

    switch self.state {
    case let .operating(state):
      self.state = .closed

      // We unexpectedly became inactive.
      if !state.hasSeenSettings || state.hasOpenStreams {
        // Haven't seen settings, or we've seen settings and there are open streams.
        operations.notifyConnectionManager(about: .inactive)
      } else {
        // Have seen settings and there are no open streams.
        operations.notifyConnectionManager(about: .idle)
      }

    case let .waitingToIdle(state):
      self.state = .closed

      // We were going to idle anyway.
      operations.notifyConnectionManager(about: .idle)
      operations.cancelIdleTask(state.idleTask)

    case let .quiescing(state):
      self.state = .closed

      if state.initiatedByUs || state.hasOpenStreams {
        operations.notifyConnectionManager(about: .inactive)
      } else {
        operations.notifyConnectionManager(about: .idle)
      }

    case let .closing(state):
      self.state = .closed

      if state.shouldIdle {
        operations.notifyConnectionManager(about: .idle)
      } else {
        operations.notifyConnectionManager(about: .inactive)
      }

    case .closed:
      ()
    }

    return operations
  }",0,,
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"internal static func other(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.cannot_decrypt_identity_changed.other"", String(describing: p1))
          }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"mutating func read(pingData: HTTP2PingData, ack: Bool) -> Action {
    if ack {
      return self.handlePong(pingData)
    } else {
      return self.handlePing(pingData)
    }
  }",0,,
"internal static func youRemovedOther(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.you_removed_other"", String(describing: p1))
        }",0,,
"private func processInputStream() {
        let buf = NSMutableData(capacity: BUFFER_MAX)
        let buffer = UnsafeMutableRawPointer(mutating: buf!.bytes).assumingMemoryBound(to: UInt8.self)
        let length = inputStream!.read(buffer, maxLength: BUFFER_MAX)
        guard length > 0 else { return }
        var process = false
        if inputQueue.count == 0 {
            process = true
        }
        inputQueue.append(Data(bytes: buffer, count: length))
        if process {
            dequeueInput()
        }
    }",0,,
"internal static func joining(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""voice.status.joining"", String(describing: p1))
        }",0,,
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    private func updateSelfPreview() {
        guard
            let selfStreamId = ZMUser.selfUser()?.selfStreamId,
            let selfStream = stream(with: selfStreamId)
        else {
            return
        }

        if let view = viewCache[selfStreamId] as? SelfVideoPreviewView {
            view.stream = selfStream
            view.shouldShowActiveSpeakerFrame = configuration.shouldShowActiveSpeakerFrame
        } else {
            viewCache[selfStreamId] = SelfVideoPreviewView(
                stream: selfStream,
                isCovered: isCovered,
                shouldShowActiveSpeakerFrame: configuration.shouldShowActiveSpeakerFrame
            )
        }
    }",1,"1,2,3,4","        guard/~/            let selfStreamId = ZMUser.selfUser()?.selfStreamId,/~/            let selfStream = stream(with: selfStreamId)/~/        else {"
"internal static func other(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.cannot_decrypt.other"", String(describing: p1))
          }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"        didSet {
            guard isCovered != oldValue else { return }
            notifyVisibilityChanged()
            displayIndicatorViewsIfNeeded()
            animateNetworkConditionView()
        }",0,,
"    private func updateSelfPreview() {
        guard
            let selfStreamId = ZMUser.selfUser()?.selfStreamId,
            let selfStream = stream(with: selfStreamId)
        else {
            return
        }

        if let view = viewCache[selfStreamId] as? SelfVideoPreviewView {
            view.stream = selfStream
            view.shouldShowActiveSpeakerFrame = configuration.shouldShowActiveSpeakerFrame
        } else {
            viewCache[selfStreamId] = SelfVideoPreviewView(
                stream: selfStream,
                isCovered: isCovered,
                shouldShowActiveSpeakerFrame: configuration.shouldShowActiveSpeakerFrame
            )
        }
    }",1,"1,2,3,4","        guard/~/            let selfStreamId = ZMUser.selfUser()?.selfStreamId,/~/            let selfStream = stream(with: selfStreamId)/~/        else {"
"internal static func removeDialogMessage(_ p1: Any) -> String {
        return L10n.tr(""Localizable"", ""profile.remove_dialog_message"", String(describing: p1))
      }",0,,
"    private func degradeSecurityLevelIfNeeded(for cause: SecurityChangeCause) {
        guard securityLevel == .secure && !allUsersTrusted else {
            return
        }

        securityLevel = .secureWithIgnored

        switch cause {
        case .addedClients, .addedUsers:
            appendNewAddedClientSystemMessage(cause: cause)
            expireAllPendingMessagesBecauseOfSecurityLevelDegradation()
        case .ignoredClients(let clients):
            appendIgnoredClientsSystemMessage(ignored: clients)
        default:
            break
        }
    }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"internal static func missedcall(_ p1: Int) -> String {
              return L10n.tr(""Localizable"", ""conversation.silenced.status.message.missedcall"", p1)
            }",0,,
"    public func isGuest(in conversation: ConversationLike) -> Bool {
        return _isGuest(in: conversation)
    }",0,,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"    func fromOffset(_ offset: Int) -> UnsafeBufferPointer<Element> {
        return UnsafeBufferPointer<Element>(start: baseAddress?.advanced(by: offset), count: count - offset)
    }",0,,
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"    fileprivate func expireAllPendingMessagesBecauseOfSecurityLevelDegradation() {
        for message in undeliveredMessages {
            if let clientMessage = message as? ZMClientMessage,
                let genericMessage = clientMessage.underlyingMessage,
                genericMessage.hasConfirmation {
                // Delivery receipt: just expire it
                message.expire()
            } else {
                // All other messages: expire and mark that it caused security degradation
                message.expire()
                message.causedSecurityLevelDegradation = true
            }
        }
    }",0,,
"internal static func newDevices(_ p1: Int) -> String {
          return L10n.tr(""Localizable"", ""content.system.new_devices"", p1)
        }",0,,
"    public func decreaseSecurityLevelIfNeededAfterIgnoring(clients: Set<UserClient>) {
        applySecurityChanges(cause: .ignoredClients(clients))
    }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"internal static func message(_ p1: Any) -> String {
                return L10n.tr(""Localizable"", ""login.sso.error.alert.invalid_status.message"", String(describing: p1))
              }",0,,
"internal static func time(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""content.message.reply.original_timestamp.time"", String(describing: p1))
            }",0,,
"internal static func otherRemovedOther(_ p1: Any, _ p2: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.other_removed_other"", String(describing: p1), String(describing: p2))
        }",0,,
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"    func contentSizeCategoryDidChange() {
        NSAttributedString.invalidateParagraphStyle()
        NSAttributedString.invalidateMarkdownStyle()
        ConversationListCell.invalidateCachedCellSize()
        defaultFontScheme = FontScheme(contentSizeCategory: UIApplication.shared.preferredContentSizeCategory)
        AppRootRouter.configureAppearance()
    }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"    private func setupAnalyticsSharing() {
        guard
            appStateCalculator.wasUnauthenticated,
            let selfUser = SelfUser.provider?.selfUser,
            selfUser.isTeamMember
        else {
            return
        }

        TrackingManager.shared.disableCrashSharing = true
        TrackingManager.shared.disableAnalyticsSharing = false
        Analytics.shared.provider?.selfUser = selfUser
    }",0,,
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func connectingTo(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.connecting_to"", String(describing: p1))
        }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"internal static func newUserDevice(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""voice.degradation.new_user_device"", String(describing: p1))
        }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }",0,,
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"    public class func keyPathsForValuesAffectingDisplayName() -> Set<String> {
        return Set([ZMConversationConversationTypeKey,
                    ""participantRoles.user.name"",
                    ""connection.to.name"",
                    ""connection.to.availability"",
                    ZMConversationUserDefinedNameKey] +
                   ZMConversation.participantRolesKeys)
    }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func reactivatedDevice(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.reactivated_device"", String(describing: p1))
        }",0,,
"internal static func messageReadReceiptOn(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.message_read_receipt_on"", String(describing: p1))
        }",0,,
"internal static func resend(_ p1: Any) -> String {
                  return L10n.tr(""Localizable"", ""self.settings.account_section.email.change.verify.resend"", String(describing: p1))
                }",0,,
"internal static func withRequirements(_ p1: Any, _ p2: Any) -> String {
            return L10n.tr(""Localizable"", ""registration.password.rules.with_requirements"", String(describing: p1), String(describing: p2))
          }",0,,
"internal static func incoming(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""call.announcement.incoming"", String(describing: p1))
        }",0,,
"        super.init(nibName: nil, bundle: nil)

        setupViews()
        createConstraints()
        updateState()
        displayIndicatorViewsIfNeeded()
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError(""init(coder:) has not been implemented"")
    }",0,,
"    public func updateSecurityLevelIfNeededAfterReceiving(message: GenericMessage, timestamp: Date) {
        updateLegalHoldIfNeededWithHint(from: message, timestamp: timestamp)
    }",0,,
"internal static func inConversation(_ p1: Any, _ p2: Any) -> String {
        return L10n.tr(""Localizable"", ""notifications.in_conversation"", String(describing: p1), String(describing: p2))
      }",0,,
"    override func setupViews() {
        super.setupViews()
        previewView.backgroundColor = .clear
        previewView.translatesAutoresizingMaskIntoConstraints = false
        insertSubview(previewView, belowSubview: userDetailsView)
    }",0,,
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"private func processRawMessagesInBuffer(_ pointer: UnsafePointer<UInt8>, bufferLen: Int) {
        var buffer = UnsafeBufferPointer(start: pointer, count: bufferLen)
        repeat {
            buffer = processOneRawMessage(inBuffer: buffer)
        } while buffer.count >= 2
        if buffer.count > 0 {
            fragBuffer = Data(buffer: buffer)
        }
    }",0,,
"    fileprivate mutating func cancelIdleTask(_ task: Scheduled<Void>) {
      self.idleTask = .cancel(task)
    }",0,,
"internal static func nameInContacts(_ p1: Any) -> String {
        return L10n.tr(""Localizable"", ""contacts_ui.name_in_contacts"", String(describing: p1))
      }",0,,
"    private func checkIfArchivedStatusChanged(addedSelfUser: Bool) {
        if addedSelfUser &&
            self.mutedStatus == MutedMessageOptionValue.none.rawValue &&
            self.isArchived
        {
            self.isArchived = false
        }
    }",0,,
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"private func animateNetworkConditionView() {
        UIView.animate(
            withDuration: 0.2,
            delay: 0,
            options: [.curveEaseInOut, .beginFromCurrentState],
            animations: { self.networkConditionView.alpha = self.isCovered ? 0.0 : 1.0 }
        )
    }",0,,
"        self.init(bytes: buffer.baseAddress!, count: buffer.count)
    }

}

private extension UnsafeBufferPointer {

    func fromOffset(_ offset: Int) -> UnsafeBufferPointer<Element> {
        return UnsafeBufferPointer<Element>(start: baseAddress?.advanced(by: offset), count: count - offset)
    }
    
}",0,,
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"    private func disconnectStream(_ error: NSError?, runDelegate: Bool = true) {
        if error == nil {
            writeQueue.waitUntilAllOperationsAreFinished()
        } else {
            writeQueue.cancelAllOperations()
        }
        cleanupStream()
        connected = false
        if runDelegate {
            doDisconnect(error)
        }
    }",0,,
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"internal static func message(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""giphy.conversation.message"", String(describing: p1))
        }",0,,
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"internal static func other(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.cannot_decrypt_resolved.other"", String(describing: p1))
          }",0,,
"    public init(filePath: String) throws {
        guard let data = try? Data(contentsOf: URL(fileURLWithPath: filePath)) else {
            throw APNSwiftError.SigningError.certificateFileDoesNotExist
        }
        var mutableByteBuffer = ByteBufferAllocator().buffer(capacity: data.count)
        mutableByteBuffer.writeBytes(data)
        self.buffer = mutableByteBuffer
    }",0,,
"    private func updateSelfPreview() {
        guard
            let selfStreamId = ZMUser.selfUser()?.selfStreamId,
            let selfStream = stream(with: selfStreamId)
        else {
            return
        }

        if let view = viewCache[selfStreamId] as? SelfVideoPreviewView {
            view.stream = selfStream
            view.shouldShowActiveSpeakerFrame = configuration.shouldShowActiveSpeakerFrame
        } else {
            viewCache[selfStreamId] = SelfVideoPreviewView(
                stream: selfStream,
                isCovered: isCovered,
                shouldShowActiveSpeakerFrame: configuration.shouldShowActiveSpeakerFrame
            )
        }
    }",1,"1,2,3,4","        guard/~/            let selfStreamId = ZMUser.selfUser()?.selfStreamId,/~/            let selfStream = stream(with: selfStreamId)/~/        else {"
"    public class func keyPathsForValuesAffectingLocalParticipantsExcludingSelf() -> Set<String> {
        return Set(ZMConversation.participantRolesKeys)
    }",0,,
"internal static func missedCall(_ p1: Int) -> String {
            return L10n.tr(""Localizable"", ""content.system.call.missed-call"", p1)
          }",0,,
"internal static func title(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.renamed_conv.title"", String(describing: p1))
          }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    func startCapture() {
        previewView.startVideoCapture()
    }",0,,
"    @objc public func markAccountAsDeleted(at timestamp: Date) {
        isAccountDeleted = true
        removeFromAllConversations(at: timestamp)
    }",0,,
"internal static func plural(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""meta.degraded.degradation_reason_message.plural"", String(describing: p1))
          }",0,,
"internal static func subheadline(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""team.activation_code.subheadline"", String(describing: p1))
        }",0,,
"    private func updateSelfPreview() {
        guard
            let selfStreamId = ZMUser.selfUser()?.selfStreamId,
            let selfStream = stream(with: selfStreamId)
        else {
            return
        }

        if let view = viewCache[selfStreamId] as? SelfVideoPreviewView {
            view.stream = selfStream
            view.shouldShowActiveSpeakerFrame = configuration.shouldShowActiveSpeakerFrame
        } else {
            viewCache[selfStreamId] = SelfVideoPreviewView(
                stream: selfStream,
                isCovered: isCovered,
                shouldShowActiveSpeakerFrame: configuration.shouldShowActiveSpeakerFrame
            )
        }
    }",1,"1,2,3,4","        guard/~/            let selfStreamId = ZMUser.selfUser()?.selfStreamId,/~/            let selfStream = stream(with: selfStreamId)/~/        else {"
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"self.stateMachine = .init(role: .server, logger: logger)
    self.idleTimeout = idleTimeout
    self.pingHandler = PingHandler(
      pingCode: 10,
      interval: configuration.interval,
      timeout: configuration.timeout,
      permitWithoutCalls: configuration.permitWithoutCalls,
      maximumPingsWithoutData: configuration.maximumPingsWithoutData,
      minimumSentPingIntervalWithoutData: configuration.minimumSentPingIntervalWithoutData,
      minimumReceivedPingIntervalWithoutData: configuration.minimumReceivedPingIntervalWithoutData,
      maximumPingStrikes: configuration.maximumPingStrikes
    )
  }

  private func sendGoAway(lastStreamID streamID: HTTP2StreamID) {
    guard let context = self.context else {
      return
    }

    let frame = HTTP2Frame(
      streamID: .rootStream,
      payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
    )

    context.writeAndFlush(self.wrapOutboundOut(frame), promise: nil)
  }",0,,
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func message(_ p1: Any) -> String {
                  return L10n.tr(""Localizable"", ""self.settings.account_section.phone_number.change.resend.message"", String(describing: p1))
                }",0,,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"internal static func subtitleAdded(_ p1: Any, _ p2: Int) -> String {
            return L10n.tr(""Localizable"", ""content.system.missing_messages.subtitle_added"", String(describing: p1), p2)
          }",0,,
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func message(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""conversation.input_bar.audio_message.too_long_size.message"", String(describing: p1))
            }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"  func channelActive(context: ChannelHandlerContext) {
    self.stateMachine.logger.addIPAddressMetadata(
      local: context.localAddress,
      remote: context.remoteAddress
    )

    // No state machine action here.
    switch self.mode {
    case let .client(connectionManager, multiplexer):
      connectionManager.channelActive(channel: context.channel, multiplexer: multiplexer)
    case .server:
      ()
    }
    context.fireChannelActive()
  }",0,,
"private func processTCPHandshake(_ buffer: UnsafePointer<UInt8>, bufferLen: Int) {
        let code = processHTTP(buffer, bufferLen: bufferLen)
        switch code {
        case 0:
            break
        case -1:
            fragBuffer = Data(bytes: buffer, count: bufferLen)
            break // do nothing, we are going to collect more data
        default:
            doDisconnect(errorWithDetail(""Invalid HTTP upgrade"", code: UInt16(code)))
        }
    }",0,,
"internal static func message(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""self.new_device_alert.message"", String(describing: p1))
        }",0,,
"internal static func deletedMessagePrefixTimestamp(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.deleted_message_prefix_timestamp"", String(describing: p1))
        }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"private static func writeUint16(_ buffer: UnsafeMutablePointer<UInt8>, offset: Int, value: UInt16) {
        buffer[offset + 0] = UInt8(value >> 8)
        buffer[offset + 1] = UInt8(value & 0xff)
    }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"internal static func services(_ p1: Int) -> String {
          return L10n.tr(""Localizable"", ""participants.section.services"", p1)
        }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"mutating func streamClosed() -> Action {
    self.activeStreams -= 1
    return .none
  }",0,,
"    private func updateState() {
        Log.calling.debug(""\nUpdating video configuration from:\n\(videoConfigurationDescription())"")

        updateSelfPreview()
        updateFloatingVideo(with: configuration.floatingVideoStream)
        updateVideoGrid(with: videoStreams)
        displayIndicatorViewsIfNeeded()
        updateGridViewAxis()

        Log.calling.debug(""\nUpdated video configuration to:\n\(videoConfigurationDescription())"")
    }",0,,
"  private static func tr(_ table: String, _ key: String, _ args: CVarArg...) -> String {
    let format = BundleToken.bundle.localizedString(forKey: key, value: nil, table: table)
    return String(format: format, locale: Locale.current, arguments: args)
  }",0,,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"    fileprivate static func validate(string : String) -> Bool {
        return CharacterSet(charactersIn: string).isSubset(of: legalCharacterSet)
    }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    init(dictionaryLiteral: (String, URLEncodedFormData)...) {
        self.values = []
        self.children = Dictionary(uniqueKeysWithValues: dictionaryLiteral)
    }",0,,
"internal static func messageTimerOffYou(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.message_timer_off-you"", String(describing: p1))
        }",0,,
"    open func write(data: Data, completion: (() -> ())? = nil) {
        guard isConnected else { return }
        dequeueWrite(data, code: .binaryFrame, writeCompletion: completion)
    }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"internal static func messageFrom(_ p1: Any, _ p2: Any) -> String {
              return L10n.tr(""Localizable"", ""conversation.input_bar.message_preview.accessibility.message_from"", String(describing: p1), String(describing: p2))
            }",0,,
"  func channelInactive(context: ChannelHandlerContext) {
    self.perform(operations: self.stateMachine.channelInactive())
    self.scheduledPing?.cancel()
    self.scheduledClose?.cancel()
    self.scheduledPing = nil
    self.scheduledClose = nil
    context.fireChannelInactive()
  }",0,,
"internal static func text(_ p1: Any) -> String {
        return L10n.tr(""Localizable"", ""send_invitation.text"", String(describing: p1))
      }",0,,
"internal static func domainUnvailable(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""peoplepicker.federation.domain_unvailable"", String(describing: p1))
        }",0,,
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"    public func increaseSecurityLevelIfNeededAfterRemoving(users: Set<ZMUser>) {
        applySecurityChanges(cause: .removedUsers(users))
    }",0,,
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"private func processResponse(_ response: WSResponse) -> Bool {
        if response.isFin && response.bytesLeft <= 0 {
            if response.code == .ping {
                let data = response.buffer! // local copy so it is perverse for writing
                dequeueWrite(data as Data, code: .pong)
            } else if response.code == .textFrame {
                let str: NSString? = NSString(data: response.buffer! as Data, encoding: String.Encoding.utf8.rawValue)
                if str == nil {
                    writeError(CloseCode.encoding.rawValue)
                    return false
                }
                if canDispatch {
                    callbackQueue.async { [weak self] in
                        guard let s = self else { return }
                        s.onText?(str! as String)
                        s.delegate?.websocketDidReceiveMessage(socket: s, text: str! as String)
                    }
                }
            } else if response.code == .binaryFrame {
                if canDispatch {
                    let data = response.buffer! // local copy so it is perverse for writing
                    callbackQueue.async { [weak self] in
                        guard let s = self else { return }
                        s.onData?(data as Data)
                        s.delegate?.websocketDidReceiveData(socket: s, data: data as Data)
                    }
                }
            }
            readStack.removeLast()
            return true
        }
        return false
    }",0,,
"internal static func called(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.call.called"", String(describing: p1))
          }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    fileprivate init(fromOperating state: Operating) {
      self.role = state.role
      // Idle if there are no open streams and we've seen the first SETTINGS frame.
      self.shouldIdle = !state.hasOpenStreams && state.hasSeenSettings
    }",0,,
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"internal static func youStartedConversation(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.you_started_conversation"", String(describing: p1))
        }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"fileprivate func appendIgnoredClientsSystemMessage(ignored clients: Set<UserClient>) {
        guard !clients.isEmpty else { return }
        let users = Set(clients.compactMap { $0.user })
        self.appendSystemMessage(type: .ignoredClient,
                                 sender: ZMUser.selfUser(in: self.managedObjectContext!),
                                 users: users,
                                 clients: clients,
                                 timestamp: timestampAfterLastMessage())
    }",0,,
"internal static func otherAddedYou(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.other_added_you"", String(describing: p1))
        }",0,,
"internal static func titleYou(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.renamed_conv.title-you"", String(describing: p1))
          }",0,,
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"internal static func messageReadReceiptOffYou(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.message_read_receipt_off-you"", String(describing: p1))
        }",0,,
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"    public func respond(to request: Request) -> EventLoopFuture<Response> {
        let startTime = DispatchTime.now().uptimeNanoseconds
        let response: EventLoopFuture<Response>
        let path: String
        if let cachedRoute = self.getRoute(for: request) {
            path = cachedRoute.route.description
            request.route = cachedRoute.route
            response = cachedRoute.responder.respond(to: request)
        } else {
            path = request.url.path
            response = self.notFoundResponder.respond(to: request)
        }
        return response.always { result in
            let status: HTTPStatus
            switch result {
            case .success(let response):
                status = response.status
            case .failure:
                status = .internalServerError
            }
            self.updateMetrics(
                for: request,
                path: path,
                startTime: startTime,
                statusCode: status.code
            )
        }
    }",1,"3,5,9,22","        let path: String/~/            path = cachedRoute.route.description/~/            path = request.url.path/~/                path: path,"
"    fileprivate init(fromQuiescing state: Quiescing) {
      self.role = state.role
      // If we initiated the quiescing then we shouldn't go idle (we want to shutdown instead).
      self.shouldIdle = !state.initiatedByUs
    }",0,,
"    private func updateSelfPreview() {
        guard
            let selfStreamId = ZMUser.selfUser()?.selfStreamId,
            let selfStream = stream(with: selfStreamId)
        else {
            return
        }

        if let view = viewCache[selfStreamId] as? SelfVideoPreviewView {
            view.stream = selfStream
            view.shouldShowActiveSpeakerFrame = configuration.shouldShowActiveSpeakerFrame
        } else {
            viewCache[selfStreamId] = SelfVideoPreviewView(
                stream: selfStream,
                isCovered: isCovered,
                shouldShowActiveSpeakerFrame: configuration.shouldShowActiveSpeakerFrame
            )
        }
    }",1,"1,2,3,4","        guard/~/            let selfStreamId = ZMUser.selfUser()?.selfStreamId,/~/            let selfStream = stream(with: selfStreamId)/~/        else {"
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"internal static func instructions(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""registration.verify_phone_number.instructions"", String(describing: p1))
        }",0,,
"    public func updateSecurityLevelIfNeededAfterFetchingClients(changes: ZMConversationRemoteClientChangeSet) {
        needsToVerifyLegalHold = false

        if changes.isEmpty {
            applySecurityChanges(cause: .verifyLegalHold)
        }
    }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"    private func resetSelfUserProviderIfNeeded(for appState: AppState) {
        guard AppDelegate.shared.shouldConfigureSelfUserProvider else { return }

        switch appState {
        case .authenticated: break
        default:
            SelfUser.provider = nil
        }
    }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    private func updateSelfPreview() {
        guard
            let selfStreamId = ZMUser.selfUser()?.selfStreamId,
            let selfStream = stream(with: selfStreamId)
        else {
            return
        }

        if let view = viewCache[selfStreamId] as? SelfVideoPreviewView {
            view.stream = selfStream
            view.shouldShowActiveSpeakerFrame = configuration.shouldShowActiveSpeakerFrame
        } else {
            viewCache[selfStreamId] = SelfVideoPreviewView(
                stream: selfStream,
                isCovered: isCovered,
                shouldShowActiveSpeakerFrame: configuration.shouldShowActiveSpeakerFrame
            )
        }
    }",1,"1,2,3,4","        guard/~/            let selfStreamId = ZMUser.selfUser()?.selfStreamId,/~/            let selfStream = stream(with: selfStreamId)/~/        else {"
"open func disconnect(forceTimeout: TimeInterval? = nil, closeCode: UInt16 = CloseCode.normal.rawValue) {
        guard isConnected else { return }
        switch forceTimeout {
        case .some(let seconds) where seconds > 0:
            let milliseconds = Int(seconds * 1_000)
            callbackQueue.asyncAfter(deadline: .now() + .milliseconds(milliseconds)) { [weak self] in
                self?.disconnectStream(nil)
            }
            fallthrough
        case .none:
            writeError(closeCode)
        default:
            disconnectStream(nil)
            break
        }
    }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"private func generateWebSocketKey() -> String {
        var key = """"
        let seed = 16
        for _ in 0..<seed {
            let uni = UnicodeScalar(UInt32(97 + arc4random_uniform(25)))
            key += ""\(Character(uni!))""
        }
        let data = key.data(using: String.Encoding.utf8)
        let baseKey = data?.base64EncodedString(options: NSData.Base64EncodingOptions(rawValue: 0))
        return baseKey!
    }",0,,
"fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {
        switch self {
            case .start(let value):
                return (offset: numericCast(value), byteCount: size - value)
            case .tail(let value):
                return (offset: numericCast(size - value), byteCount: value)
            case .within(let start, let end):
                return (offset: numericCast(start), byteCount: end - start + 1)
        }
    }",1,"0,7","fileprivate func asByteBufferBounds(withMaxSize size: Int) -> (offset: Int64, byteCount: Int) {/~/                return (offset: numericCast(start), byteCount: end - start + 1)"
"    func scheduleNotification(expositionInfo: ExpositionInfo) {
        var title, body: String?
        var sound: UNNotificationSound?
        formatter.dateFormat = ""dd.MM.YYYY""

        switch expositionInfo.level {
        case .exposed:
            title = ""NOTIFICATION_TITLE_EXPOSURE_HIGH"".localized
            body = ""NOTIFICATION_MESSAGE_EXPOSURE_HIGH"".localized
            sound = .defaultCritical
        default:
            debugPrint(""No notification for exposition: \(expositionInfo.level.rawValue)"")
        }

        if let title = title, let body = body, let sound = sound {
            scheduleNotification(title: title, body: body, sound: sound)
        }
    }",1,4,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"internal static func `left`(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""content.system.conversation.other.left"", String(describing: p1))
            }",0,,
"public func appendDecryptionFailedSystemMessage(at date: Date?, sender: ZMUser, client: UserClient?, errorCode: Int) {
        let type = (UInt32(errorCode) == CBOX_REMOTE_IDENTITY_CHANGED.rawValue) ? ZMSystemMessageType.decryptionFailed_RemoteIdentityChanged : ZMSystemMessageType.decryptionFailed
        let clients = client.flatMap { Set(arrayLiteral: $0) } ?? Set<UserClient>()
        let serverTimestamp = date ?? timestampAfterLastMessage()
        let systemMessage = appendSystemMessage(type: type,
                                               sender: sender,
                                               users: nil,
                                               clients: clients,
                                               timestamp: serverTimestamp)
        
        systemMessage.senderClientID = client?.remoteIdentifier
        systemMessage.decryptionErrorCode = NSNumber(integerLiteral: errorCode)
    }",0,,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"internal static func other(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.session_reset.other"", String(describing: p1))
          }",0,,
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"internal static func removed(_ p1: Any, _ p2: Any) -> String {
              return L10n.tr(""Localizable"", ""content.system.conversation.other.removed"", String(describing: p1), String(describing: p2))
            }",0,,
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"internal static func user(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""call.status.outgoing.user"", String(describing: p1))
          }",0,,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"internal static func mention(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""conversation.status.message.mention"", String(describing: p1))
          }",0,,
"@objc public func markToDownloadRolesIfNeeded() {
        guard self.conversationType == .group else { return }
        
        let selfUser = ZMUser.selfUser(in: self.managedObjectContext!)
        let notInMyTeam = self.teamRemoteIdentifier == nil ||
            selfUser.team?.remoteIdentifier != self.teamRemoteIdentifier
        
        guard notInMyTeam else { return }
        
        if self.nonTeamRoles.isEmpty ||
            self.nonTeamRoles.first(where: {!$0.actions.isEmpty}) == nil // there are no roles with actions
        {
            self.needsToDownloadRoles = true
        }
    }",0,,
"    private func toggleMaximized(view: BaseVideoPreviewView?) {
        let stream = view?.stream
        
        maximizedView = isMaximized(stream: stream) ? nil : view
        view?.isMaximized = isMaximized(stream: stream)
        updateVideoGrid(with: videoStreams)
    }",0,,
"        didSet {
            guard !configuration.isEqual(toConfiguration: oldValue) else { return }
            updateState()
        }",0,,
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"mutating func streamCreated() -> Action {
    self.activeStreams += 1

    if self.startedAt == nil {
      self.startedAt = self.now()
      return .schedulePing(delay: self.interval, timeout: self.timeout)
    } else {
      return .none
    }
  }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    private func updateFloatingVideo(with state: VideoStream?) {
        // No stream, remove floating video if there is any.
        guard let state = state else {
            Log.calling.debug(""Removing self video from floating preview"")
            return thumbnailViewController.removeCurrentThumbnailContentView()
        }

        // We only support the self preview in the floating overlay.
        guard state.stream.streamId == ZMUser.selfUser()?.selfStreamId else {
            return Log.calling.error(""Invalid operation: Non self preview in overlay"")
        }

        // We have a stream but don't have a preview view yet.
        if nil == thumbnailViewController.contentView, let previewView = selfPreviewView {
            Log.calling.debug(""Adding self video to floating preview"")
            thumbnailViewController.setThumbnailContentView(previewView, contentSize: .previewSize(for: traitCollection))
        }
    }",0,,
"private func initStreamsWithData(_ data: Data, _ port: Int) {
        //higher level API we will cut over to at some point
        //NSStream.getStreamsToHostWithName(url.host, port: url.port.integerValue, inputStream: &inputStream, outputStream: &outputStream)

        // Disconnect and clean up any existing streams before setting up a new pair
        disconnectStream(nil, runDelegate: false)

        var readStream: Unmanaged<CFReadStream>?
        var writeStream: Unmanaged<CFWriteStream>?
        let h = url.host! as NSString
        CFStreamCreatePairWithSocketToHost(nil, h, UInt32(port), &readStream, &writeStream)
        inputStream = readStream!.takeRetainedValue()
        outputStream = writeStream!.takeRetainedValue()
        guard let inStream = inputStream, let outStream = outputStream else { return }
        inStream.delegate = self
        outStream.delegate = self
        if supportedSSLSchemes.contains(url.scheme!) {
            inStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            outStream.setProperty(StreamSocketSecurityLevel.negotiatedSSL as AnyObject, forKey: Stream.PropertyKey.socketSecurityLevelKey)
            if disableSSLCertValidation {
                let settings: [NSObject: NSObject] = [kCFStreamSSLValidatesCertificateChain: NSNumber(value: false), kCFStreamSSLPeerName: kCFNull]
                inStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
                outStream.setProperty(settings, forKey: kCFStreamPropertySSLSettings as Stream.PropertyKey)
            }
            if let cipherSuites = self.enabledSSLCipherSuites {
                if let sslContextIn = CFReadStreamCopyProperty(inputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext?,
                    let sslContextOut = CFWriteStreamCopyProperty(outputStream, CFStreamPropertyKey(rawValue: kCFStreamPropertySSLContext)) as! SSLContext? {
                    let resIn = SSLSetEnabledCiphers(sslContextIn, cipherSuites, cipherSuites.count)
                    let resOut = SSLSetEnabledCiphers(sslContextOut, cipherSuites, cipherSuites.count)
                    if resIn != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting ingoing cypher suites"", code: UInt16(resIn))
                        disconnectStream(error)
                        return
                    }
                    if resOut != errSecSuccess {
                        let error = self.errorWithDetail(""Error setting outgoing cypher suites"", code: UInt16(resOut))
                        disconnectStream(error)
                        return
                    }
                }
            }
        } else {
            certValidated = true //not a https session, so no need to check SSL pinning
        }
        if voipEnabled {
            inStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
            outStream.setProperty(StreamNetworkServiceTypeValue.voIP as AnyObject, forKey: Stream.PropertyKey.networkServiceType)
        }
        
        CFReadStreamSetDispatchQueue(inStream, WebSocket.sharedWorkQueue)
        CFWriteStreamSetDispatchQueue(outStream, WebSocket.sharedWorkQueue)
        inStream.open()
        outStream.open()

        self.mutex.lock()
        self.readyToWrite = true
        self.mutex.unlock()
        
        let bytes = UnsafeRawPointer((data as NSData).bytes).assumingMemoryBound(to: UInt8.self)
        var out = timeout * 1_000_000 // wait 5 seconds before giving up
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            guard let sOperation = operation else { return }
            while !outStream.hasSpaceAvailable && !sOperation.isCancelled {
                usleep(100) // wait until the socket is ready
                guard !sOperation.isCancelled else { return }
                out -= 100
                if out < 0 {
                    self?.cleanupStream()
                    self?.doDisconnect(self?.errorWithDetail(""write wait timed out"", code: 2))
                    return
                } else if outStream.streamError != nil {
                    return // disconnectStream will be called.
                }
            }
            guard !sOperation.isCancelled else { return }
            outStream.write(bytes, maxLength: data.count)
        }
        writeQueue.addOperation(operation)
    }",1,"68,75",                    self?.cleanupStream()/~/            guard !sOperation.isCancelled else { return }
"result.set(value: .urlEncoded(value), forPath: [])
            case 2:
                let key = kv[0]
                let value = String(kv[1])
                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))
            default:
                //Empty `&&`
                continue
            }
        }
        return result
    }

    func parseKey(key: Substring) throws -> [String] {
        guard let percentDecodedKey = key.removingPercentEncoding else {
            throw URLEncodedFormError.malformedKey(key: key)
        }
        return try percentDecodedKey.split(separator: ""["").enumerated().map { (i, part) in 
            switch i {
            case 0:
                return String(part)
            default:
                guard part.last == ""]"" else {
                    throw URLEncodedFormError.malformedKey(key: key)
                }
                return String(part.dropLast())
            }
        }
    }",1,"0,4","                result.set(value: .urlEncoded(value), forPath: [])/~/                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))"
"internal static func started(_ p1: Any, _ p2: Any) -> String {
              return L10n.tr(""Localizable"", ""content.system.conversation.you.started"", String(describing: p1), String(describing: p2))
            }",0,,
"    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }",1,"1,2,3,6,8","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"private func validateResponse(_ buffer: UnsafePointer<UInt8>, bufferLen: Int) -> Int {
        let response = CFHTTPMessageCreateEmpty(kCFAllocatorDefault, false).takeRetainedValue()
        CFHTTPMessageAppendBytes(response, buffer, bufferLen)
        let code = CFHTTPMessageGetResponseStatusCode(response)
        if code != httpSwitchProtocolCode {
            return code
        }
        if let cfHeaders = CFHTTPMessageCopyAllHeaderFields(response) {
            let headers = cfHeaders.takeRetainedValue() as NSDictionary
            if let acceptKey = headers[headerWSAcceptName as NSString] as? NSString {
                if acceptKey.length > 0 {
                    return 0
                }
            }
        }
        return -1
    }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {
    if self.activeStreams == 0 {
      self.sentPingsWithoutData += 1
    }

    self.lastSentPingDate = self.now()
    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)
  }",1,"0,6","private mutating func generatePingFrame(code: UInt64, ack: Bool) -> HTTP2Frame.FramePayload {/~/    return HTTP2Frame.FramePayload.ping(HTTP2PingData(withInteger: code), ack: ack)"
"private func updateMetrics(
        for request: Request,
        path: String,
        startTime: UInt64,
        statusCode: UInt
    ) {
        let counterDimensions = [
            (""method"", request.method.string),
            (""path"", path),
            (""status"", statusCode.description),
        ]
        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()
        if statusCode >= 500 {
            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()
        }
        Timer(
            label: ""http_request_duration_seconds"",
            dimensions: [
                (""method"", request.method.string),
                (""path"", path)
            ],
            preferredDisplayUnit: .seconds
        ).recordNanoseconds(DispatchTime.now().uptimeNanoseconds - startTime)
    }",1,"2,6,7,8,11,13,17,18,19,20","        path: String,/~/        let counterDimensions = [/~/            (""method"", request.method.string),/~/            (""path"", path),/~/        Counter(label: ""http_requests_total"", dimensions: counterDimensions).increment()/~/            Counter(label: ""http_request_errors_total"", dimensions: counterDimensions).increment()/~/            dimensions: [/~/                (""method"", request.method.string),/~/                (""path"", path)/~/            ],"
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"internal static func titleYou(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""content.system.conversation.with_name.title-you"", String(describing: p1))
            }",0,,
"    func performWhenAuthenticated(_ block : @escaping () -> Void) {
        if case .authenticated = appStateCalculator.appState {
            block()
        } else {
            authenticatedBlocks.append(block)
        }
    }",0,,
"internal static func teamConversations(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""peoplepicker.header.team_conversations"", String(describing: p1))
        }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    public func performQuickAction(for shortcutItem: UIApplicationShortcutItem,
                                   completionHandler: ((Bool) -> Void)?) {
        quickActionsManager.performAction(for: shortcutItem,
                                          completionHandler: completionHandler)
    }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"internal static func messageTimerOff(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.message_timer_off"", String(describing: p1))
        }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"internal static func knowsTwo(_ p1: Any, _ p2: Any) -> String {
          return L10n.tr(""Localizable"", ""peoplepicker.suggested.knows_two"", String(describing: p1), String(describing: p2))
        }",0,,
"private func createHTTPRequest() {

        let urlRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, ""GET"" as CFString,
                                                    url as CFURL, kCFHTTPVersion1_1).takeRetainedValue()

        var port = url.port
        if port == nil {
            if supportedSSLSchemes.contains(url.scheme!) {
                port = 443
            } else {
                port = 80
            }
        }
        addHeader(urlRequest, key: headerWSUpgradeName, val: headerWSUpgradeValue)
        addHeader(urlRequest, key: headerWSConnectionName, val: headerWSConnectionValue)
        if let protocols = optionalProtocols {
            addHeader(urlRequest, key: headerWSProtocolName, val: protocols.joined(separator: "",""))
        }
        addHeader(urlRequest, key: headerWSVersionName, val: headerWSVersionValue)
        addHeader(urlRequest, key: headerWSKeyName, val: generateWebSocketKey())
        if let origin = origin {
            addHeader(urlRequest, key: headerOriginName, val: origin)
        }
        addHeader(urlRequest, key: headerWSHostName, val: ""\(url.host!):\(port!)"")
        for (key, value) in headers {
            addHeader(urlRequest, key: key, val: value)
        }
        if let cfHTTPMessage = CFHTTPMessageCopySerializedMessage(urlRequest) {
            let serializedRequest = cfHTTPMessage.takeRetainedValue()
            initStreamsWithData(serializedRequest as Data, Int(port!))
        }
    }",1,1,
"    public init(publicDirectory: String) {
        self.publicDirectory = publicDirectory.hasSuffix(""/"") ? publicDirectory : publicDirectory + ""/""
    }",0,,
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification,
                withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        // Forground notifications.
        completionHandler([.alert, .sound, .badge])
    }",0,,
"        super.init()

        setupAppStateCalculator()
        setupURLActionRouter()
        setupNotifications()
        setupAdditionalWindows()

        AppRootRouter.configureAppearance()

        createLifeCycleObserverTokens()
        setCallingSettings()
    }

    // MARK: - Public implementation

    public func start(launchOptions: LaunchOptions) {
        showInitial(launchOptions: launchOptions)
    }",0,,
"    @objc(acknowledgePrivacyWarningWithResendIntent:) public func acknowledgePrivacyWarning(withResendIntent shouldResendMessages: Bool) {
        acknowledgePrivacyChanges()

        if shouldResendMessages {
            resendPendingMessagesAfterPrivacyChanges()
        } else {
            discardPendingMessagesAfterPrivacyChanges()
        }
    }",0,,
"    private func gridAxis(for traitCollection: UITraitCollection) -> UICollectionView.ScrollDirection {
        let isLandscape = UIApplication.shared.statusBarOrientation.isLandscape
        switch (traitCollection.userInterfaceIdiom, traitCollection.horizontalSizeClass, isLandscape) {
        case (.pad, .regular, true):
            return .horizontal
        default:
            return .vertical
        }
    }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"self.init(light: color, dark: color)
    }
}

extension UIColor {

    static func from(scheme: ColorSchemeColor, variant: ColorSchemeVariant? = nil) -> UIColor {
        return ColorScheme.default.color(named: scheme, variant: variant)
    }

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    // NB: the order of coefficients must match ZMAccentColor enum ordering
    private static let accentColorNameColorBlendingCoefficientsDark: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.8, 0.64]
    private static let accentColorNameColorBlendingCoefficientsLight: [CGFloat] = [0.8, 0.8, 0.72, 1.0, 0.8, 0.8, 0.64, 1.0]

    /// Creates UIColor instance with color corresponding to @p accentColor that can be used to display the name.
    class func nameColor(for accentColor: ZMAccentColor, variant: ColorSchemeVariant) -> UIColor {

        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)

        let coefficientsArray = variant == .dark ? accentColorNameColorBlendingCoefficientsDark : accentColorNameColorBlendingCoefficientsLight
        let coefficient = coefficientsArray[Int(accentColor.rawValue)]

        let background: UIColor = variant == .dark ? .black : .white
        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)
    }
}",1,"17,18,19,22,24","/~/        assert(accentColor.rawValue <= ZMAccentColor.max.rawValue)/~//~//~/        return background.mix(UIColor(fromZMAccentColor: accentColor), amount: coefficient)"
"internal static func removed(_ p1: Any, _ p2: Any) -> String {
              return L10n.tr(""Localizable"", ""content.system.conversation.you.removed"", String(describing: p1), String(describing: p2))
            }",0,,
