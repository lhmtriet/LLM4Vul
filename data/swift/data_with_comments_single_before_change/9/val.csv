processed_func,target,flaw_line_index,flaw_line
"    public init(buffer: ByteBuffer) throws {
        self.buffer = buffer
    }",0,,
"internal static func continuedConversation(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.continued_conversation"", String(describing: p1))
        }",0,,
"        rootViewController.set(childViewController: AppLockModule.build(session: session),
                               completion: completion)
    }

    // MARK: - Helpers
    private func configureUnauthenticatedAppearance() {
        rootViewController.view.window?.tintColor = UIColor.Wire.primaryLabel
        ValidatedTextField.appearance(whenContainedInInstancesOf: [AuthenticationStepController.self]).tintColor = UIColor.Team.activeButton
    }",0,,
"        didSet {
            setupAnalyticsSharing()
        }",0,,
"  mutating func pingFired() -> Action {
    if self.shouldBlockPing {
      return .none
    } else {
      return .reply(self.generatePingFrame(code: self.pingCode, ack: false))
    }
  }",1,4,"      return .reply(self.generatePingFrame(code: self.pingCode, ack: false))"
"    func applicationDidBecomeActive() {
        updateOverlayWindowFrame()
        teamMetadataRefresher.triggerRefreshIfNeeded()
    }",0,,
"internal static func genericMessage(_ p1: Int) -> String {
              return L10n.tr(""Localizable"", ""conversation.silenced.status.message.generic_message"", p1)
            }",0,,
"    fileprivate init(fromOperating state: Operating, idleTask: Scheduled<Void>) {
      // We won't transition to this state unless we've seen a SETTINGS frame.
      assert(state.hasSeenSettings)

      self.role = state.role
      self.lastPeerInitiatedStreamID = state.lastPeerInitiatedStreamID
      self.maxConcurrentStreams = state.maxConcurrentStreams
      self.idleTask = idleTask
    }",0,,
"internal static func tooManyMembersInConversation(_ p1: Int) -> String {
          return L10n.tr(""Localizable"", ""error.group_call.too_many_members_in_conversation"", p1)
        }",0,,
"@objc public func replaceNewClientMessageIfNeededWithNewDeviceMesssage() {

        let selfUser = ZMUser.selfUser(in: self.managedObjectContext!)
        guard let selfClient = selfUser.selfClient() else { return }
        
        NSOrderedSet(array: lastMessages()).enumerateObjects() { (msg, idx, stop) in
            guard idx <= 2 else {
                stop.initialize(to: true)
                return
            }
            
            guard let systemMessage = msg as? ZMSystemMessage,
                systemMessage.systemMessageType == .newClient,
                systemMessage.sender == selfUser else {
                    return
            }
            
            if systemMessage.clients.contains(selfClient) {
                systemMessage.systemMessageType = .usingNewDevice
                stop.initialize(to: true)
            }
        }
    }",0,,
"internal static func missedCall(_ p1: Int) -> String {
            return L10n.tr(""Localizable"", ""content.system.call.missed-call"", p1)
          }",0,,
"    func performWhenAuthenticated(_ block : @escaping () -> Void) {
        if case .authenticated = appStateCalculator.appState {
            block()
        } else {
            authenticatedBlocks.append(block)
        }
    }",0,,
"internal static func unverifiedSelfDevices(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.unverified_self_devices"", String(describing: p1))
        }",0,,
"    public func decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set<UserClient>, causedBy users: Set<ZMUser>) {
        applySecurityChanges(cause: .addedUsers(users))
    }",0,,
"public func addParticipantsAndUpdateConversationState(users: Set<ZMUser>, role: Role?) {
        self.addParticipantsAndUpdateConversationState(usersAndRoles: users.map { ($0, role) })
    }",0,,
"public func readFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let fileSize = attributes[.size] as? NSNumber
        else {
            return self.request.eventLoop.makeFailedFuture(Abort(.internalServerError))
        }
        return self.read(
            path: path,
            fromOffset: 0,
            byteCount:
            fileSize.intValue,
            chunkSize: chunkSize,
            onRead: onRead
        )
    }",0,,
"internal static func otherLeft(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.other_left"", String(describing: p1))
        }",0,,
"private func resendPendingMessagesAfterPrivacyChanges() {
        enumerateReverseMessagesThatCausedDegradationUntilFirstSystemMessageOnSyncContext {
            $0.causedSecurityLevelDegradation = false
            $0.resend()
        }
    }",0,,
"internal static func missedcall(_ p1: Int) -> String {
              return L10n.tr(""Localizable"", ""conversation.silenced.status.message.missedcall"", p1)
            }",0,,
"internal static func otherRemovedYou(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.other_removed_you"", String(describing: p1))
        }",0,,
"        self.init(url: url, protocols: protocols)
        writeQueue.qualityOfService = writeQueueQOS
    }

    /**
     Connect to the WebSocket server on a background thread.
     */
    open func connect() {
        guard !isConnecting else { return }
        didDisconnect = false
        isConnecting = true
        createHTTPRequest()
    }",0,,
"internal static func other(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.cannot_decrypt_identity_changed.other"", String(describing: p1))
          }",0,,
"mutating func streamCreated() -> Action {
    self.activeStreams += 1

    if self.startedAt == nil {
      self.startedAt = self.now()
      return .schedulePing(delay: self.interval, timeout: self.timeout)
    } else {
      return .none
    }
  }",0,,
"internal static func message(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""login.sso.error.alert.message"", String(describing: p1))
            }",0,,
"private func handlePong(_ pingData: HTTP2PingData) -> Action {
    if pingData.integer == self.pingCode {
      return .cancelScheduledTimeout
    } else {
      return .none
    }
  }",1,1,    if pingData.integer == self.pingCode {
"internal static func instructions(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""registration.verify_email.instructions"", String(describing: p1))
        }",0,,
"internal static func user(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""call.degraded.alert.message.user"", String(describing: p1))
            }",0,,
"internal static func user(_ p1: Any) -> String {
                return L10n.tr(""Localizable"", ""call.degraded.ended.alert.message.user"", String(describing: p1))
              }",0,,
"internal static func message(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""giphy.conversation.message"", String(describing: p1))
        }",0,,
"    fileprivate init(fromWaitingToIdle state: WaitingToIdle, shouldIdle: Bool = true) {
      self.role = state.role
      self.shouldIdle = shouldIdle
    }",0,,
"    private func appendLegalHoldDisabledSystemMessageForConversationAfterReceivingMessage(at timestamp: Date) {
        appendSystemMessage(type: .legalHoldDisabled,
                            sender: ZMUser.selfUser(in: self.managedObjectContext!),
                            users: nil,
                            clients: nil,
                            timestamp: timestamp.previousNearestTimestamp)
    }",0,,
"    fileprivate func timestamp(after: ZMConversationMessage?) -> Date? {
        guard let timestamp = after?.serverTimestamp ?? self.lastModifiedDate else { return nil }
        return timestamp.nextNearestTimestamp
    }",0,,
"internal static func footer(_ p1: Int) -> String {
            return L10n.tr(""Localizable"", ""participants.section.name.footer"", p1)
          }",0,,
"    public func decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set<UserClient>, causedBy message: ZMOTRMessage?) {
        applySecurityChanges(cause: .addedClients(clients, source: message))
    }",0,,
"    private func notifyVisibilityChanged() {
        NotificationCenter.default.post(
            name: .videoGridVisibilityChanged,
            object: nil,
            userInfo: [VideoGridViewController.isCoveredKey: isCovered]
        )
    }",0,,
"    private func setupAnalyticsSharing() {
        guard
            appStateCalculator.wasUnauthenticated,
            let selfUser = SelfUser.provider?.selfUser,
            selfUser.isTeamMember
        else {
            return
        }

        TrackingManager.shared.disableCrashSharing = true
        TrackingManager.shared.disableAnalyticsSharing = false
        Analytics.shared.provider?.selfUser = selfUser
    }",0,,
"internal static func incoming(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""call.announcement.incoming"", String(describing: p1))
        }",0,,
"internal static func other(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.cannot_decrypt_resolved.other"", String(describing: p1))
          }",0,,
"internal static func title(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""content.system.renamed_conv.title"", String(describing: p1))
          }",0,,
"public func streamFile(
        at path: String,
        chunkSize: Int = NonBlockingFileIO.defaultChunkSize,
        mediaType: HTTPMediaType? = nil,
        onCompleted: @escaping (Result<Void, Error>) -> () = { _ in }
    ) -> Response {
        // Get file attributes for this file.
        guard
            let attributes = try? FileManager.default.attributesOfItem(atPath: path),
            let modifiedAt = attributes[.modificationDate] as? Date,
            let fileSize = (attributes[.size] as? NSNumber)?.intValue
        else {
            return Response(status: .internalServerError)
        }

        let contentRange: HTTPHeaders.Range?
        if let rangeFromHeaders = request.headers.range {
            if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {
                contentRange = rangeFromHeaders
            } else {
                contentRange = nil
            }
        } else {
            contentRange = nil
        }
        // Create empty headers array.
        var headers: HTTPHeaders = [:]

        // Generate ETag value, ""HEX value of last modified date"" + ""-"" + ""file size""
        let fileETag = ""\(modifiedAt.timeIntervalSince1970)-\(fileSize)""
        headers.replaceOrAdd(name: .eTag, value: fileETag)

        // Check if file has been cached already and return NotModified response if the etags match
        if fileETag == request.headers.first(name: .ifNoneMatch) {
            return Response(status: .notModified)
        }

        // Create the HTTP response.
        let response = Response(status: .ok, headers: headers)
        let offset: Int64
        let byteCount: Int
        if let contentRange = contentRange {
            response.status = .partialContent
            response.headers.add(name: .accept, value: contentRange.unit.serialize())
            if let firstRange = contentRange.ranges.first {
                let range = firstRange.asResponseContentRange(limit: fileSize)
                response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)
                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)
            } else {
                offset = 0
                byteCount = fileSize
            }
        } else {
            offset = 0
            byteCount = fileSize
        }
        // Set Content-Type header based on the media type
        // Only set Content-Type if file not modified and returned above.
        if
            let fileExtension = path.components(separatedBy: ""."").last,
            let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)
        {
            response.headers.contentType = type
        }
        response.body = .init(stream: { stream in
            self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in
                return stream.write(.buffer(chunk))
            }.whenComplete { result in
                switch result {
                case .failure(let error):
                    stream.write(.error(error), promise: nil)
                case .success:
                    stream.write(.end, promise: nil)
                }
                onCompleted(result)
            }
        }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)
        
        return response
    }

    /// Private read method. `onRead` closure uses ByteBuffer and expects future return.
    /// There may be use in publicizing this in the future for reads that must be async.
    private func read(
        path: String,
        fromOffset offset: Int64,
        byteCount: Int,
        chunkSize: Int,
        onRead: @escaping (ByteBuffer) -> EventLoopFuture<Void>
    ) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path)
            let done = self.io.readChunked(
                fileHandle: fd,
                fromOffset: offset,
                byteCount: byteCount,
                chunkSize: chunkSize,
                allocator: allocator,
                eventLoop: self.request.eventLoop
            ) { chunk in
                return onRead(chunk)
            }
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
    
    /// Write the contents of buffer to a file at the supplied path.
    ///
    ///     let data = ByteBuffer(string: ""ByteBuffer"")
    ///     try req.fileio.writeFile(data, at: ""/path/to/file.txt"").wait()
    ///
    /// - parameters:
    ///     - path: Path to file on the disk.
    ///     - buffer: The `ByteBuffer` to write.
    /// - returns: `Future` that will complete when the file write is finished.
    public func writeFile(_ buffer: ByteBuffer, at path: String) -> EventLoopFuture<Void> {
        do {
            let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())
            let done = io.write(fileHandle: fd, buffer: buffer, eventLoop: self.request.eventLoop)
            done.whenComplete { _ in
                try? fd.close()
            }
            return done
        } catch {
            return self.request.eventLoop.makeFailedFuture(error)
        }
    }
}",1,47,"                (offset, byteCount) = firstRange.asByteBufferBounds(withMaxSize: fileSize)"
"    public func handleDoubleTap(gesture: UIGestureRecognizer) {
        let location = gesture.location(in: gridView)
        toggleMaximized(view: streamView(at: location))
    }",0,,
"  mutating func channelInactive() -> Operations {
    var operations: Operations = .none

    switch self.state {
    case let .operating(state):
      self.state = .closed

      // We unexpectedly became inactive.
      if !state.hasSeenSettings || state.hasOpenStreams {
        // Haven't seen settings, or we've seen settings and there are open streams.
        operations.notifyConnectionManager(about: .inactive)
      } else {
        // Have seen settings and there are no open streams.
        operations.notifyConnectionManager(about: .idle)
      }

    case let .waitingToIdle(state):
      self.state = .closed

      // We were going to idle anyway.
      operations.notifyConnectionManager(about: .idle)
      operations.cancelIdleTask(state.idleTask)

    case let .quiescing(state):
      self.state = .closed

      if state.initiatedByUs || state.hasOpenStreams {
        operations.notifyConnectionManager(about: .inactive)
      } else {
        operations.notifyConnectionManager(about: .idle)
      }

    case let .closing(state):
      self.state = .closed

      if state.shouldIdle {
        operations.notifyConnectionManager(about: .idle)
      } else {
        operations.notifyConnectionManager(about: .inactive)
      }

    case .closed:
      ()
    }

    return operations
  }",0,,
"internal static func started(_ p1: Any, _ p2: Any) -> String {
              return L10n.tr(""Localizable"", ""content.system.conversation.other.started"", String(describing: p1), String(describing: p2))
            }",0,,
"internal static func reply(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""conversation.status.message.reply"", String(describing: p1))
          }",0,,
"private func perform(operations: GRPCIdleHandlerStateMachine.Operations) {
    // Prod the connection manager.
    if let event = operations.connectionManagerEvent, let manager = self.mode.connectionManager {
      switch event {
      case .idle:
        manager.idle()
      case .inactive:
        manager.channelInactive()
      case .ready:
        manager.ready()
      case .quiescing:
        manager.beginQuiescing()
      }
    }

    // Max concurrent streams changed.
    if let manager = self.mode.connectionManager,
      let maxConcurrentStreams = operations.maxConcurrentStreamsChange {
      manager.maxConcurrentStreamsChanged(maxConcurrentStreams)
    }

    // Handle idle timeout creation/cancellation.
    if let idleTask = operations.idleTask {
      switch idleTask {
      case let .cancel(task):
        task.cancel()

      case .schedule:
        if self.idleTimeout != .nanoseconds(.max), let context = self.context {
          let task = context.eventLoop.scheduleTask(in: self.idleTimeout) {
            self.idleTimeoutFired()
          }
          self.perform(operations: self.stateMachine.scheduledIdleTimeoutTask(task))
        }
      }
    }

    // Send a GOAWAY frame.
    if let streamID = operations.sendGoAwayWithLastPeerInitiatedStreamID {
      let goAwayFrame = HTTP2Frame(
        streamID: .rootStream,
        payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
      )
      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)
    }

    // Close the channel, if necessary.
    if operations.shouldCloseChannel, let context = self.context {
      // Close on the next event-loop tick so we don't drop any events which are
      // currently being processed.
      context.eventLoop.execute {
        context.close(mode: .all, promise: nil)
      }
    }
  }",1,43,"      self.context?.writeAndFlush(self.wrapOutboundOut(goAwayFrame), promise: nil)"
"    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification,
                withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        // Forground notifications.
        completionHandler([.alert, .sound, .badge])
    }",0,,
"    deinit {
        stopCapture()
    }",0,,
"public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {
        
        // Is this a new conversation, or an existing one that is being updated?
        let doesExistsOnBackend = self.remoteIdentifier != nil
        
        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in
            guard !user.isAccountDeleted else { return nil }
            
            // make sure the role is the right team/conversation role
            require(
                role == nil || (role!.team == self.team || role!.conversation == self),
                ""Tried to add a role that does not belong to the conversation""
            )
            
            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }
            return (result == .created) ? pr : nil
        }
        
        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})
        if addedSelfUser {
            self.markToDownloadRolesIfNeeded()
            self.needsToBeUpdatedFromBackend = true
        }
        
        if !addedRoles.isEmpty {
            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)
            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
        }
    }",1,26,self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))
"internal static func instructions(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""registration.verify_phone_number.instructions"", String(describing: p1))
        }",0,,
"internal static func message(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""profile.block_dialog.message"", String(describing: p1))
        }",0,,
"    private func setupNotifications() {
        setupApplicationNotifications()
        setupContentSizeCategoryNotifications()
        setupAudioPermissionsNotifications()
    }",0,,
"internal static func messageTimerOff(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.message_timer_off"", String(describing: p1))
        }",0,,
"    class func keyboardAppearance(for variant: ColorSchemeVariant) -> UIKeyboardAppearance {
        return variant == .light ? .light : .dark
    }",0,,
"internal static func verifyMessage(_ p1: Any) -> String {
            return L10n.tr(""Localizable"", ""profile.devices.detail.verify_message"", String(describing: p1))
          }",0,,
"public init(url: URL, protocols: [String]? = nil) {
        self.url = url
        self.origin = url.absoluteString
        if let hostUrl = URL (string: ""/"", relativeTo: url) {
            var origin = hostUrl.absoluteString
            origin.remove(at: origin.index(before: origin.endIndex))
            self.origin = origin
        }
        writeQueue.maxConcurrentOperationCount = 1
        optionalProtocols = protocols
    }",0,,
"internal static func seen(_ p1: Int) -> String {
          return L10n.tr(""Localizable"", ""message_details.tabs.seen"", p1)
        }",0,,
"    private func setupAdditionalWindows() {
        screenCurtain.makeKeyAndVisible()
        screenCurtain.isHidden = true
    }",0,,
"internal static func otherStartedConversation(_ p1: Any, _ p2: Any) -> String {
          return L10n.tr(""Localizable"", ""content.system.other_started_conversation"", String(describing: p1), String(describing: p2))
        }",0,,
"private func createConstraints() {
        for subView in [gridView, thumbnailViewController.view] {
            subView?.translatesAutoresizingMaskIntoConstraints = false
            subView?.fitInSuperview()
        }

        constrain(view, networkConditionView) { view, networkConditionView in
            networkConditionView.centerX == view.centerX
            networkConditionView.top == view.safeAreaLayoutGuideOrFallback.top + 24
        }
    }",0,,
"    override func setupViews() {
        super.setupViews()
        previewView.backgroundColor = .clear
        previewView.translatesAutoresizingMaskIntoConstraints = false
        insertSubview(previewView, belowSubview: userDetailsView)
    }",0,,
"internal static func description(_ p1: Any) -> String {
                  return L10n.tr(""Localizable"", ""self.settings.account_section.phone_number.change.verify.description"", String(describing: p1))
                }",0,,
"    internal init(io: NonBlockingFileIO, allocator: ByteBufferAllocator, request: Request) {
        self.io = io
        self.allocator = allocator
        self.request = request
    }",0,,
"internal static func guests(_ p1: Any) -> String {
              return L10n.tr(""Localizable"", ""content.system.started_conversation.complete_team.guests"", String(describing: p1))
            }",0,,
"    func startCapture() {
        previewView.startVideoCapture()
    }",0,,
"    public class func keyPathsForValuesAffectingActiveParticipants() -> Set<String> {
        return Set(participantRolesKeys)
    }",0,,
"internal static func fingerprintMessageUnencrypted(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""profile.devices.fingerprint_message_unencrypted"", String(describing: p1))
        }",0,,
"    init(values: [URLQueryFragment] = [], children: [String: URLEncodedFormData] = [:]) {
        self.values = values
        self.children = children
    }",0,,
"internal static func resendPlaceholder(_ p1: Float) -> String {
          return L10n.tr(""Localizable"", ""registration.verify_phone_number.resend_placeholder"", p1)
        }",0,,
"internal static func knowsTwo(_ p1: Any, _ p2: Any) -> String {
          return L10n.tr(""Localizable"", ""peoplepicker.suggested.knows_two"", String(describing: p1), String(describing: p2))
        }",0,,
"internal static func newUserDevice(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""voice.degradation.new_user_device"", String(describing: p1))
        }",0,,
"    private func checkIfVerificationLevelChanged(removedUsers: Set<ZMUser>) {
        self.increaseSecurityLevelIfNeededAfterRemoving(users: removedUsers)
    }",0,,
"    private func updateFloatingVideo(with state: VideoStream?) {
        // No stream, remove floating video if there is any.
        guard let state = state else {
            Log.calling.debug(""Removing self video from floating preview"")
            return thumbnailViewController.removeCurrentThumbnailContentView()
        }

        // We only support the self preview in the floating overlay.
        guard state.stream.streamId == ZMUser.selfUser()?.selfStreamId else {
            return Log.calling.error(""Invalid operation: Non self preview in overlay"")
        }

        // We have a stream but don't have a preview view yet.
        if nil == thumbnailViewController.contentView, let previewView = selfPreviewView {
            Log.calling.debug(""Adding self video to floating preview"")
            thumbnailViewController.setThumbnailContentView(previewView, contentSize: .previewSize(for: traitCollection))
        }
    }",0,,
"  func channelInactive(context: ChannelHandlerContext) {
    self.perform(operations: self.stateMachine.channelInactive())
    self.scheduledPing?.cancel()
    self.scheduledClose?.cancel()
    self.scheduledPing = nil
    self.scheduledClose = nil
    context.fireChannelInactive()
  }",0,,
"        super.init(nibName: nil, bundle: nil)

        setupViews()
        createConstraints()
        updateState()
        displayIndicatorViewsIfNeeded()
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError(""init(coder:) has not been implemented"")
    }",0,,
"    private func updateLegalHoldIfNeededWithHint(from message: GenericMessage, timestamp: Date) {
        switch message.legalHoldStatus {
        case .enabled where !legalHoldStatus.denotesEnabledComplianceDevice:
            needsToVerifyLegalHold = true
            legalHoldStatus = .pendingApproval
            appendLegalHoldEnabledSystemMessageForConversationAfterReceivingMessage(at: timestamp)
            expireAllPendingMessagesBecauseOfSecurityLevelDegradation()
        case .disabled where legalHoldStatus.denotesEnabledComplianceDevice:
            needsToVerifyLegalHold = true
            legalHoldStatus = .disabled
            appendLegalHoldDisabledSystemMessageForConversationAfterReceivingMessage(at: timestamp)
        default:
            break
        }
    }",0,,
"internal static func domainUnvailable(_ p1: Any) -> String {
          return L10n.tr(""Localizable"", ""peoplepicker.federation.domain_unvailable"", String(describing: p1))
        }",0,,
"    private func presentAlertForDeletedAccountIfNeeded(_ error: NSError?) {
        guard
            error?.userSessionErrorCode == .accountDeleted,
            let reason = error?.userInfo[ZMAccountDeletedReasonKey] as? ZMAccountDeletedReason
        else {
            return
        }

        switch reason {
        case .sessionExpired:
            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,
                                                        message: ""account_deleted_session_expired_alert.message"".localized)

        case .databaseWiped:
            let wipeCompletionViewController = WipeCompletionViewController()
            wipeCompletionViewController.modalPresentationStyle = .fullScreen
            rootViewController.present(wipeCompletionViewController, animated: true)

        default:
            break
        }
    }",1,"10,11","            rootViewController.presentAlertWithOKButton(title: ""account_deleted_session_expired_alert.title"".localized,/~/                                                        message: ""account_deleted_session_expired_alert.message"".localized)"
"private func dequeueWrite(_ data: Data, code: OpCode, writeCompletion: (() -> ())? = nil) {
        let operation = BlockOperation()
        operation.addExecutionBlock { [weak self, weak operation] in
            //stream isn't ready, let's wait
            guard let s = self else { return }
            guard let sOperation = operation else { return }
            var offset = 2
            let dataLength = data.count
            let frame = NSMutableData(capacity: dataLength + s.MaxFrameSize)
            let buffer = UnsafeMutableRawPointer(frame!.mutableBytes).assumingMemoryBound(to: UInt8.self)
            buffer[0] = s.FinMask | code.rawValue
            if dataLength < 126 {
                buffer[1] = CUnsignedChar(dataLength)
            } else if dataLength <= Int(UInt16.max) {
                buffer[1] = 126
                WebSocket.writeUint16(buffer, offset: offset, value: UInt16(dataLength))
                offset += MemoryLayout<UInt16>.size
            } else {
                buffer[1] = 127
                WebSocket.writeUint64(buffer, offset: offset, value: UInt64(dataLength))
                offset += MemoryLayout<UInt64>.size
            }
            buffer[1] |= s.MaskMask
            let maskKey = UnsafeMutablePointer<UInt8>(buffer + offset)
            _ = SecRandomCopyBytes(kSecRandomDefault, Int(MemoryLayout<UInt32>.size), maskKey)
            offset += MemoryLayout<UInt32>.size
            
            for i in 0..<dataLength {
                buffer[offset] = data[i] ^ maskKey[i % MemoryLayout<UInt32>.size]
                offset += 1
            }
            var total = 0
            while !sOperation.isCancelled {
                guard let outStream = s.outputStream else { break }
                let writeBuffer = UnsafeRawPointer(frame!.bytes+total).assumingMemoryBound(to: UInt8.self)
                let len = outStream.write(writeBuffer, maxLength: offset-total)
                if len < 0 {
                    var error: Error?
                    if let streamError = outStream.streamError {
                        error = streamError
                    } else {
                        let errCode = InternalErrorCode.outputStreamWriteError.rawValue
                        error = s.errorWithDetail(""output stream error during write"", code: errCode)
                    }
                    s.doDisconnect(error as NSError?)
                    break
                } else {
                    total += len
                }
                if total >= offset {
                    if let queue = self?.callbackQueue, let callback = writeCompletion {
                        queue.async {
                            callback()
                        }
                    }

                    break
                }
            }
        }
        writeQueue.addOperation(operation)
    }",0,,
"    private(set) var colors: [AnyHashable: Any]?

    var variant: ColorSchemeVariant = .light

    private(set) var defaultColorScheme: ColorScheme?
    var accentColor: UIColor = .red

    var keyboardAppearance: UIKeyboardAppearance {
        return ColorScheme.keyboardAppearance(for: variant)
    }",0,,
"internal static func count(_ p1: Int) -> String {
          return L10n.tr(""Localizable"", ""participants.people.count"", p1)
        }",0,,
"    private func isMaximized(stream: Stream?) -> Bool {
        guard
            let streamId = stream?.streamId,
            let maximizedStreamId = maximizedView?.stream.streamId
        else { return false }
        
        return streamId == maximizedStreamId
    }",0,,
"    private func configureSelfUserProviderIfNeeded(for appState: AppState) {
        guard AppDelegate.shared.shouldConfigureSelfUserProvider else { return }

        if case .authenticated = appState {
            SelfUser.provider = ZMUserSession.shared()
        }
    }",0,,
"self.stateMachine = .init(role: .server, logger: logger)
    self.idleTimeout = idleTimeout
    self.pingHandler = PingHandler(
      pingCode: 10,
      interval: configuration.interval,
      timeout: configuration.timeout,
      permitWithoutCalls: configuration.permitWithoutCalls,
      maximumPingsWithoutData: configuration.maximumPingsWithoutData,
      minimumSentPingIntervalWithoutData: configuration.minimumSentPingIntervalWithoutData,
      minimumReceivedPingIntervalWithoutData: configuration.minimumReceivedPingIntervalWithoutData,
      maximumPingStrikes: configuration.maximumPingStrikes
    )
  }

  private func sendGoAway(lastStreamID streamID: HTTP2StreamID) {
    guard let context = self.context else {
      return
    }

    let frame = HTTP2Frame(
      streamID: .rootStream,
      payload: .goAway(lastStreamID: streamID, errorCode: .noError, opaqueData: nil)
    )

    context.writeAndFlush(self.wrapOutboundOut(frame), promise: nil)
  }",0,,
"private func processOneRawMessage(inBuffer buffer: UnsafeBufferPointer<UInt8>) -> UnsafeBufferPointer<UInt8> {
        let response = readStack.last
        guard let baseAddress = buffer.baseAddress else {return emptyBuffer}
        let bufferLen = buffer.count
        if response != nil && bufferLen < 2 {
            fragBuffer = Data(buffer: buffer)
            return emptyBuffer
        }
        if let response = response, response.bytesLeft > 0 {
            var len = response.bytesLeft
            var extra = bufferLen - response.bytesLeft
            if response.bytesLeft > bufferLen {
                len = bufferLen
                extra = 0
            }
            response.bytesLeft -= len
            response.buffer?.append(Data(bytes: baseAddress, count: len))
            _ = processResponse(response)
            return buffer.fromOffset(bufferLen - extra)
        } else {
            let isFin = (FinMask & baseAddress[0])
            let receivedOpcode = OpCode(rawValue: (OpCodeMask & baseAddress[0]))
            let isMasked = (MaskMask & baseAddress[1])
            let payloadLen = (PayloadLenMask & baseAddress[1])
            var offset = 2
            if (isMasked > 0 || (RSVMask & baseAddress[0]) > 0) && receivedOpcode != .pong {
                let errCode = CloseCode.protocolError.rawValue
                doDisconnect(errorWithDetail(""masked and rsv data is not currently supported"", code: errCode))
                writeError(errCode)
                return emptyBuffer
            }
            let isControlFrame = (receivedOpcode == .connectionClose || receivedOpcode == .ping)
            if !isControlFrame && (receivedOpcode != .binaryFrame && receivedOpcode != .continueFrame &&
                receivedOpcode != .textFrame && receivedOpcode != .pong) {
                    let errCode = CloseCode.protocolError.rawValue
                    doDisconnect(errorWithDetail(""unknown opcode: \(receivedOpcode)"", code: errCode))
                    writeError(errCode)
                    return emptyBuffer
            }
            if isControlFrame && isFin == 0 {
                let errCode = CloseCode.protocolError.rawValue
                doDisconnect(errorWithDetail(""control frames can't be fragmented"", code: errCode))
                writeError(errCode)
                return emptyBuffer
            }
            var closeCode = CloseCode.normal.rawValue
            if receivedOpcode == .connectionClose {
                if payloadLen == 1 {
                    closeCode = CloseCode.protocolError.rawValue
                } else if payloadLen > 1 {
                    closeCode = WebSocket.readUint16(baseAddress, offset: offset)
                    if closeCode < 1000 || (closeCode > 1003 && closeCode < 1007) || (closeCode > 1011 && closeCode < 3000) {
                        closeCode = CloseCode.protocolError.rawValue
                    }
                }
                if payloadLen < 2 {
                    doDisconnect(errorWithDetail(""connection closed by server"", code: closeCode))
                    writeError(closeCode)
                    return emptyBuffer
                }
            } else if isControlFrame && payloadLen > 125 {
                writeError(CloseCode.protocolError.rawValue)
                return emptyBuffer
            }
            var dataLength = UInt64(payloadLen)
            if dataLength == 127 {
                dataLength = WebSocket.readUint64(baseAddress, offset: offset)
                offset += MemoryLayout<UInt64>.size
            } else if dataLength == 126 {
                dataLength = UInt64(WebSocket.readUint16(baseAddress, offset: offset))
                offset += MemoryLayout<UInt16>.size
            }
            if bufferLen < offset || UInt64(bufferLen - offset) < dataLength {
                fragBuffer = Data(bytes: baseAddress, count: bufferLen)
                return emptyBuffer
            }
            var len = dataLength
            if dataLength > UInt64(bufferLen) {
                len = UInt64(bufferLen-offset)
            }
            let data: Data
            if len < 0 {
                len = 0
                data = Data()
            } else {
                if receivedOpcode == .connectionClose && len > 0 {
                    let size = MemoryLayout<UInt16>.size
                    offset += size
                    len -= UInt64(size)
                }
                data = Data(bytes: baseAddress+offset, count: Int(len))
            }
            if receivedOpcode == .connectionClose {
                var closeReason = ""connection closed by server""
                if let customCloseReason = String(data: data, encoding: .utf8) {
                    closeReason = customCloseReason
                } else {
                    closeCode = CloseCode.protocolError.rawValue
                }
                doDisconnect(errorWithDetail(closeReason, code: closeCode))
                writeError(closeCode)
                return emptyBuffer
            }
            if receivedOpcode == .pong {
                if canDispatch {
                    callbackQueue.async { [weak self] in
                        guard let s = self else { return }
                        let pongData: Data? = data.count > 0 ? data : nil
                        s.onPong?(pongData)
                        s.pongDelegate?.websocketDidReceivePong(socket: s, data: pongData)
                    }
                }
                return buffer.fromOffset(offset + Int(len))
            }
            var response = readStack.last
            if isControlFrame {
                response = nil // Don't append pings.
            }
            if isFin == 0 && receivedOpcode == .continueFrame && response == nil {
                let errCode = CloseCode.protocolError.rawValue
                doDisconnect(errorWithDetail(""continue frame before a binary or text frame"", code: errCode))
                writeError(errCode)
                return emptyBuffer
            }
            var isNew = false
            if response == nil {
                if receivedOpcode == .continueFrame {
                    let errCode = CloseCode.protocolError.rawValue
                    doDisconnect(errorWithDetail(""first frame can't be a continue frame"",
                        code: errCode))
                    writeError(errCode)
                    return emptyBuffer
                }
                isNew = true
                response = WSResponse()
                response!.code = receivedOpcode!
                response!.bytesLeft = Int(dataLength)
                response!.buffer = NSMutableData(data: data)
            } else {
                if receivedOpcode == .continueFrame {
                    response!.bytesLeft = Int(dataLength)
                } else {
                    let errCode = CloseCode.protocolError.rawValue
                    doDisconnect(errorWithDetail(""second and beyond of fragment message must be a continue frame"",
                        code: errCode))
                    writeError(errCode)
                    return emptyBuffer
                }
                response!.buffer!.append(data)
            }
            if let response = response {
                response.bytesLeft -= Int(len)
                response.frameCount += 1
                response.isFin = isFin > 0 ? true : false
                if isNew {
                    readStack.append(response)
                }
                _ = processResponse(response)
            }

            let step = Int(offset + numericCast(len))
            return buffer.fromOffset(step)
        }
    }",0,,
"internal static func lockDescription(_ p1: Any) -> String {
                return L10n.tr(""Localizable"", ""self.settings.privacy_security.lock_app.subtitle.lock_description"", String(describing: p1))
              }",0,,
"fileprivate mutating func streamClosed(_ streamID: HTTP2StreamID, logger: Logger) {
    self.openStreams -= 1

    logger.debug(""HTTP2 stream closed"", metadata: [
      MetadataKey.h2StreamID: ""\(streamID)"",
      MetadataKey.h2ActiveStreams: ""\(self.openStreams)"",
    ])
  }",0,,
"internal static func onTwitter(_ p1: Any) -> String {
        return L10n.tr(""Localizable"", ""twitter_status.on_twitter"", String(describing: p1))
      }",0,,
"private func dequeueInput() {
        while !inputQueue.isEmpty {
            autoreleasepool {
                let data = inputQueue[0]
                var work = data
                if let buffer = fragBuffer {
                    var combine = NSData(data: buffer) as Data
                    combine.append(data)
                    work = combine
                    fragBuffer = nil
                }
                let buffer = UnsafeRawPointer((work as NSData).bytes).assumingMemoryBound(to: UInt8.self)
                let length = work.count
                if !connected {
                    processTCPHandshake(buffer, bufferLen: length)
                } else {
                    processRawMessagesInBuffer(buffer, bufferLen: length)
                }
                inputQueue = inputQueue.filter{ $0 != data }
            }
        }
    }",0,,
