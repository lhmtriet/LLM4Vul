processed_func,target,flaw_line_index,flaw_line
"override fun onCreate() {
        super.onCreate()

        initRxJavaSettings()

        DP3T.init(
            this,
            ApplicationInfo(packageName, BuildConfig.REPORT_URL, BuildConfig.BUCKET_URL),
            SignatureUtil.getPublicKeyFromBase64OrThrow(BuildConfig.PUBLIC_KEY),
            BuildConfig.DEBUG
        )
        DP3T.setCertificatePinner(certificatePinner)
        DP3T.setUserAgent(userAgent)

        FakeInfectionReportWorker.start(this)

        registerReceiver(ExposureStatusChangeBroadcastReceiver(), DP3T.getUpdateIntentFilter())

    }",1,14,        FakeInfectionReportWorker.start(this)
"fun sampleFromStandard(): Double {
            val random = SecureRandom()
            return -ln(1.0 - random.nextDouble())
        }",0,,
"    override fun setInfectionReportDate(date: Date) {
        preferences.edit()
            .putLong(KEY_INFECTION_REPORT_DATE, date.time)
            .apply()
    }",0,,
"    private inline fun <T> maybeCallOnContent(blockOnType: () -> T, blockOnContent: YamlInput.() -> T): T {
        return when (currentField) {
            CurrentField.NotStarted, CurrentField.Type -> blockOnType()
            CurrentField.Content -> contentDecoder.blockOnContent()
        }
    }",0,,
"private fun start(
            context: Context,
            tDummy: Long,
            existingWorkPolicy: ExistingWorkPolicy
        ) {

            val now = clock.currentTimeMillis()
            val executionDelay = 0L.coerceAtLeast(tDummy - now)
            val executionDelayDays =
                executionDelay / FACTOR_DAY_MILLIS

            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
            val work =
                OneTimeWorkRequest
                    .Builder(FakeInfectionReportWorker::class.java)
                    .setInitialDelay(executionDelayDays, TimeUnit.MINUTES)
                    .setConstraints(constraints)
                    .setInputData(Data.Builder().putLong(KEY_T_DUMMY, tDummy).build())
                    .build()
            WorkManager.getInstance(context)
                .enqueueUniqueWork(TAG, existingWorkPolicy, work)
        }",1,17,"                    .setInitialDelay(executionDelayDays, TimeUnit.MINUTES)"
"private fun throwUnknownProperty(name: String, path: YamlPath, desc: SerialDescriptor): Nothing {
        val knownPropertyNames = (0 until desc.elementsCount)
            .map { desc.getElementName(it) }
            .toSet()

        throw UnknownPropertyException(name, knownPropertyNames, path)
    }",0,,
"    override fun getCurrentPath(): YamlPath = node.path
}",0,,
"fun start(context: Context, preferencesRepository: PreferencesRepository) {
            var tDummy: Long = preferencesRepository.getTDummy()
            if (tDummy == -1L) {
                tDummy = clock.currentTimeMillis() + clock.syncInterval()
                preferencesRepository.setTDummy(tDummy)
            }
            start(context, tDummy, ExistingWorkPolicy.KEEP)
        }",0,,
"    fun write(baseline: Baseline, path: Path) {
        try {
            Files.newBufferedWriter(path).addFinalNewLine().use {
                it.streamXml().prettyPrinter().save(baseline)
            }
        } catch (error: XMLStreamException) {
            val (line, column) = error.positions
            throw InvalidState(""Error on position $line:$column while writing the baseline xml file!"", error)
        }
    }",0,,
"override fun doWork(): Result {
        val now = clock.currentTimeMillis()
        var tDummy = inputData.getLong(KEY_T_DUMMY, now)
        while (tDummy < now) {
            if (tDummy >= now - FACTOR_HOUR_MILLIS * MAX_DELAY_HOURS) {
                if (BuildConfig.DEBUG)
                    DP3T.addWorkerStartedToHistory(applicationContext, TAG)
                reportFakeInfectionUseCase.reportFakeInfection().subscribe()
            }
            tDummy += clock.syncInterval();
            preferencesRepository.setTDummy(tDummy)
        }

        start(applicationContext, tDummy, ExistingWorkPolicy.APPEND)
        return Result.success()
    }",0,,
"fun start(context: Context, preferencesRepository: PreferencesRepository) {
            var tDummy: Long = preferencesRepository.getTDummy()
            if (tDummy == -1L) {
                tDummy = clock.currentTimeMillis() + clock.syncInterval()
                preferencesRepository.setTDummy(tDummy)
            }
            start(context, tDummy, ExistingWorkPolicy.KEEP)
        }",0,,
"    private fun initRxJavaSettings() {
        RxJavaPlugins.setErrorHandler {
            if (BuildConfig.DEBUG)
                it.printStackTrace()
        }
    }",0,,
"        fun start(context: Context) {
            start(context, getRandomDelay(), ExistingWorkPolicy.KEEP)
        }",1,"0,1","        fun start(context: Context) {/~/            start(context, getRandomDelay(), ExistingWorkPolicy.KEEP)"
"    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {
        if (haveStartedReadingEntries) {
            return fromCurrentValue { beginStructure(descriptor) }
        }

        return super.beginStructure(descriptor)
    }",0,,
"    override fun <T> decodeSerializableValue(deserializer: DeserializationStrategy<T>): T {
        try {
            return super.decodeSerializableValue(deserializer)
        } catch (e: SerializationException) {
            throwIfMissingRequiredPropertyException(e)

            throw e
        }
    }",0,,
"fun sampleFromStandard(): Double {
            val random = SecureRandom()
            return -ln(1.0 - random.nextDouble())
        }",0,,
"    override fun decodeNotNullMark(): Boolean {
        if (!haveStartedReadingElements) {
            return true
        }

        return currentElementDecoder.decodeNotNullMark()
    }",0,,
"override fun getHealingTime(): HealingTime {
        val healingTimeJson = preferences.getString(
            KEY_HEALING_TIME,
            ""{\n"" +
                    ""        \""exposureHighMinutes\"": 20160,\n"" +
                    ""        \""infectedMinutes\"": 43200\n"" +
                    ""    }""
        )
        return Gson().fromJson(healingTimeJson, HealingTime::class.java)
    }",0,,
