processed_func,target,flaw_line_index,flaw_line
"            override fun <Base : Any, Sub : Base> polymorphic(baseClass: KClass<Base>, actualClass: KClass<Sub>, actualSerializer: KSerializer<Sub>) {
                if (baseClass.simpleName == className) {
                    knownTypes.add(actualSerializer.descriptor.serialName)
                }
            }",0,,
"    override fun exampleRequest(): Either<Throwable, String> = callService {
        apiInterface.test()
    }

}",1,"0,1,2,3,4","    override fun exampleRequest(): Either<Throwable, String> = callService {/~/        apiInterface.test()/~/    }/~//~/}"
"private fun start(
            context: Context,
            tDummy: Long,
            existingWorkPolicy: ExistingWorkPolicy
        ) {

            val now = clock.currentTimeMillis()
            val executionDelay = 0L.coerceAtLeast(tDummy - now)
            val executionDelayDays =
                executionDelay / FACTOR_DAY_MILLIS

            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
            val work =
                OneTimeWorkRequest
                    .Builder(FakeInfectionReportWorker::class.java)
                    .setInitialDelay(executionDelayDays, TimeUnit.MILLISECONDS)
                    .setConstraints(constraints)
                    .setInputData(Data.Builder().putLong(KEY_T_DUMMY, tDummy).build())
                    .build()
            WorkManager.getInstance(context)
                .enqueueUniqueWork(TAG, existingWorkPolicy, work)
        }",1,"8,9,17","            val executionDelayDays =/~/                executionDelay / FACTOR_DAY_MILLIS/~/                    .setInitialDelay(executionDelayDays, TimeUnit.MILLISECONDS)"
"    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {
        if (haveStartedReadingElements) {
            return currentElementDecoder
        }

        return super.beginStructure(descriptor)
    }",0,,
"private fun throwUnknownProperty(name: String, path: YamlPath, desc: SerialDescriptor): Nothing {
        val knownPropertyNames = (0 until desc.elementsCount)
            .map { desc.getElementName(it) }
            .toSet()

        throw UnknownPropertyException(name, knownPropertyNames, path)
    }",0,,
"        override fun currentTimeMillis(): Long {
            return System.currentTimeMillis()
        }",0,,
"override fun checkClientTrusted(
                                    chain: Array<X509Certificate>,
                                    authType: String
                            ) {
                            }",1,"0,1,2,3,4","override fun checkClientTrusted(/~/                                    chain: Array<X509Certificate>,/~/                                    authType: String/~/                            ) {/~/                            }"
"    protected fun <T> fromCurrentValue(action: YamlInput.() -> T): T {
        try {
            return action(currentValueDecoder)
        } catch (e: YamlException) {
            if (currentlyReadingValue) {
                throw InvalidPropertyValueException(propertyName, e.message, e.path, e)
            } else {
                throw e
            }
        }
    }",0,,
"override fun doWork(): Result {
        val now = clock.currentTimeMillis()
        var tDummy = inputData.getLong(KEY_T_DUMMY, now)
        while (tDummy < now) {
            // only do request if it was planned to do in the last 48h
            if (tDummy >= now - FACTOR_HOUR_MILLIS * MAX_DELAY_HOURS) {
                if (BuildConfig.DEBUG)
                    DP3T.addWorkerStartedToHistory(applicationContext, TAG)
                reportFakeInfectionUseCase.reportFakeInfection().subscribe()
            }
            tDummy += clock.syncInterval();
            preferencesRepository.setTDummy(tDummy)
        }

        start(applicationContext, tDummy, ExistingWorkPolicy.APPEND)
        return Result.success()
    }",1,14,"        start(applicationContext, tDummy, ExistingWorkPolicy.APPEND)"
"    fun read(path: Path): Baseline {
        try {
            Files.newInputStream(path).use {
                val reader = SAXParserFactory.newInstance().newSAXParser()
                val handler = BaselineHandler()
                reader.parse(it, handler)
                return handler.createBaseline()
            }
        } catch (error: SAXParseException) {
            val (line, column) = error.lineNumber to error.columnNumber
            throw InvalidState(""Error on position $line:$column while reading the baseline xml file!"", error)
        }
    }",1,3,                val reader = SAXParserFactory.newInstance().newSAXParser()
"        fun start(context: Context) {
            start(context, getRandomDelay(), ExistingWorkPolicy.KEEP)
        }",1,"0,1","        fun start(context: Context) {/~/            start(context, getRandomDelay(), ExistingWorkPolicy.KEEP)"
"override fun decodeEnum(enumDescriptor: SerialDescriptor): Int {
        val index = enumDescriptor.getElementIndex(scalar.content)

        if (index != UNKNOWN_NAME) {
            return index
        }

        val choices = (0..enumDescriptor.elementsCount - 1)
            .map { enumDescriptor.getElementName(it) }
            .sorted()
            .joinToString("", "")

        throw YamlScalarFormatException(""Value ${scalar.contentToString()} is not a valid option, permitted choices are: $choices"", scalar.path, scalar.content)
    }",0,,
"override fun doWork(): Result {
        val now = clock.currentTimeMillis()
        var tDummy = inputData.getLong(KEY_T_DUMMY, now)
        while (tDummy < now) {
            if (tDummy >= now - FACTOR_HOUR_MILLIS * MAX_DELAY_HOURS) {
                if (BuildConfig.DEBUG)
                    DP3T.addWorkerStartedToHistory(applicationContext, TAG)
                reportFakeInfectionUseCase.reportFakeInfection().subscribe()
            }
            tDummy += clock.syncInterval();
            preferencesRepository.setTDummy(tDummy)
        }

        start(applicationContext, tDummy, ExistingWorkPolicy.APPEND)
        return Result.success()
    }",0,,
"override fun getAcceptedIssuers(): Array<X509Certificate?> {
                                return arrayOfNulls(0)
                            }",1,"0,1,2",override fun getAcceptedIssuers(): Array<X509Certificate?> {/~/                                return arrayOfNulls(0)/~/                            }
"    override fun getCurrentPath(): YamlPath {
        return if (haveStartedReadingEntries) {
            currentValueDecoder.node.path
        } else {
            node.path
        }
    }",0,,
"override fun checkServerTrusted(
                                    chain: Array<X509Certificate>,
                                    authType: String
                            ) {
                            }",1,"0,1,2,3,4","override fun checkServerTrusted(/~/                                    chain: Array<X509Certificate>,/~/                                    authType: String/~/                            ) {/~/                            }"
"    override fun <T> decodeSerializableValue(deserializer: DeserializationStrategy<T>): T {
        try {
            return super.decodeSerializableValue(deserializer)
        } catch (e: SerializationException) {
            throwIfUnknownPolymorphicTypeException(e, deserializer)

            throw e
        }
    }",0,,
"private fun start(
            context: Context,
            tDummy: Long,
            existingWorkPolicy: ExistingWorkPolicy
        ) {

            val now = clock.currentTimeMillis()
            val executionDelay = 0L.coerceAtLeast(tDummy - now)
            val executionDelayDays =
                executionDelay / FACTOR_DAY_MILLIS

            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
            val work =
                OneTimeWorkRequest
                    .Builder(FakeInfectionReportWorker::class.java)
                    .setInitialDelay(executionDelayDays, TimeUnit.MINUTES)
                    .setConstraints(constraints)
                    .setInputData(Data.Builder().putLong(KEY_T_DUMMY, tDummy).build())
                    .build()
            WorkManager.getInstance(context)
                .enqueueUniqueWork(TAG, existingWorkPolicy, work)
        }",1,17,"                    .setInitialDelay(executionDelayDays, TimeUnit.MINUTES)"
"fun sampleFromStandard(): Double {
            val random = SecureRandom()
            return -Math.log(1.0 - random.nextDouble())
        }",1,2,return -Math.log(1.0 - random.nextDouble())
"    override fun getCurrentPath(): YamlPath {
        return if (haveStartedReadingElements) {
            currentElementDecoder.node.path
        } else {
            list.path
        }
    }",0,,
