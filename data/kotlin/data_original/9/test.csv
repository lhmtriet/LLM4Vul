processed_func,target
"    fun providesApiRepository(repository: ApiRepositoryImpl): ApiRepository = repository

}",0
"    override fun getRegions(): List<Region> {
        val itemType = object : TypeToken<List<Region>>() {}.type
        return Gson().fromJson(
            preferences.getString(
                KEY_REGIONS, ""[]""
            ),
            itemType
        )
    }",0
"    override fun getSelectedLanguage(): String =
        preferences.getString(KEY_CURRENT_LANGUAGE, ""es-ES"") ?: ""es-ES""

    override fun setLabels(labels: Map<String, String>) {
        preferences.edit()
            .putString(KEY_LABELS, labels.toJson())
            .apply()
    }

    override fun getLabels(): Map<String, String> {
        val itemType = object : TypeToken<HashMap<String, String>>() {}.type
        return Gson().fromJson(
            preferences.getString(
                KEY_LABELS, ""{\""test\"":\""Hola Label\""}""
            ),
            itemType
        )
    }

    override fun setLanguages(languages: List<Language>) {
        preferences.edit()
            .putString(KEY_LANGUAGES, languages.toJson())
            .apply()
    }

    override fun getLanguages(): List<Language> {
        val itemType = object : TypeToken<List<Language>>() {}.type
        return Gson().fromJson(
            preferences.getString(
                KEY_LANGUAGES, ""[]""
            ),
            itemType
        )
    }

    override fun setRegions(regions: List<Region>) {
        preferences.edit()
            .putString(KEY_REGIONS, regions.toJson())
            .apply()
    }

    override fun getRegions(): List<Region> {
        val itemType = object : TypeToken<List<Region>>() {}.type
        return Gson().fromJson(
            preferences.getString(
                KEY_REGIONS, ""[]""
            ),
            itemType
        )
    }

    override fun setHealingTime(healingTime: HealingTime) {
        preferences.edit()
            .putString(KEY_HEALING_TIME, healingTime.toJson())
            .apply()
    }

    override fun getHealingTime(): HealingTime {
        val healingTimeJson = preferences.getString(
            KEY_HEALING_TIME,
            ""{\n"" +
                    ""        \""exposureHighMinutes\"": 20160,\n"" +
                    ""        \""infectedMinutes\"": 43200\n"" +
                    ""    }""
        )
        return Gson().fromJson(healingTimeJson, HealingTime::class.java)
    }

}",1
"        override fun syncInterval(): Long {
            val newDelayDays: Double =
                ExponentialDistribution.sampleFromStandard() / SAMPLING_RATE
            return (newDelayDays * FACTOR_DAY_MILLIS).toLong()
        }",0
"    override fun setSelectedLanguage(language: String) {
        preferences.edit()
            .putString(KEY_CURRENT_LANGUAGE, language)
            .apply()
    }",0
"        override fun syncInterval(): Long {
            val newDelayDays: Double =
                ExponentialDistribution.sampleFromStandard() / SAMPLING_RATE
            return (newDelayDays * FACTOR_DAY_MILLIS).toLong()
        }",0
"        fun sampleFromStandard(): Double {
            val random = SecureRandom()
            return -Math.log(1.0 - random.nextDouble())
        }",0
"    protected fun <T> fromCurrentValue(action: YamlInput.() -> T): T {
        try {
            return action(currentValueDecoder)
        } catch (e: YamlException) {
            if (currentlyReadingValue) {
                throw InvalidPropertyValueException(propertyName, e.message, e.path, e)
            } else {
                throw e
            }
        }
    }",0
"    private fun throwIfMissingRequiredPropertyException(e: SerializationException) {
        val match = missingFieldExceptionMessage.matchEntire(e.message!!) ?: return

        throw MissingRequiredPropertyException(match.groupValues[1], node.path, e)
    }",0
"        override fun syncInterval(): Long {
            val newDelayDays: Double =
                ExponentialDistribution.sampleFromStandard() / SAMPLING_RATE
            return (newDelayDays * FACTOR_DAY_MILLIS).toLong()
        }",0
"        override fun syncInterval(): Long {
            val newDelayDays: Double =
                ExponentialDistribution.sampleFromStandard() / SAMPLING_RATE
            return (newDelayDays * FACTOR_DAY_MILLIS) as Long
        }",1
"    private fun initRxJavaSettings() {
        RxJavaPlugins.setErrorHandler {
            if (BuildConfig.DEBUG)
                it.printStackTrace()
        }
    }",0
"    override fun doWork(): Result {
        if (BuildConfig.DEBUG)
            DP3T.addWorkerStartedToHistory(applicationContext, TAG)
        reportFakeInfectionUseCase.reportFakeInfection().subscribe()
        start(applicationContext, getRandomDelay(), ExistingWorkPolicy.APPEND)
        return Result.success()
    }",1
"    override fun getCurrentLocation(): Location = getCurrentPath().endLocation
}",0
"        fun start(context: Context) {
            start(context, getRandomDelay(), ExistingWorkPolicy.KEEP)
        }",1
"        fun start(context: Context, preferencesRepository: PreferencesRepository) {
            var tDummy: Long = preferencesRepository.getTDummy()
            if (tDummy == -1L) {
                tDummy = clock.currentTimeMillis() + clock.syncInterval()
                preferencesRepository.setTDummy(tDummy)
            }
            start(context, tDummy, ExistingWorkPolicy.KEEP)
        }",0
"        fun sampleFromStandard(): Double {
            val random = SecureRandom()
            return -ln(1.0 - random.nextDouble())
        }",0
"        private fun start(
            context: Context,
            tDummy: Long,
            existingWorkPolicy: ExistingWorkPolicy
        ) {

            val now = clock.currentTimeMillis()
            val executionDelay = 0L.coerceAtLeast(tDummy - now)
            val executionDelayDays =
                executionDelay / FACTOR_DAY_MILLIS

            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
            val work =
                OneTimeWorkRequest
                    .Builder(FakeInfectionReportWorker::class.java)
                    .setInitialDelay(executionDelayDays, TimeUnit.MILLISECONDS)
                    .setConstraints(constraints)
                    .setInputData(Data.Builder().putLong(KEY_T_DUMMY, tDummy).build())
                    .build()
            WorkManager.getInstance(context)
                .enqueueUniqueWork(TAG, existingWorkPolicy, work)
        }",0
"    override fun setLanguages(languages: List<Language>) {
        preferences.edit()
            .putString(KEY_LANGUAGES, languages.toJson())
            .apply()
    }",0
"        private fun getRandomDelay(): Long = Random.nextLong(180, 360)

    }",0
"    override fun setRegions(regions: List<Region>) {
        preferences.edit()
            .putString(KEY_REGIONS, regions.toJson())
            .apply()
    }",0
"        private fun start(
            context: Context,
            tDummy: Long,
            existingWorkPolicy: ExistingWorkPolicy
        ) {

            val now = clock.currentTimeMillis()
            val executionDelay = 0L.coerceAtLeast(tDummy - now)

            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
            val work =
                OneTimeWorkRequest
                    .Builder(FakeInfectionReportWorker::class.java)
                    .setInitialDelay(executionDelay, TimeUnit.MILLISECONDS)
                    .setConstraints(constraints)
                    .setInputData(Data.Builder().putLong(KEY_T_DUMMY, tDummy).build())
                    .build()
            WorkManager.getInstance(context)
                .enqueueUniqueWork(TAG, existingWorkPolicy, work)
        }",0
"        fun sampleFromStandard(): Double {
            val random = SecureRandom()
            return -ln(1.0 - random.nextDouble())
        }",0
"    override fun decodeNotNullMark(): Boolean {
        if (!haveStartedReadingEntries) {
            return true
        }

        return fromCurrentValue { decodeNotNullMark() }
    }",0
