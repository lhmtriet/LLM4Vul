processed_func,target
"    private inline fun <T> maybeCallOnContent(functionName: String, blockOnContent: YamlInput.() -> T): T =
        maybeCallOnContent(blockOnType = { throw UnsupportedOperationException(""Can't call $functionName() on type field"") }, blockOnContent = blockOnContent)

    private inline fun <T> maybeCallOnContent(blockOnType: () -> T, blockOnContent: YamlInput.() -> T): T {
        return when (currentField) {
            CurrentField.NotStarted, CurrentField.Type -> blockOnType()
            CurrentField.Content -> contentDecoder.blockOnContent()
        }
    }

    override fun <T> decodeSerializableValue(deserializer: DeserializationStrategy<T>): T {
        try {
            return super.decodeSerializableValue(deserializer)
        } catch (e: SerializationException) {
            throwIfUnknownPolymorphicTypeException(e, deserializer)

            throw e
        }
    }

    private fun throwIfUnknownPolymorphicTypeException(e: Exception, deserializer: DeserializationStrategy<*>) {
        val message = e.message ?: return
        val match = unknownPolymorphicTypeExceptionMessage.matchEntire(message) ?: return
        val unknownType = match.groupValues[1]
        val className = match.groupValues[2]

        val knownTypes = when (deserializer.descriptor.kind) {
            PolymorphicKind.SEALED -> getKnownTypesForSealedType(deserializer)
            PolymorphicKind.OPEN -> getKnownTypesForOpenType(className)
            else -> throw IllegalArgumentException(""Can't get known types for descriptor of kind ${deserializer.descriptor.kind}"")
        }

        throw UnknownPolymorphicTypeException(unknownType, knownTypes, typeNamePath, e)
    }

    private fun getKnownTypesForSealedType(deserializer: DeserializationStrategy<*>): Set<String> {
        val typesDescriptor = deserializer.descriptor.getElementDescriptor(1)

        return typesDescriptor.elementNames.toSet()
    }

    private fun getKnownTypesForOpenType(className: String): Set<String> {
        val knownTypes = mutableSetOf<String>()

        serializersModule.dumpTo(object : SerializersModuleCollector {
            override fun <T : Any> contextual(kClass: KClass<T>, provider: (typeArgumentsSerializers: List<KSerializer<*>>) -> KSerializer<*>) {}

            
            
            override fun <Base : Any, Sub : Base> polymorphic(baseClass: KClass<Base>, actualClass: KClass<Sub>, actualSerializer: KSerializer<Sub>) {
                if (baseClass.simpleName == className) {
                    knownTypes.add(actualSerializer.descriptor.serialName)
                }
            }

            override fun <Base : Any> polymorphicDefault(baseClass: KClass<Base>, defaultSerializerProvider: (className: String?) -> DeserializationStrategy<out Base>?) {
                throw UnsupportedOperationException(""This method should never be called."")
            }
        })

        return knownTypes
    }

    private enum class CurrentField {
        NotStarted,
        Type,
        Content
    }

    companion object {
        private val unknownPolymorphicTypeExceptionMessage: Regex = """"""^Class '(.*)' is not registered for polymorphic serialization in the scope of '(.*)'.\nMark the base class as 'sealed' or register the serializer explicitly.$"""""".toRegex()
    }
}",0
"    override fun doWork(): Result {
        val now = clock.currentTimeMillis()
        var tDummy = inputData.getLong(KEY_T_DUMMY, now)
        while (tDummy < now) {
            if (tDummy >= now - FACTOR_HOUR_MILLIS * MAX_DELAY_HOURS) {
                if (BuildConfig.DEBUG)
                    DP3T.addWorkerStartedToHistory(applicationContext, TAG)
                reportFakeInfectionUseCase.reportFakeInfection().subscribe()
            }
            tDummy += clock.syncInterval();
            preferencesRepository.setTDummy(tDummy)
        }

        start(applicationContext, tDummy, ExistingWorkPolicy.APPEND)
        return Result.success()
    }",1
"    override fun decodeElementIndex(descriptor: SerialDescriptor): Int = DECODE_DONE
}",0
"        override fun currentTimeMillis(): Long {
            return System.currentTimeMillis()
        }",0
"        fun start(context: Context) {
            start(context, getRandomDelay(), ExistingWorkPolicy.KEEP)
        }",1
"        override fun syncInterval(): Long {
            val newDelayDays: Double =
                ExponentialDistribution.sampleFromStandard() / SAMPLING_RATE
            return (newDelayDays * FACTOR_DAY_MILLIS).toLong()
        }",0
"    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {
        if (haveStartedReadingEntries) {
            return fromCurrentValue { beginStructure(descriptor) }
        }

        return super.beginStructure(descriptor)
    }",0
"        fun start(context: Context, preferencesRepository: PreferencesRepository) {
            var tDummy: Long = preferencesRepository.getTDummy()
            if (tDummy == -1L) {
                tDummy = clock.currentTimeMillis() + clock.syncInterval()
                preferencesRepository.setTDummy(tDummy)
            }
            start(context, tDummy, ExistingWorkPolicy.KEEP)
        }",0
"        override fun currentTimeMillis(): Long {
            return System.currentTimeMillis()
        }",0
"        fun start(context: Context) {
            start(context, getRandomDelay(), ExistingWorkPolicy.KEEP)
        }",0
"        override fun syncInterval(): Long {
            val newDelayDays: Double =
                ExponentialDistribution.sampleFromStandard() / SAMPLING_RATE
            return (newDelayDays * FACTOR_DAY_MILLIS).toLong()
        }",0
"    override fun getCurrentLocation(): Location = getCurrentPath().endLocation
}",0
"                            override fun checkServerTrusted(
                                    chain: Array<X509Certificate>,
                                    authType: String
                            ) {
                            }",1
"    override fun doWork(): Result {
        val now = clock.currentTimeMillis()
        var tDummy = inputData.getLong(KEY_T_DUMMY, now)
        while (tDummy < now) {
            if (tDummy >= now - FACTOR_HOUR_MILLIS * MAX_DELAY_HOURS) {
                if (BuildConfig.DEBUG)
                    DP3T.addWorkerStartedToHistory(applicationContext, TAG)
                reportFakeInfectionUseCase.reportFakeInfection().subscribe()
            }
            tDummy += clock.syncInterval();
            preferencesRepository.setTDummy(tDummy)
        }

        start(applicationContext, tDummy, ExistingWorkPolicy.APPEND)
        return Result.success()
    }",0
"        override fun currentTimeMillis(): Long {
            return System.currentTimeMillis()
        }",0
"    override fun onCreate() {
        super.onCreate()

        initRxJavaSettings()

        DP3T.init(
            this,
            ApplicationInfo(packageName, BuildConfig.REPORT_URL, BuildConfig.BUCKET_URL),
            SignatureUtil.getPublicKeyFromBase64OrThrow(BuildConfig.PUBLIC_KEY),
            BuildConfig.DEBUG
        )
        DP3T.setCertificatePinner(certificatePinner)
        DP3T.setUserAgent(userAgent)

        registerReceiver(ExposureStatusChangeBroadcastReceiver(), DP3T.getUpdateIntentFilter())

    }",1
"    override fun doWork(): Result {
        val now = clock.currentTimeMillis()
        var tDummy = inputData.getLong(KEY_T_DUMMY, now)
        while (tDummy < now) {
            if (tDummy >= now - FACTOR_HOUR_MILLIS * MAX_DELAY_HOURS) {
                if (BuildConfig.DEBUG)
                    DP3T.addWorkerStartedToHistory(applicationContext, TAG)
                reportFakeInfectionUseCase.reportFakeInfection().subscribe()
            }
            tDummy += clock.syncInterval();
            preferencesRepository.setTDummy(tDummy)
        }

        start(applicationContext, tDummy, ExistingWorkPolicy.APPEND)
        return Result.success()
    }",0
"    private fun throwUnknownProperty(name: String, path: YamlPath, desc: SerialDescriptor): Nothing {
        val knownPropertyNames = (0 until desc.elementsCount)
            .map { desc.getElementName(it) }
            .toSet()

        throw UnknownPropertyException(name, knownPropertyNames, path)
    }",0
"    override fun setSelectedLanguage(language: String) {
        preferences.edit()
            .putString(KEY_CURRENT_LANGUAGE, language)
            .apply()
    }",0
"        fun start(context: Context, preferencesRepository: PreferencesRepository) {
            var tDummy: Long = preferencesRepository.getTDummy()
            if (tDummy == -1L) {
                tDummy = clock.currentTimeMillis() + clock.syncInterval()
                preferencesRepository.setTDummy(tDummy)
            }
            start(context, tDummy, ExistingWorkPolicy.KEEP)
        }",0
"    override fun beginStructure(descriptor: SerialDescriptor): CompositeDecoder {
        return when (currentField) {
            CurrentField.NotStarted, CurrentField.Type -> super.beginStructure(descriptor)
            CurrentField.Content -> {
                contentDecoder = createFor(contentNode, serializersModule, configuration, descriptor)

                return contentDecoder
            }
        }
    }",0
"    override fun getTDummy(): Long {
        return preferences.getLong(KEY_T_DUMMY, -1)
    }",0
"        fun sampleFromStandard(): Double {
            val random = SecureRandom()
            return -ln(1.0 - random.nextDouble())
        }",0
"        override fun syncInterval(): Long {
            val newDelayDays: Double =
                ExponentialDistribution.sampleFromStandard() / SAMPLING_RATE
            return (newDelayDays * FACTOR_DAY_MILLIS).toLong()
        }",0
