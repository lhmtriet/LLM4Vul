repo_url,hash,committer,committer_date,merge,filename,programming_language,signature,code,label,before_change,added_only,mod_lines
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,jit.rs,Rust,"round_to_page_size value : usize , page_size : usize","fn round_to_page_size(value: usize, page_size: usize) -> usize {
    (value + page_size - 1) / page_size * page_size
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,jit.rs,Rust,"new pc : usize , code_size : usize","    fn new<E: UserDefinedError>(pc: usize, code_size: usize) -> Result<Self, EbpfError<E>> {
        #[cfg(target_os = ""windows"")]
        {
            Ok(Self {
                page_size: 0,
                pc_section: &mut [],
                text_section: &mut [],
            })
        }
        #[cfg(not(target_os = ""windows""))]
        unsafe {
            let page_size = libc::sysconf(libc::_SC_PAGESIZE) as usize;
            let pc_loc_table_size = round_to_page_size(pc * 8, page_size);
            let over_allocated_code_size = round_to_page_size(code_size, page_size);
            let mut raw: *mut libc::c_void = std::ptr::null_mut();
            libc_error_guard!(mmap, &mut raw, pc_loc_table_size + over_allocated_code_size, libc::PROT_READ | libc::PROT_WRITE, libc::MAP_ANONYMOUS | libc::MAP_PRIVATE, 0, 0);
            Ok(Self {
                page_size,
                pc_section: std::slice::from_raw_parts_mut(raw as *mut u64, pc),
                text_section: std::slice::from_raw_parts_mut(raw.add(pc_loc_table_size) as *mut u8, over_allocated_code_size),
            })
        }
    }",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,jit.rs,Rust,"seal & mut self , text_section_usage : usize","    fn seal<E: UserDefinedError>(&mut self, text_section_usage: usize) -> Result<(), EbpfError<E>> {
        if self.page_size > 0 {
            let raw = self.pc_section.as_ptr() as *mut u8;
            let pc_loc_table_size = round_to_page_size(self.pc_section.len() * 8, self.page_size);
            let over_allocated_code_size = round_to_page_size(self.text_section.len(), self.page_size);
            let code_size = round_to_page_size(text_section_usage, self.page_size);
            #[cfg(not(target_os = ""windows""))]
            unsafe {
                if over_allocated_code_size > code_size {
                    libc_error_guard!(munmap, raw.add(pc_loc_table_size).add(code_size) as *mut _, over_allocated_code_size - code_size);
                }
                std::ptr::write_bytes(raw.add(pc_loc_table_size).add(text_section_usage), 0xcc, code_size - text_section_usage); // Fill with debugger traps
                self.text_section = std::slice::from_raw_parts_mut(raw.add(pc_loc_table_size), text_section_usage);
                libc_error_guard!(mprotect, self.pc_section.as_mut_ptr() as *mut _, pc_loc_table_size, libc::PROT_READ);
                libc_error_guard!(mprotect, self.text_section.as_mut_ptr() as *mut _, code_size, libc::PROT_EXEC | libc::PROT_READ);
            }
        }
        Ok(())
    }",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,jit.rs,Rust,mem_size & self,"    pub fn mem_size(&self) -> usize {
        let pc_loc_table_size = round_to_page_size(self.pc_section.len() * 8, self.page_size);
        let code_size = round_to_page_size(self.text_section.len(), self.page_size);
        pc_loc_table_size + code_size
    }",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,jit.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        let pc_loc_table_size = round_to_page_size(self.pc_section.len() * 8, self.page_size);
        let code_size = round_to_page_size(self.text_section.len(), self.page_size);
        if pc_loc_table_size + code_size > 0 {
            #[cfg(not(target_os = ""windows""))]
            unsafe {
                libc::munmap(self.pc_section.as_ptr() as *mut _, pc_loc_table_size + code_size);
            }
        }
    }",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_sdiv32_neg_imm,"fn test_sdiv32_neg_imm() {
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x10000000c
        sdiv32 r0, -4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() as i64 == -3 } },
        3
    );
}",0,False,True,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_sdiv32_neg_reg,"fn test_sdiv32_neg_reg() {
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x10000000c
        mov r1, -4
        sdiv32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() as i64 == -0x3 } },
        4
    );
}",0,False,True,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mov,"fn test_mov() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r1, 1
        mov32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mov32_imm_large,"fn test_mov32_imm_large() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, -1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xffffffff } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mov_large,"fn test_mov_large() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r1, -1
        mov32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xffffffff } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_bounce,"fn test_bounce() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 1
        mov r6, r0
        mov r7, r6
        mov r8, r7
        mov r9, r8
        mov r0, r9
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_add32,"fn test_add32() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 2
        add32 r0, 1
        add32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3 } },
        5
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_neg32,"fn test_neg32() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 2
        neg32 r0
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xfffffffe } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_neg64,"fn test_neg64() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 2
        neg r0
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xfffffffffffffffe } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_alu32_arithmetic,"fn test_alu32_arithmetic() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 1
        mov32 r2, 2
        mov32 r3, 3
        mov32 r4, 4
        mov32 r5, 5
        mov32 r6, 6
        mov32 r7, 7
        mov32 r8, 8
        mov32 r9, 9
        add32 r0, 23
        add32 r0, r7
        sub32 r0, 13
        sub32 r0, r1
        mul32 r0, 7
        mul32 r0, r3
        div32 r0, 2
        div32 r0, r4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2a } },
        19
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_alu64_arithmetic,"fn test_alu64_arithmetic() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        mov r1, 1
        mov r2, 2
        mov r3, 3
        mov r4, 4
        mov r5, 5
        mov r6, 6
        mov r7, 7
        mov r8, 8
        mov r9, 9
        add r0, 23
        add r0, r7
        sub r0, 13
        sub r0, r1
        mul r0, 7
        mul r0, r3
        div r0, 2
        div r0, r4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2a } },
        19
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mul128,"fn test_mul128() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        mov r2, 30
        mov r3, 0
        mov r4, 20
        mov r5, 0
        mul64 r3, r4
        mul64 r5, r2
        add64 r5, r3
        mov64 r0, r2
        rsh64 r0, 0x20
        mov64 r3, r4
        rsh64 r3, 0x20
        mov64 r6, r3
        mul64 r6, r0
        add64 r5, r6
        lsh64 r4, 0x20
        rsh64 r4, 0x20
        mov64 r6, r4
        mul64 r6, r0
        lsh64 r2, 0x20
        rsh64 r2, 0x20
        mul64 r4, r2
        mov64 r0, r4
        rsh64 r0, 0x20
        add64 r0, r6
        mov64 r6, r0
        rsh64 r6, 0x20
        add64 r5, r6
        mul64 r3, r2
        lsh64 r0, 0x20
        rsh64 r0, 0x20
        add64 r0, r3
        mov64 r2, r0
        rsh64 r2, 0x20
        add64 r5, r2
        stxdw [r1+0x8], r5
        lsh64 r0, 0x20
        lsh64 r4, 0x20
        rsh64 r4, 0x20
        or64 r0, r4
        stxdw [r1+0x0], r0
        exit"",
        [0; 16],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 600 } },
        42
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_alu32_logic,"fn test_alu32_logic() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 1
        mov32 r2, 2
        mov32 r3, 3
        mov32 r4, 4
        mov32 r5, 5
        mov32 r6, 6
        mov32 r7, 7
        mov32 r8, 8
        or32 r0, r5
        or32 r0, 0xa0
        and32 r0, 0xa3
        mov32 r9, 0x91
        and32 r0, r9
        lsh32 r0, 22
        lsh32 r0, r8
        rsh32 r0, 19
        rsh32 r0, r7
        xor32 r0, 0x03
        xor32 r0, r2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11 } },
        21
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_alu64_logic,"fn test_alu64_logic() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        mov r1, 1
        mov r2, 2
        mov r3, 3
        mov r4, 4
        mov r5, 5
        mov r6, 6
        mov r7, 7
        mov r8, 8
        or r0, r5
        or r0, 0xa0
        and r0, 0xa3
        mov r9, 0x91
        and r0, r9
        lsh r0, 32
        lsh r0, 22
        lsh r0, r8
        rsh r0, 32
        rsh r0, 19
        rsh r0, r7
        xor r0, 0x03
        xor r0, r2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11 } },
        23
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_arsh32_high_shift,"fn test_arsh32_high_shift() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 8
        lddw r1, 0x100000001
        arsh32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x4 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_arsh32_imm,"fn test_arsh32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0xf8
        lsh32 r0, 28
        arsh32 r0, 16
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xffff8000 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_arsh32_reg,"fn test_arsh32_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0xf8
        mov32 r1, 16
        lsh32 r0, 28
        arsh32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xffff8000 } },
        5
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_arsh64,"fn test_arsh64() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        lsh r0, 63
        arsh r0, 55
        mov32 r1, 5
        arsh r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xfffffffffffffff8 } },
        6
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_lsh64_reg,"fn test_lsh64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x1
        mov r7, 4
        lsh r0, r7
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x10 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_rhs32_imm,"fn test_rhs32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        xor r0, r0
        sub r0, 1
        rsh32 r0, 8
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x00ffffff } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_rsh64_reg,"fn test_rsh64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x10
        mov r7, 4
        rsh r0, r7
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_be16,"fn test_be16() {
    test_interpreter_and_jit_asm!(
        ""
        ldxh r0, [r1]
        be16 r0
        exit"",
        [0x11, 0x22],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_be16_high,"fn test_be16_high() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1]
        be16 r0
        exit"",
        [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_be32,"fn test_be32() {
    test_interpreter_and_jit_asm!(
        ""
        ldxw r0, [r1]
        be32 r0
        exit"",
        [0x11, 0x22, 0x33, 0x44],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11223344 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_be32_high,"fn test_be32_high() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1]
        be32 r0
        exit"",
        [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11223344 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_be64,"fn test_be64() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1]
        be64 r0
        exit"",
        [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122334455667788 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_le16,"fn test_le16() {
    test_interpreter_and_jit_asm!(
        ""
        ldxh r0, [r1]
        le16 r0
        exit"",
        [0x22, 0x11],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_le16_high,"fn test_le16_high() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1]
        le16 r0
        exit"",
        [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2211 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_le32,"fn test_le32() {
    test_interpreter_and_jit_asm!(
        ""
        ldxw r0, [r1]
        le32 r0
        exit"",
        [0x44, 0x33, 0x22, 0x11],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11223344 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_le32_high,"fn test_le32_high() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1]
        le32 r0
        exit"",
        [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x44332211 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_le64,"fn test_le64() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1]
        le64 r0
        exit"",
        [0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122334455667788 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mul32_imm,"fn test_mul32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 3
        mul32 r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xc } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mul32_reg,"fn test_mul32_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 3
        mov r1, 4
        mul32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xc } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mul32_reg_overflow,"fn test_mul32_reg_overflow() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x40000001
        mov r1, 4
        mul32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x4 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mul64_imm,"fn test_mul64_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x40000001
        mul r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x100000004 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mul64_reg,"fn test_mul64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x40000001
        mov r1, 4
        mul r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x100000004 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_div32_high_divisor,"fn test_div32_high_divisor() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 12
        lddw r1, 0x100000004
        div32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_div32_imm,"fn test_div32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x10000000c
        div32 r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_div32_reg,"fn test_div32_reg() {
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x10000000c
        mov r1, 4
        div32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_sdiv32_imm,"fn test_sdiv32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x10000000c
        sdiv32 r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_sdiv32_reg,"fn test_sdiv32_reg() {
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x10000000c
        mov r1, 4
        sdiv32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_div64_imm,"fn test_div64_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xc
        lsh r0, 32
        div r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x300000000 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_div64_reg,"fn test_div64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xc
        lsh r0, 32
        mov r1, 4
        div r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x300000000 } },
        5
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_sdiv64_imm,"fn test_sdiv64_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xc
        lsh r0, 32
        sdiv r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x300000000 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_sdiv64_reg,"fn test_sdiv64_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xc
        lsh r0, 32
        mov r1, 4
        sdiv r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x300000000 } },
        5
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_div64_by_zero_reg,"fn test_err_div64_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        div r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_div32_by_zero_reg,"fn test_err_div32_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        div32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_sdiv64_by_zero_reg,"fn test_err_sdiv64_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        sdiv r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_sdiv32_by_zero_reg,"fn test_err_sdiv32_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        sdiv32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_sdiv64_overflow_imm,"fn test_err_sdiv64_overflow_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x80
        lsh r0, 56
        sdiv r0, -1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideOverflow(pc) if pc == 31)
        },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_sdiv64_overflow_reg,"fn test_err_sdiv64_overflow_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x80
        lsh r0, 56
        mov r1, -1
        sdiv r0, r1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideOverflow(pc) if pc == 32)
        },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_sdiv32_overflow_imm,"fn test_err_sdiv32_overflow_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x80
        lsh r0, 24
        sdiv32 r0, -1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideOverflow(pc) if pc == 31)
        },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_sdiv32_overflow_reg,"fn test_err_sdiv32_overflow_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x80
        lsh r0, 24
        mov r1, -1
        sdiv32 r0, r1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideOverflow(pc) if pc == 32)
        },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mod32,"fn test_mod32() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 5748
        mod32 r0, 92
        mov32 r1, 13
        mod32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x5 } },
        5
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mod32_imm,"fn test_mod32_imm() {
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x100000003
        mod32 r0, 3
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mod64,"fn test_mod64() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, -1316649930
        lsh r0, 32
        or r0, 0x100dc5c8
        mov32 r1, 0xdde263e
        lsh r1, 32
        or r1, 0x3cbef7f3
        mod r0, r1
        mod r0, 0x658f1778
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x30ba5a04 } },
        9
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_mod64_by_zero_reg,"fn test_err_mod64_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        mod r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_mod_by_zero_reg,"fn test_err_mod_by_zero_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 1
        mov32 r1, 0
        mod32 r0, r1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::DivideByZero(pc) if pc == 31) },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldabsb,"fn test_ldabsb() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsb 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x33 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldabsh,"fn test_ldabsh() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsh 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x4433 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldabsw,"fn test_ldabsw() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsw 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x66554433 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldabsdw,"fn test_ldabsdw() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsdw 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xaa99887766554433 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_ldabsb_oob,"fn test_err_ldabsb_oob() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsb 0x33
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 29 && vm_addr == 0x400000033 && len == 1 && name == ""input""
                )
            }
        },
        1
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_ldabsb_nomem,"fn test_err_ldabsb_nomem() {
    test_interpreter_and_jit_asm!(
        ""
        ldabsb 0x33
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 29 && vm_addr == 0x400000033 && len == 1 && name == ""input""
                )
            }
        },
        1
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldindb,"fn test_ldindb() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x5
        ldindb r1, 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x88 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldindh,"fn test_ldindh() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x5
        ldindh r1, 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x9988 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldindw,"fn test_ldindw() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x4
        ldindw r1, 0x1
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x88776655 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldinddw,"fn test_ldinddw() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x2
        ldinddw r1, 0x3
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xccbbaa9988776655 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_ldindb_oob,"fn test_err_ldindb_oob() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x5
        ldindb r1, 0x33
        exit"",
        [
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, //
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, //
        ],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 30 && vm_addr == 0x400000038 && len == 1 && name == ""input""
                )
            }
        },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_ldindb_nomem,"fn test_err_ldindb_nomem() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x5
        ldindb r1, 0x33
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 30 && vm_addr == 0x400000038 && len == 1 && name == ""input""
                )
            }
        },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldxb,"fn test_ldxb() {
    test_interpreter_and_jit_asm!(
        ""
        ldxb r0, [r1+2]
        exit"",
        [0xaa, 0xbb, 0x11, 0xcc, 0xdd],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldxh,"fn test_ldxh() {
    test_interpreter_and_jit_asm!(
        ""
        ldxh r0, [r1+2]
        exit"",
        [0xaa, 0xbb, 0x11, 0x22, 0xcc, 0xdd],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2211 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldxw,"fn test_ldxw() {
    test_interpreter_and_jit_asm!(
        ""
        ldxw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0x11, 0x22, 0x33, 0x44, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x44332211 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldxh_same_reg,"fn test_ldxh_same_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        sth [r0], 0x1234
        ldxh r0, [r0]
        exit"",
        [0xff, 0xff],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1234 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_lldxdw,"fn test_lldxdw() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, //
            0x77, 0x88, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x8877665544332211 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_ldxdw_oob,"fn test_err_ldxdw_oob() {
    test_interpreter_and_jit_asm!(
        ""
        ldxdw r0, [r1+6]
        exit"",
        [
            0xaa, 0xbb, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, //
            0x77, 0x88, 0xcc, 0xdd, //
        ],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 29 && vm_addr == 0x400000006 && len == 8 && name == ""input""
                )
            }
        },
        1
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldxb_all,"fn test_ldxb_all() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxb r9, [r0+0]
        lsh r9, 0
        ldxb r8, [r0+1]
        lsh r8, 4
        ldxb r7, [r0+2]
        lsh r7, 8
        ldxb r6, [r0+3]
        lsh r6, 12
        ldxb r5, [r0+4]
        lsh r5, 16
        ldxb r4, [r0+5]
        lsh r4, 20
        ldxb r3, [r0+6]
        lsh r3, 24
        ldxb r2, [r0+7]
        lsh r2, 28
        ldxb r1, [r0+8]
        lsh r1, 32
        ldxb r0, [r0+9]
        lsh r0, 36
        or r0, r1
        or r0, r2
        or r0, r3
        or r0, r4
        or r0, r5
        or r0, r6
        or r0, r7
        or r0, r8
        or r0, r9
        exit"",
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, //
            0x08, 0x09, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x9876543210 } },
        31
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldxh_all,"fn test_ldxh_all() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxh r9, [r0+0]
        be16 r9
        lsh r9, 0
        ldxh r8, [r0+2]
        be16 r8
        lsh r8, 4
        ldxh r7, [r0+4]
        be16 r7
        lsh r7, 8
        ldxh r6, [r0+6]
        be16 r6
        lsh r6, 12
        ldxh r5, [r0+8]
        be16 r5
        lsh r5, 16
        ldxh r4, [r0+10]
        be16 r4
        lsh r4, 20
        ldxh r3, [r0+12]
        be16 r3
        lsh r3, 24
        ldxh r2, [r0+14]
        be16 r2
        lsh r2, 28
        ldxh r1, [r0+16]
        be16 r1
        lsh r1, 32
        ldxh r0, [r0+18]
        be16 r0
        lsh r0, 36
        or r0, r1
        or r0, r2
        or r0, r3
        or r0, r4
        or r0, r5
        or r0, r6
        or r0, r7
        or r0, r8
        or r0, r9
        exit"",
        [
            0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, //
            0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, //
            0x00, 0x08, 0x00, 0x09, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x9876543210 } },
        41
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldxh_all2,"fn test_ldxh_all2() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxh r9, [r0+0]
        be16 r9
        ldxh r8, [r0+2]
        be16 r8
        ldxh r7, [r0+4]
        be16 r7
        ldxh r6, [r0+6]
        be16 r6
        ldxh r5, [r0+8]
        be16 r5
        ldxh r4, [r0+10]
        be16 r4
        ldxh r3, [r0+12]
        be16 r3
        ldxh r2, [r0+14]
        be16 r2
        ldxh r1, [r0+16]
        be16 r1
        ldxh r0, [r0+18]
        be16 r0
        or r0, r1
        or r0, r2
        or r0, r3
        or r0, r4
        or r0, r5
        or r0, r6
        or r0, r7
        or r0, r8
        or r0, r9
        exit"",
        [
            0x00, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, //
            0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, //
            0x01, 0x00, 0x02, 0x00, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3ff } },
        31
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ldxw_all,"fn test_ldxw_all() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxw r9, [r0+0]
        be32 r9
        ldxw r8, [r0+4]
        be32 r8
        ldxw r7, [r0+8]
        be32 r7
        ldxw r6, [r0+12]
        be32 r6
        ldxw r5, [r0+16]
        be32 r5
        ldxw r4, [r0+20]
        be32 r4
        ldxw r3, [r0+24]
        be32 r3
        ldxw r2, [r0+28]
        be32 r2
        ldxw r1, [r0+32]
        be32 r1
        ldxw r0, [r0+36]
        be32 r0
        or r0, r1
        or r0, r2
        or r0, r3
        or r0, r4
        or r0, r5
        or r0, r6
        or r0, r7
        or r0, r8
        or r0, r9
        exit"",
        [
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, //
            0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, //
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, //
            0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, //
            0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x030f0f } },
        31
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_lddw,"fn test_lddw() {
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x1122334455667788
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1122334455667788 } },
        2
    );
    test_interpreter_and_jit_asm!(
        ""
        lddw r0, 0x0000000080000000
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x80000000 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stb,"fn test_stb() {
    test_interpreter_and_jit_asm!(
        ""
        stb [r1+2], 0x11
        ldxb r0, [r1+2]
        exit"",
        [0xaa, 0xbb, 0xff, 0xcc, 0xdd],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_sth,"fn test_sth() {
    test_interpreter_and_jit_asm!(
        ""
        sth [r1+2], 0x2211
        ldxh r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2211 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stw,"fn test_stw() {
    test_interpreter_and_jit_asm!(
        ""
        stw [r1+2], 0x44332211
        ldxw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x44332211 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stdw,"fn test_stdw() {
    test_interpreter_and_jit_asm!(
        ""
        stdw [r1+2], 0x44332211
        ldxdw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //
            0xff, 0xff, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x44332211 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stxb,"fn test_stxb() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r2, 0x11
        stxb [r1+2], r2
        ldxb r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x11 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stxh,"fn test_stxh() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r2, 0x2211
        stxh [r1+2], r2
        ldxh r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2211 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stxw,"fn test_stxw() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r2, 0x44332211
        stxw [r1+2], r2
        ldxw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x44332211 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stxdw,"fn test_stxdw() {
    test_interpreter_and_jit_asm!(
        ""
        mov r2, -2005440939
        lsh r2, 32
        or r2, 0x44332211
        stxdw [r1+2], r2
        ldxdw r0, [r1+2]
        exit"",
        [
            0xaa, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //
            0xff, 0xff, 0xcc, 0xdd, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x8877665544332211 } },
        6
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stxb_all,"fn test_stxb_all() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0xf0
        mov r2, 0xf2
        mov r3, 0xf3
        mov r4, 0xf4
        mov r5, 0xf5
        mov r6, 0xf6
        mov r7, 0xf7
        mov r8, 0xf8
        stxb [r1], r0
        stxb [r1+1], r2
        stxb [r1+2], r3
        stxb [r1+3], r4
        stxb [r1+4], r5
        stxb [r1+5], r6
        stxb [r1+6], r7
        stxb [r1+7], r8
        ldxdw r0, [r1]
        be64 r0
        exit"",
        [
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xf0f2f3f4f5f6f7f8 } },
        19
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stxb_all2,"fn test_stxb_all2() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        mov r1, 0xf1
        mov r9, 0xf9
        stxb [r0], r1
        stxb [r0+1], r9
        ldxh r0, [r0]
        be16 r0
        exit"",
        [0xff, 0xff],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xf1f9 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stxb_chain,"fn test_stxb_chain() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, r1
        ldxb r9, [r0+0]
        stxb [r0+1], r9
        ldxb r8, [r0+1]
        stxb [r0+2], r8
        ldxb r7, [r0+2]
        stxb [r0+3], r7
        ldxb r6, [r0+3]
        stxb [r0+4], r6
        ldxb r5, [r0+4]
        stxb [r0+5], r5
        ldxb r4, [r0+5]
        stxb [r0+6], r4
        ldxb r3, [r0+6]
        stxb [r0+7], r3
        ldxb r2, [r0+7]
        stxb [r0+8], r2
        ldxb r1, [r0+8]
        stxb [r0+9], r1
        ldxb r0, [r0+9]
        exit"",
        [
            0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
            0x00, 0x00, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2a } },
        21
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_exit_without_value,"fn test_exit_without_value() {
    test_interpreter_and_jit_asm!(
        ""
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        1
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_exit,"fn test_exit() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_early_exit,"fn test_early_exit() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 3
        exit
        mov r0, 4
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x3 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_ja,"fn test_ja() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 1
        ja +1
        mov r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jeq_imm,"fn test_jeq_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xa
        jeq r1, 0xb, +4
        mov32 r0, 1
        mov32 r1, 0xb
        jeq r1, 0xb, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jeq_reg,"fn test_jeq_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xa
        mov32 r2, 0xb
        jeq r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0xb
        jeq r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jge_imm,"fn test_jge_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xa
        jge r1, 0xb, +4
        mov32 r0, 1
        mov32 r1, 0xc
        jge r1, 0xb, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jge_reg,"fn test_jge_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xa
        mov32 r2, 0xb
        jge r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0xb
        jge r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jle_imm,"fn test_jle_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 5
        jle r1, 4, +1
        jle r1, 6, +1
        exit
        jle r1, 5, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jle_reg,"fn test_jle_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        mov r1, 5
        mov r2, 4
        mov r3, 6
        jle r1, r2, +2
        jle r1, r1, +1
        exit
        jle r1, r3, +1
        exit
        mov r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        9
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jgt_imm,"fn test_jgt_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 5
        jgt r1, 6, +2
        jgt r1, 5, +1
        jgt r1, 4, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jgt_reg,"fn test_jgt_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        mov r1, 5
        mov r2, 6
        mov r3, 4
        jgt r1, r2, +2
        jgt r1, r1, +1
        jgt r1, r3, +1
        exit
        mov r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        9
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jlt_imm,"fn test_jlt_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 5
        jlt r1, 4, +2
        jlt r1, 5, +1
        jlt r1, 6, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jlt_reg,"fn test_jlt_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        mov r1, 5
        mov r2, 4
        mov r3, 6
        jlt r1, r2, +2
        jlt r1, r1, +1
        jlt r1, r3, +1
        exit
        mov r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        9
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jne_imm,"fn test_jne_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xb
        jne r1, 0xb, +4
        mov32 r0, 1
        mov32 r1, 0xa
        jne r1, 0xb, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jne_reg,"fn test_jne_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0xb
        mov32 r2, 0xb
        jne r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0xa
        jne r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jset_imm,"fn test_jset_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0x7
        jset r1, 0x8, +4
        mov32 r0, 1
        mov32 r1, 0x9
        jset r1, 0x8, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jset_reg,"fn test_jset_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov32 r1, 0x7
        mov32 r2, 0x8
        jset r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0x9
        jset r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jsge_imm,"fn test_jsge_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        jsge r1, -1, +5
        jsge r1, 0, +4
        mov32 r0, 1
        mov r1, -1
        jsge r1, -1, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jsge_reg,"fn test_jsge_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        mov r2, -1
        mov32 r3, 0
        jsge r1, r2, +5
        jsge r1, r3, +4
        mov32 r0, 1
        mov r1, r2
        jsge r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        10
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jsle_imm,"fn test_jsle_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        jsle r1, -3, +1
        jsle r1, -1, +1
        exit
        mov32 r0, 1
        jsle r1, -2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jsle_reg,"fn test_jsle_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -1
        mov r2, -2
        mov32 r3, 0
        jsle r1, r2, +1
        jsle r1, r3, +1
        exit
        mov32 r0, 1
        mov r1, r2
        jsle r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        10
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jsgt_imm,"fn test_jsgt_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        jsgt r1, -1, +4
        mov32 r0, 1
        mov32 r1, 0
        jsgt r1, -1, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jsgt_reg,"fn test_jsgt_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        mov r2, -1
        jsgt r1, r2, +4
        mov32 r0, 1
        mov32 r1, 0
        jsgt r1, r2, +1
        mov32 r0, 2
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jslt_imm,"fn test_jslt_imm() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        jslt r1, -3, +2
        jslt r1, -2, +1
        jslt r1, -1, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_jslt_reg,"fn test_jslt_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov32 r0, 0
        mov r1, -2
        mov r2, -3
        mov r3, -1
        jslt r1, r1, +2
        jslt r1, r2, +1
        jslt r1, r3, +1
        exit
        mov32 r0, 1
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        9
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stack1,"fn test_stack1() {
    test_interpreter_and_jit_asm!(
        ""
        mov r1, 51
        stdw [r10-16], 0xab
        stdw [r10-8], 0xcd
        and r1, 1
        lsh r1, 3
        mov r2, r10
        add r2, r1
        ldxdw r0, [r2-16]
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0xcd } },
        9
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stack2,"fn test_stack2() {
    test_interpreter_and_jit_asm!(
        ""
        stb [r10-4], 0x01
        stb [r10-3], 0x02
        stb [r10-2], 0x03
        stb [r10-1], 0x04
        mov r1, r10
        mov r2, 0x4
        sub r1, r2
        syscall BpfMemFrob
        mov r1, 0
        ldxb r2, [r10-4]
        ldxb r3, [r10-3]
        ldxb r4, [r10-2]
        ldxb r5, [r10-1]
        syscall BpfGatherBytes
        xor r0, 0x2a2a2a2a
        exit"",
        [],
        (
            b""BpfMemFrob"" => syscalls::BpfMemFrob::init::<BpfSyscallContext, UserError>; syscalls::BpfMemFrob::call,
            b""BpfGatherBytes"" => syscalls::BpfGatherBytes::init::<BpfSyscallContext, UserError>; syscalls::BpfGatherBytes::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x01020304 } },
        16
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_string_stack,"fn test_string_stack() {
    test_interpreter_and_jit_asm!(
        ""
        mov r1, 0x78636261
        stxw [r10-8], r1
        mov r6, 0x0
        stxb [r10-4], r6
        stxb [r10-12], r6
        mov r1, 0x79636261
        stxw [r10-16], r1
        mov r1, r10
        add r1, -8
        mov r2, r1
        syscall BpfStrCmp
        mov r1, r0
        mov r0, 0x1
        lsh r1, 0x20
        rsh r1, 0x20
        jne r1, 0x0, +11
        mov r1, r10
        add r1, -8
        mov r2, r10
        add r2, -16
        syscall BpfStrCmp
        mov r1, r0
        lsh r1, 0x20
        rsh r1, 0x20
        mov r0, 0x1
        jeq r1, r6, +1
        mov r0, 0x0
        exit"",
        [],
        (
            b""BpfStrCmp"" => syscalls::BpfStrCmp::init::<BpfSyscallContext, UserError>; syscalls::BpfStrCmp::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        28
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_fixed_stack_out_of_bound,"fn test_err_fixed_stack_out_of_bound() {
    let config = Config {
        dynamic_stack_frames: false,
        max_call_depth: 3,
        ..Config::default()
    };
    test_interpreter_and_jit_asm!(
        ""
        stb [r10-0x4000], 0
        exit"",
        config,
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Store && pc == 29 && vm_addr == 0x1FFFFD000 && len == 1 && name == ""program""
                )
            }
        },
        1
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_dynamic_stack_out_of_bound,"fn test_err_dynamic_stack_out_of_bound() {
    let config = Config {
        dynamic_stack_frames: true,
        max_call_depth: 3,
        ..Config::default()
    };

    // The stack goes from MM_STACK_START + config.stack_size() to MM_STACK_START

    // Check that accessing MM_STACK_START - 1 fails
    test_interpreter_and_jit_asm!(
        ""
        stb [r10-0x3001], 0
        exit"",
        config,
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, region)
                    if access_type == AccessType::Store && pc == 29 && vm_addr == ebpf::MM_STACK_START - 1 && len == 1 && region == ""program""
                )
            }
        },
        1
    );

    // Check that accessing MM_STACK_START + expected_stack_len fails
    test_interpreter_and_jit_asm!(
        ""
        stb [r10], 0
        exit"",
        config,
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, region)
                    if access_type == AccessType::Store && pc == 29 && vm_addr == ebpf::MM_STACK_START + config.stack_size() as u64 && len == 1 && region == ""stack""
                )
            }
        },
        1
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_dynamic_stack_ptr_overflow,"fn test_err_dynamic_stack_ptr_overflow() {
    let config = Config {
        dynamic_stack_frames: true,
        ..Config::default()
    };

    // See the comment in CallFrames::resize_stack() for the reason why it's
    // safe to let the stack pointer overflow

    // stack_ptr -= stack_ptr + 1
    test_interpreter_and_jit_asm!(
        ""
        sub r11, 0x7FFFFFFF
        sub r11, 0x7FFFFFFF
        sub r11, 0x7FFFFFFF
        sub r11, 0x7FFFFFFF
        sub r11, 0x14005
        call foo
        exit
        foo:
        stb [r10], 0
        exit"",
        config,
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, region)
                    if access_type == AccessType::Store && pc == 29 + 7 && vm_addr == u64::MAX && len == 1 && region == ""unknown""
                )
            }
        },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_dynamic_stack_frames_empty,"fn test_dynamic_stack_frames_empty() {
    let config = Config {
        dynamic_stack_frames: true,
        ..Config::default()
    };

    // Check that unless explicitly resized the stack doesn't grow
    test_interpreter_and_jit_asm!(
        ""
        call foo
        exit
        foo:
        mov r0, r10
        exit"",
        config,
        [],
        (),
        0,
        { |_vm, res: Result| res.unwrap() == ebpf::MM_STACK_START + config.stack_size() as u64 },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_dynamic_frame_ptr,"fn test_dynamic_frame_ptr() {
    let config = Config {
        dynamic_stack_frames: true,
        ..Config::default()
    };

    // Check that upon entering a function (foo) the frame pointer is advanced
    // to the top of the stack
    test_interpreter_and_jit_asm!(
        ""
        sub r11, 8
        call foo
        exit
        foo:
        mov r0, r10
        exit"",
        config,
        [],
        (),
        0,
        {
            |_vm, res: Result| res.unwrap() == ebpf::MM_STACK_START + config.stack_size() as u64 - 8
        },
        5
    );

    // And check that when exiting a function (foo) the caller's frame pointer
    // is restored
    test_interpreter_and_jit_asm!(
        ""
        sub r11, 8
        call foo
        mov r0, r10
        exit
        foo:
        exit
        "",
        config,
        [],
        (),
        0,
        { |_vm, res: Result| res.unwrap() == ebpf::MM_STACK_START + config.stack_size() as u64 },
        5
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_entrypoint_exit,"fn test_entrypoint_exit() {
    // With fixed frames we used to exit the entrypoint when we reached an exit
    // instruction and the stack size was 1 * config.stack_frame_size, which
    // meant that we were in the entrypoint's frame.  With dynamic frames we
    // can't infer anything from the stack size so we track call depth
    // explicitly. Make sure exit still works with both fixed and dynamic
    // frames.
    for dynamic_stack_frames in [false, true] {
        let config = Config {
            dynamic_stack_frames,
            ..Config::default()
        };

        // This checks that when foo exits we don't stop execution even if the
        // stack is empty (stack size and call depth are decoupled)
        test_interpreter_and_jit_asm!(
            ""
            entrypoint:
            call foo
            mov r0, 42
            exit
            foo:
            mov r0, 12
            exit"",
            config,
            [],
            (),
            0,
            { |_vm, res: Result| { res.unwrap() == 42 } },
            5
        );
    }
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_stack_call_depth_tracking,"fn test_stack_call_depth_tracking() {
    for dynamic_stack_frames in [false, true] {
        let config = Config {
            dynamic_stack_frames,
            max_call_depth: 2,
            ..Config::default()
        };

        // Given max_call_depth=2, make sure that two sibling calls don't
        // trigger CallDepthExceeded. In other words ensure that we correctly
        // pop frames in the interpreter and decrement
        // EnvironmentStackSlot::CallDepth on ebpf::EXIT in the jit.
        test_interpreter_and_jit_asm!(
            ""
            call foo
            call foo
            exit
            foo:
            exit
            "",
            config,
            [],
            (),
            0,
            { |_vm, res: Result| { res.is_ok() } },
            5
        );

        // two nested calls should trigger CallDepthExceeded instead
        test_interpreter_and_jit_asm!(
            ""
            entrypoint:
            call foo
            exit
            foo:
            call bar
            exit
            bar:
            exit
            "",
            config,
            [],
            (),
            0,
            {
                |_vm, res: Result| {
                    matches!(res.unwrap_err(),
                        EbpfError::CallDepthExceeded(pc, depth)
                        if pc == 29 + 2 && depth == config.max_call_depth
                    )
                }
            },
            2
        );
    }
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_mem_access_out_of_bound,"fn test_err_mem_access_out_of_bound() {
    let mem = [0; 512];
    let mut prog = [0; 32];
    prog[0] = ebpf::LD_DW_IMM;
    prog[16] = ebpf::ST_B_IMM;
    prog[24] = ebpf::EXIT;
    for address in [0x2u64, 0x8002u64, 0x80000002u64, 0x8000000000000002u64] {
        LittleEndian::write_u32(&mut prog[4..], address as u32);
        LittleEndian::write_u32(&mut prog[12..], (address >> 32) as u32);
        let config = Config::default();
        let mut bpf_functions = BTreeMap::new();
        let syscall_registry = SyscallRegistry::default();
        register_bpf_function(
            &config,
            &mut bpf_functions,
            &syscall_registry,
            0,
            ""entrypoint"",
        )
        .unwrap();
        #[allow(unused_mut)]
        let mut executable = Executable::<UserError, TestInstructionMeter>::from_text_bytes(
            &prog,
            None,
            config,
            syscall_registry,
            bpf_functions,
        )
        .unwrap();
        test_interpreter_and_jit!(
            executable,
            mem,
            0,
            {
                |_vm, res: Result| {
                    matches!(res.unwrap_err(),
                        EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                        if access_type == AccessType::Store && pc == 31 && vm_addr == address && len == 1 && name == ""unknown""
                    )
                }
            },
            2
        );
    }
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_relative_call,"fn test_relative_call() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/relative_call.so"",
        config,
        [1],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 2 } },
        14
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_bpf_to_bpf_scratch_registers,"fn test_bpf_to_bpf_scratch_registers() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/scratch_registers.so"",
        config,
        [1],
        (
            b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 112 } },
        41
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_bpf_to_bpf_pass_stack_reference,"fn test_bpf_to_bpf_pass_stack_reference() {
    test_interpreter_and_jit_elf!(
        ""tests/elfs/pass_stack_reference.so"",
        [],
        (),
        0,
        { |_vm, res: Result| res.unwrap() == 42 },
        29
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_syscall_parameter_on_stack,"fn test_syscall_parameter_on_stack() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, r10
        add64 r1, -0x100
        mov64 r2, 0x1
        syscall BpfSyscallString
        mov64 r0, 0x0
        exit"",
        [],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        6
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_call_reg,"fn test_call_reg() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r0, 0x0
        mov64 r8, 0x1
        lsh64 r8, 0x20
        or64 r8, 0x30
        callx r8
        exit
        mov64 r0, 0x2A
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 42 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_callx_oob_low,"fn test_err_callx_oob_low() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r0, 0x3
        callx r0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::CallOutsideTextSegment(pc, target_pc)
                    if pc == 30 && target_pc == 0
                )
            }
        },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_callx_oob_high,"fn test_err_callx_oob_high() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r0, -0x1
        lsh64 r0, 0x20
        or64 r0, 0x3
        callx r0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::CallOutsideTextSegment(pc, target_pc)
                    if pc == 32 && target_pc == 0xffffffff00000000
                )
            }
        },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_static_jmp_lddw,"fn test_err_static_jmp_lddw() {
    test_interpreter_and_jit_asm!(
        ""
        ja 2
        mov r0, r0
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 32
                )
            }
        },
        2
    );
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        mov r1, 0
        mov r2, 0
        lddw r0, 0x1
        ja +2
        lddw r1, 0x1
        lddw r2, 0x1
        add r1, r2
        add r0, r1
        exit
        "",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x2 } },
        9
    );
    test_interpreter_and_jit_asm!(
        ""
        jeq r0, 0, 1
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 31
                )
            }
        },
        2
    );
    test_interpreter_and_jit_asm!(
        ""
        call 3
        mov r0, r0
        mov r0, r0
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 33
                )
            }
        },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_dynamic_jmp_lddw,"fn test_err_dynamic_jmp_lddw() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r8, 0x1
        lsh64 r8, 0x20
        or64 r8, 0x28
        callx r8
        lddw r0, 0x1122334455667788
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 34
                )
            }
        },
        5
    );
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x1
        lsh64 r1, 0x20
        or64 r1, 0x38
        callx r1
        mov r0, r0
        mov r0, r0
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 36
                )
            }
        },
        5
    );
    test_interpreter_and_jit_asm!(
        ""
        lddw r1, 0x100000038
        callx r1
        mov r0, r0
        mov r0, r0
        exit
        lddw r0, 0x1122334455667788
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc) if pc == 36
                )
            }
        },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_bpf_to_bpf_depth,"fn test_bpf_to_bpf_depth() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    for i in 0..config.max_call_depth {
        test_interpreter_and_jit_elf!(
            ""tests/elfs/multiple_file.so"",
            config,
            [i as u8],
            (
                b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
            ),
            0,
            { |_vm, res: Result| { res.unwrap() == 0 } },
            if i == 0 { 4 } else { 3 + 10 * i as u64 }
        );
    }
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_bpf_to_bpf_too_deep,"fn test_err_bpf_to_bpf_too_deep() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/multiple_file.so"",
        config,
        [config.max_call_depth as u8],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::CallDepthExceeded(pc, depth)
                    if pc == 55 && depth == config.max_call_depth
                )
            }
        },
        176
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_reg_stack_depth,"fn test_err_reg_stack_depth() {
    let config = Config::default();
    test_interpreter_and_jit_asm!(
        ""
        mov64 r0, 0x1
        lsh64 r0, 0x20
        callx r0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::CallDepthExceeded(pc, depth)
                    if pc == 31 && depth == config.max_call_depth
                )
            }
        },
        60
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_syscall_string,"fn test_err_syscall_string() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x0
        syscall BpfSyscallString
        mov64 r0, 0x0
        exit"",
        [72, 101, 108, 108, 111],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::AccessViolation(pc, access_type, vm_addr, len, name)
                    if access_type == AccessType::Load && pc == 0 && vm_addr == 0 && len == 0 && name == ""unknown""
                )
            }
        },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_syscall_string,"fn test_syscall_string() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r2, 0x5
        syscall BpfSyscallString
        mov64 r0, 0x0
        exit"",
        [72, 101, 108, 108, 111],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_syscall,"fn test_syscall() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0xAA
        mov64 r2, 0xBB
        mov64 r3, 0xCC
        mov64 r4, 0xDD
        mov64 r5, 0xEE
        syscall BpfSyscallU64
        mov64 r0, 0x0
        exit"",
        [],
        (
            b""BpfSyscallU64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_call_gather_bytes,"fn test_call_gather_bytes() {
    test_interpreter_and_jit_asm!(
        ""
        mov r1, 1
        mov r2, 2
        mov r3, 3
        mov r4, 4
        mov r5, 5
        syscall BpfGatherBytes
        exit"",
        [],
        (
            b""BpfGatherBytes"" => syscalls::BpfGatherBytes::init::<BpfSyscallContext, UserError>; syscalls::BpfGatherBytes::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0102030405 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_call_memfrob,"fn test_call_memfrob() {
    test_interpreter_and_jit_asm!(
        ""
        mov r6, r1
        add r1, 2
        mov r2, 4
        syscall BpfMemFrob
        ldxdw r0, [r6]
        be64 r0
        exit"",
        [
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, //
        ],
        (
            b""BpfMemFrob"" => syscalls::BpfMemFrob::init::<BpfSyscallContext, UserError>; syscalls::BpfMemFrob::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x102292e2f2c0708 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_syscall_with_context,"fn test_syscall_with_context() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0xAA
        mov64 r2, 0xBB
        mov64 r3, 0xCC
        mov64 r4, 0xDD
        mov64 r5, 0xEE
        syscall SyscallWithContext
        mov64 r0, 0x0
        exit"",
        [],
        (
            b""SyscallWithContext"" => syscalls::SyscallWithContext::init::< syscalls::BpfSyscallContext, UserError>; syscalls::SyscallWithContext::call
        ),
        42,
        { |vm: &EbpfVm<UserError, TestInstructionMeter>, res: Result| {
            let syscall_context_object = unsafe { &*(vm.get_syscall_context_object(syscalls::SyscallWithContext::call as usize).unwrap() as *const syscalls::SyscallWithContext) };
            assert_eq!(syscall_context_object.context, 84);
            res.unwrap() == 0
        }},
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,init _unused : C,"    pub fn init<C, E>(_unused: C) -> Box<dyn SyscallObject<UserError>> {
        Box::new(Self {})
    }",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,"call & mut self , depth : u64 , throw : u64 , _arg3 : u64 , _arg4 : u64 , _arg5 : u64 , _memory_mapping : & MemoryMapping , result : & mut Result ,","    fn call(
        &mut self,
        depth: u64,
        throw: u64,
        _arg3: u64,
        _arg4: u64,
        _arg5: u64,
        _memory_mapping: &MemoryMapping,
        result: &mut Result,
    ) {
        #[allow(unused_mut)]
        if depth > 0 {
            let mut syscall_registry = SyscallRegistry::default();
            syscall_registry
                .register_syscall_by_name(
                    b""NestedVmSyscall"",
                    NestedVmSyscall::init::<UserContext, UserError>,
                    NestedVmSyscall::call,
                )
                .unwrap();
            let mem = [depth as u8 - 1, throw as u8];
            let mut executable = assemble::<UserError, TestInstructionMeter>(
                ""
                ldabsb 0
                mov64 r1, r0
                ldabsb 1
                mov64 r2, r0
                syscall NestedVmSyscall
                exit"",
                None,
                Config::default(),
                syscall_registry,
            )
            .unwrap();
            test_interpreter_and_jit!(
                executable,
                mem,
                0,
                {
                    |_vm, res: Result| {
                        *result = res;
                        true
                    }
                },
                if throw == 0 { 6 } else { 5 }
            );
        } else {
            *result = if throw == 0 {
                Ok(42)
            } else {
                Err(EbpfError::CallDepthExceeded(33, 0))
            };
        }
    }",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_nested_vm_syscall,"fn test_nested_vm_syscall() {
    let config = Config::default();
    let mut nested_vm_syscall = NestedVmSyscall {};
    let memory_mapping = MemoryMapping::new::<UserError>(vec![], &config).unwrap();
    let mut result = Ok(0);
    nested_vm_syscall.call(1, 0, 0, 0, 0, &memory_mapping, &mut result);
    assert!(result.unwrap() == 42);
    let mut result = Ok(0);
    nested_vm_syscall.call(1, 1, 0, 0, 0, &memory_mapping, &mut result);
    assert!(matches!(result.unwrap_err(),
        EbpfError::CallDepthExceeded(pc, depth)
        if pc == 33 && depth == 0
    ));
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_load_elf,"fn test_load_elf() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/noop.so"",
        config,
        [],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
            b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        11
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_load_elf_empty_noro,"fn test_load_elf_empty_noro() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/noro.so"",
        config,
        [],
        (
            b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_load_elf_empty_rodata,"fn test_load_elf_empty_rodata() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_elf!(
        ""tests/elfs/empty_rodata.so"",
        config,
        [],
        (
            b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        8
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_load_elf_rodata,"fn test_load_elf_rodata() {
    // checks that the program loads the correct rodata offset with both
    // borrowed and owned rodata
    for optimize_rodata in [false, true] {
        let config = Config {
            optimize_rodata,
            ..Config::default()
        };
        test_interpreter_and_jit_elf!(
            ""tests/elfs/rodata.so"",
            config,
            [],
            (),
            0,
            { |_vm, res: Result| { res.unwrap() == 42 } },
            3
        );
    }
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_load_elf_rodata_high_vaddr,"fn test_load_elf_rodata_high_vaddr() {
    test_interpreter_and_jit_elf!(
        ""tests/elfs/rodata_high_vaddr.so"",
        [1],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 42 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_custom_entrypoint,"fn test_custom_entrypoint() {
    let mut file = File::open(""tests/elfs/unresolved_syscall.so"").expect(""file open failed"");
    let mut elf = Vec::new();
    file.read_to_end(&mut elf).unwrap();
    elf[24] = 80; // Move entrypoint to later in the text section
    let config = Config {
        enable_instruction_tracing: true,
        ..Config::default()
    };
    let mut syscall_registry = SyscallRegistry::default();
    test_interpreter_and_jit!(register, syscall_registry, b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call);
    let mut syscall_registry = SyscallRegistry::default();
    test_interpreter_and_jit!(register, syscall_registry, b""log_64"" => syscalls::BpfSyscallU64::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallU64::call);
    #[allow(unused_mut)]
    let mut executable = Executable::<UserError, TestInstructionMeter>::from_elf(
        &elf,
        None,
        config,
        syscall_registry,
    )
    .unwrap();
    test_interpreter_and_jit!(
        executable,
        [],
        syscalls::BpfSyscallContext::default(),
        { |_vm, res: Result| { res.unwrap() == 0 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_tight_infinite_loop_conditional,"fn test_tight_infinite_loop_conditional() {
    test_interpreter_and_jit_asm!(
        ""
        jsge r0, r0, -1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 30 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_tight_infinite_loop_unconditional,"fn test_tight_infinite_loop_unconditional() {
    test_interpreter_and_jit_asm!(
        ""
        ja -1
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 30 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_tight_infinite_recursion,"fn test_tight_infinite_recursion() {
    test_interpreter_and_jit_asm!(
        ""
        entrypoint:
        mov64 r3, 0x41414141
        call entrypoint
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 31 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_tight_infinite_recursion_callx,"fn test_tight_infinite_recursion_callx() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r8, 0x1
        lsh64 r8, 0x20
        or64 r8, 0x18
        mov64 r3, 0x41414141
        callx r8
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 34 && initial_insn_count == 7
                )
            }
        },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_instruction_count_syscall,"fn test_instruction_count_syscall() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r2, 0x5
        syscall BpfSyscallString
        mov64 r0, 0x0
        exit"",
        [72, 101, 108, 108, 111],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_instruction_count_syscall_capped,"fn test_err_instruction_count_syscall_capped() {
    let config = Config {
        static_syscalls: false,
        ..Config::default()
    };
    test_interpreter_and_jit_asm!(
        ""
        mov64 r2, 0x5
        call 0
        mov64 r0, 0x0
        exit"",
        config,
        [72, 101, 108, 108, 111],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 32 && initial_insn_count == 3
                )
            }
        },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_instruction_count_lddw_capped,"fn test_err_instruction_count_lddw_capped() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0
        lddw r1, 0x1
        mov r2, 0
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 32 && initial_insn_count == 2
                )
            }
        },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_non_terminate_early,"fn test_non_terminate_early() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r6, 0x0
        mov64 r1, 0x0
        mov64 r2, 0x0
        mov64 r3, 0x0
        mov64 r4, 0x0
        mov64 r5, r6
        syscall Unresolved
        add64 r6, 0x1
        ja -0x8
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::UnsupportedInstruction(pc)
                    if pc == 35
                )
            }
        },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_non_terminate_capped,"fn test_err_non_terminate_capped() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r6, 0x0
        mov64 r1, 0x0
        mov64 r2, 0x0
        mov64 r3, 0x0
        mov64 r4, 0x0
        mov64 r5, r6
        syscall BpfTracePrintf
        add64 r6, 0x1
        ja -0x8
        exit"",
        [],
        (
            b""BpfTracePrintf"" => syscalls::BpfTracePrintf::init::<BpfSyscallContext, UserError>; syscalls::BpfTracePrintf::call,
        ),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 35 && initial_insn_count == 6
                )
            }
        },
        6
    );
    test_interpreter_and_jit_asm!(
        ""
        mov64 r6, 0x0
        mov64 r1, 0x0
        mov64 r2, 0x0
        mov64 r3, 0x0
        mov64 r4, 0x0
        mov64 r5, r6
        syscall BpfTracePrintf
        add64 r6, 0x1
        ja -0x8
        exit"",
        [],
        (
            b""BpfTracePrintf"" => syscalls::BpfTracePrintf::init::<BpfSyscallContext, UserError>; syscalls::BpfTracePrintf::call,
        ),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 37 && initial_insn_count == 1000
                )
            }
        },
        1000
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_capped_before_exception,"fn test_err_capped_before_exception() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x0
        mov64 r2, 0x0
        add64 r0, 0x0
        add64 r0, 0x0
        div64 r1, r2
        add64 r0, 0x0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 31 && initial_insn_count == 2
                )
            }
        },
        2
    );
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x0
        mov64 r2, 0x0
        add64 r0, 0x0
        add64 r0, 0x0
        syscall Unresolved
        add64 r0, 0x0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count)
                    if pc == 33 && initial_insn_count == 4
                )
            }
        },
        4
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_exit_capped,"fn test_err_exit_capped() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x1
        lsh64 r1, 0x20
        or64 r1, 0x20
        callx r1
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count) if pc == 34 && initial_insn_count == 5
                )
            }
        },
        5
    );
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, 0x1
        lsh64 r1, 0x20
        or64 r1, 0x20
        callx r1
        mov r0, r0
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count) if pc == 35 && initial_insn_count == 6
                )
            }
        },
        6
    );
    test_interpreter_and_jit_asm!(
        ""
        call 0
        mov r0, r0
        exit
        "",
        [],
        (),
        0,
        {
            |_vm, res: Result| {
                matches!(res.unwrap_err(),
                    EbpfError::ExceededMaxInstructions(pc, initial_insn_count) if pc == 32 && initial_insn_count == 3
                )
            }
        },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_symbol_relocation,"fn test_symbol_relocation() {
    test_interpreter_and_jit_asm!(
        ""
        mov64 r1, r10
        sub64 r1, 0x1
        mov64 r2, 0x1
        syscall BpfSyscallString
        mov64 r0, 0x0
        exit"",
        [72, 101, 108, 108, 111],
        (
            b""BpfSyscallString"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        6
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_call_unresolved,"fn test_err_call_unresolved() {
    test_interpreter_and_jit_asm!(
        ""
        mov r1, 1
        mov r2, 2
        mov r3, 3
        mov r4, 4
        mov r5, 5
        syscall Unresolved
        mov64 r0, 0x0
        exit"",
        [],
        (),
        0,
        {
            |_vm, res: Result| matches!(res.unwrap_err(), EbpfError::UnsupportedInstruction(pc) if pc == 34)
        },
        6
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_err_unresolved_elf,"fn test_err_unresolved_elf() {
    let mut syscall_registry = SyscallRegistry::default();
    test_interpreter_and_jit!(register, syscall_registry, b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call);
    let mut file = File::open(""tests/elfs/unresolved_syscall.so"").unwrap();
    let mut elf = Vec::new();
    file.read_to_end(&mut elf).unwrap();
    let config = Config {
        reject_broken_elfs: true,
        ..Config::default()
    };
    assert!(
        matches!(Executable::<UserError, TestInstructionMeter>::from_elf(&elf, None, config, syscall_registry), Err(EbpfError::ElfError(ElfError::UnresolvedSymbol(symbol, pc, offset))) if symbol == ""log_64"" && pc == 550 && offset == 4168)
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_syscall_static,"fn test_syscall_static() {
    test_interpreter_and_jit_elf!(
        ""tests/elfs/syscall_static.so"",
        [],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { res.unwrap() == 0 } },
        5
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_syscall_unknown_static,"fn test_syscall_unknown_static() {
    // Check that unknown static syscalls result in UnsupportedInstruction (or
    // would be UnresolvedSymbol with
    // config.disable_unresolved_symbols_at_runtime=false).
    //
    // See also elf::test::test_static_syscall_disabled for the corresponding
    // check with config.syscalls_static=false.
    test_interpreter_and_jit_elf!(
        ""tests/elfs/syscall_static_unknown.so"",
        [],
        (
            b""log"" => syscalls::BpfSyscallString::init::<BpfSyscallContext, UserError>; syscalls::BpfSyscallString::call,
        ),
        0,
        { |_vm, res: Result| { matches!(res.unwrap_err(), EbpfError::UnsupportedInstruction(29)) } },
        1
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_reloc_64_64,"fn test_reloc_64_64() {
    // Tests the correctness of R_BPF_64_64 relocations. The program returns the
    // address of the entrypoint.
    //   [ 1] .text             PROGBITS        00000000000000e8 0000e8 000018 00  AX  0   0  8
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_64.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0xe8 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_reloc_64_64_high_vaddr,"fn test_reloc_64_64_high_vaddr() {
    // Same as test_reloc_64_64, but with .text already alinged to
    // MM_PROGRAM_START by the linker
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_64_high_vaddr.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_reloc_64_relative,"fn test_reloc_64_relative() {
    // Tests the correctness of R_BPF_64_RELATIVE relocations. The program
    // returns the address of the first .rodata byte.
    //   [ 1] .text             PROGBITS        00000000000000e8 0000e8 000018 00  AX  0   0  8
    //   [ 2] .rodata           PROGBITS        0000000000000100 000100 00000b 01 AMS  0   0  1
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x100 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_reloc_64_relative_high_vaddr,"fn test_reloc_64_relative_high_vaddr() {
    // Same as test_reloc_64_relative, but with .text placed already within
    // MM_PROGRAM_START by the linker
    // [ 1] .text             PROGBITS        0000000100000000 001000 000018 00  AX  0   0  8
    // [ 2] .rodata           PROGBITS        0000000100000018 001018 00000b 01 AMS  0   0  1
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative_high_vaddr.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x18 } },
        2
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_reloc_64_relative_data,"fn test_reloc_64_relative_data() {
    // Tests the correctness of R_BPF_64_RELATIVE relocations in sections other
    // than .text. The program returns the address of the first .rodata byte.
    // [ 1] .text             PROGBITS        00000000000000e8 0000e8 000020 00  AX  0   0  8
    // [ 2] .rodata           PROGBITS        0000000000000108 000108 000019 01 AMS  0   0  1
    //
    // 00000000000001f8 <FILE>:
    // 63:       08 01 00 00 00 00 00 00
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative_data.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x108 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_reloc_64_relative_data_high_vaddr,"fn test_reloc_64_relative_data_high_vaddr() {
    // Same as test_reloc_64_relative_data, but with rodata already placed
    // within MM_PROGRAM_START by the linker
    // [ 1] .text             PROGBITS        0000000100000000 001000 000020 00  AX  0   0  8
    // [ 2] .rodata           PROGBITS        0000000100000020 001020 000019 01 AMS  0   0  1
    //
    // 0000000100000110 <FILE>:
    // 536870946:      20 00 00 00 01 00 00 00
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative_data_high_vaddr.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x20 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_reloc_64_relative_data_pre_sbfv2,"fn test_reloc_64_relative_data_pre_sbfv2() {
    // Before https://github.com/solana-labs/llvm-project/pull/35, we used to
    // generate invalid R_BPF_64_RELATIVE relocations in sections other than
    // .text.
    //
    // This test checks that the old behaviour is maintained for backwards
    // compatibility when dealing with non-sbfv2 files. See also Elf::relocate().
    //
    // The program returns the address of the first .rodata byte.
    // [ 1] .text             PROGBITS        00000000000000e8 0000e8 000020 00  AX  0   0  8
    // [ 2] .rodata           PROGBITS        0000000000000108 000108 000019 01 AMS  0   0  1
    //
    // 00000000000001f8 <FILE>:
    // 63:       00 00 00 00 08 01 00 00
    test_interpreter_and_jit_elf!(
        ""tests/elfs/reloc_64_relative_data_pre_sbfv2.so"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == ebpf::MM_PROGRAM_START + 0x108 } },
        3
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_mul_loop,"fn test_mul_loop() {
    test_interpreter_and_jit_asm!(
        ""
        mov r0, 0x7
        add r1, 0xa
        lsh r1, 0x20
        rsh r1, 0x20
        jeq r1, 0x0, +4
        mov r0, 0x7
        mul r0, 0x7
        add r1, -1
        jne r1, 0x0, -3
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x75db9c97 } },
        37
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_prime,"fn test_prime() {
    test_interpreter_and_jit_asm!(
        ""
        mov r1, 67
        mov r0, 0x1
        mov r2, 0x2
        jgt r1, 0x2, +4
        ja +10
        add r2, 0x1
        mov r0, 0x1
        jge r2, r1, +7
        mov r3, r1
        div r3, r2
        mul r3, r2
        mov r4, r1
        sub r4, r3
        mov r0, 0x0
        jne r4, 0x0, -10
        exit"",
        [],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        655
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_subnet,"fn test_subnet() {
    test_interpreter_and_jit_asm!(
        ""
        mov r2, 0xe
        ldxh r3, [r1+12]
        jne r3, 0x81, +2
        mov r2, 0x12
        ldxh r3, [r1+16]
        and r3, 0xffff
        jne r3, 0x8, +5
        add r1, r2
        mov r0, 0x1
        ldxw r1, [r1+16]
        and r1, 0xffffff
        jeq r1, 0x1a8c0, +1
        mov r0, 0x0
        exit"",
        [
            0x00, 0x00, 0xc0, 0x9f, 0xa0, 0x97, 0x00, 0xa0, //
            0xcc, 0x3b, 0xbf, 0xfa, 0x08, 0x00, 0x45, 0x10, //
            0x00, 0x3c, 0x46, 0x3c, 0x40, 0x00, 0x40, 0x06, //
            0x73, 0x1c, 0xc0, 0xa8, 0x01, 0x02, 0xc0, 0xa8, //
            0x01, 0x01, 0x06, 0x0e, 0x00, 0x17, 0x99, 0xc5, //
            0xa0, 0xec, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x02, //
            0x7d, 0x78, 0xe0, 0xa3, 0x00, 0x00, 0x02, 0x04, //
            0x05, 0xb4, 0x04, 0x02, 0x08, 0x0a, 0x00, 0x9c, //
            0x27, 0x24, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, //
            0x03, 0x00, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        11
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_tcp_port80_match,"fn test_tcp_port80_match() {
    test_interpreter_and_jit_asm!(
        PROG_TCP_PORT_80,
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x06, //
            0x07, 0x08, 0x09, 0x0a, 0x08, 0x00, 0x45, 0x00, //
            0x00, 0x56, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, //
            0xf9, 0x4d, 0xc0, 0xa8, 0x00, 0x01, 0xc0, 0xa8, //
            0x00, 0x02, 0x27, 0x10, 0x00, 0x50, 0x00, 0x00, //
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02, //
            0x20, 0x00, 0xc5, 0x18, 0x00, 0x00, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x1 } },
        17
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_tcp_port80_nomatch,"fn test_tcp_port80_nomatch() {
    test_interpreter_and_jit_asm!(
        PROG_TCP_PORT_80,
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x06, //
            0x07, 0x08, 0x09, 0x0a, 0x08, 0x00, 0x45, 0x00, //
            0x00, 0x56, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, //
            0xf9, 0x4d, 0xc0, 0xa8, 0x00, 0x01, 0xc0, 0xa8, //
            0x00, 0x02, 0x00, 0x16, 0x27, 0x10, 0x00, 0x00, //
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x02, //
            0x20, 0x00, 0xc5, 0x18, 0x00, 0x00, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        18
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_tcp_port80_nomatch_ethertype,"fn test_tcp_port80_nomatch_ethertype() {
    test_interpreter_and_jit_asm!(
        PROG_TCP_PORT_80,
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x06, //
            0x07, 0x08, 0x09, 0x0a, 0x08, 0x01, 0x45, 0x00, //
            0x00, 0x56, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, //
            0xf9, 0x4d, 0xc0, 0xa8, 0x00, 0x01, 0xc0, 0xa8, //
            0x00, 0x02, 0x27, 0x10, 0x00, 0x50, 0x00, 0x00, //
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02, //
            0x20, 0x00, 0xc5, 0x18, 0x00, 0x00, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        7
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_tcp_port80_nomatch_proto,"fn test_tcp_port80_nomatch_proto() {
    test_interpreter_and_jit_asm!(
        PROG_TCP_PORT_80,
        [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x06, //
            0x07, 0x08, 0x09, 0x0a, 0x08, 0x00, 0x45, 0x00, //
            0x00, 0x56, 0x00, 0x01, 0x00, 0x00, 0x40, 0x11, //
            0xf9, 0x4d, 0xc0, 0xa8, 0x00, 0x01, 0xc0, 0xa8, //
            0x00, 0x02, 0x27, 0x10, 0x00, 0x50, 0x00, 0x00, //
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02, //
            0x20, 0x00, 0xc5, 0x18, 0x00, 0x00, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, //
            0x44, 0x44, 0x44, 0x44, //
        ],
        (),
        0,
        { |_vm, res: Result| { res.unwrap() == 0x0 } },
        9
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_tcp_sack_match,"fn test_tcp_sack_match() {
    test_interpreter_and_jit_asm!(
        TCP_SACK_ASM,
        TCP_SACK_MATCH,
        (),
        0,
        { |_vm, res: Result| res.unwrap() == 0x1 },
        79
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_tcp_sack_nomatch,"fn test_tcp_sack_nomatch() {
    test_interpreter_and_jit_asm!(
        TCP_SACK_ASM,
        TCP_SACK_NOMATCH,
        (),
        0,
        { |_vm, res: Result| res.unwrap() == 0x0 },
        55
    );
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,execute_generated_program prog : & [ u8 ],"fn execute_generated_program(prog: &[u8]) -> bool {
    let max_instruction_count = 1024;
    let mem_size = 1024 * 1024;
    let mut bpf_functions = BTreeMap::new();
    let config = Config {
        enable_instruction_tracing: true,
        ..Config::default()
    };
    let syscall_registry = SyscallRegistry::default();
    register_bpf_function(
        &config,
        &mut bpf_functions,
        &syscall_registry,
        0,
        ""entrypoint"",
    )
    .unwrap();
    let executable = Executable::<UserError, TestInstructionMeter>::from_text_bytes(
        prog,
        Some(solana_rbpf::verifier::check),
        config,
        syscall_registry,
        bpf_functions,
    );
    let mut executable = if let Ok(executable) = executable {
        executable
    } else {
        return false;
    };
    if Executable::<UserError, TestInstructionMeter>::jit_compile(&mut executable).is_err() {
        return false;
    }
    let (instruction_count_interpreter, tracer_interpreter, result_interpreter) = {
        let mut mem = vec![0u8; mem_size];
        let mem_region = MemoryRegion::new_writable(&mut mem, ebpf::MM_INPUT_START);
        let mut vm = EbpfVm::new(&executable, &mut [], vec![mem_region]).unwrap();
        let result_interpreter = vm.execute_program_interpreted(&mut TestInstructionMeter {
            remaining: max_instruction_count,
        });
        let tracer_interpreter = vm.get_tracer().clone();
        (
            vm.get_total_instruction_count(),
            tracer_interpreter,
            result_interpreter,
        )
    };
    let mut mem = vec![0u8; mem_size];
    let mem_region = MemoryRegion::new_writable(&mut mem, ebpf::MM_INPUT_START);
    let mut vm = EbpfVm::new(&executable, &mut [], vec![mem_region]).unwrap();
    let result_jit = vm.execute_program_jit(&mut TestInstructionMeter {
        remaining: max_instruction_count,
    });
    let tracer_jit = vm.get_tracer();
    if result_interpreter != result_jit
        || !solana_rbpf::vm::Tracer::compare(&tracer_interpreter, tracer_jit)
    {
        let analysis =
            solana_rbpf::static_analysis::Analysis::from_executable(&executable).unwrap();
        println!(""result_interpreter={:?}"", result_interpreter);
        println!(""result_jit={:?}"", result_jit);
        let stdout = std::io::stdout();
        tracer_interpreter
            .write(&mut stdout.lock(), &analysis)
            .unwrap();
        tracer_jit.write(&mut stdout.lock(), &analysis).unwrap();
        panic!();
    }
    if executable.get_config().enable_instruction_meter {
        let instruction_count_jit = vm.get_total_instruction_count();
        assert_eq!(instruction_count_interpreter, instruction_count_jit);
    }
    true
}",0,True,False,
https://github.com/solana-labs/rbpf.git,e61e045f8c244de978401d186dcfd50838817297,GitHub,2022-04-29 15:08:56+02:00,False,ubpf_execution.rs,Rust,test_total_chaos,"fn test_total_chaos() {
    let instruction_count = 6;
    let iteration_count = 1000000;
    let mut program = vec![0; instruction_count * ebpf::INSN_SIZE];
    program[ebpf::INSN_SIZE * (instruction_count - 1)..ebpf::INSN_SIZE * instruction_count]
        .copy_from_slice(&[ebpf::EXIT, 0, 0, 0, 0, 0, 0, 0]);
    let seed = 0xC2DB2F8F282284A0;
    let mut prng = SmallRng::seed_from_u64(seed);
    for _ in 0..iteration_count {
        prng.fill_bytes(&mut program[0..ebpf::INSN_SIZE * (instruction_count - 1)]);
        execute_generated_program(&program);
    }
    for _ in 0..iteration_count {
        prng.fill_bytes(&mut program[0..ebpf::INSN_SIZE * (instruction_count - 1)]);
        for index in (0..program.len()).step_by(ebpf::INSN_SIZE) {
            program[index + 0x1] &= 0x77;
            program[index + 0x2] &= 0x00;
            program[index + 0x3] &= 0x77;
            program[index + 0x4] &= 0x00;
            program[index + 0x5] &= 0x77;
            program[index + 0x6] &= 0x77;
            program[index + 0x7] &= 0x77;
        }
        execute_generated_program(&program);
    }
}",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,mksnap.rs,Rust,"mksnap handle : & CoreDB , con : & mut Connection , act : ActionGroup","pub async fn mksnap(handle: &CoreDB, con: &mut Connection, act: ActionGroup) -> TResult<()> {
    let howmany = act.howmany();
    if howmany == 0 {
        if !handle.is_snapshot_enabled() {
            // Since snapshotting is disabled, we can't create a snapshot!
            // We'll just return an error returning the same
            let error = ""err-snapshot-disabled"";
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(error.to_string()));
            return con.write_response(error).await;
        }
        // We will just follow the standard convention of creating snapshots
        let mut was_engine_error = false;
        let mut snap_result = None;
        let mut engine_was_busy = false;
        {
            let snaphandle = handle.snapcfg.clone();
            let snapstatus = (*snaphandle)
                .as_ref()
                .unwrap_or_else(|| unsafe { unreachable_unchecked() });
            let snapengine = SnapshotEngine::new(snapstatus.max, &handle, None);
            if snapengine.is_err() {
                was_engine_error = true;
            } else {
                if snapstatus.is_busy() {
                    engine_was_busy = true;
                } else {
                    let mut snapengine =
                        snapengine.unwrap_or_else(|_| unsafe { unreachable_unchecked() });

                    snap_result = snapengine.mksnap();
                }
            }
        }
        if was_engine_error {
            return con
                .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                .await;
        }
        if engine_was_busy {
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(""err-snapshot-busy"".to_owned()));
            return con.write_response(error).await;
        }
        if let Some(succeeded) = snap_result {
            if succeeded {
                // Snapshotting succeeded, return Okay
                return con
                    .write_response(responses::fresp::R_OKAY.to_owned())
                    .await;
            } else {
                // Nope, something happened while creating a snapshot
                // return a server error
                return con
                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                    .await;
            }
        } else {
            // We shouldn't ever reach here if all our logic is correct
            // but if we do, something is wrong with the runtime
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(""err-access-after-termsig"".to_owned()));
            return con.write_response(error).await;
        }
    } else {
        if howmany == 1 {
            // This means that the user wants to create a 'named' snapshot
            let snapname = act
                .get_ref()
                .get(1)
                .unwrap_or_else(|| unsafe { unreachable_unchecked() });
            let mut path = PathBuf::from(DIR_SNAPSHOT);
            path.push(""remote"");
            path.push(snapname.to_owned() + "".snapshot"");
            let failed;
            {
                match diskstore::flush_data(&path, &handle.acquire_read().get_ref()) {
                    Ok(_) => failed = false,
                    Err(e) => {
                        log::error!(""Error while creating snapshot: {}"", e);
                        failed = true;
                    }
                }
            }
            if failed {
                return con
                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                    .await;
            } else {
                return con
                    .write_response(responses::fresp::R_OKAY.to_owned())
                    .await;
            }
        } else {
            return con
                .write_response(responses::fresp::R_ACTION_ERR.to_owned())
                .await;
        }
    }
}",1,True,False,99
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,mksnap.rs,Rust,"mksnap handle : & CoreDB , con : & mut Connection , act : ActionGroup","pub async fn mksnap(handle: &CoreDB, con: &mut Connection, act: ActionGroup) -> TResult<()> {
    let howmany = act.howmany();
    if howmany == 0 {
        if !handle.is_snapshot_enabled() {
            // Since snapshotting is disabled, we can't create a snapshot!
            // We'll just return an error returning the same
            let error = ""err-snapshot-disabled"";
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(error.to_string()));
            return con.write_response(error).await;
        }
        // We will just follow the standard convention of creating snapshots
        let mut was_engine_error = false;
        let mut snap_result = None;
        let mut engine_was_busy = false;
        {
            let snaphandle = handle.snapcfg.clone();
            let snapstatus = (*snaphandle)
                .as_ref()
                .unwrap_or_else(|| unsafe { unreachable_unchecked() });
            let snapengine = SnapshotEngine::new(snapstatus.max, &handle, None);
            if snapengine.is_err() {
                was_engine_error = true;
            } else {
                if snapstatus.is_busy() {
                    engine_was_busy = true;
                } else {
                    let mut snapengine =
                        snapengine.unwrap_or_else(|_| unsafe { unreachable_unchecked() });

                    snap_result = snapengine.mksnap();
                }
            }
        }
        if was_engine_error {
            return con
                .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                .await;
        }
        if engine_was_busy {
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(""err-snapshot-busy"".to_owned()));
            return con.write_response(error).await;
        }
        if let Some(succeeded) = snap_result {
            if succeeded {
                // Snapshotting succeeded, return Okay
                return con
                    .write_response(responses::fresp::R_OKAY.to_owned())
                    .await;
            } else {
                // Nope, something happened while creating a snapshot
                // return a server error
                return con
                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                    .await;
            }
        } else {
            // We shouldn't ever reach here if all our logic is correct
            // but if we do, something is wrong with the runtime
            con.write_response(GroupBegin(1)).await?;
            let error = RespCodes::OtherError(Some(""err-access-after-termsig"".to_owned()));
            return con.write_response(error).await;
        }
    } else {
        if howmany == 1 {
            // This means that the user wants to create a 'named' snapshot
            let snapname = act
                .get_ref()
                .get(1)
                .unwrap_or_else(|| unsafe { unreachable_unchecked() });
            let mut path = PathBuf::from(DIR_SNAPSHOT);
            path.push(""remote"");
            path.push(snapname.to_owned() + "".snapshot"");
            let illegal_snapshot = path
                .components()
                .filter(|dir| {
                    // Sanitize snapshot name, to avoid directory traversal attacks
                    // If the snapshot name has any root directory or parent directory, then
                    // we'll allow it to pass through this adaptor.
                    // As a result, this iterator will give us a count of the 'bad' components
                    dir == &Component::RootDir || dir == &Component::ParentDir
                })
                .count()
                != 0;
            if illegal_snapshot {
                con.write_response(GroupBegin(1)).await?;
                return con
                    .write_response(RespCodes::OtherError(Some(
                        ""err-invalid-snapshot-name"".to_owned(),
                    )))
                    .await;
            }
            let failed;
            {
                match diskstore::flush_data(&path, &handle.acquire_read().get_ref()) {
                    Ok(_) => failed = false,
                    Err(e) => {
                        log::error!(""Error while creating snapshot: {}"", e);
                        failed = true;
                    }
                }
            }
            if failed {
                return con
                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())
                    .await;
            } else {
                return con
                    .write_response(responses::fresp::R_OKAY.to_owned())
                    .await;
            }
        } else {
            return con
                .write_response(responses::fresp::R_ACTION_ERR.to_owned())
                .await;
        }
    }
}",0,False,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,dbnet.rs,Rust,run & mut self,"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            // Take the permit first, but we won't use it right now
            // that's why we will forget it
            self.climit.acquire().await.forget();
            let stream = self.accept().await?;
            let mut chandle = CHandler {
                db: self.db.clone(),
                con: Connection::new(stream),
                climit: self.climit.clone(),
                terminator: Terminator::new(self.signal.subscribe()),
                _term_sig_tx: self.terminate_tx.clone(),
            };
            tokio::spawn(async move {
                if let Err(e) = chandle.run().await {
                    eprintln!(""Error: {}"", e);
                }
            });
        }
    }",1,True,False,4
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,dbnet.rs,Rust,run & mut self,"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            // Take the permit first, but we won't use it right now
            // that's why we will forget it
            self.climit.acquire().await.unwrap().forget();
            let stream = self.accept().await?;
            let mut chandle = CHandler {
                db: self.db.clone(),
                con: Connection::new(stream),
                climit: self.climit.clone(),
                terminator: Terminator::new(self.signal.subscribe()),
                _term_sig_tx: self.terminate_tx.clone(),
            };
            tokio::spawn(async move {
                if let Err(e) = chandle.run().await {
                    eprintln!(""Error: {}"", e);
                }
            });
        }
    }",0,False,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,dbnet.rs,Rust,new signal : broadcast :: Receiver < >,"    pub const fn new(signal: broadcast::Receiver<()>) -> Self {
        Terminator {
            // Don't terminate on creation!
            terminate: false,
            signal,
        }
    }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,dbnet.rs,Rust,is_termination_signal & self,"    pub const fn is_termination_signal(&self) -> bool {
        self.terminate
    }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,dbnet.rs,Rust,receive_signal & mut self,"    pub async fn receive_signal(&mut self) {
        // The server may have already been terminated
        // In that event, just return
        if self.terminate {
            return;
        }
        let _ = self.signal.recv().await;
        self.terminate = true;
    }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,dbnet.rs,Rust,accept & mut self,"    async fn accept(&mut self) -> TResult<TcpStream> {
        // We will steal the idea of Ethernet's backoff for connection errors
        let mut backoff = 1;
        loop {
            match self.listener.accept().await {
                // We don't need the bindaddr
                Ok((stream, _)) => return Ok(stream),
                Err(e) => {
                    if backoff > 64 {
                        // Too many retries, goodbye user
                        return Err(e.into());
                    }
                }
            }
            // Wait for the `backoff` duration
            time::sleep(Duration::from_secs(backoff)).await;
            // We're using exponential backoff
            backoff *= 2;
        }
    }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,dbnet.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        // Make sure that the permit is returned to the semaphore
        // in the case that there is a panic inside
        self.climit.add_permits(1);
    }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,dbnet.rs,Rust,"run listener : TcpListener , bgsave_cfg : BGSave , snapshot_cfg : SnapshotConfig , sig : impl Future , restore_filepath : Option < PathBuf > ,","pub async fn run(
    listener: TcpListener,
    bgsave_cfg: BGSave,
    snapshot_cfg: SnapshotConfig,
    sig: impl Future,
    restore_filepath: Option<PathBuf>,
) {
    let (signal, _) = broadcast::channel(1);
    let (terminate_tx, terminate_rx) = mpsc::channel(1);
    let db = match CoreDB::new(bgsave_cfg, snapshot_cfg, restore_filepath) {
        Ok(d) => d,
        Err(e) => {
            eprintln!(""ERROR: {}"", e);
            process::exit(0x100);
        }
    };
    match fs::create_dir_all(&*DIR_REMOTE_SNAPSHOT) {
        Ok(_) => (),
        Err(e) => match e.kind() {
            ErrorKind::AlreadyExists => (),
            _ => {
                log::error!(""Failed to create snapshot directories: '{}'"", e);
                process::exit(0x100);
            }
        },
    }
    log::info!(
        ""Started server on terrapipe://{}"",
        listener
            .local_addr()
            .expect(""The local address couldn't be fetched. Please file a bug report"")
    );
    let mut server = Listener {
        listener,
        db,
        climit: Arc::new(Semaphore::new(50000)),
        signal,
        terminate_tx,
        terminate_rx,
    };
    tokio::select! {
        _ = server.run() => {}
        _ = sig => {
            log::info!(""Signalling all workers to shut down"");
        }
    }
    let Listener {
        mut terminate_rx,
        terminate_tx,
        signal,
        db,
        ..
    } = server;
    if let Ok(_) = db.flush_db() {
        log::info!(""Successfully saved data to disk"");
        ()
    } else {
        log::error!(""Failed to flush data to disk"");
        loop {
            // Keep looping until we successfully write the in-memory table to disk
            log::warn!(""Press enter to try again..."");
            io::stdout().flush().unwrap();
            io::stdin().read(&mut [0]).unwrap();
            if let Ok(_) = db.flush_db() {
                log::info!(""Successfully saved data to disk"");
                break;
            } else {
                continue;
            }
        }
    }
    drop(signal);
    drop(terminate_tx);
    let _ = terminate_rx.recv().await;
    terminal::write_info(""Goodbye :)\n"").unwrap();
}",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,dbnet.rs,Rust,"test_run listener : TcpListener , db : CoreDB , sig : impl Future","pub async fn test_run(listener: TcpListener, db: CoreDB, sig: impl Future) {
    let (signal, _) = broadcast::channel(1);
    let (terminate_tx, terminate_rx) = mpsc::channel(1);
    let mut server = Listener {
        listener,
        db,
        climit: Arc::new(Semaphore::new(50000)),
        signal,
        terminate_tx,
        terminate_rx,
    };
    tokio::select! {
        _ = server.run() => {}
        _ = sig => {}
    }
    let Listener {
        mut terminate_rx,
        terminate_tx,
        signal,
        ..
    } = server;
    drop(signal);
    drop(terminate_tx);
    let _ = terminate_rx.recv().await;
}",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,main.rs,Rust,main,"fn main() {
    benchtool::runner();
}",1,True,False,2
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,main.rs,Rust,main,"fn main() {
    benchtool::runner();
}",0,False,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,main.rs,Rust,"ran_string len : usize , rand : impl rand :: Rng","    fn ran_string(len: usize, rand: impl rand::Rng) -> String {
        let rand_string: String = rand
            .sample_iter(&Alphanumeric)
            .take(len)
            .map(char::from)
            .collect();
        rand_string
    }",0,False,True,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,main.rs,Rust,"new size : usize , host : & String","        pub fn new(size: usize, host: &String) -> Netpool {
            assert!(size > 0);
            let (sender, receiver) = mpsc::channel();
            let receiver = Arc::new(Mutex::new(receiver));
            let mut workers = Vec::with_capacity(size);
            for _ in 0..size {
                workers.push(Worker::new(Arc::clone(&receiver), host.to_owned()));
            }
            Netpool { workers, sender }
        }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,main.rs,Rust,"execute & mut self , action : Vec < u8 >","        pub fn execute(&mut self, action: Vec<u8>) {
            self.sender.send(WhatToDo::NewJob(action)).unwrap();
        }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,main.rs,Rust,"new receiver : Arc < Mutex < mpsc :: Receiver < WhatToDo > > > , host : std :: string :: String ,","        fn new(
            receiver: Arc<Mutex<mpsc::Receiver<WhatToDo>>>,
            host: std::string::String,
        ) -> Worker {
            let thread = thread::spawn(move || {
                let mut connection = TcpStream::connect(host).unwrap();
                loop {
                    let action = receiver.lock().unwrap().recv().unwrap();
                    match action {
                        WhatToDo::NewJob(someaction) => {
                            // We have to write something to the socket
                            connection.write_all(&someaction).unwrap();
                            // Ignore whatever we get, we don't need them
                            connection.read(&mut vec![0; 1024]).unwrap();
                        }
                        WhatToDo::Nothing => {
                            // A termination signal - just close the stream and
                            // return
                            connection.shutdown(net::Shutdown::Both).unwrap();
                            break;
                        }
                    }
                }
            });
            Worker {
                thread: Some(thread),
            }
        }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,main.rs,Rust,drop & mut self,"        fn drop(&mut self) {
            // Signal all the workers to shut down
            for _ in &mut self.workers {
                self.sender.send(WhatToDo::Nothing).unwrap();
            }
            // Terminate all the threads
            for worker in &mut self.workers {
                if let Some(thread) = worker.thread.take() {
                    thread.join().unwrap();
                }
            }
        }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,main.rs,Rust,"new report : & 'static str, stat: f64) -> Self {
            JSONReportBlock {
                report: report.to_owned(),
                stat,
            }
        }
    }

    /// Run the benchmark tool
    pub fn runner() {
        let cfg_layout = load_yaml!(""./cli.yml"");
        let matches = App::from_yaml(cfg_layout).get_matches();
        let mut host = match matches.value_of(""host"") {
            Some(h) => h.to_owned(),
            None => ""127.0.0.1"".to_owned(),
        };
        host.push(' : '","        pub fn new(report: &'static str, stat: f64) -> Self {
            JSONReportBlock {
                report: report.to_owned(),
                stat,
            }
        }
    }

    /// Run the benchmark tool
    pub fn runner() {
        let cfg_layout = load_yaml!(""./cli.yml"");
        let matches = App::from_yaml(cfg_layout).get_matches();
        let mut host = match matches.value_of(""host"") {
            Some(h) => h.to_owned(),
            None => ""127.0.0.1"".to_owned(),
        };
        host.push(':');
        match matches.value_of(""port"") {
            Some(p) => match p.parse::<u16>() {
                Ok(p) => host.push_str(&p.to_string()),
                Err(_) => {
                    eprintln!(""ERROR: Invalid port"");
                    std::process::exit(0x100);
                }
            },
            None => host.push_str(""2003""),
        }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,main.rs,Rust,"calc reqs : usize , time : u128","    fn calc(reqs: usize, time: u128) -> f64 {
        reqs as f64 / (time as f64 / 1_000_000_000 as f64)
    }",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,lib.rs,Rust,"parse_dbtest mut input : syn :: ItemFn , rand : u16","fn parse_dbtest(mut input: syn::ItemFn, rand: u16) -> Result<TokenStream, syn::Error> {
    let sig = &mut input.sig;
    let fname = sig.ident.to_string();
    let body = &input.block;
    let attrs = &input.attrs;
    let vis = &input.vis;
    let header = quote! {
        #[::core::prelude::v1::test]
    };
    if sig.asyncness.is_none() {
        let msg = ""`dbtest` functions need to be async"";
        return Err(syn::Error::new_spanned(sig.fn_token, msg));
    }
    sig.asyncness = None;
    let body = quote! {
        let asyncdb = crate::coredb::CoreDB::new(
            crate::config::BGSave::Disabled,
            crate::config::SnapshotConfig::default(),
            None
        ).unwrap();
        let addr = crate::tests::start_test_server(#rand, Some(asyncdb.clone())).await;
        let mut stream = tokio::net::TcpStream::connect(&addr).await.unwrap();
        #body
        stream.shutdown(::std::net::Shutdown::Write).unwrap();
        asyncdb.finish_db();
        drop(asyncdb);
    };
    let result = quote! {
        #header
        #(#attrs)*
        #vis #sig {
            tokio::runtime::Builder::new_multi_thread()
            .worker_threads(4)
            .thread_name(#fname)
            .thread_stack_size(3 * 1024 * 1024)
            .enable_all()
            .build()
            .unwrap()
            .block_on(async { #body });
        }
    };
    Ok(result.into())
}",1,True,False,23
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,lib.rs,Rust,"parse_test_module args : TokenStream , item : TokenStream","fn parse_test_module(args: TokenStream, item: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(item as syn::ItemMod);
    let content = match input.content {
        Some((_, c)) => c,
        None => {
            return syn::Error::new_spanned(&input, ""Couldn't get the module content"")
                .to_compile_error()
                .into()
        }
    };
    let args = syn::parse_macro_input!(args as syn::AttributeArgs);
    let mut skips = Vec::new();
    for arg in args {
        match arg {
            syn::NestedMeta::Meta(syn::Meta::NameValue(namevalue)) => {
                let ident = namevalue.path.get_ident();
                if ident.is_none() {
                    let msg = ""Must have specified ident"";
                    return syn::Error::new_spanned(namevalue, msg)
                        .to_compile_error()
                        .into();
                }
                match ident.unwrap().to_string().to_lowercase().as_str() {
                    ""skip"" => {
                        let skip_lit = namevalue.lit.clone();
                        let span = skip_lit.span();
                        skips = match parse_string(skip_lit, span, ""skip"") {
                            Ok(s) => s,
                            Err(_) => {
                                return syn::Error::new_spanned(
                                    namevalue,
                                    ""Expected a value for argument `skip`"",
                                )
                                .to_compile_error()
                                .into();
                            }
                        }
                        .split_whitespace()
                        .map(|val| val.to_string())
                        .collect();
                    }
                    x => {
                        let msg = format!(""Unknown attribute {} is specified; expected `skip`"", x);
                        return syn::Error::new_spanned(namevalue, msg)
                            .to_compile_error()
                            .into();
                    }
                }
            }
            _ => (),
        }
    }
    let modname = &input.ident;
    if modname.to_string() != ""__private"" {
        return syn::Error::new_spanned(
            modname,
            ""By convention, all the modules using the `dbtest` macro have to be called `__private`"",
        )
        .to_compile_error()
        .into();
    }
    let mut rng = thread_rng();
    let mut in_set = HashSet::<u16>::new();

    let mut result = quote! {};
    for item in content {
        /*
        Since standard (non-root) users can only access ports greater than 1024
        we will set the limit to (1024, 65535)
        However, for Windows, several ports in the range [49670, 50293] and ports {5357, 7680} are taken
        over by Hyper-V, which is why we'll prevent attempts to bind to them, if
        the OS is Windows.
        */
        let mut rand: u16 = rng.gen_range(1025, 65535);
        #[cfg(not(target_os = ""windows""))]
        {
            while in_set.contains(&rand) {
                rand = rng.gen_range(1025, 65535);
            }
        }
        #[cfg(target_os = ""windows"")]
        {
            in_set.insert(5357);
            in_set.insert(7680);
            while in_set.contains(&rand) || (rand >= 49670 && rand <= 50293) {
                rand = rng.gen_range(1025, 65535);
            }
        }
        in_set.insert(rand);
        match item {
            // We just care about functions, so parse functions and ignore everything
            // else
            syn::Item::Fn(function) => {
                if skips.contains(&function.sig.ident.to_string()) {
                    result = quote! {
                        #result
                        #function
                    };
                    continue;
                }
                let inp = parse_test_sig(function, rand);
                let __tok: syn::ItemFn = syn::parse_macro_input!(inp as syn::ItemFn);
                let tok = quote! {
                    #__tok
                };
                result = quote! {
                    #result
                    #tok
                };
            }
            token => {
                result = quote! {
                    #result
                    #token
                };
            }
        }
    }
    result.into()
}",1,True,False,"73,77,85"
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,lib.rs,Rust,"parse_dbtest mut input : syn :: ItemFn , rand : u16","fn parse_dbtest(mut input: syn::ItemFn, rand: u16) -> Result<TokenStream, syn::Error> {
    let sig = &mut input.sig;
    let fname = sig.ident.to_string();
    let body = &input.block;
    let attrs = &input.attrs;
    let vis = &input.vis;
    let header = quote! {
        #[::core::prelude::v1::test]
    };
    if sig.asyncness.is_none() {
        let msg = ""`dbtest` functions need to be async"";
        return Err(syn::Error::new_spanned(sig.fn_token, msg));
    }
    sig.asyncness = None;
    let body = quote! {
        let asyncdb = crate::coredb::CoreDB::new(
            crate::config::BGSave::Disabled,
            crate::config::SnapshotConfig::default(),
            None
        ).unwrap();
        let addr = crate::tests::start_test_server(#rand, Some(asyncdb.clone())).await;
        let mut stream = tokio::net::TcpStream::connect(&addr).await.unwrap();
        #body
        stream.shutdown().await.unwrap();
        asyncdb.finish_db();
        drop(asyncdb);
    };
    let result = quote! {
        #header
        #(#attrs)*
        #vis #sig {
            tokio::runtime::Builder::new_multi_thread()
            .worker_threads(4)
            .thread_name(#fname)
            .thread_stack_size(3 * 1024 * 1024)
            .enable_all()
            .build()
            .unwrap()
            .block_on(async { #body });
        }
    };
    Ok(result.into())
}",0,False,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,lib.rs,Rust,"parse_test_module args : TokenStream , item : TokenStream","fn parse_test_module(args: TokenStream, item: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(item as syn::ItemMod);
    let content = match input.content {
        Some((_, c)) => c,
        None => {
            return syn::Error::new_spanned(&input, ""Couldn't get the module content"")
                .to_compile_error()
                .into()
        }
    };
    let args = syn::parse_macro_input!(args as syn::AttributeArgs);
    let mut skips = Vec::new();
    for arg in args {
        match arg {
            syn::NestedMeta::Meta(syn::Meta::NameValue(namevalue)) => {
                let ident = namevalue.path.get_ident();
                if ident.is_none() {
                    let msg = ""Must have specified ident"";
                    return syn::Error::new_spanned(namevalue, msg)
                        .to_compile_error()
                        .into();
                }
                match ident.unwrap().to_string().to_lowercase().as_str() {
                    ""skip"" => {
                        let skip_lit = namevalue.lit.clone();
                        let span = skip_lit.span();
                        skips = match parse_string(skip_lit, span, ""skip"") {
                            Ok(s) => s,
                            Err(_) => {
                                return syn::Error::new_spanned(
                                    namevalue,
                                    ""Expected a value for argument `skip`"",
                                )
                                .to_compile_error()
                                .into();
                            }
                        }
                        .split_whitespace()
                        .map(|val| val.to_string())
                        .collect();
                    }
                    x => {
                        let msg = format!(""Unknown attribute {} is specified; expected `skip`"", x);
                        return syn::Error::new_spanned(namevalue, msg)
                            .to_compile_error()
                            .into();
                    }
                }
            }
            _ => (),
        }
    }
    let modname = &input.ident;
    if modname.to_string() != ""__private"" {
        return syn::Error::new_spanned(
            modname,
            ""By convention, all the modules using the `dbtest` macro have to be called `__private`"",
        )
        .to_compile_error()
        .into();
    }
    let mut rng = thread_rng();
    let mut in_set = HashSet::<u16>::new();

    let mut result = quote! {};
    for item in content {
        /*
        Since standard (non-root) users can only access ports greater than 1024
        we will set the limit to (1024, 65535)
        However, for Windows, several ports in the range [49670, 50293] and ports {5357, 7680} are taken
        over by Hyper-V, which is why we'll prevent attempts to bind to them, if
        the OS is Windows.
        */
        let mut rand: u16 = rng.gen_range(1025..=65535);
        #[cfg(not(target_os = ""windows""))]
        {
            while in_set.contains(&rand) {
                rand = rng.gen_range(1025..=65535);
            }
        }
        #[cfg(target_os = ""windows"")]
        {
            in_set.insert(5357);
            in_set.insert(7680);
            while in_set.contains(&rand) || (rand >= 49670 && rand <= 50293) {
                rand = rng.gen_range(1025..=65535);
            }
        }
        in_set.insert(rand);
        match item {
            // We just care about functions, so parse functions and ignore everything
            // else
            syn::Item::Fn(function) => {
                if skips.contains(&function.sig.ident.to_string()) {
                    result = quote! {
                        #result
                        #function
                    };
                    continue;
                }
                let inp = parse_test_sig(function, rand);
                let __tok: syn::ItemFn = syn::parse_macro_input!(inp as syn::ItemFn);
                let tok = quote! {
                    #__tok
                };
                result = quote! {
                    #result
                    #tok
                };
            }
            token => {
                result = quote! {
                    #result
                    #token
                };
            }
        }
    }
    result.into()
}",0,False,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,lib.rs,Rust,"parse_test_sig input : syn :: ItemFn , rand : u16","fn parse_test_sig(input: syn::ItemFn, rand: u16) -> TokenStream {
    for attr in &input.attrs {
        if attr.path.is_ident(""test"") {
            let msg = ""second test attribute is supplied"";
            return syn::Error::new_spanned(&attr, msg)
                .to_compile_error()
                .into();
        }
    }

    if !input.sig.inputs.is_empty() {
        let msg = ""the test function cannot accept arguments"";
        return syn::Error::new_spanned(&input.sig.inputs, msg)
            .to_compile_error()
            .into();
    }
    parse_dbtest(input, rand).unwrap_or_else(|e| e.to_compile_error().into())
}",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,lib.rs,Rust,"parse_string int : syn :: Lit , span : Span , field : & str","fn parse_string(int: syn::Lit, span: Span, field: &str) -> Result<String, syn::Error> {
    match int {
        syn::Lit::Str(s) => Ok(s.value()),
        syn::Lit::Verbatim(s) => Ok(s.to_string()),
        _ => Err(syn::Error::new(
            span,
            format!(""Failed to parse {} into a string."", field),
        )),
    }
}",0,True,False,
https://github.com/skytable/skytable.git,38b011273bb92b83c61053ae2fcd80aa9320315c,Sayan Nandan,2021-02-15 10:29:27+05:18,False,lib.rs,Rust,"dbtest args : TokenStream , item : TokenStream","pub fn dbtest(args: TokenStream, item: TokenStream) -> TokenStream {
    parse_test_module(args, item)
}",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,new signal : broadcast :: Receiver < >,"    pub const fn new(signal: broadcast::Receiver<()>) -> Self {
        Terminator {
            // Don't terminate on creation!
            terminate: false,
            signal,
        }
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,is_termination_signal & self,"    pub const fn is_termination_signal(&self) -> bool {
        self.terminate
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,receive_signal & mut self,"    pub async fn receive_signal(&mut self) {
        // The server may have already been terminated
        // In that event, just return
        if self.terminate {
            return;
        }
        let _ = self.signal.recv().await;
        self.terminate = true;
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,"init db : & Corestore , host : IpAddr , port : u16 , semaphore : Arc < Semaphore > , signal : broadcast :: Sender < > ,","    pub async fn init(
        db: &Corestore,
        host: IpAddr,
        port: u16,
        semaphore: Arc<Semaphore>,
        signal: broadcast::Sender<()>,
    ) -> Result<Self, IoError> {
        let (terminate_tx, terminate_rx) = mpsc::channel(1);
        Ok(Self {
            db: db.clone(),
            listener: TcpListener::bind((host, port)).await?,
            climit: semaphore,
            signal,
            terminate_tx,
            terminate_rx,
        })
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,release_self self,"    pub async fn release_self(self) {
        let Self {
            mut terminate_rx,
            terminate_tx,
            signal,
            ..
        } = self;
        drop(signal);
        drop(terminate_tx);
        let _ = terminate_rx.recv().await;
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,new_insecure_only base : BaseListener,"    pub fn new_insecure_only(base: BaseListener) -> Result<Self, String> {
        log::info!(""Server started on: skyhash://{}"", bindaddr!(base));
        Ok(MultiListener::InsecureOnly(Listener { base }))
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,"new_secure_only base : BaseListener , ssl : SslOpts","    pub fn new_secure_only(base: BaseListener, ssl: SslOpts) -> Result<Self, String> {
        let bindaddr = bindaddr!(base);
        let slf = MultiListener::SecureOnly(
            SslListener::new_pem_based_ssl_connection(ssl.key, ssl.chain, base, ssl.passfile)
                .map_err(|e| format!(""Couldn't bind to secure port: {}"", e))?,
        );
        log::info!(""Server started on: skyhash-secure://{}"", bindaddr);
        Ok(slf)
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,"new_multi ssl_base_listener : BaseListener , tcp_base_listener : BaseListener , ssl : SslOpts ,","    pub async fn new_multi(
        ssl_base_listener: BaseListener,
        tcp_base_listener: BaseListener,
        ssl: SslOpts,
    ) -> Result<Self, String> {
        let sec_bindaddr = bindaddr!(ssl_base_listener);
        let insec_binaddr = bindaddr!(tcp_base_listener);
        let secure_listener = SslListener::new_pem_based_ssl_connection(
            ssl.key,
            ssl.chain,
            ssl_base_listener,
            ssl.passfile,
        )
        .map_err(|e| format!(""Couldn't bind to secure port: {}"", e))?;
        let insecure_listener = Listener {
            base: tcp_base_listener,
        };
        log::info!(
            ""Server started on: skyhash://{} and skyhash-secure://{}"",
            insec_binaddr,
            sec_bindaddr
        );
        Ok(MultiListener::Multi(insecure_listener, secure_listener))
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,run_server & mut self,"    pub async fn run_server(&mut self) -> TResult<()> {
        match self {
            MultiListener::SecureOnly(secure_listener) => secure_listener.run().await,
            MultiListener::InsecureOnly(insecure_listener) => insecure_listener.run().await,
            MultiListener::Multi(insecure_listener, secure_listener) => {
                let insec = insecure_listener.run();
                let sec = secure_listener.run();
                let (e1, e2) = tokio::join!(insec, sec);
                if let Err(e) = e1 {
                    log::error!(""Insecure listener failed with: {}"", e);
                }
                if let Err(e) = e2 {
                    log::error!(""Secure listener failed with: {}"", e);
                }
                Ok(())
            }
        }
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,finish_with_termsig self,"    pub async fn finish_with_termsig(self) {
        match self {
            MultiListener::InsecureOnly(server) => server.base.release_self().await,
            MultiListener::SecureOnly(server) => server.base.release_self().await,
            MultiListener::Multi(insecure, secure) => {
                insecure.base.release_self().await;
                secure.base.release_self().await;
            }
        }
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,mod.rs,Rust,"connect ports : PortConfig , maxcon : usize , db : Corestore , signal : broadcast :: Sender < > ,","pub async fn connect(
    ports: PortConfig,
    maxcon: usize,
    db: Corestore,
    signal: broadcast::Sender<()>,
) -> Result<MultiListener, String> {
    let climit = Arc::new(Semaphore::const_new(maxcon));
    let server = match ports {
        PortConfig::InsecureOnly { host, port } => MultiListener::new_insecure_only(
            BaseListener::init(&db, host, port, climit.clone(), signal.clone())
                .await
                .map_err(|e| format!(""Failed to bind to TCP port with error: {}"", e))?,
        )?,
        PortConfig::SecureOnly { host, ssl } => MultiListener::new_secure_only(
            BaseListener::init(&db, host, ssl.port, climit.clone(), signal.clone())
                .await
                .map_err(|e| format!(""Failed to initialize secure port with error: {}"", e))?,
            ssl,
        )?,
        PortConfig::Multi { host, port, ssl } => {
            let secure_listener =
                BaseListener::init(&db, host, ssl.port, climit.clone(), signal.clone())
                    .await
                    .map_err(|e| format!(""Failed to bind to TCP port with error: {}"", e))?;
            let insecure_listener =
                BaseListener::init(&db, host, port, climit.clone(), signal.clone())
                    .await
                    .map_err(|e| format!(""Failed to initialize secure port with error: {}"", e))?;
            MultiListener::new_multi(secure_listener, insecure_listener, ssl).await?
        }
    };
    Ok(server)
}",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,tcp.rs,Rust,run & mut self,"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            // Take the permit first, but we won't use it right now
            // that's why we will forget it
            self.base.climit.acquire().await.unwrap().forget();
            let stream = self.accept().await?;
            let mut chandle = ConnectionHandler::new(
                self.base.db.clone(),
                Connection::new(stream),
                self.base.climit.clone(),
                Terminator::new(self.base.signal.subscribe()),
                self.base.terminate_tx.clone(),
            );
            tokio::spawn(async move {
                if let Err(e) = chandle.run().await {
                    log::error!(""Error: {}"", e);
                }
            });
        }
    }",1,True,False,5
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,tcp.rs,Rust,run & mut self,"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            // Take the permit first, but we won't use it right now
            // that's why we will forget it
            self.base.climit.acquire().await.unwrap().forget();
            /*
             SECURITY: Ignore any errors that may arise in the accept
             loop. If we apply the try operator here, we will immediately
             terminate the run loop causing the entire server to go down.
             Also, do not log any errors because many connection errors
             can arise and it will flood the log and might also result
             in a crash
            */
            let stream = skip_loop_err!(self.accept().await);
            let mut chandle = ConnectionHandler::new(
                self.base.db.clone(),
                Connection::new(stream),
                self.base.climit.clone(),
                Terminator::new(self.base.signal.subscribe()),
                self.base.terminate_tx.clone(),
            );
            tokio::spawn(async move {
                if let Err(e) = chandle.run().await {
                    log::error!(""Error: {}"", e);
                }
            });
        }
    }",0,False,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,tcp.rs,Rust,new stream : T,"    pub fn new(stream: T) -> Self {
        Connection {
            stream: BufWriter::new(stream),
            buffer: BytesMut::with_capacity(BUF_CAP),
        }
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,tcp.rs,Rust,accept & mut self,"    async fn accept(&mut self) -> TResult<TcpStream> {
        // We will steal the idea of Ethernet's backoff for connection errors
        let mut backoff = 1;
        loop {
            match self.base.listener.accept().await {
                // We don't need the bindaddr
                Ok((stream, _)) => return Ok(stream),
                Err(e) => {
                    if backoff > 64 {
                        // Too many retries, goodbye user
                        return Err(e.into());
                    }
                }
            }
            // Wait for the `backoff` duration
            time::sleep(Duration::from_secs(backoff)).await;
            // We're using exponential backoff
            backoff *= 2;
        }
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,tls.rs,Rust,run & mut self,"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            // Take the permit first, but we won't use it right now
            // that's why we will forget it
            self.base.climit.acquire().await.unwrap().forget();
            let stream = self.accept().await?;
            let mut sslhandle = ConnectionHandler::new(
                self.base.db.clone(),
                Connection::new(stream),
                self.base.climit.clone(),
                Terminator::new(self.base.signal.subscribe()),
                self.base.terminate_tx.clone(),
            );
            tokio::spawn(async move {
                if let Err(e) = sslhandle.run().await {
                    log::error!(""Error: {}"", e);
                }
            });
        }
    }",1,True,False,5
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,tls.rs,Rust,run & mut self,"    pub async fn run(&mut self) -> TResult<()> {
        loop {
            // Take the permit first, but we won't use it right now
            // that's why we will forget it
            self.base.climit.acquire().await.unwrap().forget();
            /*
             SECURITY: Ignore any errors that may arise in the accept
             loop. If we apply the try operator here, we will immediately
             terminate the run loop causing the entire server to go down.
             Also, do not log any errors because many connection errors
             can arise and it will flood the log and might also result
             in a crash
            */
            let stream = skip_loop_err!(self.accept().await);
            let mut sslhandle = ConnectionHandler::new(
                self.base.db.clone(),
                Connection::new(stream),
                self.base.climit.clone(),
                Terminator::new(self.base.signal.subscribe()),
                self.base.terminate_tx.clone(),
            );
            tokio::spawn(async move {
                log::debug!(""Spawned listener task"");
                if let Err(e) = sslhandle.run().await {
                    log::error!(""Error: {}"", e);
                }
            });
        }
    }",0,False,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,tls.rs,Rust,"new_pem_based_ssl_connection key_file : String , chain_file : String , base : BaseListener , tls_passfile : Option < String > ,","    pub fn new_pem_based_ssl_connection(
        key_file: String,
        chain_file: String,
        base: BaseListener,
        tls_passfile: Option<String>,
    ) -> TResult<Self> {
        let mut acceptor_builder = SslAcceptor::mozilla_intermediate(SslMethod::tls())?;
        // cert is the same for both
        acceptor_builder.set_certificate_chain_file(chain_file)?;
        if let Some(tls_passfile) = tls_passfile {
            // first read in the private key
            let tls_private_key = fs::read(key_file).map_err(|e: IoError| {
                format!(""Failed to read TLS private key file with error: {}"", e)
            })?;
            // read the passphrase because the passphrase file stream was provided
            let tls_keyfile_stream = fs::read(tls_passfile).map_err(|e: IoError| {
                format!(
                    ""Failed to read TLS private key passphrase file with error: {}"",
                    e
                )
            })?;
            // decrypt the private key
            let pkey = Rsa::private_key_from_pem_passphrase(&tls_private_key, &tls_keyfile_stream)?;
            let pkey = PKey::from_rsa(pkey)?;
            // set the private key for the acceptor
            acceptor_builder.set_private_key(&pkey)?;
        } else {
            // no passphrase, needs interactive
            acceptor_builder.set_private_key_file(key_file, SslFiletype::PEM)?;
        }
        Ok(SslListener {
            base,
            acceptor: acceptor_builder.build(),
        })
    }",0,True,False,
https://github.com/skytable/skytable.git,bb19d024ea1e5e0c9a3d75a9ee58ff03c70c7e5d,Sayan Nandan,2021-08-05 02:52:16-07:00,False,tls.rs,Rust,accept & mut self,"    async fn accept(&mut self) -> TResult<SslStream<TcpStream>> {
        let mut backoff = 1;
        loop {
            match self.base.listener.accept().await {
                // We don't need the bindaddr
                // We get the encrypted stream which we need to decrypt
                // by using the acceptor
                Ok((stream, _)) => {
                    let ssl = Ssl::new(self.acceptor.context())?;
                    let mut stream = SslStream::new(ssl, stream)?;
                    Pin::new(&mut stream).accept().await?;
                    return Ok(stream);
                }
                Err(e) => {
                    if backoff > 64 {
                        // Too many retries, goodbye user
                        return Err(e.into());
                    }
                }
            }
            // Wait for the `backoff` duration
            time::sleep(Duration::from_secs(backoff)).await;
            // We're using exponential backoff
            backoff *= 2;
        }
    }",0,True,False,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,"discard_exact & mut self , mut len : usize","    fn discard_exact(&mut self, mut len: usize) -> io::Result<()> {
        while len > 0 {
            let consume_len = match self.fill_buf() {
                Ok(buf) => buf.len().min(len),
                Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,
                Err(e) => return Err(e),
            };
            self.consume(consume_len);
            len -= consume_len;
        }
        Ok(())
    }",1,True,True,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,"discard_exact & mut self , len : usize","    fn discard_exact(&mut self, len: usize) -> io::Result<()>;
}

impl<T> BufReadExt for T where T: io::BufRead {
    fn discard_exact(&mut self, mut len: usize) -> io::Result<()> {
        while len > 0 {
            let consume_len = match self.fill_buf() {
                Ok(buf) => buf.len().min(len),
                Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,
                Err(e) => return Err(e),
            };
            self.consume(consume_len);
            len -= consume_len;
        }
        Ok(())
    }
}",1,True,True,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,"discard_exact & mut self , mut len : usize","    fn discard_exact(&mut self, mut len: usize) -> io::Result<()> {
        while len > 0 {
            let consume_len = match self.fill_buf() {
                Ok(buf) if buf.is_empty() =>
                    return Err(io::Error::new(
                        io::ErrorKind::UnexpectedEof, ""unexpected EOF"")),
                Ok(buf) => buf.len().min(len),
                Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,
                Err(e) => return Err(e),
            };
            self.consume(consume_len);
            len -= consume_len;
        }
        Ok(())
    }",0,False,True,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,"discard_exact & mut self , len : usize","    fn discard_exact(&mut self, len: usize) -> io::Result<()>;
}

impl<T> BufReadExt for T where T: io::BufRead {
    fn discard_exact(&mut self, mut len: usize) -> io::Result<()> {
        while len > 0 {
            let consume_len = match self.fill_buf() {
                Ok(buf) if buf.is_empty() =>
                    return Err(io::Error::new(
                        io::ErrorKind::UnexpectedEof, ""unexpected EOF"")),
                Ok(buf) => buf.len().min(len),
                Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,
                Err(e) => return Err(e),
            };
            self.consume(consume_len);
            len -= consume_len;
        }
        Ok(())
    }
}",0,False,True,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,discard_exact,"    fn discard_exact() {
        let mut buf = b""abc"".as_ref();
        buf.discard_exact(1).unwrap();
        assert_eq!(buf, b""bc"");
        buf.discard_exact(2).unwrap();
        assert_eq!(buf, b"""");
        buf.discard_exact(1).unwrap_err();
    }",0,False,True,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,read8 reader : & mut R,"pub fn read8<R>(reader: &mut R) -> Result<u8, io::Error> where R: io::Read {
    let mut buf = [0u8; 1];
    reader.read_exact(&mut buf).and(Ok(buf[0]))
}",0,True,False,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,read16 reader : & mut R,"pub fn read16<R>(reader: &mut R) -> Result<u16, io::Error> where R: io::Read {
    let mut buf = [0u8; 2];
    reader.read_exact(&mut buf)?;
    Ok(u16::from_be_bytes(buf))
}",0,True,False,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,read64 reader : & mut R,"pub fn read64<R>(reader: &mut R) -> Result<u64, io::Error> where R: io::Read {
    let mut buf = [0u8; 8];
    reader.read_exact(&mut buf)?;
    Ok(u64::from_be_bytes(buf))
}",0,True,False,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,atou16 bytes : & [ u8 ],"pub fn atou16(bytes: &[u8]) -> Result<u16, Error> {
    if cfg!(debug_assertions) && bytes.len() >= 5 {
        panic!(""atou16 accepts up to 4 bytes"");
    }
    if bytes.len() == 0 {
        return Err(Error::InvalidFormat(""Not a number""));
    }
    let mut n = 0;
    for &c in bytes {
        if c < ASCII_0 || ASCII_9 < c {
            return Err(Error::InvalidFormat(""Not a number""));
        }
        n = n * 10 + (c - ASCII_0) as u16;
    }
    Ok(n)
}",0,True,False,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,ctou32 c : u8,"pub fn ctou32(c: u8) -> Result<u32, Error> {
    if c < ASCII_0 || ASCII_9 < c {
        return Err(Error::InvalidFormat(""Not a number""));
    }
    Ok((c - ASCII_0) as u32)
}",0,True,False,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,read8_len,"    fn read8_len() {
        let mut reader = Cursor::new([]);
        assert_err_kind!(read8(&mut reader), ErrorKind::UnexpectedEof);
        let mut reader = Cursor::new([0x01]);
        assert_ok!(read8(&mut reader), 0x01);
        let mut reader = Cursor::new([0x01, 0x02]);
        let mut buf = Vec::new();
        assert_ok!(read8(&mut reader), 0x01);
        assert_ok!(reader.read_to_end(&mut buf), 1);
        assert_eq!(buf, [0x02]);
    }",0,True,False,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,read16_len,"    fn read16_len() {
        let mut reader = Cursor::new([]);
        assert_err_kind!(read16(&mut reader), ErrorKind::UnexpectedEof);
        let mut reader = Cursor::new([0x01]);
        assert_err_kind!(read16(&mut reader), ErrorKind::UnexpectedEof);
        let mut reader = Cursor::new([0x01, 0x02]);
        assert_ok!(read16(&mut reader), 0x0102);
        let mut reader = Cursor::new([0x01, 0x02, 0x03]);
        let mut buf = Vec::new();
        assert_ok!(read16(&mut reader), 0x0102);
        assert_ok!(reader.read_to_end(&mut buf), 1);
        assert_eq!(buf, [0x03]);
    }",0,True,False,
https://github.com/kamadak/exif-rs.git,f21df24616ea611c5d5d0e0e2f8042eb74d5ff48,KAMADA Ken'ichi,2021-01-04 11:06:15+09:00,False,util.rs,Rust,atou16_misc,"    fn atou16_misc() {
        assert_ok!(atou16(b""0""), 0);
        assert_ok!(atou16(b""0010""), 10);
        assert_ok!(atou16(b""9999""), 9999);
        assert_err_pat!(atou16(b""""), Error::InvalidFormat(_));
        assert_err_pat!(atou16(b""/""), Error::InvalidFormat(_));
        assert_err_pat!(atou16(b"":""), Error::InvalidFormat(_));
        assert_err_pat!(atou16(b""-1""), Error::InvalidFormat(_));
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,less.rs,Rust,retrieve_less_version,"pub fn retrieve_less_version() -> Option<usize> {
    let cmd = Command::new(""less"").arg(""--version"").output().ok()?;
    parse_less_version(&cmd.stdout)
}",1,True,False,"1,2"
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,less.rs,Rust,retrieve_less_version,"pub fn retrieve_less_version() -> Option<usize> {
    if let Ok(less_path) = grep_cli::resolve_binary(""less"") {
        let cmd = Command::new(less_path).arg(""--version"").output().ok()?;
        parse_less_version(&cmd.stdout)
    } else {
        None
    }
}",0,False,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,less.rs,Rust,parse_less_version output : & [ u8 ],"fn parse_less_version(output: &[u8]) -> Option<usize> {
    if output.starts_with(b""less "") {
        let version = std::str::from_utf8(&output[5..]).ok()?;
        let end = version.find(|c: char| !c.is_ascii_digit())?;
        version[..end].parse::<usize>().ok()
    } else {
        None
    }
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,less.rs,Rust,test_parse_less_version_487,"fn test_parse_less_version_487() {
    let output = b""less 487 (GNU regular expressions)
Copyright (C) 1984-2016  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Homepage: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(487), parse_less_version(output));
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,less.rs,Rust,test_parse_less_version_529,"fn test_parse_less_version_529() {
    let output = b""less 529 (Spencer V8 regular expressions)
Copyright (C) 1984-2017  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Homepage: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(529), parse_less_version(output));
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,less.rs,Rust,test_parse_less_version_551,"fn test_parse_less_version_551() {
    let output = b""less 551 (PCRE regular expressions)
Copyright (C) 1984-2019  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Home page: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(551), parse_less_version(output));
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,less.rs,Rust,test_parse_less_version_wrong_program,"fn test_parse_less_version_wrong_program() {
    let output = b""more from util-linux 2.34"";

    assert_eq!(None, parse_less_version(output));
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,output.rs,Rust,"try_pager quit_if_one_screen : bool , pager_from_config : Option < String > , config : & config :: Config ,","    fn try_pager(
        quit_if_one_screen: bool,
        pager_from_config: Option<String>,
        config: &config::Config,
    ) -> Result<Self> {
        let mut replace_arguments_to_less = false;

        let pager_from_env = match (
            env::var(""DELTA_PAGER""),
            env::var(""BAT_PAGER""),
            env::var(""PAGER""),
        ) {
            (Ok(delta_pager), _, _) => Some(delta_pager),
            (_, Ok(bat_pager), _) => Some(bat_pager),
            (_, _, Ok(pager)) => {
                // less needs to be called with the '-R' option in order to properly interpret ANSI
                // color sequences. If someone has set PAGER=""less -F"", we therefore need to
                // overwrite the arguments and add '-R'.
                // We only do this for PAGER, since it is used in other contexts.
                replace_arguments_to_less = true;
                Some(pager)
            }
            _ => None,
        };

        if pager_from_config.is_some() {
            replace_arguments_to_less = false;
        }

        let pager = pager_from_config
            .or(pager_from_env)
            .unwrap_or_else(|| String::from(""less""));

        let pagerflags =
            shell_words::split(&pager).chain_err(|| ""Could not parse pager command."")?;

        match pagerflags.split_first() {
            Some((pager_name, args)) => {
                let pager_path = PathBuf::from(pager_name);

                let is_less = pager_path.file_stem() == Some(&OsString::from(""less""));

                let mut process = if is_less {
                    let mut p = Command::new(&pager_path);
                    if args.is_empty() || replace_arguments_to_less {
                        p.args(vec![""--RAW-CONTROL-CHARS""]);

                        // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older
                        // versions of 'less'. Unfortunately, it also breaks mouse-wheel support.
                        //
                        // See: http://www.greenwoodsoftware.com/less/news.530.html
                        //
                        // For newer versions (530 or 558 on Windows), we omit '--no-init' as it
                        // is not needed anymore.
                        match retrieve_less_version() {
                            None => {
                                p.arg(""--no-init"");
                            }
                            Some(version)
                                if (version < 530 || (cfg!(windows) && version < 558)) =>
                            {
                                p.arg(""--no-init"");
                            }
                            _ => {}
                        }

                        if quit_if_one_screen {
                            p.arg(""--quit-if-one-screen"");
                        }
                    } else {
                        p.args(args);
                    }
                    p.env(""LESSCHARSET"", ""UTF-8"");
                    p
                } else {
                    if pager_path.file_stem() == Some(&OsString::from(""delta"")) {
                        eprintln!(
                            ""\
It looks like you have set delta as the value of $PAGER. \
This would result in a non-terminating recursion. \
delta is not an appropriate value for $PAGER \
(but it is an appropriate value for $GIT_PAGER).""
                        );
                        std::process::exit(1);
                    }
                    let mut p = Command::new(&pager_path);
                    p.args(args);
                    p
                };
                if is_less && config.navigate {
                    if let Ok(hist_file) =
                        navigate::copy_less_hist_file_and_append_navigate_regexp(config)
                    {
                        process.env(""LESSHISTFILE"", hist_file);
                        if config.show_themes {
                            process.arg(""+n"");
                        }
                    }
                }
                Ok(process
                    .env(""LESSANSIENDCHARS"", ""mK"")
                    .stdin(Stdio::piped())
                    .spawn()
                    .map(OutputType::Pager)
                    .unwrap_or_else(|_| OutputType::stdout()))
            }
            None => Ok(OutputType::stdout()),
        }
    }",1,True,False,"36,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,75,76,77,78,79,80,81,82,83,84,85,86,87,89,90,91,92,93,94,95,96,97,99,100,101,102,103,104,106,107"
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,output.rs,Rust,"_make_process_from_less_path less_path : PathBuf , args : & [ String ] , replace_arguments_to_less : bool , quit_if_one_screen : bool , config : & config :: Config ,","fn _make_process_from_less_path(
    less_path: PathBuf,
    args: &[String],
    replace_arguments_to_less: bool,
    quit_if_one_screen: bool,
    config: &config::Config,
) -> Option<Command> {
    if let Ok(less_path) = grep_cli::resolve_binary(less_path) {
        let mut p = Command::new(&less_path);
        if args.is_empty() || replace_arguments_to_less {
            p.args(vec![""--RAW-CONTROL-CHARS""]);

            // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older
            // versions of 'less'. Unfortunately, it also breaks mouse-wheel support.
            //
            // See: http://www.greenwoodsoftware.com/less/news.530.html
            //
            // For newer versions (530 or 558 on Windows), we omit '--no-init' as it
            // is not needed anymore.
            match retrieve_less_version() {
                None => {
                    p.arg(""--no-init"");
                }
                Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {
                    p.arg(""--no-init"");
                }
                _ => {}
            }

            if quit_if_one_screen {
                p.arg(""--quit-if-one-screen"");
            }
        } else {
            p.args(args);
        }
        p.env(""LESSCHARSET"", ""UTF-8"");
        p.env(""LESSANSIENDCHARS"", ""mK"");
        if config.navigate {
            if let Ok(hist_file) = navigate::copy_less_hist_file_and_append_navigate_regexp(config)
            {
                p.env(""LESSHISTFILE"", hist_file);
                if config.show_themes {
                    p.arg(""+n"");
                }
            }
        }
        Some(p)
    } else {
        None
    }
}",0,False,True,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,output.rs,Rust,"_make_process_from_pager_path pager_path : PathBuf , args : & [ String ]","fn _make_process_from_pager_path(pager_path: PathBuf, args: &[String]) -> Option<Command> {
    if pager_path.file_stem() == Some(&OsString::from(""delta"")) {
        eprintln!(
            ""\
It looks like you have set delta as the value of $PAGER. \
This would result in a non-terminating recursion. \
delta is not an appropriate value for $PAGER \
(but it is an appropriate value for $GIT_PAGER).""
        );
        std::process::exit(1);
    }
    if let Ok(pager_path) = grep_cli::resolve_binary(pager_path) {
        let mut p = Command::new(&pager_path);
        p.args(args);
        Some(p)
    } else {
        None
    }
}",0,False,True,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,output.rs,Rust,"try_pager quit_if_one_screen : bool , pager_from_config : Option < String > , config : & config :: Config ,","    fn try_pager(
        quit_if_one_screen: bool,
        pager_from_config: Option<String>,
        config: &config::Config,
    ) -> Result<Self> {
        let mut replace_arguments_to_less = false;

        let pager_from_env = match (
            env::var(""DELTA_PAGER""),
            env::var(""BAT_PAGER""),
            env::var(""PAGER""),
        ) {
            (Ok(delta_pager), _, _) => Some(delta_pager),
            (_, Ok(bat_pager), _) => Some(bat_pager),
            (_, _, Ok(pager)) => {
                // less needs to be called with the '-R' option in order to properly interpret ANSI
                // color sequences. If someone has set PAGER=""less -F"", we therefore need to
                // overwrite the arguments and add '-R'.
                // We only do this for PAGER, since it is used in other contexts.
                replace_arguments_to_less = true;
                Some(pager)
            }
            _ => None,
        };

        if pager_from_config.is_some() {
            replace_arguments_to_less = false;
        }

        let pager = pager_from_config
            .or(pager_from_env)
            .unwrap_or_else(|| String::from(""less""));

        let pagerflags =
            shell_words::split(&pager).chain_err(|| ""Could not parse pager command."")?;

        Ok(match pagerflags.split_first() {
            Some((pager_name, args)) => {
                let pager_path = PathBuf::from(pager_name);

                let is_less = pager_path.file_stem() == Some(&OsString::from(""less""));

                let process = if is_less {
                    _make_process_from_less_path(
                        pager_path,
                        args,
                        replace_arguments_to_less,
                        quit_if_one_screen,
                        config,
                    )
                } else {
                    _make_process_from_pager_path(pager_path, args)
                };
                if let Some(mut process) = process {
                    process
                        .stdin(Stdio::piped())
                        .spawn()
                        .map(OutputType::Pager)
                        .unwrap_or_else(|_| OutputType::stdout())
                } else {
                    OutputType::stdout()
                }
            }
            None => OutputType::stdout(),
        })
    }",0,False,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,output.rs,Rust,"from_mode mode : PagingMode , pager : Option < String > , config : & config :: Config ,","    pub fn from_mode(
        mode: PagingMode,
        pager: Option<String>,
        config: &config::Config,
    ) -> Result<Self> {
        use self::PagingMode::*;
        Ok(match mode {
            Always => OutputType::try_pager(false, pager, config)?,
            QuitIfOneScreen => OutputType::try_pager(true, pager, config)?,
            _ => OutputType::stdout(),
        })
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,output.rs,Rust,stdout,"    fn stdout() -> Self {
        OutputType::Stdout(io::stdout())
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,output.rs,Rust,handle & mut self,"    pub fn handle(&mut self) -> Result<&mut dyn Write> {
        Ok(match *self {
            OutputType::Pager(ref mut command) => command
                .stdin
                .as_mut()
                .chain_err(|| ""Could not open stdin for pager"")?,
            OutputType::Stdout(ref mut handle) => handle,
        })
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,output.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        if let OutputType::Pager(ref mut command) = *self {
            let _ = command.wait();
        }
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,"diff minus_file : Option < & PathBuf > , plus_file : Option < & PathBuf > , config : & config :: Config , writer : & mut dyn Write ,","fn diff(
    minus_file: Option<&PathBuf>,
    plus_file: Option<&PathBuf>,
    config: &config::Config,
    writer: &mut dyn Write,
) -> i32 {
    use std::io::BufReader;
    let die = || {
        eprintln!(
            ""\
The main way to use delta is to configure it as the pager for git: \
see https://github.com/dandavison/delta#configuration. \
You can also use delta to diff two files: `delta file_A file_B`.""
        );
        process::exit(config.error_exit_code);
    };
    let diff_command = ""git"";
    let minus_file = minus_file.unwrap_or_else(die);
    let plus_file = plus_file.unwrap_or_else(die);
    let mut diff_process = process::Command::new(PathBuf::from(diff_command))
        .args(&[""diff"", ""--no-index""])
        .args(&[minus_file, plus_file])
        .stdout(process::Stdio::piped())
        .spawn()
        .unwrap_or_else(|err| {
            eprintln!(""Failed to execute the command '{}': {}"", diff_command, err);
            process::exit(config.error_exit_code);
        });

    let exit_code = diff_process
        .wait()
        .unwrap_or_else(|_| {
            delta_unreachable(&format!(""'{}' process not running."", diff_command));
        })
        .code()
        .unwrap_or_else(|| {
            eprintln!(""'{}' process terminated without exit status."", diff_command);
            process::exit(config.error_exit_code);
        });

    if let Err(error) = delta(
        BufReader::new(diff_process.stdout.unwrap()).byte_lines(),
        writer,
        &config,
    ) {
        match error.kind() {
            ErrorKind::BrokenPipe => process::exit(0),
            _ => {
                eprintln!(""{}"", error);
                process::exit(config.error_exit_code);
            }
        }
    };
    exit_code
}",1,True,False,19
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,"diff minus_file : Option < & PathBuf > , plus_file : Option < & PathBuf > , config : & config :: Config , writer : & mut dyn Write ,","fn diff(
    minus_file: Option<&PathBuf>,
    plus_file: Option<&PathBuf>,
    config: &config::Config,
    writer: &mut dyn Write,
) -> i32 {
    use std::io::BufReader;
    let die = || {
        eprintln!(
            ""\
The main way to use delta is to configure it as the pager for git: \
see https://github.com/dandavison/delta#configuration. \
You can also use delta to diff two files: `delta file_A file_B`.""
        );
        process::exit(config.error_exit_code);
    };
    let diff_command = ""git"";
    let minus_file = minus_file.unwrap_or_else(die);
    let plus_file = plus_file.unwrap_or_else(die);
    let diff_command_path = match grep_cli::resolve_binary(PathBuf::from(diff_command)) {
        Ok(path) => path,
        Err(_) => return config.error_exit_code,
    };
    let mut diff_process = process::Command::new(diff_command_path)
        .args(&[""diff"", ""--no-index""])
        .args(&[minus_file, plus_file])
        .stdout(process::Stdio::piped())
        .spawn()
        .unwrap_or_else(|err| {
            eprintln!(""Failed to execute the command '{}': {}"", diff_command, err);
            process::exit(config.error_exit_code);
        });

    let exit_code = diff_process
        .wait()
        .unwrap_or_else(|_| {
            delta_unreachable(&format!(""'{}' process not running."", diff_command));
        })
        .code()
        .unwrap_or_else(|| {
            eprintln!(""'{}' process terminated without exit status."", diff_command);
            process::exit(config.error_exit_code);
        });

    if let Err(error) = delta(
        BufReader::new(diff_process.stdout.unwrap()).byte_lines(),
        writer,
        &config,
    ) {
        match error.kind() {
            ErrorKind::BrokenPipe => process::exit(0),
            _ => {
                eprintln!(""{}"", error);
                process::exit(config.error_exit_code);
            }
        }
    };
    exit_code
}",0,False,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,run_app,"fn run_app() -> std::io::Result<i32> {
    let assets = HighlightingAssets::new();
    let opt = cli::Opt::from_args_and_git_config(&mut git_config::GitConfig::try_create(), assets);

    if opt.list_languages {
        list_languages()?;
        return Ok(0);
    } else if opt.list_syntax_themes {
        list_syntax_themes()?;
        return Ok(0);
    } else if opt.show_syntax_themes {
        show_syntax_themes()?;
        return Ok(0);
    } else if opt.show_themes {
        show_themes(opt.dark, opt.light, opt.computed.is_light_mode)?;
        return Ok(0);
    }

    let _show_config = opt.show_config;
    let config = config::Config::from(opt);

    if _show_config {
        let stdout = io::stdout();
        let mut stdout = stdout.lock();
        show_config(&config, &mut stdout)?;
        return Ok(0);
    }

    let mut output_type =
        OutputType::from_mode(config.paging_mode, config.pager.clone(), &config).unwrap();
    let mut writer = output_type.handle().unwrap();

    if atty::is(atty::Stream::Stdin) {
        let exit_code = diff(
            config.minus_file.as_ref(),
            config.plus_file.as_ref(),
            &config,
            &mut writer,
        );
        return Ok(exit_code);
    }

    if let Err(error) = delta(io::stdin().lock().byte_lines(), &mut writer, &config) {
        match error.kind() {
            ErrorKind::BrokenPipe => return Ok(0),
            _ => eprintln!(""{}"", error),
        }
    };
    Ok(0)
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,main,"fn main() -> std::io::Result<()> {
    let exit_code = run_app()?;
    // when you call process::exit, no destructors are called, so we want to do it only once, here
    process::exit(exit_code);
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,"show_config config : & config :: Config , writer : & mut dyn Write","fn show_config(config: &config::Config, writer: &mut dyn Write) -> std::io::Result<()> {
    // styles first
    writeln!(
        writer,
        ""    commit-style                  = {commit_style}
    file-style                    = {file_style}
    hunk-header-style             = {hunk_header_style}
    minus-style                   = {minus_style}
    minus-non-emph-style          = {minus_non_emph_style}
    minus-emph-style              = {minus_emph_style}
    minus-empty-line-marker-style = {minus_empty_line_marker_style}
    zero-style                    = {zero_style}
    plus-style                    = {plus_style}
    plus-non-emph-style           = {plus_non_emph_style}
    plus-emph-style               = {plus_emph_style}
    plus-empty-line-marker-style  = {plus_empty_line_marker_style}
    whitespace-error-style        = {whitespace_error_style}"",
        commit_style = config.commit_style.to_painted_string(),
        file_style = config.file_style.to_painted_string(),
        hunk_header_style = config.hunk_header_style.to_painted_string(),
        minus_emph_style = config.minus_emph_style.to_painted_string(),
        minus_empty_line_marker_style = config.minus_empty_line_marker_style.to_painted_string(),
        minus_non_emph_style = config.minus_non_emph_style.to_painted_string(),
        minus_style = config.minus_style.to_painted_string(),
        plus_emph_style = config.plus_emph_style.to_painted_string(),
        plus_empty_line_marker_style = config.plus_empty_line_marker_style.to_painted_string(),
        plus_non_emph_style = config.plus_non_emph_style.to_painted_string(),
        plus_style = config.plus_style.to_painted_string(),
        whitespace_error_style = config.whitespace_error_style.to_painted_string(),
        zero_style = config.zero_style.to_painted_string(),
    )?;
    // Everything else
    writeln!(
        writer,
        ""    true-color                    = {true_color}
    file-added-label              = {file_added_label}
    file-modified-label           = {file_modified_label}
    file-removed-label            = {file_removed_label}
    file-renamed-label            = {file_renamed_label}"",
        true_color = config.true_color,
        file_added_label = format_option_value(&config.file_added_label),
        file_modified_label = format_option_value(&config.file_modified_label),
        file_removed_label = format_option_value(&config.file_removed_label),
        file_renamed_label = format_option_value(&config.file_renamed_label),
    )?;
    writeln!(
        writer,
        ""    hyperlinks                    = {hyperlinks}"",
        hyperlinks = config.hyperlinks
    )?;
    if config.hyperlinks {
        writeln!(
            writer,
            ""    hyperlinks-file-link-format   = {hyperlinks_file_link_format}"",
            hyperlinks_file_link_format = format_option_value(&config.hyperlinks_file_link_format),
        )?
    }
    writeln!(
        writer,
        ""    inspect-raw-lines             = {inspect_raw_lines}
    keep-plus-minus-markers       = {keep_plus_minus_markers}"",
        inspect_raw_lines = match config.inspect_raw_lines {
            cli::InspectRawLines::True => ""true"",
            cli::InspectRawLines::False => ""false"",
        },
        keep_plus_minus_markers = config.keep_plus_minus_markers,
    )?;
    writeln!(
        writer,
        ""    line-numbers                  = {line_numbers}"",
        line_numbers = config.line_numbers
    )?;
    if config.line_numbers {
        writeln!(
            writer,
            ""    line-numbers-minus-style      = {line_numbers_minus_style}
    line-numbers-zero-style       = {line_numbers_zero_style}
    line-numbers-plus-style       = {line_numbers_plus_style}
    line-numbers-left-style       = {line_numbers_left_style}
    line-numbers-right-style      = {line_numbers_right_style}
    line-numbers-left-format      = {line_numbers_left_format}
    line-numbers-right-format     = {line_numbers_right_format}"",
            line_numbers_minus_style = config.line_numbers_minus_style.to_painted_string(),
            line_numbers_zero_style = config.line_numbers_zero_style.to_painted_string(),
            line_numbers_plus_style = config.line_numbers_plus_style.to_painted_string(),
            line_numbers_left_style = config.line_numbers_left_style.to_painted_string(),
            line_numbers_right_style = config.line_numbers_right_style.to_painted_string(),
            line_numbers_left_format = format_option_value(&config.line_numbers_left_format),
            line_numbers_right_format = format_option_value(&config.line_numbers_right_format),
        )?
    }
    writeln!(
        writer,
        ""    max-line-distance             = {max_line_distance}
    max-line-length               = {max_line_length}
    navigate                      = {navigate}
    navigate-regexp               = {navigate_regexp}
    pager                         = {pager}
    paging                        = {paging_mode}
    side-by-side                  = {side_by_side}
    syntax-theme                  = {syntax_theme}
    width                         = {width}
    tabs                          = {tab_width}
    word-diff-regex               = {tokenization_regex}"",
        max_line_distance = config.max_line_distance,
        max_line_length = config.max_line_length,
        navigate = config.navigate,
        navigate_regexp = match &config.navigate_regexp {
            None => """".to_string(),
            Some(s) => s.to_string(),
        },
        pager = config.pager.clone().unwrap_or_else(|| ""none"".to_string()),
        paging_mode = match config.paging_mode {
            PagingMode::Always => ""always"",
            PagingMode::Never => ""never"",
            PagingMode::QuitIfOneScreen => ""auto"",
        },
        side_by_side = config.side_by_side,
        syntax_theme = config
            .syntax_theme
            .clone()
            .map(|t| t.name.unwrap_or_else(|| ""none"".to_string()))
            .unwrap_or_else(|| ""none"".to_string()),
        width = match config.decorations_width {
            cli::Width::Fixed(width) => width.to_string(),
            cli::Width::Variable => ""variable"".to_string(),
        },
        tab_width = config.tab_width,
        tokenization_regex = format_option_value(&config.tokenization_regex.to_string()),
    )?;
    Ok(())
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,format_option_value s : S,"fn format_option_value<S>(s: S) -> String
where
    S: AsRef<str>,
{
    let s = s.as_ref();
    if s.ends_with(' ')
        || s.starts_with(' ')
        || s.contains(&['\\', '{', '}', ':'][..])
        || s.is_empty()
    {
        format!(""'{}'"", s)
    } else {
        s.to_string()
    }
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,"show_themes dark : bool , light : bool , computed_theme_is_light : bool","fn show_themes(dark: bool, light: bool, computed_theme_is_light: bool) -> std::io::Result<()> {
    use bytelines::ByteLines;
    use sample_diff::DIFF;
    use std::io::BufReader;
    let mut input = DIFF.to_vec();

    if !atty::is(atty::Stream::Stdin) {
        let mut buf = Vec::new();
        io::stdin().lock().read_to_end(&mut buf)?;
        if !buf.is_empty() {
            input = buf;
        }
    };

    let mut git_config = git_config::GitConfig::try_create();
    let opt = cli::Opt::from_iter_and_git_config(
        &["""", """", ""--navigate"", ""--show-themes""],
        &mut git_config,
    );
    let mut output_type =
        OutputType::from_mode(PagingMode::Always, None, &config::Config::from(opt)).unwrap();
    let title_style = ansi_term::Style::new().bold();
    let writer = output_type.handle().unwrap();

    for theme in &get_themes(git_config::GitConfig::try_create()) {
        let opt =
            cli::Opt::from_iter_and_git_config(&["""", """", ""--features"", &theme], &mut git_config);
        let is_dark_theme = opt.dark;
        let is_light_theme = opt.light;
        let config = config::Config::from(opt);

        if (!computed_theme_is_light && is_dark_theme)
            || (computed_theme_is_light && is_light_theme)
            || (dark && light)
        {
            writeln!(writer, ""\n\nTheme: {}\n"", title_style.paint(theme))?;

            if let Err(error) = delta(ByteLines::new(BufReader::new(&input[0..])), writer, &config)
            {
                match error.kind() {
                    ErrorKind::BrokenPipe => process::exit(0),
                    _ => eprintln!(""{}"", error),
                }
            }
        }
    }

    Ok(())
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,show_syntax_themes,"fn show_syntax_themes() -> std::io::Result<()> {
    let mut opt = cli::Opt::from_args();
    let assets = HighlightingAssets::new();
    let mut output_type = OutputType::from_mode(
        PagingMode::QuitIfOneScreen,
        None,
        &config::Config::from(cli::Opt::default()),
    )
    .unwrap();
    let mut writer = output_type.handle().unwrap();
    opt.computed.syntax_set = assets.syntax_set;

    let stdin_data = if !atty::is(atty::Stream::Stdin) {
        let mut buf = Vec::new();
        io::stdin().lock().read_to_end(&mut buf)?;
        if !buf.is_empty() {
            Some(buf)
        } else {
            None
        }
    } else {
        None
    };

    if !(opt.dark || opt.light) {
        _show_syntax_themes(opt.clone(), false, &mut writer, stdin_data.as_ref())?;
        _show_syntax_themes(opt, true, &mut writer, stdin_data.as_ref())?;
    } else if opt.light {
        _show_syntax_themes(opt, true, &mut writer, stdin_data.as_ref())?;
    } else {
        _show_syntax_themes(opt, false, &mut writer, stdin_data.as_ref())?
    };
    Ok(())
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,"_show_syntax_themes mut opt : cli :: Opt , is_light_mode : bool , writer : & mut dyn Write , stdin : Option < & Vec < u8 > > ,","fn _show_syntax_themes(
    mut opt: cli::Opt,
    is_light_mode: bool,
    writer: &mut dyn Write,
    stdin: Option<&Vec<u8>>,
) -> std::io::Result<()> {
    use bytelines::ByteLines;
    use std::io::BufReader;
    let input = match stdin {
        Some(stdin_data) => &stdin_data[..],
        None => {
            b""\
diff --git a/example.rs b/example.rs
index f38589a..0f1bb83 100644
--- a/example.rs
+++ b/example.rs
@@ -1,5 +1,5 @@
-// Output the square of a number.
-fn print_square(num: f64) {
-    let result = f64::powf(num, 2.0);
-    println!(\""The square of {:.2} is {:.2}.\"", num, result);
+// Output the cube of a number.
+fn print_cube(num: f64) {
+    let result = f64::powf(num, 3.0);
+    println!(\""The cube of {:.2} is {:.2}.\"", num, result);
""
        }
    };

    opt.computed.is_light_mode = is_light_mode;
    let mut config = config::Config::from(opt);
    let title_style = ansi_term::Style::new().bold();
    let assets = HighlightingAssets::new();

    for syntax_theme in assets
        .theme_set
        .themes
        .iter()
        .filter(|(t, _)| is_light_syntax_theme(t) == is_light_mode)
        .map(|(t, _)| t)
    {
        writeln!(writer, ""\n\nTheme: {}\n"", title_style.paint(syntax_theme))?;
        config.syntax_theme = Some(assets.theme_set.themes[syntax_theme.as_str()].clone());
        if let Err(error) = delta(ByteLines::new(BufReader::new(&input[0..])), writer, &config) {
            match error.kind() {
                ErrorKind::BrokenPipe => process::exit(0),
                _ => eprintln!(""{}"", error),
            }
        };
    }
    Ok(())
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,list_syntax_themes,"pub fn list_syntax_themes() -> std::io::Result<()> {
    let stdout = io::stdout();
    let mut stdout = stdout.lock();
    if atty::is(atty::Stream::Stdout) {
        _list_syntax_themes_for_humans(&mut stdout)
    } else {
        _list_syntax_themes_for_machines(&mut stdout)
    }
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,_list_syntax_themes_for_humans writer : & mut dyn Write,"pub fn _list_syntax_themes_for_humans(writer: &mut dyn Write) -> std::io::Result<()> {
    let assets = HighlightingAssets::new();
    let themes = &assets.theme_set.themes;

    writeln!(writer, ""Light themes:"")?;
    for (theme, _) in themes.iter().filter(|(t, _)| is_light_syntax_theme(*t)) {
        writeln!(writer, ""    {}"", theme)?;
    }
    writeln!(writer, ""\nDark themes:"")?;
    for (theme, _) in themes.iter().filter(|(t, _)| !is_light_syntax_theme(*t)) {
        writeln!(writer, ""    {}"", theme)?;
    }
    writeln!(
        writer,
        ""\nUse delta --show-syntax-themes to demo the themes.""
    )?;
    Ok(())
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,_list_syntax_themes_for_machines writer : & mut dyn Write,"pub fn _list_syntax_themes_for_machines(writer: &mut dyn Write) -> std::io::Result<()> {
    let assets = HighlightingAssets::new();
    let themes = &assets.theme_set.themes;
    for (theme, _) in themes
        .iter()
        .sorted_by_key(|(t, _)| is_light_syntax_theme(*t))
    {
        writeln!(
            writer,
            ""{}\t{}"",
            if is_light_syntax_theme(theme) {
                ""light""
            } else {
                ""dark""
            },
            theme
        )?;
    }
    Ok(())
}",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,test_show_config,"    fn test_show_config() {
        let config = integration_test_utils::make_config_from_args(&[]);
        let mut writer = Cursor::new(vec![0; 1024]);
        show_config(&config, &mut writer).unwrap();
        let mut s = String::new();
        writer.seek(SeekFrom::Start(0)).unwrap();
        writer.read_to_string(&mut s).unwrap();
        let s = ansi::strip_ansi_codes(&s);
        assert!(s.contains(""    commit-style                  = raw\n""));
        assert!(s.contains(r""    word-diff-regex               = '\w+'""));
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,test_show_syntax_themes,"    fn test_show_syntax_themes() {
        let opt = integration_test_utils::make_options_from_args(&[]);

        let mut writer = Cursor::new(vec![0; 1024]);
        _show_syntax_themes(opt, true, &mut writer, None).unwrap();
        let mut s = String::new();
        writer.seek(SeekFrom::Start(0)).unwrap();
        writer.read_to_string(&mut s).unwrap();
        let s = ansi::strip_ansi_codes(&s);
        assert!(s.contains(""\nTheme: gruvbox-light\n""));
        println!(""{}"", s);
        assert!(s.contains(""\nfn print_cube(num: f64) {\n""));
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,test_list_syntax_themes_for_humans,"    fn test_list_syntax_themes_for_humans() {
        let mut writer = Cursor::new(vec![0; 512]);
        _list_syntax_themes_for_humans(&mut writer).unwrap();
        let mut s = String::new();
        writer.seek(SeekFrom::Start(0)).unwrap();
        writer.read_to_string(&mut s).unwrap();
        assert!(s.contains(""Light themes:\n""));
        assert!(s.contains(""    GitHub\n""));
        assert!(s.contains(""Dark themes:\n""));
        assert!(s.contains(""    Dracula\n""));
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,test_list_syntax_themes_for_machines,"    fn test_list_syntax_themes_for_machines() {
        let mut writer = Cursor::new(vec![0; 512]);
        _list_syntax_themes_for_machines(&mut writer).unwrap();
        let mut s = String::new();
        writer.seek(SeekFrom::Start(0)).unwrap();
        writer.read_to_string(&mut s).unwrap();
        assert!(s.contains(""light	GitHub\n""));
        assert!(s.contains(""dark	Dracula\n""));
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,test_diff_same_empty_file,"    fn test_diff_same_empty_file() {
        _do_diff_test(""/dev/null"", ""/dev/null"", false);
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,test_diff_same_non_empty_file,"    fn test_diff_same_non_empty_file() {
        _do_diff_test(""/etc/passwd"", ""/etc/passwd"", false);
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,test_diff_empty_vs_non_empty_file,"    fn test_diff_empty_vs_non_empty_file() {
        _do_diff_test(""/dev/null"", ""/etc/passwd"", true);
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,test_diff_two_non_empty_files,"    fn test_diff_two_non_empty_files() {
        _do_diff_test(""/etc/group"", ""/etc/passwd"", true);
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,"_do_diff_test file_a : & str , file_b : & str , expect_diff : bool","    fn _do_diff_test(file_a: &str, file_b: &str, expect_diff: bool) {
        let config = integration_test_utils::make_config_from_args(&[]);
        let mut writer = Cursor::new(vec![]);
        let exit_code = diff(
            Some(&PathBuf::from(file_a)),
            Some(&PathBuf::from(file_b)),
            &config,
            &mut writer,
        );
        assert_eq!(exit_code, if expect_diff { 1 } else { 0 });
    }",0,True,False,
https://github.com/dandavison/delta.git,f01846bd443aaf92fdd5ac20f461beac3f6ee3fd,GitHub,2021-07-10 15:52:06+01:00,False,main.rs,Rust,_read_to_string cursor : & mut Cursor < Vec < u8 > >,"    fn _read_to_string(cursor: &mut Cursor<Vec<u8>>) -> String {
        let mut s = String::new();
        cursor.seek(SeekFrom::Start(0)).unwrap();
        cursor.read_to_string(&mut s).unwrap();
        s
    }",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,less.rs,Rust,retrieve_less_version less_path : & dyn AsRef < OsStr >,"pub fn retrieve_less_version(less_path: &dyn AsRef<OsStr>) -> Option<usize> {
    let cmd = Command::new(less_path).arg(""--version"").output().ok()?;
    parse_less_version(&cmd.stdout)
}",1,True,False,1
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,less.rs,Rust,retrieve_less_version less_path : & dyn AsRef < OsStr >,"pub fn retrieve_less_version(less_path: &dyn AsRef<OsStr>) -> Option<usize> {
    let resolved_path = grep_cli::resolve_binary(less_path.as_ref()).ok()?;

    let cmd = Command::new(resolved_path).arg(""--version"").output().ok()?;
    parse_less_version(&cmd.stdout)
}",0,False,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,less.rs,Rust,parse_less_version output : & [ u8 ],"fn parse_less_version(output: &[u8]) -> Option<usize> {
    if output.starts_with(b""less "") {
        let version = std::str::from_utf8(&output[5..]).ok()?;
        let end = version.find(|c: char| !c.is_ascii_digit())?;
        version[..end].parse::<usize>().ok()
    } else {
        None
    }
}",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,less.rs,Rust,test_parse_less_version_487,"fn test_parse_less_version_487() {
    let output = b""less 487 (GNU regular expressions)
Copyright (C) 1984-2016  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Homepage: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(487), parse_less_version(output));
}",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,less.rs,Rust,test_parse_less_version_529,"fn test_parse_less_version_529() {
    let output = b""less 529 (Spencer V8 regular expressions)
Copyright (C) 1984-2017  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Homepage: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(529), parse_less_version(output));
}",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,less.rs,Rust,test_parse_less_version_551,"fn test_parse_less_version_551() {
    let output = b""less 551 (PCRE regular expressions)
Copyright (C) 1984-2019  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Home page: http://www.greenwoodsoftware.com/less"";

    assert_eq!(Some(551), parse_less_version(output));
}",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,less.rs,Rust,test_parse_less_version_581_2,"fn test_parse_less_version_581_2() {
    let output = b""less 581.2 (PCRE2 regular expressions)
Copyright (C) 1984-2021  Mark Nudelman

less comes with NO WARRANTY, to the extent permitted by law.
For information about the terms of redistribution,
see the file named README in the less distribution.
Home page: https://greenwoodsoftware.com/less"";

    assert_eq!(Some(581), parse_less_version(output));
}",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,less.rs,Rust,test_parse_less_version_wrong_program,"fn test_parse_less_version_wrong_program() {
    let output = b""more from util-linux 2.34"";

    assert_eq!(None, parse_less_version(output));
}",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,output.rs,Rust,"try_pager single_screen_action : SingleScreenAction , wrapping_mode : WrappingMode , pager_from_config : Option < & str > ,","    fn try_pager(
        single_screen_action: SingleScreenAction,
        wrapping_mode: WrappingMode,
        pager_from_config: Option<&str>,
    ) -> Result<Self> {
        use crate::pager::{self, PagerKind, PagerSource};
        use std::process::{Command, Stdio};

        let pager_opt =
            pager::get_pager(pager_from_config).chain_err(|| ""Could not parse pager command."")?;

        let pager = match pager_opt {
            Some(pager) => pager,
            None => return Ok(OutputType::stdout()),
        };

        if pager.kind == PagerKind::Bat {
            return Err(ErrorKind::InvalidPagerValueBat.into());
        }

        let mut p = Command::new(&pager.bin);
        let args = pager.args;

        if pager.kind == PagerKind::Less {
            // less needs to be called with the '-R' option in order to properly interpret the
            // ANSI color sequences printed by bat. If someone has set PAGER=""less -F"", we
            // therefore need to overwrite the arguments and add '-R'.
            //
            // We only do this for PAGER (as it is not specific to 'bat'), not for BAT_PAGER
            // or bats '--pager' command line option.
            let replace_arguments_to_less = pager.source == PagerSource::EnvVarPager;

            if args.is_empty() || replace_arguments_to_less {
                p.arg(""--RAW-CONTROL-CHARS"");
                if single_screen_action == SingleScreenAction::Quit {
                    p.arg(""--quit-if-one-screen"");
                }

                if wrapping_mode == WrappingMode::NoWrapping(true) {
                    p.arg(""--chop-long-lines"");
                }

                // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older
                // versions of 'less'. Unfortunately, it also breaks mouse-wheel support.
                //
                // See: http://www.greenwoodsoftware.com/less/news.530.html
                //
                // For newer versions (530 or 558 on Windows), we omit '--no-init' as it
                // is not needed anymore.
                match retrieve_less_version(&pager.bin) {
                    None => {
                        p.arg(""--no-init"");
                    }
                    Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {
                        p.arg(""--no-init"");
                    }
                    _ => {}
                }
            } else {
                p.args(args);
            }
            p.env(""LESSCHARSET"", ""UTF-8"");
        } else {
            p.args(args);
        };

        Ok(p.stdin(Stdio::piped())
            .spawn()
            .map(OutputType::Pager)
            .unwrap_or_else(|_| OutputType::stdout()))
    }",1,True,False,20
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,output.rs,Rust,"try_pager single_screen_action : SingleScreenAction , wrapping_mode : WrappingMode , pager_from_config : Option < & str > ,","    fn try_pager(
        single_screen_action: SingleScreenAction,
        wrapping_mode: WrappingMode,
        pager_from_config: Option<&str>,
    ) -> Result<Self> {
        use crate::pager::{self, PagerKind, PagerSource};
        use std::process::{Command, Stdio};

        let pager_opt =
            pager::get_pager(pager_from_config).chain_err(|| ""Could not parse pager command."")?;

        let pager = match pager_opt {
            Some(pager) => pager,
            None => return Ok(OutputType::stdout()),
        };

        if pager.kind == PagerKind::Bat {
            return Err(ErrorKind::InvalidPagerValueBat.into());
        }

        let resolved_path = match grep_cli::resolve_binary(&pager.bin) {
            Ok(path) => path,
            Err(_) => {
                return Ok(OutputType::stdout());
            }
        };

        let mut p = Command::new(resolved_path);
        let args = pager.args;

        if pager.kind == PagerKind::Less {
            // less needs to be called with the '-R' option in order to properly interpret the
            // ANSI color sequences printed by bat. If someone has set PAGER=""less -F"", we
            // therefore need to overwrite the arguments and add '-R'.
            //
            // We only do this for PAGER (as it is not specific to 'bat'), not for BAT_PAGER
            // or bats '--pager' command line option.
            let replace_arguments_to_less = pager.source == PagerSource::EnvVarPager;

            if args.is_empty() || replace_arguments_to_less {
                p.arg(""--RAW-CONTROL-CHARS"");
                if single_screen_action == SingleScreenAction::Quit {
                    p.arg(""--quit-if-one-screen"");
                }

                if wrapping_mode == WrappingMode::NoWrapping(true) {
                    p.arg(""--chop-long-lines"");
                }

                // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older
                // versions of 'less'. Unfortunately, it also breaks mouse-wheel support.
                //
                // See: http://www.greenwoodsoftware.com/less/news.530.html
                //
                // For newer versions (530 or 558 on Windows), we omit '--no-init' as it
                // is not needed anymore.
                match retrieve_less_version(&pager.bin) {
                    None => {
                        p.arg(""--no-init"");
                    }
                    Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {
                        p.arg(""--no-init"");
                    }
                    _ => {}
                }
            } else {
                p.args(args);
            }
            p.env(""LESSCHARSET"", ""UTF-8"");
        } else {
            p.args(args);
        };

        Ok(p.stdin(Stdio::piped())
            .spawn()
            .map(OutputType::Pager)
            .unwrap_or_else(|_| OutputType::stdout()))
    }",0,False,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,output.rs,Rust,"from_mode paging_mode : PagingMode , wrapping_mode : WrappingMode , pager : Option < & str > ,","    pub fn from_mode(
        paging_mode: PagingMode,
        wrapping_mode: WrappingMode,
        pager: Option<&str>,
    ) -> Result<Self> {
        use self::PagingMode::*;
        Ok(match paging_mode {
            Always => OutputType::try_pager(SingleScreenAction::Nothing, wrapping_mode, pager)?,
            QuitIfOneScreen => {
                OutputType::try_pager(SingleScreenAction::Quit, wrapping_mode, pager)?
            }
            _ => OutputType::stdout(),
        })
    }",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,output.rs,Rust,stdout,"    pub(crate) fn stdout() -> Self {
        OutputType::Stdout(io::stdout())
    }",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,output.rs,Rust,is_pager & self,"    pub(crate) fn is_pager(&self) -> bool {
        matches!(self, OutputType::Pager(_))
    }",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,output.rs,Rust,is_pager & self,"    pub(crate) fn is_pager(&self) -> bool {
        false
    }",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,output.rs,Rust,handle & mut self,"    pub fn handle(&mut self) -> Result<&mut dyn Write> {
        Ok(match *self {
            #[cfg(feature = ""paging"")]
            OutputType::Pager(ref mut command) => command
                .stdin
                .as_mut()
                .chain_err(|| ""Could not open stdin for pager"")?,
            OutputType::Stdout(ref mut handle) => handle,
        })
    }",0,True,False,
https://github.com/sharkdp/bat.git,bf2b2df9c9e218e35e5a38ce3d03cffb7c363956,David Peter,2021-07-12 23:17:30+02:00,False,output.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        if let OutputType::Pager(ref mut command) = *self {
            let _ = command.wait();
        }
    }",0,True,False,
https://github.com/hyperium/hyper.git,8f93123efef5c1361086688fe4f34c83c89cec02,Sean McArthur,2021-02-05 14:10:02-08:00,False,role.rs,Rust,"parse_headers bytes : & mut BytesMut , ctx : ParseContext < '_>,
) -> ParseResult<T::Incoming>
where
    T: Http1Transaction,
{
    // If the buffer is empty, don' t bother entering the span , it 's just noise.
    if bytes.is_empty() {
        return Ok(None);
    }

    let span = trace_span!(""parse_headers"");
    let _s = span.enter();
    T::parse(bytes, ctx)
}

pub(super) fn encode_headers<T>(
    enc: Encode<' _ , T :: Outgoing > , dst : & mut Vec < u8 > ,","pub(super) fn parse_headers<T>(
    bytes: &mut BytesMut,
    ctx: ParseContext<'_>,
) -> ParseResult<T::Incoming>
where
    T: Http1Transaction,
{
    // If the buffer is empty, don't bother entering the span, it's just noise.
    if bytes.is_empty() {
        return Ok(None);
    }

    let span = trace_span!(""parse_headers"");
    let _s = span.enter();
    T::parse(bytes, ctx)
}

pub(super) fn encode_headers<T>(
    enc: Encode<'_, T::Outgoing>,
    dst: &mut Vec<u8>,
) -> crate::Result<Encoder>
where
    T: Http1Transaction,
{
    let span = trace_span!(""encode_headers"");
    let _s = span.enter();
    T::encode(enc, dst)
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"emit & self ,","    pub fn emit(
        &self,
    ) -> (
        MachBuffer<I>,
        Vec<CodeOffset>,
        Vec<(CodeOffset, CodeOffset)>,
    )
    where
        I: MachInstEmit,
    {
        let _tt = timing::vcode_emit();
        let mut buffer = MachBuffer::new();
        let mut state = I::State::new(&*self.abi);
        let cfg_metadata = self.flags().machine_code_cfg_info();
        let mut bb_starts: Vec<Option<CodeOffset>> = vec![];

        // The first M MachLabels are reserved for block indices, the next N MachLabels for
        // constants.
        buffer.reserve_labels_for_blocks(self.num_blocks() as BlockIndex);
        buffer.reserve_labels_for_constants(&self.constants);

        let mut inst_end_offsets = vec![0; self.insts.len()];
        let mut label_inst_indices = vec![0; self.num_blocks()];

        // Construct the final order we emit code in: cold blocks at the end.
        let mut final_order: SmallVec<[BlockIndex; 16]> = smallvec![];
        let mut cold_blocks: SmallVec<[BlockIndex; 16]> = smallvec![];
        for block in 0..self.num_blocks() {
            let block = block as BlockIndex;
            if self.block_order.is_cold(block) {
                cold_blocks.push(block);
            } else {
                final_order.push(block);
            }
        }
        let first_cold_block = cold_blocks.first().cloned();
        final_order.extend(cold_blocks.clone());

        // Emit blocks.
        let mut safepoint_idx = 0;
        let mut cur_srcloc = None;
        let mut last_offset = None;
        let mut start_of_cold_code = None;
        for block in final_order {
            let new_offset = I::align_basic_block(buffer.cur_offset());
            while new_offset > buffer.cur_offset() {
                // Pad with NOPs up to the aligned block offset.
                let nop = I::gen_nop((new_offset - buffer.cur_offset()) as usize);
                nop.emit(&mut buffer, &self.emit_info, &mut Default::default());
            }
            assert_eq!(buffer.cur_offset(), new_offset);

            if Some(block) == first_cold_block {
                start_of_cold_code = Some(buffer.cur_offset());
            }

            let (start, end) = self.block_ranges[block as usize];
            buffer.bind_label(MachLabel::from_block(block));
            label_inst_indices[block as usize] = start;

            if cfg_metadata {
                // Track BB starts. If we have backed up due to MachBuffer
                // branch opts, note that the removed blocks were removed.
                let cur_offset = buffer.cur_offset();
                if last_offset.is_some() && cur_offset <= last_offset.unwrap() {
                    for i in (0..bb_starts.len()).rev() {
                        if bb_starts[i].is_some() && cur_offset > bb_starts[i].unwrap() {
                            break;
                        }
                        bb_starts[i] = None;
                    }
                }
                bb_starts.push(Some(cur_offset));
                last_offset = Some(cur_offset);
            }

            for iix in start..end {
                let srcloc = self.srclocs[iix as usize];
                if cur_srcloc != Some(srcloc) {
                    if cur_srcloc.is_some() {
                        buffer.end_srcloc();
                    }
                    buffer.start_srcloc(srcloc);
                    cur_srcloc = Some(srcloc);
                }
                state.pre_sourceloc(cur_srcloc.unwrap_or(SourceLoc::default()));

                if safepoint_idx < self.safepoint_insns.len()
                    && self.safepoint_insns[safepoint_idx] == iix
                {
                    if self.safepoint_slots[safepoint_idx].len() > 0 {
                        let stack_map = self.abi.spillslots_to_stack_map(
                            &self.safepoint_slots[safepoint_idx][..],
                            &state,
                        );
                        state.pre_safepoint(stack_map);
                    }
                    safepoint_idx += 1;
                }

                self.insts[iix as usize].emit(&mut buffer, &self.emit_info, &mut state);

                if self.generate_debug_info {
                    // Buffer truncation may have happened since last inst append; trim inst-end
                    // layout info as appropriate.
                    let l = &mut inst_end_offsets[0..iix as usize];
                    for end in l.iter_mut().rev() {
                        if *end > buffer.cur_offset() {
                            *end = buffer.cur_offset();
                        } else {
                            break;
                        }
                    }
                    inst_end_offsets[iix as usize] = buffer.cur_offset();
                }
            }

            if cur_srcloc.is_some() {
                buffer.end_srcloc();
                cur_srcloc = None;
            }

            // Do we need an island? Get the worst-case size of the next BB and see if, having
            // emitted that many bytes, we will be beyond the deadline.
            if block < (self.num_blocks() - 1) as BlockIndex {
                let next_block = block + 1;
                let next_block_range = self.block_ranges[next_block as usize];
                let next_block_size = next_block_range.1 - next_block_range.0;
                let worst_case_next_bb = I::worst_case_size() * next_block_size;
                if buffer.island_needed(worst_case_next_bb) {
                    buffer.emit_island(worst_case_next_bb);
                }
            }
        }

        // Emit the constants used by the function.
        for (constant, data) in self.constants.iter() {
            let label = buffer.get_label_for_constant(constant);
            buffer.defer_constant(label, data.alignment(), data.as_slice(), u32::max_value());
        }

        if self.generate_debug_info {
            for end in inst_end_offsets.iter_mut().rev() {
                if *end > buffer.cur_offset() {
                    *end = buffer.cur_offset();
                } else {
                    break;
                }
            }
            *self.insts_layout.borrow_mut() = InstsLayoutInfo {
                inst_end_offsets,
                label_inst_indices,
                start_of_cold_code,
            };
        }

        // Create `bb_edges` and final (filtered) `bb_starts`.
        let mut final_bb_starts = vec![];
        let mut bb_edges = vec![];
        if cfg_metadata {
            for block in 0..self.num_blocks() {
                if bb_starts[block].is_none() {
                    // Block was deleted by MachBuffer; skip.
                    continue;
                }
                let from = bb_starts[block].unwrap();

                final_bb_starts.push(from);
                // Resolve each `succ` label and add edges.
                let succs = self.block_succs(BlockIx::new(block as u32));
                for succ in succs.iter() {
                    let to = buffer.resolve_label_offset(MachLabel::from_block(succ.get()));
                    bb_edges.push((from, to));
                }
            }
        }

        (buffer, final_bb_starts, bb_edges)
    }",1,True,False,"39,87,88,89,90,91,92,93,94,95,96,97"
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"emit & self ,","    pub fn emit(
        &self,
    ) -> (
        MachBuffer<I>,
        Vec<CodeOffset>,
        Vec<(CodeOffset, CodeOffset)>,
    )
    where
        I: MachInstEmit,
    {
        let _tt = timing::vcode_emit();
        let mut buffer = MachBuffer::new();
        let mut state = I::State::new(&*self.abi);
        let cfg_metadata = self.flags().machine_code_cfg_info();
        let mut bb_starts: Vec<Option<CodeOffset>> = vec![];

        // The first M MachLabels are reserved for block indices, the next N MachLabels for
        // constants.
        buffer.reserve_labels_for_blocks(self.num_blocks() as BlockIndex);
        buffer.reserve_labels_for_constants(&self.constants);

        let mut inst_end_offsets = vec![0; self.insts.len()];
        let mut label_inst_indices = vec![0; self.num_blocks()];

        // Map from instruction index to index in
        // `safepoint_slots`. We need this because we emit
        // instructions out-of-order, while the safepoint_insns /
        // safepoint_slots data structures are sorted in instruction
        // order.
        let mut safepoint_indices: FxHashMap<u32, usize> = FxHashMap::default();
        for (safepoint_idx, iix) in self.safepoint_insns.iter().enumerate() {
            // Disregard safepoints that ended up having no live refs.
            if self.safepoint_slots[safepoint_idx].len() > 0 {
                safepoint_indices.insert(*iix, safepoint_idx);
            }
        }

        // Construct the final order we emit code in: cold blocks at the end.
        let mut final_order: SmallVec<[BlockIndex; 16]> = smallvec![];
        let mut cold_blocks: SmallVec<[BlockIndex; 16]> = smallvec![];
        for block in 0..self.num_blocks() {
            let block = block as BlockIndex;
            if self.block_order.is_cold(block) {
                cold_blocks.push(block);
            } else {
                final_order.push(block);
            }
        }
        let first_cold_block = cold_blocks.first().cloned();
        final_order.extend(cold_blocks.clone());

        // Emit blocks.
        let mut cur_srcloc = None;
        let mut last_offset = None;
        let mut start_of_cold_code = None;
        for block in final_order {
            let new_offset = I::align_basic_block(buffer.cur_offset());
            while new_offset > buffer.cur_offset() {
                // Pad with NOPs up to the aligned block offset.
                let nop = I::gen_nop((new_offset - buffer.cur_offset()) as usize);
                nop.emit(&mut buffer, &self.emit_info, &mut Default::default());
            }
            assert_eq!(buffer.cur_offset(), new_offset);

            if Some(block) == first_cold_block {
                start_of_cold_code = Some(buffer.cur_offset());
            }

            let (start, end) = self.block_ranges[block as usize];
            buffer.bind_label(MachLabel::from_block(block));
            label_inst_indices[block as usize] = start;

            if cfg_metadata {
                // Track BB starts. If we have backed up due to MachBuffer
                // branch opts, note that the removed blocks were removed.
                let cur_offset = buffer.cur_offset();
                if last_offset.is_some() && cur_offset <= last_offset.unwrap() {
                    for i in (0..bb_starts.len()).rev() {
                        if bb_starts[i].is_some() && cur_offset > bb_starts[i].unwrap() {
                            break;
                        }
                        bb_starts[i] = None;
                    }
                }
                bb_starts.push(Some(cur_offset));
                last_offset = Some(cur_offset);
            }

            for iix in start..end {
                let srcloc = self.srclocs[iix as usize];
                if cur_srcloc != Some(srcloc) {
                    if cur_srcloc.is_some() {
                        buffer.end_srcloc();
                    }
                    buffer.start_srcloc(srcloc);
                    cur_srcloc = Some(srcloc);
                }
                state.pre_sourceloc(cur_srcloc.unwrap_or(SourceLoc::default()));

                if let Some(safepoint_idx) = safepoint_indices.get(&iix) {
                    let stack_map = self
                        .abi
                        .spillslots_to_stack_map(&self.safepoint_slots[*safepoint_idx][..], &state);
                    state.pre_safepoint(stack_map);
                }

                self.insts[iix as usize].emit(&mut buffer, &self.emit_info, &mut state);

                if self.generate_debug_info {
                    // Buffer truncation may have happened since last inst append; trim inst-end
                    // layout info as appropriate.
                    let l = &mut inst_end_offsets[0..iix as usize];
                    for end in l.iter_mut().rev() {
                        if *end > buffer.cur_offset() {
                            *end = buffer.cur_offset();
                        } else {
                            break;
                        }
                    }
                    inst_end_offsets[iix as usize] = buffer.cur_offset();
                }
            }

            if cur_srcloc.is_some() {
                buffer.end_srcloc();
                cur_srcloc = None;
            }

            // Do we need an island? Get the worst-case size of the next BB and see if, having
            // emitted that many bytes, we will be beyond the deadline.
            if block < (self.num_blocks() - 1) as BlockIndex {
                let next_block = block + 1;
                let next_block_range = self.block_ranges[next_block as usize];
                let next_block_size = next_block_range.1 - next_block_range.0;
                let worst_case_next_bb = I::worst_case_size() * next_block_size;
                if buffer.island_needed(worst_case_next_bb) {
                    buffer.emit_island(worst_case_next_bb);
                }
            }
        }

        // Emit the constants used by the function.
        for (constant, data) in self.constants.iter() {
            let label = buffer.get_label_for_constant(constant);
            buffer.defer_constant(label, data.alignment(), data.as_slice(), u32::max_value());
        }

        if self.generate_debug_info {
            for end in inst_end_offsets.iter_mut().rev() {
                if *end > buffer.cur_offset() {
                    *end = buffer.cur_offset();
                } else {
                    break;
                }
            }
            *self.insts_layout.borrow_mut() = InstsLayoutInfo {
                inst_end_offsets,
                label_inst_indices,
                start_of_cold_code,
            };
        }

        // Create `bb_edges` and final (filtered) `bb_starts`.
        let mut final_bb_starts = vec![];
        let mut bb_edges = vec![];
        if cfg_metadata {
            for block in 0..self.num_blocks() {
                if bb_starts[block].is_none() {
                    // Block was deleted by MachBuffer; skip.
                    continue;
                }
                let from = bb_starts[block].unwrap();

                final_bb_starts.push(from);
                // Resolve each `succ` label and add edges.
                let succs = self.block_succs(BlockIx::new(block as u32));
                for succ in succs.iter() {
                    let to = buffer.resolve_label_offset(MachLabel::from_block(succ.get()));
                    bb_edges.push((from, to));
                }
            }
        }

        (buffer, final_bb_starts, bb_edges)
    }",0,False,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"new abi : Box < dyn ABICallee < I = I > > , emit_info : I :: Info , block_order : BlockLoweringOrder , constants : VCodeConstants ,","    pub fn new(
        abi: Box<dyn ABICallee<I = I>>,
        emit_info: I::Info,
        block_order: BlockLoweringOrder,
        constants: VCodeConstants,
    ) -> VCodeBuilder<I> {
        let reftype_class = I::ref_type_regclass(abi.flags());
        let vcode = VCode::new(
            abi,
            emit_info,
            block_order,
            constants,
            /* generate_debug_info = */ true,
        );
        let stack_map_info = StackmapRequestInfo {
            reftype_class,
            reftyped_vregs: vec![],
            safepoint_insns: vec![],
        };

        VCodeBuilder {
            vcode,
            stack_map_info,
            block_start: 0,
            succ_start: 0,
            cur_srcloc: SourceLoc::default(),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,abi & mut self,"    pub fn abi(&mut self) -> &mut dyn ABICallee<I = I> {
        &mut *self.vcode.abi
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,block_order & self,"    pub fn block_order(&self) -> &BlockLoweringOrder {
        &self.vcode.block_order
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"set_vreg_type & mut self , vreg : VirtualReg , ty : Type","    pub fn set_vreg_type(&mut self, vreg: VirtualReg, ty: Type) {
        if self.vcode.vreg_types.len() <= vreg.get_index() {
            self.vcode
                .vreg_types
                .resize(vreg.get_index() + 1, ir::types::I8);
        }
        self.vcode.vreg_types[vreg.get_index()] = ty;
        if is_reftype(ty) {
            self.stack_map_info.reftyped_vregs.push(vreg);
            self.vcode.have_ref_values = true;
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"set_entry & mut self , block : BlockIndex","    pub fn set_entry(&mut self, block: BlockIndex) {
        self.vcode.entry = block;
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,end_bb & mut self,"    pub fn end_bb(&mut self) {
        let start_idx = self.block_start;
        let end_idx = self.vcode.insts.len() as InsnIndex;
        self.block_start = end_idx;
        // Add the instruction index range to the list of blocks.
        self.vcode.block_ranges.push((start_idx, end_idx));
        // End the successors list.
        let succ_end = self.vcode.block_succs.len();
        self.vcode
            .block_succ_range
            .push((self.succ_start, succ_end));
        self.succ_start = succ_end;
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"push & mut self , insn : I , is_safepoint : bool","    pub fn push(&mut self, insn: I, is_safepoint: bool) {
        match insn.is_term() {
            MachTerminator::None | MachTerminator::Ret => {}
            MachTerminator::Uncond(target) => {
                self.vcode.block_succs.push(BlockIx::new(target.get()));
            }
            MachTerminator::Cond(true_branch, false_branch) => {
                self.vcode.block_succs.push(BlockIx::new(true_branch.get()));
                self.vcode
                    .block_succs
                    .push(BlockIx::new(false_branch.get()));
            }
            MachTerminator::Indirect(targets) => {
                for target in targets {
                    self.vcode.block_succs.push(BlockIx::new(target.get()));
                }
            }
        }
        if insn.defines_value_label().is_some() {
            self.vcode.has_value_labels = true;
        }
        self.vcode.insts.push(insn);
        self.vcode.srclocs.push(self.cur_srcloc);
        if is_safepoint {
            self.stack_map_info
                .safepoint_insns
                .push(InstIx::new((self.vcode.insts.len() - 1) as u32));
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"set_srcloc & mut self , srcloc : SourceLoc","    pub fn set_srcloc(&mut self, srcloc: SourceLoc) {
        self.cur_srcloc = srcloc;
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,constants & mut self,"    pub fn constants(&mut self) -> &mut VCodeConstants {
        &mut self.vcode.constants
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,build self,"    pub fn build(self) -> (VCode<I>, StackmapRequestInfo) {
        // TODO: come up with an abstraction for ""vcode and auxiliary data"". The
        // auxiliary data needs to be separate from the vcode so that it can be
        // referenced as the vcode is mutated (e.g. by the register allocator).
        (self.vcode, self.stack_map_info)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,is_redundant_move insn : & I,"fn is_redundant_move<I: VCodeInst>(insn: &I) -> bool {
    if let Some((to, from)) = insn.is_move() {
        to.to_reg() == from
    } else {
        false
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,is_reftype ty : Type,"fn is_reftype(ty: Type) -> bool {
    ty == types::R64 || ty == types::R32
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"new abi : Box < dyn ABICallee < I = I > > , emit_info : I :: Info , block_order : BlockLoweringOrder , constants : VCodeConstants , generate_debug_info : bool ,","    fn new(
        abi: Box<dyn ABICallee<I = I>>,
        emit_info: I::Info,
        block_order: BlockLoweringOrder,
        constants: VCodeConstants,
        generate_debug_info: bool,
    ) -> VCode<I> {
        VCode {
            liveins: abi.liveins(),
            liveouts: abi.liveouts(),
            vreg_types: vec![],
            have_ref_values: false,
            insts: vec![],
            srclocs: vec![],
            entry: 0,
            block_ranges: vec![],
            block_succ_range: vec![],
            block_succs: vec![],
            block_order,
            abi,
            emit_info,
            safepoint_insns: vec![],
            safepoint_slots: vec![],
            generate_debug_info,
            insts_layout: RefCell::new(Default::default()),
            constants,
            has_value_labels: false,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,flags & self,"    pub fn flags(&self) -> &settings::Flags {
        self.abi.flags()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"vreg_type & self , vreg : VirtualReg","    pub fn vreg_type(&self, vreg: VirtualReg) -> Type {
        self.vreg_types[vreg.get_index()]
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,num_blocks & self,"    pub fn num_blocks(&self) -> usize {
        self.block_ranges.len()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,frame_size & self,"    pub fn frame_size(&self) -> u32 {
        self.abi.frame_size()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"succs & self , block : BlockIndex","    pub fn succs(&self, block: BlockIndex) -> &[BlockIx] {
        let (start, end) = self.block_succ_range[block as usize];
        &self.block_succs[start..end]
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"replace_insns_from_regalloc & mut self , result : RegAllocResult < Self >","    pub fn replace_insns_from_regalloc(&mut self, result: RegAllocResult<Self>) {
        // Record the spillslot count and clobbered registers for the ABI/stack
        // setup code.
        self.abi.set_num_spillslots(result.num_spill_slots as usize);
        self.abi
            .set_clobbered(result.clobbered_registers.map(|r| Writable::from_reg(*r)));

        let mut final_insns = vec![];
        let mut final_block_ranges = vec![(0, 0); self.num_blocks()];
        let mut final_srclocs = vec![];
        let mut final_safepoint_insns = vec![];
        let mut safept_idx = 0;

        assert!(result.target_map.elems().len() == self.num_blocks());
        for block in 0..self.num_blocks() {
            let start = result.target_map.elems()[block].get() as usize;
            let end = if block == self.num_blocks() - 1 {
                result.insns.len()
            } else {
                result.target_map.elems()[block + 1].get() as usize
            };
            let block = block as BlockIndex;
            let final_start = final_insns.len() as InsnIndex;

            if block == self.entry {
                // Start with the prologue.
                let prologue = self.abi.gen_prologue();
                let len = prologue.len();
                final_insns.extend(prologue.into_iter());
                final_srclocs.extend(iter::repeat(SourceLoc::default()).take(len));
            }

            for i in start..end {
                let insn = &result.insns[i];

                // Elide redundant moves at this point (we only know what is
                // redundant once registers are allocated).
                if is_redundant_move(insn) {
                    continue;
                }

                // Is there a srcloc associated with this insn? Look it up based on original
                // instruction index (if new insn corresponds to some original insn, i.e., is not
                // an inserted load/spill/move).
                let orig_iix = result.orig_insn_map[InstIx::new(i as u32)];
                let srcloc = if orig_iix.is_invalid() {
                    SourceLoc::default()
                } else {
                    self.srclocs[orig_iix.get() as usize]
                };

                // Whenever encountering a return instruction, replace it
                // with the epilogue.
                let is_ret = insn.is_term() == MachTerminator::Ret;
                if is_ret {
                    let epilogue = self.abi.gen_epilogue();
                    let len = epilogue.len();
                    final_insns.extend(epilogue.into_iter());
                    final_srclocs.extend(iter::repeat(srcloc).take(len));
                } else {
                    final_insns.push(insn.clone());
                    final_srclocs.push(srcloc);
                }

                // Was this instruction a safepoint instruction? Add its final
                // index to the safepoint insn-index list if so.
                if safept_idx < result.new_safepoint_insns.len()
                    && (result.new_safepoint_insns[safept_idx].get() as usize) == i
                {
                    let idx = final_insns.len() - 1;
                    final_safepoint_insns.push(idx as InsnIndex);
                    safept_idx += 1;
                }
            }

            let final_end = final_insns.len() as InsnIndex;
            final_block_ranges[block as usize] = (final_start, final_end);
        }

        debug_assert!(final_insns.len() == final_srclocs.len());

        self.insts = final_insns;
        self.srclocs = final_srclocs;
        self.block_ranges = final_block_ranges;
        self.safepoint_insns = final_safepoint_insns;

        // Save safepoint slot-lists. These will be passed to the `EmitState`
        // for the machine backend during emission so that it can do
        // target-specific translations of slot numbers to stack offsets.
        self.safepoint_slots = result.stackmaps;
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,value_labels_ranges & self,"    pub fn value_labels_ranges(&self) -> ValueLabelsRanges {
        if !self.has_value_labels {
            return ValueLabelsRanges::default();
        }

        let layout_info = &self.insts_layout.borrow();
        debug::compute(&self.insts, &*layout_info)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,stackslot_offsets & self,"    pub fn stackslot_offsets(&self) -> &PrimaryMap<StackSlot, u32> {
        self.abi.stackslot_offsets()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"bindex_to_bb & self , block : BlockIndex","    pub fn bindex_to_bb(&self, block: BlockIndex) -> Option<ir::Block> {
        self.block_order.lowered_order()[block as usize].orig_block()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,insns & self,"    fn insns(&self) -> &[I] {
        &self.insts[..]
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,insns_mut & mut self,"    fn insns_mut(&mut self) -> &mut [I] {
        &mut self.insts[..]
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"get_insn & self , insn : InstIx","    fn get_insn(&self, insn: InstIx) -> &I {
        &self.insts[insn.get() as usize]
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"get_insn_mut & mut self , insn : InstIx","    fn get_insn_mut(&mut self, insn: InstIx) -> &mut I {
        &mut self.insts[insn.get() as usize]
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,blocks & self,"    fn blocks(&self) -> Range<BlockIx> {
        Range::new(BlockIx::new(0), self.block_ranges.len())
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,entry_block & self,"    fn entry_block(&self) -> BlockIx {
        BlockIx::new(self.entry)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"block_insns & self , block : BlockIx","    fn block_insns(&self, block: BlockIx) -> Range<InstIx> {
        let (start, end) = self.block_ranges[block.get() as usize];
        Range::new(InstIx::new(start), (end - start) as usize)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"block_succs & self , block : BlockIx","    fn block_succs(&self, block: BlockIx) -> Cow<[BlockIx]> {
        let (start, end) = self.block_succ_range[block.get() as usize];
        Cow::Borrowed(&self.block_succs[start..end])
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"is_ret & self , insn : InstIx","    fn is_ret(&self, insn: InstIx) -> bool {
        match self.insts[insn.get() as usize].is_term() {
            MachTerminator::Ret => true,
            _ => false,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"is_included_in_clobbers & self , insn : & I","    fn is_included_in_clobbers(&self, insn: &I) -> bool {
        insn.is_included_in_clobbers()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"get_regs insn : & I , collector : & mut RegUsageCollector","    fn get_regs(insn: &I, collector: &mut RegUsageCollector) {
        insn.get_regs(collector)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"map_regs insn : & mut I , mapper : & RUM","    fn map_regs<RUM: RegUsageMapper>(insn: &mut I, mapper: &RUM) {
        insn.map_regs(mapper);
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"is_move & self , insn : & I","    fn is_move(&self, insn: &I) -> Option<(Writable<Reg>, Reg)> {
        insn.is_move()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,get_num_vregs & self,"    fn get_num_vregs(&self) -> usize {
        self.vreg_types.len()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"get_spillslot_size & self , regclass : RegClass , _ : VirtualReg","    fn get_spillslot_size(&self, regclass: RegClass, _: VirtualReg) -> u32 {
        self.abi.get_spillslot_size(regclass)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"gen_spill & self , to_slot : SpillSlot , from_reg : RealReg , _ : Option < VirtualReg >","    fn gen_spill(&self, to_slot: SpillSlot, from_reg: RealReg, _: Option<VirtualReg>) -> I {
        self.abi.gen_spill(to_slot, from_reg)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"gen_reload & self , to_reg : Writable < RealReg > , from_slot : SpillSlot , _ : Option < VirtualReg > ,","    fn gen_reload(
        &self,
        to_reg: Writable<RealReg>,
        from_slot: SpillSlot,
        _: Option<VirtualReg>,
    ) -> I {
        self.abi.gen_reload(to_reg, from_slot)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"gen_move & self , to_reg : Writable < RealReg > , from_reg : RealReg , vreg : VirtualReg","    fn gen_move(&self, to_reg: Writable<RealReg>, from_reg: RealReg, vreg: VirtualReg) -> I {
        let ty = self.vreg_type(vreg);
        I::gen_move(to_reg.map(|r| r.to_reg()), from_reg.to_reg(), ty)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,gen_zero_len_nop & self,"    fn gen_zero_len_nop(&self) -> I {
        I::gen_nop(0)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"maybe_direct_reload & self , insn : & I , reg : VirtualReg , slot : SpillSlot","    fn maybe_direct_reload(&self, insn: &I, reg: VirtualReg, slot: SpillSlot) -> Option<I> {
        insn.maybe_direct_reload(reg, slot)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,func_liveins & self,"    fn func_liveins(&self) -> RegallocSet<RealReg> {
        self.liveins.clone()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,func_liveouts & self,"    fn func_liveouts(&self) -> RegallocSet<RealReg> {
        self.liveouts.clone()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"fmt & self , f : & mut fmt :: Formatter","    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, ""VCode_Debug {{"")?;
        writeln!(f, ""  Entry block: {}"", self.entry)?;

        for block in 0..self.num_blocks() {
            writeln!(f, ""Block {}:"", block,)?;
            for succ in self.succs(block as BlockIndex) {
                writeln!(f, ""  (successor: Block {})"", succ.get())?;
            }
            let (start, end) = self.block_ranges[block];
            writeln!(f, ""  (instruction range: {} .. {})"", start, end)?;
            for inst in start..end {
                writeln!(f, ""  Inst {}: {:?}"", inst, self.insts[inst as usize])?;
            }
        }

        writeln!(f, ""}}"")?;
        Ok(())
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"show_rru & self , mb_rru : Option < & RealRegUniverse >","    fn show_rru(&self, mb_rru: Option<&RealRegUniverse>) -> String {
        use std::fmt::Write;

        let mut s = String::new();
        write!(&mut s, ""VCode_ShowWithRRU {{{{\n"").unwrap();
        write!(&mut s, ""  Entry block: {}\n"", self.entry).unwrap();

        let mut state = Default::default();
        let mut safepoint_idx = 0;
        for i in 0..self.num_blocks() {
            let block = i as BlockIndex;

            write!(&mut s, ""Block {}:\n"", block).unwrap();
            if let Some(bb) = self.bindex_to_bb(block) {
                write!(&mut s, ""  (original IR block: {})\n"", bb).unwrap();
            }
            for succ in self.succs(block) {
                write!(&mut s, ""  (successor: Block {})\n"", succ.get()).unwrap();
            }
            let (start, end) = self.block_ranges[block as usize];
            write!(&mut s, ""  (instruction range: {} .. {})\n"", start, end).unwrap();
            for inst in start..end {
                if safepoint_idx < self.safepoint_insns.len()
                    && self.safepoint_insns[safepoint_idx] == inst
                {
                    write!(
                        &mut s,
                        ""      (safepoint: slots {:?} with EmitState {:?})\n"",
                        self.safepoint_slots[safepoint_idx], state,
                    )
                    .unwrap();
                    safepoint_idx += 1;
                }
                write!(
                    &mut s,
                    ""  Inst {}:   {}\n"",
                    inst,
                    self.insts[inst as usize].pretty_print(mb_rru, &mut state)
                )
                .unwrap();
            }
        }

        write!(&mut s, ""}}}}\n"").unwrap();

        s
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,with_capacity expected_num_constants : usize,"    pub fn with_capacity(expected_num_constants: usize) -> Self {
        Self {
            constants: PrimaryMap::with_capacity(expected_num_constants),
            pool_uses: HashMap::with_capacity(expected_num_constants),
            well_known_uses: HashMap::new(),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,"insert & mut self , data : VCodeConstantData","    pub fn insert(&mut self, data: VCodeConstantData) -> VCodeConstant {
        match data {
            VCodeConstantData::Generated(_) => self.constants.push(data),
            VCodeConstantData::Pool(constant, _) => match self.pool_uses.get(&constant) {
                None => {
                    let vcode_constant = self.constants.push(data);
                    self.pool_uses.insert(constant, vcode_constant);
                    vcode_constant
                }
                Some(&vcode_constant) => vcode_constant,
            },
            VCodeConstantData::WellKnown(data_ref) => {
                match self.well_known_uses.get(&(data_ref as *const [u8])) {
                    None => {
                        let vcode_constant = self.constants.push(data);
                        self.well_known_uses
                            .insert(data_ref as *const [u8], vcode_constant);
                        vcode_constant
                    }
                    Some(&vcode_constant) => vcode_constant,
                }
            }
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,len & self,"    pub fn len(&self) -> usize {
        self.constants.len()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,keys & self,"    pub fn keys(&self) -> Keys<VCodeConstant> {
        self.constants.keys()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,vcode.rs,Rust,iter & self,"    pub fn iter(&self) -> impl Iterator<Item = (VCodeConstant, &VCodeConstantData)> {
        self.constants.iter()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,funcref.rs,Rust,pass_funcref_in_and_out_of_wasm,"fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (func (export ""func"") (param funcref) (result funcref)
                    local.get 0
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let func = instance.get_func(&mut store, ""func"").unwrap();

    // Pass in a non-null funcref.
    {
        let mut results = [Val::I32(0)];
        func.call(
            &mut store,
            &[Val::FuncRef(Some(func.clone()))],
            &mut results,
        )?;

        // Can't compare `Func` for equality, so this is the best we can do here.
        let result_func = results[0].unwrap_funcref().unwrap();
        assert_eq!(func.ty(&store), result_func.ty(&store));
    }

    // Pass in a null funcref.
    {
        let mut results = [Val::I32(0)];
        func.call(&mut store, &[Val::FuncRef(None)], &mut results)?;
        let result_func = results[0].unwrap_funcref();
        assert!(result_func.is_none());
    }

    // Pass in a `funcref` from another instance.
    {
        let other_instance = Instance::new(&mut store, &module, &[])?;
        let other_instance_func = other_instance.get_func(&mut store, ""func"").unwrap();

        let mut results = [Val::I32(0)];
        func.call(
            &mut store,
            &[Val::FuncRef(Some(other_instance_func.clone()))],
            &mut results,
        )?;
        assert_eq!(results.len(), 1);

        // Can't compare `Func` for equality, so this is the best we can do here.
        let result_func = results[0].unwrap_funcref().unwrap();
        assert_eq!(other_instance_func.ty(&store), result_func.ty(&store));
    }

    // Passing in a `funcref` from another store fails.
    {
        let (mut other_store, other_module) = ref_types_module(r#""(module (func (export ""f"")))""#)?;
        let other_store_instance = Instance::new(&mut other_store, &other_module, &[])?;
        let f = other_store_instance
            .get_func(&mut other_store, ""f"")
            .unwrap();

        assert!(func
            .call(&mut store, &[Val::FuncRef(Some(f))], &mut [Val::I32(0)])
            .is_err());
    }

    Ok(())
}",1,True,False,56
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,funcref.rs,Rust,receive_null_funcref_from_wasm,"fn receive_null_funcref_from_wasm() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (func (export ""get-null"") (result funcref)
                    ref.null func
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let get_null = instance.get_func(&mut store, ""get-null"").unwrap();

    let mut results = [Val::I32(0)];
    get_null.call(&mut store, &[], &mut results)?;
    let result_func = results[0].unwrap_funcref();
    assert!(result_func.is_none());

    Ok(())
}",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,funcref.rs,Rust,pass_funcref_in_and_out_of_wasm,"fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        false,
        r#""
            (module
                (func (export ""func"") (param funcref) (result funcref)
                    local.get 0
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let func = instance.get_func(&mut store, ""func"").unwrap();

    // Pass in a non-null funcref.
    {
        let mut results = [Val::I32(0)];
        func.call(
            &mut store,
            &[Val::FuncRef(Some(func.clone()))],
            &mut results,
        )?;

        // Can't compare `Func` for equality, so this is the best we can do here.
        let result_func = results[0].unwrap_funcref().unwrap();
        assert_eq!(func.ty(&store), result_func.ty(&store));
    }

    // Pass in a null funcref.
    {
        let mut results = [Val::I32(0)];
        func.call(&mut store, &[Val::FuncRef(None)], &mut results)?;
        let result_func = results[0].unwrap_funcref();
        assert!(result_func.is_none());
    }

    // Pass in a `funcref` from another instance.
    {
        let other_instance = Instance::new(&mut store, &module, &[])?;
        let other_instance_func = other_instance.get_func(&mut store, ""func"").unwrap();

        let mut results = [Val::I32(0)];
        func.call(
            &mut store,
            &[Val::FuncRef(Some(other_instance_func.clone()))],
            &mut results,
        )?;
        assert_eq!(results.len(), 1);

        // Can't compare `Func` for equality, so this is the best we can do here.
        let result_func = results[0].unwrap_funcref().unwrap();
        assert_eq!(other_instance_func.ty(&store), result_func.ty(&store));
    }

    // Passing in a `funcref` from another store fails.
    {
        let (mut other_store, other_module) =
            ref_types_module(false, r#""(module (func (export ""f"")))""#)?;
        let other_store_instance = Instance::new(&mut other_store, &other_module, &[])?;
        let f = other_store_instance
            .get_func(&mut other_store, ""f"")
            .unwrap();

        assert!(func
            .call(&mut store, &[Val::FuncRef(Some(f))], &mut [Val::I32(0)])
            .is_err());
    }

    Ok(())
}",0,False,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,funcref.rs,Rust,receive_null_funcref_from_wasm,"fn receive_null_funcref_from_wasm() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        false,
        r#""
            (module
                (func (export ""get-null"") (result funcref)
                    ref.null func
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let get_null = instance.get_func(&mut store, ""get-null"").unwrap();

    let mut results = [Val::I32(0)];
    get_null.call(&mut store, &[], &mut results)?;
    let result_func = results[0].unwrap_funcref();
    assert!(result_func.is_none());

    Ok(())
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,funcref.rs,Rust,drop & mut self,"        fn drop(&mut self) {
            self.0.store(true, SeqCst);
        }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,funcref.rs,Rust,wrong_store,"fn wrong_store() -> anyhow::Result<()> {
    let dropped = Arc::new(AtomicBool::new(false));
    {
        let mut store1 = Store::<()>::default();
        let mut store2 = Store::<()>::default();

        let set = SetOnDrop(dropped.clone());
        let f1 = Func::wrap(&mut store1, move || drop(&set));
        let f2 = Func::wrap(&mut store2, move || Some(f1.clone()));
        assert!(f2.call(&mut store2, &[], &mut []).is_err());
    }
    assert!(dropped.load(SeqCst));

    return Ok(());

    struct SetOnDrop(Arc<AtomicBool>);

    impl Drop for SetOnDrop {
        fn drop(&mut self) {
            self.0.store(true, SeqCst);
        }
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,funcref.rs,Rust,drop & mut self,"        fn drop(&mut self) {
            self.0.store(true, SeqCst);
        }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,funcref.rs,Rust,func_new_returns_wrong_store,"fn func_new_returns_wrong_store() -> anyhow::Result<()> {
    let dropped = Arc::new(AtomicBool::new(false));
    {
        let mut store1 = Store::<()>::default();
        let mut store2 = Store::<()>::default();

        let set = SetOnDrop(dropped.clone());
        let f1 = Func::wrap(&mut store1, move || drop(&set));
        let f2 = Func::new(
            &mut store2,
            FuncType::new(None, Some(ValType::FuncRef)),
            move |_, _, results| {
                results[0] = f1.clone().into();
                Ok(())
            },
        );
        assert!(f2.call(&mut store2, &[], &mut [Val::I32(0)]).is_err());
    }
    assert!(dropped.load(SeqCst));

    return Ok(());

    struct SetOnDrop(Arc<AtomicBool>);

    impl Drop for SetOnDrop {
        fn drop(&mut self) {
            self.0.store(true, SeqCst);
        }
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,many_live_refs,"fn many_live_refs() -> anyhow::Result<()> {
    let mut wat = r#""
        (module
            ;; Make new `externref`s.
            (import """" ""make_ref"" (func $make_ref (result externref)))

            ;; Observe an `externref` so it is kept live.
            (import """" ""observe_ref"" (func $observe_ref (param externref)))

            (func (export ""many_live_refs"")
    ""#
    .to_string();

    // This is more than the initial `VMExternRefActivationsTable` capacity, so
    // it will need to allocate additional bump chunks.
    const NUM_LIVE_REFS: usize = 1024;

    // Push `externref`s onto the stack.
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $make_ref)\n"");
    }

    // Pop `externref`s from the stack. Because we pass each of them to a
    // function call here, they are all live references for the duration of
    // their lifetimes.
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $observe_ref)\n"");
    }

    wat.push_str(
        ""
            ) ;; func
        ) ;; module
        "",
    );

    let (mut store, module) = ref_types_module(&wat)?;

    let live_refs = Arc::new(AtomicUsize::new(0));

    let make_ref = Func::wrap(&mut store, {
        let live_refs = live_refs.clone();
        move || Some(ExternRef::new(CountLiveRefs::new(live_refs.clone())))
    });

    let observe_ref = Func::wrap(&mut store, |r: Option<ExternRef>| {
        let r = r.unwrap();
        let r = r.data().downcast_ref::<CountLiveRefs>().unwrap();
        assert!(r.live_refs.load(SeqCst) > 0);
    });

    let instance = Instance::new(&mut store, &module, &[make_ref.into(), observe_ref.into()])?;
    let many_live_refs = instance.get_func(&mut store, ""many_live_refs"").unwrap();

    many_live_refs.call(&mut store, &[], &mut [])?;

    store.gc();
    assert_eq!(live_refs.load(SeqCst), 0);

    return Ok(());

    struct CountLiveRefs {
        live_refs: Arc<AtomicUsize>,
    }

    impl CountLiveRefs {
        fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }
    }

    impl Drop for CountLiveRefs {
        fn drop(&mut self) {
            self.live_refs.fetch_sub(1, SeqCst);
        }
    }
}",1,True,False,36
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,smoke_test_gc,"fn smoke_test_gc() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (import """" """" (func $do_gc))
                (func $recursive (export ""func"") (param i32 externref) (result externref)
                    local.get 0
                    i32.eqz
                    if (result externref)
                        call $do_gc
                        local.get 1
                    else
                        local.get 0
                        i32.const 1
                        i32.sub
                        local.get 1
                        call $recursive
                    end
                )
            )
        ""#,
    )?;

    let do_gc = Func::wrap(&mut store, |mut caller: Caller<'_, _>| {
        // Do a GC with `externref`s on the stack in Wasm frames.
        caller.gc();
    });
    let instance = Instance::new(&mut store, &module, &[do_gc.into()])?;
    let func = instance.get_func(&mut store, ""func"").unwrap();

    let inner_dropped = Arc::new(AtomicBool::new(false));
    let r = ExternRef::new(SetFlagOnDrop(inner_dropped.clone()));
    {
        let args = [Val::I32(5), Val::ExternRef(Some(r.clone()))];
        func.call(&mut store, &args, &mut [Val::I32(0)])?;
    }

    // Still held alive by the `VMExternRefActivationsTable` (potentially in
    // multiple slots within the table) and by this `r` local.
    assert!(r.strong_count() >= 2);

    // Doing a GC should see that there aren't any `externref`s on the stack in
    // Wasm frames anymore.
    store.gc();
    assert_eq!(r.strong_count(), 1);

    // Dropping `r` should drop the inner `SetFlagOnDrop` value.
    drop(r);
    assert!(inner_dropped.load(SeqCst));

    Ok(())
}",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,wasm_dropping_refs,"fn wasm_dropping_refs() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (func (export ""drop_ref"") (param externref)
                    nop
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let drop_ref = instance.get_func(&mut store, ""drop_ref"").unwrap();

    let num_refs_dropped = Arc::new(AtomicUsize::new(0));

    // NB: 4096 is greater than the initial `VMExternRefActivationsTable`
    // capacity, so this will trigger at least one GC.
    for _ in 0..4096 {
        let r = ExternRef::new(CountDrops(num_refs_dropped.clone()));
        let args = [Val::ExternRef(Some(r))];
        drop_ref.call(&mut store, &args, &mut [])?;
    }

    assert!(num_refs_dropped.load(SeqCst) > 0);

    // And after doing a final GC, all the refs should have been dropped.
    store.gc();
    assert_eq!(num_refs_dropped.load(SeqCst), 4096);

    return Ok(());

    struct CountDrops(Arc<AtomicUsize>);

    impl Drop for CountDrops {
        fn drop(&mut self) {
            self.0.fetch_add(1, SeqCst);
        }
    }
}",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,drop_externref_via_table_set,"fn drop_externref_via_table_set() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (table $t 1 externref)

                (func (export ""table-set"") (param externref)
                  (table.set $t (i32.const 0) (local.get 0))
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let table_set = instance.get_func(&mut store, ""table-set"").unwrap();

    let foo_is_dropped = Arc::new(AtomicBool::new(false));
    let bar_is_dropped = Arc::new(AtomicBool::new(false));

    let foo = ExternRef::new(SetFlagOnDrop(foo_is_dropped.clone()));
    let bar = ExternRef::new(SetFlagOnDrop(bar_is_dropped.clone()));

    {
        let args = vec![Val::ExternRef(Some(foo))];
        table_set.call(&mut store, &args, &mut [])?;
    }
    store.gc();
    assert!(!foo_is_dropped.load(SeqCst));
    assert!(!bar_is_dropped.load(SeqCst));

    {
        let args = vec![Val::ExternRef(Some(bar))];
        table_set.call(&mut store, &args, &mut [])?;
    }
    store.gc();
    assert!(foo_is_dropped.load(SeqCst));
    assert!(!bar_is_dropped.load(SeqCst));

    table_set.call(&mut store, &[Val::ExternRef(None)], &mut [])?;
    assert!(foo_is_dropped.load(SeqCst));
    assert!(bar_is_dropped.load(SeqCst));

    Ok(())
}",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,global_init_no_leak,"fn global_init_no_leak() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (import """" """" (global externref))
                (global externref (global.get 0))
            )
        ""#,
    )?;

    let externref = ExternRef::new(());
    let global = Global::new(
        &mut store,
        GlobalType::new(ValType::ExternRef, Mutability::Const),
        externref.clone().into(),
    )?;
    Instance::new(&mut store, &module, &[global.into()])?;
    drop(store);
    assert_eq!(externref.strong_count(), 1);

    Ok(())
}",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,no_gc_middle_of_args,"fn no_gc_middle_of_args() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (import """" ""return_some"" (func $return (result externref externref externref)))
                (import """" ""take_some"" (func $take (param externref externref externref)))
                (func (export ""run"")
                    (local i32)
                    i32.const 1000
                    local.set 0
                    loop
                        call $return
                        call $take
                        local.get 0
                        i32.const -1
                        i32.add
                        local.tee 0
                        br_if 0
                    end
                )
            )
        ""#,
    )?;

    let mut linker = Linker::new(store.engine());
    linker.func_wrap("""", ""return_some"", || {
        (
            Some(ExternRef::new(""a"".to_string())),
            Some(ExternRef::new(""b"".to_string())),
            Some(ExternRef::new(""c"".to_string())),
        )
    })?;
    linker.func_wrap(
        """",
        ""take_some"",
        |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {
            let a = a.unwrap();
            let b = b.unwrap();
            let c = c.unwrap();
            assert_eq!(a.data().downcast_ref::<String>().unwrap(), ""a"");
            assert_eq!(b.data().downcast_ref::<String>().unwrap(), ""b"");
            assert_eq!(c.data().downcast_ref::<String>().unwrap(), ""c"");
        },
    )?;

    let instance = linker.instantiate(&mut store, &module)?;
    let func = instance.get_typed_func::<(), (), _>(&mut store, ""run"")?;
    func.call(&mut store, ())?;

    Ok(())
}",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,drop_externref_via_table_set,"fn drop_externref_via_table_set() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        false,
        r#""
            (module
                (table $t 1 externref)

                (func (export ""table-set"") (param externref)
                  (table.set $t (i32.const 0) (local.get 0))
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let table_set = instance.get_func(&mut store, ""table-set"").unwrap();

    let foo_is_dropped = Arc::new(AtomicBool::new(false));
    let bar_is_dropped = Arc::new(AtomicBool::new(false));

    let foo = ExternRef::new(SetFlagOnDrop(foo_is_dropped.clone()));
    let bar = ExternRef::new(SetFlagOnDrop(bar_is_dropped.clone()));

    {
        let args = vec![Val::ExternRef(Some(foo))];
        table_set.call(&mut store, &args, &mut [])?;
    }
    store.gc();
    assert!(!foo_is_dropped.load(SeqCst));
    assert!(!bar_is_dropped.load(SeqCst));

    {
        let args = vec![Val::ExternRef(Some(bar))];
        table_set.call(&mut store, &args, &mut [])?;
    }
    store.gc();
    assert!(foo_is_dropped.load(SeqCst));
    assert!(!bar_is_dropped.load(SeqCst));

    table_set.call(&mut store, &[Val::ExternRef(None)], &mut [])?;
    assert!(foo_is_dropped.load(SeqCst));
    assert!(bar_is_dropped.load(SeqCst));

    Ok(())
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,smoke_test_gc,"fn smoke_test_gc() -> anyhow::Result<()> {
    smoke_test_gc_impl(false)
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,many_live_refs,"fn many_live_refs() -> anyhow::Result<()> {
    let mut wat = r#""
        (module
            ;; Make new `externref`s.
            (import """" ""make_ref"" (func $make_ref (result externref)))

            ;; Observe an `externref` so it is kept live.
            (import """" ""observe_ref"" (func $observe_ref (param externref)))

            (func (export ""many_live_refs"")
    ""#
    .to_string();

    // This is more than the initial `VMExternRefActivationsTable` capacity, so
    // it will need to allocate additional bump chunks.
    const NUM_LIVE_REFS: usize = 1024;

    // Push `externref`s onto the stack.
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $make_ref)\n"");
    }

    // Pop `externref`s from the stack. Because we pass each of them to a
    // function call here, they are all live references for the duration of
    // their lifetimes.
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $observe_ref)\n"");
    }

    wat.push_str(
        ""
            ) ;; func
        ) ;; module
        "",
    );

    let (mut store, module) = ref_types_module(false, &wat)?;

    let live_refs = Arc::new(AtomicUsize::new(0));

    let make_ref = Func::wrap(&mut store, {
        let live_refs = live_refs.clone();
        move || Some(ExternRef::new(CountLiveRefs::new(live_refs.clone())))
    });

    let observe_ref = Func::wrap(&mut store, |r: Option<ExternRef>| {
        let r = r.unwrap();
        let r = r.data().downcast_ref::<CountLiveRefs>().unwrap();
        assert!(r.live_refs.load(SeqCst) > 0);
    });

    let instance = Instance::new(&mut store, &module, &[make_ref.into(), observe_ref.into()])?;
    let many_live_refs = instance.get_func(&mut store, ""many_live_refs"").unwrap();

    many_live_refs.call(&mut store, &[], &mut [])?;

    store.gc();
    assert_eq!(live_refs.load(SeqCst), 0);

    return Ok(());

    struct CountLiveRefs {
        live_refs: Arc<AtomicUsize>,
    }

    impl CountLiveRefs {
        fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }
    }

    impl Drop for CountLiveRefs {
        fn drop(&mut self) {
            self.live_refs.fetch_sub(1, SeqCst);
        }
    }
}",0,False,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,global_init_no_leak,"fn global_init_no_leak() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        false,
        r#""
            (module
                (import """" """" (global externref))
                (global externref (global.get 0))
            )
        ""#,
    )?;

    let externref = ExternRef::new(());
    let global = Global::new(
        &mut store,
        GlobalType::new(ValType::ExternRef, Mutability::Const),
        externref.clone().into(),
    )?;
    Instance::new(&mut store, &module, &[global.into()])?;
    drop(store);
    assert_eq!(externref.strong_count(), 1);

    Ok(())
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,wasm_dropping_refs,"fn wasm_dropping_refs() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        false,
        r#""
            (module
                (func (export ""drop_ref"") (param externref)
                    nop
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let drop_ref = instance.get_func(&mut store, ""drop_ref"").unwrap();

    let num_refs_dropped = Arc::new(AtomicUsize::new(0));

    // NB: 4096 is greater than the initial `VMExternRefActivationsTable`
    // capacity, so this will trigger at least one GC.
    for _ in 0..4096 {
        let r = ExternRef::new(CountDrops(num_refs_dropped.clone()));
        let args = [Val::ExternRef(Some(r))];
        drop_ref.call(&mut store, &args, &mut [])?;
    }

    assert!(num_refs_dropped.load(SeqCst) > 0);

    // And after doing a final GC, all the refs should have been dropped.
    store.gc();
    assert_eq!(num_refs_dropped.load(SeqCst), 4096);

    return Ok(());

    struct CountDrops(Arc<AtomicUsize>);

    impl Drop for CountDrops {
        fn drop(&mut self) {
            self.0.fetch_add(1, SeqCst);
        }
    }
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,no_gc_middle_of_args,"fn no_gc_middle_of_args() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        false,
        r#""
            (module
                (import """" ""return_some"" (func $return (result externref externref externref)))
                (import """" ""take_some"" (func $take (param externref externref externref)))
                (func (export ""run"")
                    (local i32)
                    i32.const 1000
                    local.set 0
                    loop
                        call $return
                        call $take
                        local.get 0
                        i32.const -1
                        i32.add
                        local.tee 0
                        br_if 0
                    end
                )
            )
        ""#,
    )?;

    let mut linker = Linker::new(store.engine());
    linker.func_wrap("""", ""return_some"", || {
        (
            Some(ExternRef::new(""a"".to_string())),
            Some(ExternRef::new(""b"".to_string())),
            Some(ExternRef::new(""c"".to_string())),
        )
    })?;
    linker.func_wrap(
        """",
        ""take_some"",
        |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {
            let a = a.unwrap();
            let b = b.unwrap();
            let c = c.unwrap();
            assert_eq!(a.data().downcast_ref::<String>().unwrap(), ""a"");
            assert_eq!(b.data().downcast_ref::<String>().unwrap(), ""b"");
            assert_eq!(c.data().downcast_ref::<String>().unwrap(), ""c"");
        },
    )?;

    let instance = linker.instantiate(&mut store, &module)?;
    let func = instance.get_typed_func::<(), (), _>(&mut store, ""run"")?;
    func.call(&mut store, ())?;

    Ok(())
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,smoke_test_gc_epochs,"fn smoke_test_gc_epochs() -> anyhow::Result<()> {
    smoke_test_gc_impl(true)
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,smoke_test_gc_impl use_epochs : bool,"fn smoke_test_gc_impl(use_epochs: bool) -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        use_epochs,
        r#""
            (module
                (import """" """" (func $do_gc))
                (func $recursive (export ""func"") (param i32 externref) (result externref)
                    local.get 0
                    i32.eqz
                    if (result externref)
                        call $do_gc
                        local.get 1
                    else
                        local.get 0
                        i32.const 1
                        i32.sub
                        local.get 1
                        call $recursive
                    end
                )
            )
        ""#,
    )?;

    let do_gc = Func::wrap(&mut store, |mut caller: Caller<'_, _>| {
        // Do a GC with `externref`s on the stack in Wasm frames.
        caller.gc();
    });
    let instance = Instance::new(&mut store, &module, &[do_gc.into()])?;
    let func = instance.get_func(&mut store, ""func"").unwrap();

    let inner_dropped = Arc::new(AtomicBool::new(false));
    let r = ExternRef::new(SetFlagOnDrop(inner_dropped.clone()));
    {
        let args = [Val::I32(5), Val::ExternRef(Some(r.clone()))];
        func.call(&mut store, &args, &mut [Val::I32(0)])?;
    }

    // Still held alive by the `VMExternRefActivationsTable` (potentially in
    // multiple slots within the table) and by this `r` local.
    assert!(r.strong_count() >= 2);

    // Doing a GC should see that there aren't any `externref`s on the stack in
    // Wasm frames anymore.
    store.gc();
    assert_eq!(r.strong_count(), 1);

    // Dropping `r` should drop the inner `SetFlagOnDrop` value.
    drop(r);
    assert!(inner_dropped.load(SeqCst));

    Ok(())
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        self.0.store(true, SeqCst);
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,drop & mut self,"        fn drop(&mut self) {
            self.0.fetch_add(1, SeqCst);
        }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,new live_refs : Arc < AtomicUsize >,"        fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,drop & mut self,"        fn drop(&mut self) {
            self.live_refs.fetch_sub(1, SeqCst);
        }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,test_engine engine : & Engine,"    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Global::new(
            &mut store,
            GlobalType::new(ValType::ExternRef, Mutability::Const),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
                (module
                    (global (mut externref) (ref.null extern))

                    (func (export ""run"") (param externref)
                        local.get 0
                        global.set 0
                    )
                )
            ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,global_drops_externref,"fn global_drops_externref() -> anyhow::Result<()> {
    test_engine(&Engine::default())?;

    if !skip_pooling_allocator_tests() {
        test_engine(&Engine::new(
            Config::new().allocation_strategy(InstanceAllocationStrategy::pooling()),
        )?)?;
    }

    return Ok(());

    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Global::new(
            &mut store,
            GlobalType::new(ValType::ExternRef, Mutability::Const),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
                (module
                    (global (mut externref) (ref.null extern))

                    (func (export ""run"") (param externref)
                        local.get 0
                        global.set 0
                    )
                )
            ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,test_engine engine : & Engine,"    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Table::new(
            &mut store,
            TableType::new(ValType::ExternRef, 1, None),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
            (module
                (table 1 externref)

                (func (export ""run"") (param externref)
                    i32.const 0
                    local.get 0
                    table.set 0
                )
            )
        ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,table_drops_externref,"fn table_drops_externref() -> anyhow::Result<()> {
    test_engine(&Engine::default())?;

    if !skip_pooling_allocator_tests() {
        test_engine(&Engine::new(
            Config::new().allocation_strategy(InstanceAllocationStrategy::pooling()),
        )?)?;
    }

    return Ok(());

    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Table::new(
            &mut store,
            TableType::new(ValType::ExternRef, 1, None),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
            (module
                (table 1 externref)

                (func (export ""run"") (param externref)
                    i32.const 0
                    local.get 0
                    table.set 0
                )
            )
        ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,gc.rs,Rust,gee_i_sure_hope_refcounting_is_atomic,"fn gee_i_sure_hope_refcounting_is_atomic() -> anyhow::Result<()> {
    let mut config = Config::new();
    config.wasm_reference_types(true);
    config.epoch_interruption(true);
    let engine = Engine::new(&config)?;
    let mut store = Store::new(&engine, ());
    let module = Module::new(
        &engine,
        r#""
            (module
                (global (mut externref) (ref.null extern))
                (table 1 externref)

                (func (export ""run"") (param externref)
                    local.get 0
                    global.set 0
                    i32.const 0
                    local.get 0
                    table.set 0
                    loop
                        global.get 0
                        global.set 0

                        i32.const 0
                        i32.const 0
                        table.get
                        table.set

                        local.get 0
                        call $f

                        br 0
                    end
                )

                (func $f (param externref))
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;

    let flag = Arc::new(AtomicBool::new(false));
    let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
    let externref2 = externref.clone();

    let child = std::thread::spawn(move || run.call(&mut store, Some(externref2)));

    for _ in 0..10000 {
        drop(externref.clone());
    }
    engine.increment_epoch();

    assert!(child.join().unwrap().is_err());
    assert!(!flag.load(SeqCst));
    assert_eq!(externref.strong_count(), 1);
    drop(externref);
    assert!(flag.load(SeqCst));

    Ok(())
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,main.rs,Rust,"ref_types_module source : & str ,","pub(crate) fn ref_types_module(
    source: &str,
) -> anyhow::Result<(wasmtime::Store<()>, wasmtime::Module)> {
    use wasmtime::*;

    let _ = env_logger::try_init();

    let mut config = Config::new();
    config.wasm_reference_types(true);

    let engine = Engine::new(&config)?;
    let store = Store::new(&engine, ());

    let module = Module::new(&engine, source)?;

    Ok((store, module))
}",1,True,False,11
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,main.rs,Rust,"ref_types_module use_epochs : bool , source : & str ,","pub(crate) fn ref_types_module(
    use_epochs: bool,
    source: &str,
) -> anyhow::Result<(wasmtime::Store<()>, wasmtime::Module)> {
    use wasmtime::*;

    let _ = env_logger::try_init();

    let mut config = Config::new();
    config.wasm_reference_types(true);
    if use_epochs {
        config.epoch_interruption(true);
    }

    let engine = Engine::new(&config)?;
    let mut store = Store::new(&engine, ());
    if use_epochs {
        store.set_epoch_deadline(1);
    }

    let module = Module::new(&engine, source)?;

    Ok((store, module))
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,666c2554ea0e1728c35aa41178cf235920db888a,GitHub,2022-03-31 14:26:01-07:00,False,main.rs,Rust,skip_pooling_allocator_tests,"pub(crate) fn skip_pooling_allocator_tests() -> bool {
    // There are a couple of issues when running the pooling allocator tests under QEMU:
    // - high memory usage that may exceed the limits imposed by the environment (e.g. CI)
    // - https://github.com/bytecodealliance/wasmtime/pull/2518#issuecomment-747280133
    std::env::var(""WASMTIME_TEST_NO_HOG_MEMORY"").is_ok()
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"lookup_stack_map & self , pc : usize","    fn lookup_stack_map(&self, pc: usize) -> Option<&StackMap> {
        let text_offset = pc - self.start;
        let (index, func_offset) = self.module.func_by_text_offset(text_offset)?;
        let info = self.module.func_info(index);

        // Do a binary search to find the stack map for the given offset.
        //
        // Because GC safepoints are technically only associated with a single
        // PC, we should ideally only care about `Ok(index)` values returned
        // from the binary search. However, safepoints are inserted right before
        // calls, and there are two things that can disturb the PC/offset
        // associated with the safepoint versus the PC we actually use to query
        // for the stack map:
        //
        // 1. The `backtrace` crate gives us the PC in a frame that will be
        //    *returned to*, and where execution will continue from, rather than
        //    the PC of the call we are currently at. So we would need to
        //    disassemble one instruction backwards to query the actual PC for
        //    the stack map.
        //
        //    TODO: One thing we *could* do to make this a little less error
        //    prone, would be to assert/check that the nearest GC safepoint
        //    found is within `max_encoded_size(any kind of call instruction)`
        //    our queried PC for the target architecture.
        //
        // 2. Cranelift's stack maps only handle the stack, not
        //    registers. However, some references that are arguments to a call
        //    may need to be in registers. In these cases, what Cranelift will
        //    do is:
        //
        //      a. spill all the live references,
        //      b. insert a GC safepoint for those references,
        //      c. reload the references into registers, and finally
        //      d. make the call.
        //
        //    Step (c) adds drift between the GC safepoint and the location of
        //    the call, which is where we actually walk the stack frame and
        //    collect its live references.
        //
        //    Luckily, the spill stack slots for the live references are still
        //    up to date, so we can still find all the on-stack roots.
        //    Furthermore, we do not have a moving GC, so we don't need to worry
        //    whether the following code will reuse the references in registers
        //    (which would not have been updated to point to the moved objects)
        //    or reload from the stack slots (which would have been updated to
        //    point to the moved objects).

        let index = match info
            .stack_maps
            .binary_search_by_key(&func_offset, |i| i.code_offset)
        {
            // Exact hit.
            Ok(i) => i,

            // `Err(0)` means that the associated stack map would have been the
            // first element in the array if this pc had an associated stack
            // map, but this pc does not have an associated stack map. This can
            // only happen inside a Wasm frame if there are no live refs at this
            // pc.
            Err(0) => return None,

            Err(i) => i - 1,
        };

        Some(&info.stack_maps[index].stack_map)
    }",1,True,False,"6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,51,54,55,56,57,58,60"
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"lookup_stack_map & self , pc : usize","    fn lookup_stack_map(&self, pc: usize) -> Option<&StackMap> {
        let text_offset = pc - self.start;
        let (index, func_offset) = self.module.func_by_text_offset(text_offset)?;
        let info = self.module.func_info(index);

        // Do a binary search to find the stack map for the given offset.
        let index = match info
            .stack_maps
            .binary_search_by_key(&func_offset, |i| i.code_offset)
        {
            // Found it.
            Ok(i) => i,

            // No stack map associated with this PC.
            //
            // Because we know we are in Wasm code, and we must be at some kind
            // of call/safepoint, then the Cranelift backend must have avoided
            // emitting a stack map for this location because no refs were live.
            #[cfg(not(feature = ""old-x86-backend""))]
            Err(_) => return None,

            // ### Old x86_64 backend specific code.
            //
            // Because GC safepoints are technically only associated with a
            // single PC, we should ideally only care about `Ok(index)` values
            // returned from the binary search. However, safepoints are inserted
            // right before calls, and there are two things that can disturb the
            // PC/offset associated with the safepoint versus the PC we actually
            // use to query for the stack map:
            //
            // 1. The `backtrace` crate gives us the PC in a frame that will be
            //    *returned to*, and where execution will continue from, rather than
            //    the PC of the call we are currently at. So we would need to
            //    disassemble one instruction backwards to query the actual PC for
            //    the stack map.
            //
            //    TODO: One thing we *could* do to make this a little less error
            //    prone, would be to assert/check that the nearest GC safepoint
            //    found is within `max_encoded_size(any kind of call instruction)`
            //    our queried PC for the target architecture.
            //
            // 2. Cranelift's stack maps only handle the stack, not
            //    registers. However, some references that are arguments to a call
            //    may need to be in registers. In these cases, what Cranelift will
            //    do is:
            //
            //      a. spill all the live references,
            //      b. insert a GC safepoint for those references,
            //      c. reload the references into registers, and finally
            //      d. make the call.
            //
            //    Step (c) adds drift between the GC safepoint and the location of
            //    the call, which is where we actually walk the stack frame and
            //    collect its live references.
            //
            //    Luckily, the spill stack slots for the live references are still
            //    up to date, so we can still find all the on-stack roots.
            //    Furthermore, we do not have a moving GC, so we don't need to worry
            //    whether the following code will reuse the references in registers
            //    (which would not have been updated to point to the moved objects)
            //    or reload from the stack slots (which would have been updated to
            //    point to the moved objects).
            #[cfg(feature = ""old-x86-backend"")]
            Err(0) => return None,
            #[cfg(feature = ""old-x86-backend"")]
            Err(i) => i - 1,
        };

        Some(&info.stack_maps[index].stack_map)
    }",0,False,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"lookup_module & self , pc : usize","    pub fn lookup_module(&self, pc: usize) -> Option<Arc<dyn ModuleInfo>> {
        self.module(pc)
            .map(|m| -> Arc<dyn ModuleInfo> { m.clone() })
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"module & self , pc : usize","    fn module(&self, pc: usize) -> Option<&Arc<RegisteredModule>> {
        let (end, info) = self.modules_with_code.range(pc..).next()?;
        if pc < info.start || *end < pc {
            return None;
        }

        Some(info)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"register & mut self , module : & Module","    pub fn register(&mut self, module: &Module) {
        let compiled_module = module.compiled_module();

        // If there's not actually any functions in this module then we may
        // still need to preserve it for its data segments. Instances of this
        // module will hold a pointer to the data stored in the module itself,
        // and for schemes like uffd this performs lazy initialization which
        // could use the module in the future. For that reason we continue to
        // register empty modules and retain them.
        if compiled_module.finished_functions().len() == 0 {
            self.modules_without_code.push(compiled_module.clone());
            return;
        }

        // The module code range is exclusive for end, so make it inclusive as it
        // may be a valid PC value
        let code = compiled_module.code();
        assert!(!code.is_empty());
        let start = code.as_ptr() as usize;
        let end = start + code.len() - 1;

        // Ensure the module isn't already present in the registry
        // This is expected when a module is instantiated multiple times in the
        // same store
        if let Some(m) = self.modules_with_code.get(&end) {
            assert_eq!(m.start, start);
            return;
        }

        // Assert that this module's code doesn't collide with any other registered modules
        if let Some((_, prev)) = self.modules_with_code.range(end..).next() {
            assert!(prev.start > end);
        }

        if let Some((prev_end, _)) = self.modules_with_code.range(..=start).next_back() {
            assert!(*prev_end < start);
        }

        let prev = self.modules_with_code.insert(
            end,
            Arc::new(RegisteredModule {
                start,
                module: compiled_module.clone(),
                signatures: module.signatures().clone(),
            }),
        );
        assert!(prev.is_none());

        GLOBAL_MODULES.write().unwrap().register(start, end, module);
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"lookup_trampoline & self , anyfunc : & VMCallerCheckedAnyfunc","    pub fn lookup_trampoline(&self, anyfunc: &VMCallerCheckedAnyfunc) -> Option<VMTrampoline> {
        let module = self.module(anyfunc.func_ptr.as_ptr() as usize)?;
        module.signatures.trampoline(anyfunc.type_index)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        let mut info = GLOBAL_MODULES.write().unwrap();
        for end in self.modules_with_code.keys() {
            info.unregister(*end);
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,is_wasm_pc pc : usize,"    pub(crate) fn is_wasm_pc(pc: usize) -> bool {
        let modules = GLOBAL_MODULES.read().unwrap();

        match modules.module(pc) {
            Some((entry, text_offset)) => {
                wasmtime_environ::lookup_file_pos(entry.module.address_map_data(), text_offset)
                    .is_some()
            }
            None => false,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"module & self , pc : usize","    fn module(&self, pc: usize) -> Option<(&GlobalRegisteredModule, usize)> {
        let (end, info) = self.0.range(pc..).next()?;
        if pc < info.start || *end < pc {
            return None;
        }
        Some((info, pc - info.start))
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,with f : impl FnOnce & GlobalModuleRegistry -> R,"    pub(crate) fn with<R>(f: impl FnOnce(&GlobalModuleRegistry) -> R) -> R {
        f(&GLOBAL_MODULES.read().unwrap())
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"lookup_frame_info & self , pc : usize","    pub(crate) fn lookup_frame_info(&self, pc: usize) -> Option<(FrameInfo, bool, bool)> {
        let (module, offset) = self.module(pc)?;
        module.lookup_frame_info(offset).map(|info| {
            (
                info,
                module.has_unparsed_debuginfo(),
                module.wasm_backtrace_details_env_used,
            )
        })
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"lookup_trap_code & self , pc : usize","    pub(crate) fn lookup_trap_code(&self, pc: usize) -> Option<TrapCode> {
        let (module, offset) = self.module(pc)?;
        wasmtime_environ::lookup_trap_code(module.module.trap_data(), offset)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"register & mut self , start : usize , end : usize , module : & Module","    fn register(&mut self, start: usize, end: usize, module: &Module) {
        let info = self.0.entry(end).or_insert_with(|| GlobalRegisteredModule {
            start,
            module: module.compiled_module().clone(),
            wasm_backtrace_details_env_used: module
                .engine()
                .config()
                .wasm_backtrace_details_env_used,
            references: 0,
        });

        // Note that ideally we'd debug_assert that the information previously
        // stored, if any, matches the `functions` we were given, but for now we
        // just do some simple checks to hope it's the same.
        assert_eq!(info.start, start);
        info.references += 1;
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"unregister & mut self , end : usize","    fn unregister(&mut self, end: usize) {
        let info = self.0.get_mut(&end).unwrap();
        info.references -= 1;
        if info.references == 0 {
            self.0.remove(&end);
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,has_unparsed_debuginfo & self,"    pub fn has_unparsed_debuginfo(&self) -> bool {
        self.module.has_unparsed_debuginfo()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,"lookup_frame_info & self , text_offset : usize","    pub fn lookup_frame_info(&self, text_offset: usize) -> Option<FrameInfo> {
        let (index, _func_offset) = self.module.func_by_text_offset(text_offset)?;
        let info = self.module.func_info(index);
        let instr = wasmtime_environ::lookup_file_pos(self.module.address_map_data(), text_offset);

        // In debug mode for now assert that we found a mapping for `pc` within
        // the function, because otherwise something is buggy along the way and
        // not accounting for all the instructions. This isn't super critical
        // though so we can omit this check in release mode.
        debug_assert!(
            instr.is_some(),
            ""failed to find instruction for {:#x}"",
            text_offset
        );

        let instr = instr.unwrap_or(info.start_srcloc);

        // Use our wasm-relative pc to symbolize this frame. If there's a
        // symbolication context (dwarf debug info) available then we can try to
        // look this up there.
        //
        // Note that dwarf pcs are code-section-relative, hence the subtraction
        // from the location of `instr`. Also note that all errors are ignored
        // here for now since technically wasm modules can always have any
        // custom section contents.
        let mut symbols = Vec::new();

        if let Some(s) = &self.module.symbolize_context().ok().and_then(|c| c) {
            if let Some(offset) = instr.file_offset() {
                let to_lookup = u64::from(offset) - s.code_section_offset();
                if let Ok(mut frames) = s.addr2line().find_frames(to_lookup) {
                    while let Ok(Some(frame)) = frames.next() {
                        symbols.push(FrameSymbol {
                            name: frame
                                .function
                                .as_ref()
                                .and_then(|l| l.raw_name().ok())
                                .map(|s| s.to_string()),
                            file: frame
                                .location
                                .as_ref()
                                .and_then(|l| l.file)
                                .map(|s| s.to_string()),
                            line: frame.location.as_ref().and_then(|l| l.line),
                            column: frame.location.as_ref().and_then(|l| l.column),
                        });
                    }
                }
            }
        }

        let module = self.module.module();
        let index = module.func_index(index);

        Some(FrameInfo {
            module_name: module.name.clone(),
            func_index: index.index() as u32,
            func_name: module.func_names.get(&index).cloned(),
            instr,
            func_start: info.start_srcloc,
            symbols,
        })
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,func_index & self,"    pub fn func_index(&self) -> u32 {
        self.func_index
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,module_name & self,"    pub fn module_name(&self) -> Option<&str> {
        self.module_name.as_deref()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,func_name & self,"    pub fn func_name(&self) -> Option<&str> {
        self.func_name.as_deref()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,module_offset & self,"    pub fn module_offset(&self) -> usize {
        self.instr.file_offset().unwrap_or(u32::MAX) as usize
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,func_offset & self,"    pub fn func_offset(&self) -> usize {
        match self.instr.file_offset() {
            Some(i) => (i - self.func_start.file_offset().unwrap()) as usize,
            None => u32::MAX as usize,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,symbols & self,"    pub fn symbols(&self) -> &[FrameSymbol] {
        &self.symbols
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,name & self,"    pub fn name(&self) -> Option<&str> {
        self.name.as_deref()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,file & self,"    pub fn file(&self) -> Option<&str> {
        self.file.as_deref()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,line & self,"    pub fn line(&self) -> Option<u32> {
        self.line
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,column & self,"    pub fn column(&self) -> Option<u32> {
        self.column
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,ec4e48d4cbc28bcfd99e25842a90704e765b800f,Nick Fitzgerald,2021-09-13 10:41:26-07:00,True,registry.rs,Rust,test_frame_info,"fn test_frame_info() -> Result<(), anyhow::Error> {
    use crate::*;
    let mut store = Store::<()>::default();
    let module = Module::new(
        store.engine(),
        r#""
            (module
                (func (export ""add"") (param $x i32) (param $y i32) (result i32) (i32.add (local.get $x) (local.get $y)))
                (func (export ""sub"") (param $x i32) (param $y i32) (result i32) (i32.sub (local.get $x) (local.get $y)))
                (func (export ""mul"") (param $x i32) (param $y i32) (result i32) (i32.mul (local.get $x) (local.get $y)))
                (func (export ""div_s"") (param $x i32) (param $y i32) (result i32) (i32.div_s (local.get $x) (local.get $y)))
                (func (export ""div_u"") (param $x i32) (param $y i32) (result i32) (i32.div_u (local.get $x) (local.get $y)))
                (func (export ""rem_s"") (param $x i32) (param $y i32) (result i32) (i32.rem_s (local.get $x) (local.get $y)))
                (func (export ""rem_u"") (param $x i32) (param $y i32) (result i32) (i32.rem_u (local.get $x) (local.get $y)))
            )
         ""#,
    )?;
    // Create an instance to ensure the frame information is registered.
    Instance::new(&mut store, &module, &[])?;

    GlobalModuleRegistry::with(|modules| {
        for (i, alloc) in module.compiled_module().finished_functions() {
            let (start, end) = unsafe {
                let ptr = (*alloc).as_ptr();
                let len = (*alloc).len();
                (ptr as usize, ptr as usize + len)
            };
            for pc in start..end {
                let (frame, _, _) = modules.lookup_frame_info(pc).unwrap();
                assert!(
                    frame.func_index() == i.as_u32(),
                    ""lookup of {:#x} returned {}, expected {}"",
                    pc,
                    frame.func_index(),
                    i.as_u32()
                );
            }
        }
    });
    Ok(())
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,eb4089e21206875bc528f336d3fbb9b70cae2ed1,Alex Crichton,2021-09-14 14:09:14-07:00,True,func.rs,Rust,"new mut store : impl AsContextMut < Data = T > , ty : FuncType , func : impl Fn Caller < '_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + ' static , -> Self { let store = store . as_context_mut . 0 ; unsafe { let host = HostFunc :: new store . engine , ty , func ; host . into_func store } } #[cfg(all(feature = ""async"", feature = ""cranelift""))] #[cfg_attr(nightlydoc, doc(cfg(all(feature = ""async"", feature = ""cranelift""))))] pub fn new_async < T , F > store : impl AsContextMut < Data = T > , ty : FuncType , func : F -> Func where F : for < 'a> Fn(
                Caller<' a , T > , & 'a [Val],
                &' a mut [ Val ] ,","    pub fn new<T>(
        mut store: impl AsContextMut<Data = T>,
        ty: FuncType,
        func: impl Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + 'static,
    ) -> Self {
        let store = store.as_context_mut().0;

        // part of this unsafety is about matching the `T` to a `Store<T>`,
        // which is done through the `AsContextMut` bound above.
        unsafe {
            let host = HostFunc::new(store.engine(), ty, func);
            host.into_func(store)
        }
    }

    /// Creates a new host-defined WebAssembly function which, when called,
    /// will run the asynchronous computation defined by `func` to completion
    /// and then return the result to WebAssembly.
    ///
    /// This function is the asynchronous analogue of [`Func::new`] and much of
    /// that documentation applies to this as well. The key difference is that
    /// `func` returns a future instead of simply a `Result`. Note that the
    /// returned future can close over any of the arguments, but it cannot close
    /// over the state of the closure itself. It's recommended to store any
    /// necessary async state in the `T` of the [`Store<T>`](crate::Store) which
    /// can be accessed through [`Caller::data`] or [`Caller::data_mut`].
    ///
    /// For more information on `Send + Sync + 'static`, see
    /// [`Func::wrap`](#why-send--sync--static).
    ///
    /// # Panics
    ///
    /// This function will panic if `store` is not associated with an [async
    /// config](crate::Config::async_support).
    ///
    /// # Examples
    ///
    /// ```
    /// # use wasmtime::*;
    /// # fn main() -> anyhow::Result<()> {
    /// // Simulate some application-specific state as well as asynchronous
    /// // functions to query that state.
    /// struct MyDatabase {
    ///     // ...
    /// }
    ///
    /// impl MyDatabase {
    ///     async fn get_row_count(&self) -> u32 {
    ///         // ...
    /// #       100
    ///     }
    /// }
    ///
    /// let my_database = MyDatabase {
    ///     // ...
    /// };
    ///
    /// // Using `new_async` we can hook up into calling our async
    /// // `get_row_count` function.
    /// let engine = Engine::new(Config::new().async_support(true))?;
    /// let mut store = Store::new(&engine, MyDatabase {
    ///     // ...
    /// });
    /// let get_row_count_type = wasmtime::FuncType::new(
    ///     None,
    ///     Some(wasmtime::ValType::I32),
    /// );
    /// let get = Func::new_async(&mut store, get_row_count_type, |caller, _params, results| {
    ///     Box::new(async move {
    ///         let count = caller.data().get_row_count().await;
    ///         results[0] = Val::I32(count as i32);
    ///         Ok(())
    ///     })
    /// });
    /// // ...
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(all(feature = ""async"", feature = ""cranelift""))]
    #[cfg_attr(nightlydoc, doc(cfg(all(feature = ""async"", feature = ""cranelift""))))]
    pub fn new_async<T, F>(store: impl AsContextMut<Data = T>, ty: FuncType, func: F) -> Func
    where
        F: for<'a> Fn(
                Caller<'a, T>,
                &'a [Val],
                &'a mut [Val],
            ) -> Box<dyn Future<Output = Result<(), Trap>> + Send + 'a>
            + Send
            + Sync
            + 'static,
    {
        assert!(
            store.as_context().async_support(),
            ""cannot use `new_async` without enabling async support in the config""
        );
        Func::new(store, ty, move |mut caller, params, results| {
            let async_cx = caller.store.as_context_mut().0.async_cx();
            let mut future = Pin::from(func(caller, params, results));
            match unsafe { async_cx.block_on(future.as_mut()) } {
                Ok(Ok(())) => Ok(()),
                Ok(Err(trap)) | Err(trap) => Err(trap),
            }
        })
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,eb4089e21206875bc528f336d3fbb9b70cae2ed1,Alex Crichton,2021-09-14 14:09:14-07:00,True,func.rs,Rust,"from_caller_checked_anyfunc store : & mut StoreOpaque , anyfunc : * mut VMCallerCheckedAnyfunc ,","    pub(crate) unsafe fn from_caller_checked_anyfunc(
        store: &mut StoreOpaque,
        anyfunc: *mut VMCallerCheckedAnyfunc,
    ) -> Option<Self> {
        let anyfunc = NonNull::new(anyfunc)?;
        debug_assert!(anyfunc.as_ref().type_index != VMSharedSignatureIndex::default());
        let export = ExportFunction { anyfunc };
        Some(Func::from_wasmtime_function(export, store))
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,eb4089e21206875bc528f336d3fbb9b70cae2ed1,Alex Crichton,2021-09-14 14:09:14-07:00,True,func.rs,Rust,"wrap mut store : impl AsContextMut < Data = T > , func : impl IntoFunc < T , Params , Results > ,","    pub fn wrap<T, Params, Results>(
        mut store: impl AsContextMut<Data = T>,
        func: impl IntoFunc<T, Params, Results>,
    ) -> Func {
        let store = store.as_context_mut().0;
        // part of this unsafety is about matching the `T` to a `Store<T>`,
        // which is done through the `AsContextMut` bound above.
        unsafe {
            let host = HostFunc::wrap(store.engine(), func);
            host.into_func(store)
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,eb4089e21206875bc528f336d3fbb9b70cae2ed1,Alex Crichton,2021-09-14 14:09:14-07:00,True,func.rs,Rust,"ty & self , store : impl AsContext","    pub fn ty(&self, store: impl AsContext) -> FuncType {
        // Signatures should always be registered in the engine's registry of
        // shared signatures, so we should be able to unwrap safely here.
        let store = store.as_context();
        let sig_index = unsafe { store[self.0].export().anyfunc.as_ref().type_index };
        FuncType::from_wasm_func_type(
            store
                .engine()
                .signatures()
                .lookup_type(sig_index)
                .expect(""signature should be registered""),
        )
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,eb4089e21206875bc528f336d3fbb9b70cae2ed1,Alex Crichton,2021-09-14 14:09:14-07:00,True,func.rs,Rust,"sig_index & self , data : & StoreData","    pub(crate) fn sig_index(&self, data: &StoreData) -> VMSharedSignatureIndex {
        unsafe { data[self.0].export().anyfunc.as_ref().type_index }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,eb4089e21206875bc528f336d3fbb9b70cae2ed1,Alex Crichton,2021-09-14 14:09:14-07:00,True,func.rs,Rust,"call & self , mut store : impl AsContextMut , params : & [ Val ]","    pub fn call(&self, mut store: impl AsContextMut, params: &[Val]) -> Result<Box<[Val]>> {
        assert!(
            !store.as_context().async_support(),
            ""must use `call_async` when async support is enabled on the config"",
        );
        let my_ty = self.ty(&store);
        self.call_impl(&mut store.as_context_mut(), my_ty, params)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,eb4089e21206875bc528f336d3fbb9b70cae2ed1,Alex Crichton,2021-09-14 14:09:14-07:00,True,func.rs,Rust,"call_async & self , mut store : impl AsContextMut < Data = T > , params : & [ Val ] ,","    pub async fn call_async<T>(
        &self,
        mut store: impl AsContextMut<Data = T>,
        params: &[Val],
    ) -> Result<Box<[Val]>>
    where
        T: Send,
    {
        let mut store = store.as_context_mut();
        assert!(
            store.0.async_support(),
            ""cannot use `call_async` without enabling async support in the config"",
        );
        let my_ty = self.ty(&store);
        let result = store
            .on_fiber(|store| self.call_impl(store, my_ty, params))
            .await??;
        Ok(result)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,get_func_name func_index : FuncIndex,"fn get_func_name(func_index: FuncIndex) -> ir::ExternalName {
    ir::ExternalName::user(0, func_index.as_u32())
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,new entity : T,"    pub fn new(entity: T) -> Self {
        Self {
            entity,
            export_names: Vec::new(),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,new config : TargetFrontendConfig,"    pub fn new(config: TargetFrontendConfig) -> Self {
        Self {
            config,
            signatures: PrimaryMap::new(),
            imported_funcs: Vec::new(),
            imported_globals: Vec::new(),
            imported_tables: Vec::new(),
            imported_memories: Vec::new(),
            functions: PrimaryMap::new(),
            function_bodies: PrimaryMap::new(),
            tables: PrimaryMap::new(),
            memories: PrimaryMap::new(),
            globals: PrimaryMap::new(),
            start_func: None,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,"check_before & mut self , reachable : bool","    fn check_before(&mut self, reachable: bool) {
        assert_eq!(reachable, self.reachability[self.before_idx].0);
        self.before_idx += 1;
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,"check_after & mut self , reachable : bool","    fn check_after(&mut self, reachable: bool) {
        assert_eq!(reachable, self.reachability[self.after_idx].1);
        self.after_idx += 1;
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,check_end & self,"    fn check_end(&self) {
        assert_eq!(self.before_idx, self.reachability.len());
        assert_eq!(self.after_idx, self.reachability.len());
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,"new config : TargetFrontendConfig , return_mode : ReturnMode , debug_info : bool","    pub fn new(config: TargetFrontendConfig, return_mode: ReturnMode, debug_info: bool) -> Self {
        Self {
            info: DummyModuleInfo::new(config),
            trans: FuncTranslator::new(),
            func_bytecode_sizes: Vec::new(),
            return_mode,
            debug_info,
            module_name: None,
            function_names: SecondaryMap::new(),
            expected_reachability: None,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,func_env & self,"    pub fn func_env(&self) -> DummyFuncEnvironment {
        DummyFuncEnvironment::new(
            &self.info,
            self.return_mode,
            self.expected_reachability.clone(),
        )
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,"get_func_type & self , func_index : FuncIndex","    fn get_func_type(&self, func_index: FuncIndex) -> TypeIndex {
        self.info.functions[func_index].entity
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,get_num_func_imports & self,"    pub fn get_num_func_imports(&self) -> usize {
        self.info.imported_funcs.len()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,"get_func_name & self , func_index : FuncIndex","    pub fn get_func_name(&self, func_index: FuncIndex) -> Option<&str> {
        self.function_names.get(func_index).map(String::as_ref)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,dummy.rs,Rust,"test_expected_reachability & mut self , reachability : Vec < bool , bool >","    pub fn test_expected_reachability(&mut self, reachability: Vec<(bool, bool)>) {
        self.expected_reachability = Some(ExpectedReachability {
            reachability,
            before_idx: 0,
            after_idx: 0,
        });
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,compiler.rs,Rust,"new isa : Box < dyn TargetIsa > , linkopts : LinkOptions","    pub(crate) fn new(isa: Box<dyn TargetIsa>, linkopts: LinkOptions) -> Compiler {
        Compiler {
            translators: Default::default(),
            isa,
            linkopts,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,compiler.rs,Rust,take_translator & self,"    fn take_translator(&self) -> FuncTranslator {
        let candidate = self.translators.lock().unwrap().pop();
        candidate.unwrap_or_else(FuncTranslator::new)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,compiler.rs,Rust,"save_translator & self , translator : FuncTranslator","    fn save_translator(&self, translator: FuncTranslator) {
        self.translators.lock().unwrap().push(translator);
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,"push_types isa : & dyn TargetIsa , sig : & mut ir :: Signature , wasm : & WasmFuncType","fn push_types(isa: &dyn TargetIsa, sig: &mut ir::Signature, wasm: &WasmFuncType) {
    let cvt = |ty: &WasmType| ir::AbiParam::new(value_type(isa, *ty));
    sig.params.extend(wasm.params.iter().map(&cvt));
    sig.returns.extend(wasm.returns.iter().map(&cvt));
}",1,True,False,"2,3"
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,"push_types isa : & dyn TargetIsa , sig : & mut ir :: Signature , wasm : & WasmFuncType","fn push_types(isa: &dyn TargetIsa, sig: &mut ir::Signature, wasm: &WasmFuncType) {
    let cvt = |ty: &WasmType| ir::AbiParam::new(value_type(isa, *ty));
    sig.params.extend(wasm.params().iter().map(&cvt));
    sig.returns.extend(wasm.returns().iter().map(&cvt));
}",0,False,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,"blank_sig isa : & dyn TargetIsa , call_conv : CallConv","fn blank_sig(isa: &dyn TargetIsa, call_conv: CallConv) -> ir::Signature {
    let pointer_type = isa.pointer_type();
    let mut sig = ir::Signature::new(call_conv);
    // Add the caller/callee `vmctx` parameters.
    sig.params.push(ir::AbiParam::special(
        pointer_type,
        ir::ArgumentPurpose::VMContext,
    ));
    sig.params.push(ir::AbiParam::new(pointer_type));
    return sig;
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,wasmtime_call_conv isa : & dyn TargetIsa,"fn wasmtime_call_conv(isa: &dyn TargetIsa) -> CallConv {
    match isa.triple().default_calling_convention() {
        Ok(CallingConvention::AppleAarch64) => CallConv::WasmtimeAppleAarch64,
        Ok(CallingConvention::SystemV) | Err(()) => CallConv::WasmtimeSystemV,
        Ok(CallingConvention::WindowsFastcall) => CallConv::WasmtimeFastcall,
        Ok(unimp) => unimplemented!(""calling convention: {:?}"", unimp),
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,"value_type isa : & dyn TargetIsa , ty : WasmType","fn value_type(isa: &dyn TargetIsa, ty: WasmType) -> ir::types::Type {
    match ty {
        WasmType::I32 => ir::types::I32,
        WasmType::I64 => ir::types::I64,
        WasmType::F32 => ir::types::F32,
        WasmType::F64 => ir::types::F64,
        WasmType::V128 => ir::types::I8X16,
        WasmType::FuncRef | WasmType::ExternRef => reference_type(ty, isa.pointer_type()),
        WasmType::ExnRef => unimplemented!(),
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,"indirect_signature isa : & dyn TargetIsa , wasm : & WasmFuncType","fn indirect_signature(isa: &dyn TargetIsa, wasm: &WasmFuncType) -> ir::Signature {
    let mut sig = blank_sig(isa, wasmtime_call_conv(isa));
    push_types(isa, &mut sig, wasm);
    return sig;
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,"func_signature isa : & dyn TargetIsa , translation : & ModuleTranslation , types : & TypeTables , index : FuncIndex ,","fn func_signature(
    isa: &dyn TargetIsa,
    translation: &ModuleTranslation,
    types: &TypeTables,
    index: FuncIndex,
) -> ir::Signature {
    let call_conv = match translation.module.defined_func_index(index) {
        // If this is a defined function in the module and it's never possibly
        // exported, then we can optimize this function to use the fastest
        // calling convention since it's purely an internal implementation
        // detail of the module itself.
        Some(idx) if !translation.escaped_funcs.contains(&idx) => CallConv::Fast,

        // ... otherwise if it's an imported function or if it's a possibly
        // exported function then we use the default ABI wasmtime would
        // otherwise select.
        _ => wasmtime_call_conv(isa),
    };
    let mut sig = blank_sig(isa, call_conv);
    push_types(
        isa,
        &mut sig,
        &types.wasm_signatures[translation.module.functions[index]],
    );
    return sig;
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,"reference_type wasm_ty : cranelift_wasm :: WasmType , pointer_type : ir :: Type","fn reference_type(wasm_ty: cranelift_wasm::WasmType, pointer_type: ir::Type) -> ir::Type {
    match wasm_ty {
        cranelift_wasm::WasmType::FuncRef => pointer_type,
        cranelift_wasm::WasmType::ExternRef => match pointer_type {
            ir::types::I32 => ir::types::R32,
            ir::types::I64 => ir::types::R64,
            _ => panic!(""unsupported pointer type""),
        },
        _ => panic!(""unsupported Wasm reference type""),
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,module_environ.rs,Rust,"new tunables : & Tunables , features : & WasmFeatures","    pub fn new(tunables: &Tunables, features: &WasmFeatures) -> Self {
        Self {
            result: ModuleTranslation::default(),
            results: Vec::with_capacity(1),
            in_progress: Vec::new(),
            modules_to_be: 1,
            types: Default::default(),
            tunables: tunables.clone(),
            features: *features,
            first_module: true,
            interned_func_types: Default::default(),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,module_environ.rs,Rust,"translate mut self , data : & 'data [u8],
    ) -> WasmResult<(usize, Vec<ModuleTranslation<' data > > , TypeTables","    pub fn translate(
        mut self,
        data: &'data [u8],
    ) -> WasmResult<(usize, Vec<ModuleTranslation<'data>>, TypeTables)> {
        let mut validator = Validator::new();
        validator.wasm_features(self.features);

        for payload in Parser::new(0).parse_all(data) {
            self.translate_payload(&mut validator, payload?)?;
        }

        assert!(self.results.len() > 0);
        Ok((self.results.len() - 1, self.results, self.types))
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,table_ops.rs,Rust,to_wasm_binary & self,"    pub fn to_wasm_binary(&self) -> Vec<u8> {
        let mut module = Module::new();

        // Import the GC function.
        let mut imports = ImportSection::new();
        imports.import("""", Some(""gc""), EntityType::Function(0));

        // Define our table.
        let mut tables = TableSection::new();
        tables.table(TableType {
            element_type: ValType::ExternRef,
            minimum: self.table_size(),
            maximum: None,
        });

        // Encode the types for all functions that we are using.
        let mut types = TypeSection::new();
        types.function(vec![], vec![]); // 0: ""gc""
        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);
        for _i in 0..self.num_params() {
            params.push(ValType::ExternRef);
        }
        let results = vec![];
        types.function(params, results); // 1: ""run""

        // Define the ""run"" function export.
        let mut functions = FunctionSection::new();
        functions.function(1);

        let mut exports = ExportSection::new();
        exports.export(""run"", Export::Function(1));

        let mut params: Vec<(u32, ValType)> = Vec::with_capacity(self.num_params() as usize);
        for _i in 0..self.num_params() {
            params.push((0, ValType::ExternRef));
        }
        let mut func = Function::new(params);

        for op in self.ops.iter().take(MAX_OPS) {
            op.insert(&mut func);
        }

        let mut code = CodeSection::new();
        code.function(&func);

        module
            .section(&types)
            .section(&imports)
            .section(&functions)
            .section(&tables)
            .section(&exports)
            .section(&code);

        module.finish()
    }",1,True,False,"15,16,17,18,19,20,21,22,23,24,30,32,33,34,35,36,39"
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,table_ops.rs,Rust,"insert & self , func : & mut Function","    fn insert(&self, func: &mut Function) {
        match self {
            Self::Gc => {
                func.instruction(Instruction::Call(0));
            }
            Self::Get(x) => {
                func.instruction(Instruction::I32Const(*x));
                func.instruction(Instruction::TableGet { table: 0 });
                func.instruction(Instruction::Drop);
            }
            Self::SetFromParam(x, y) => {
                func.instruction(Instruction::I32Const(*x));
                func.instruction(Instruction::LocalGet(*y));
                func.instruction(Instruction::TableSet { table: 0 });
            }
            Self::SetFromGet(x, y) => {
                func.instruction(Instruction::I32Const(*x));
                func.instruction(Instruction::I32Const(*y));
                func.instruction(Instruction::TableGet { table: 0 });
                func.instruction(Instruction::TableSet { table: 0 });
            }
        }
    }",1,True,False,"0,6,11,12,16,17"
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,table_ops.rs,Rust,test_wat_string,"    fn test_wat_string() {
        let ops = TableOps {
            num_params: 2,
            table_size: 10,
            ops: vec![
                TableOp::Gc,
                TableOp::Get(0),
                TableOp::SetFromParam(1, 2),
                TableOp::SetFromGet(3, 4),
            ],
        };

        let expected = r#""
(module
  (type (;0;) (func))
  (type (;1;) (func (param externref externref)))
  (import """" ""gc"" (func (;0;) (type 0)))
  (func (;1;) (type 1) (param externref externref)
    call 0
    i32.const 0
    table.get 0
    drop
    i32.const 1
    local.get 2
    table.set 0
    i32.const 3
    i32.const 4
    table.get 0
    table.set 0)
  (table (;0;) 10 externref)
  (export ""run"" (func 1)))
""#;
        let actual = ops.to_wasm_binary();
        let actual = wasmprinter::print_bytes(&actual).unwrap();
        assert_eq!(actual.trim(), expected.trim());
    }",1,True,False,"2,3,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30"
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,table_ops.rs,Rust,to_wasm_binary & self,"    pub fn to_wasm_binary(&self) -> Vec<u8> {
        let mut module = Module::new();

        // Encode the types for all functions that we are using.
        let mut types = TypeSection::new();

        // 0: ""gc""
        types.function(
            vec![],
            // Return a bunch of stuff from `gc` so that we exercise GCing when
            // there is return pointer space allocated on the stack. This is
            // especially important because the x64 backend currently
            // dynamically adjusts the stack pointer for each call that uses
            // return pointers rather than statically allocating space in the
            // stack frame.
            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],
        );

        // 1: ""run""
        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);
        for _i in 0..self.num_params() {
            params.push(ValType::ExternRef);
        }
        let results = vec![];
        types.function(params, results);

        // 2: `take_refs`
        types.function(
            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],
            vec![],
        );

        // 3: `make_refs`
        types.function(
            vec![],
            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],
        );

        // Import the GC function.
        let mut imports = ImportSection::new();
        imports.import("""", Some(""gc""), EntityType::Function(0));
        imports.import("""", Some(""take_refs""), EntityType::Function(2));
        imports.import("""", Some(""make_refs""), EntityType::Function(3));

        // Define our table.
        let mut tables = TableSection::new();
        tables.table(TableType {
            element_type: ValType::ExternRef,
            minimum: self.table_size(),
            maximum: None,
        });

        // Define the ""run"" function export.
        let mut functions = FunctionSection::new();
        functions.function(1);

        let mut exports = ExportSection::new();
        exports.export(""run"", Export::Function(3));

        // Give ourselves one scratch local that we can use in various `TableOp`
        // implementations.
        let mut func = Function::new(vec![(1, ValType::ExternRef)]);

        func.instruction(Instruction::Loop(wasm_encoder::BlockType::Empty));
        for op in self.ops.iter().take(MAX_OPS) {
            op.insert(&mut func, self.num_params() as u32, self.table_size());
        }
        func.instruction(Instruction::Br(0));
        func.instruction(Instruction::End);
        func.instruction(Instruction::End);

        let mut code = CodeSection::new();
        code.function(&func);

        module
            .section(&types)
            .section(&imports)
            .section(&functions)
            .section(&tables)
            .section(&exports)
            .section(&code);

        module.finish()
    }",0,False,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,table_ops.rs,Rust,test_wat_string,"    fn test_wat_string() {
        let ops = TableOps {
            num_params: 5,
            table_size: 20,
            ops: vec![
                TableOp::Gc,
                TableOp::Get(0),
                TableOp::SetFromParam(1, 2),
                TableOp::SetFromGet(3, 4),
                TableOp::SetFromMake(5, 6, 7),
                TableOp::Make,
                TableOp::TakeFromParams(8, 9, 10),
                TableOp::TakeFromGet(11, 12, 13),
                TableOp::TakeFromMake,
            ],
        };

        let expected = r#""
(module
  (type (;0;) (func))
  (type (;1;) (func (param externref externref externref externref externref)))
  (type (;2;) (func (param externref externref externref)))
  (type (;3;) (func (result externref externref externref)))
  (import """" ""gc"" (func (;0;) (type 0)))
  (import """" ""take_refs"" (func (;1;) (type 2)))
  (import """" ""make_refs"" (func (;2;) (type 3)))
  (func (;3;) (type 1) (param externref externref externref externref externref)
    (local externref i32)
    i32.const 100
    local.set 6
    loop  ;; label = @1
      call 0
      i32.const 0
      table.get 0
      drop
      i32.const 1
      local.get 2
      table.set 0
      i32.const 3
      i32.const 4
      table.get 0
      table.set 0
      call 2
      local.set 5
      i32.const 5
      local.get 5
      table.set 0
      local.set 5
      i32.const 6
      local.get 5
      table.set 0
      local.set 5
      i32.const 7
      local.get 5
      table.set 0
      call 2
      drop
      drop
      drop
      local.get 3
      local.get 4
      local.get 0
      call 1
      i32.const 11
      table.get 0
      i32.const 12
      table.get 0
      i32.const 13
      table.get 0
      call 1
      call 2
      call 1
      local.get 6
      i32.const -1
      i32.add
      local.tee 6
      br_if 0 (;@1;)
    end)
  (table (;0;) 20 externref)
  (export ""run"" (func 3)))
""#;
        eprintln!(""expected WAT = {}"", expected);

        let actual = ops.to_wasm_binary();
        if let Err(e) = wasmparser::validate(&actual) {
            panic!(""TableOps should generate valid Wasm; got error: {}"", e);
        }

        let actual = wasmprinter::print_bytes(&actual).unwrap();
        eprintln!(""actual WAT = {}"", actual);

        assert_eq!(actual.trim(), expected.trim());
    }",0,False,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,table_ops.rs,Rust,"insert & self , func : & mut Function , num_params : u32 , table_size : u32","    fn insert(&self, func: &mut Function, num_params: u32, table_size: u32) {
        assert!(num_params > 0);
        assert!(table_size > 0);

        // Add one to make sure that out of bounds table accesses are possible,
        // but still rare.
        let table_mod = table_size as i32 + 1;

        match self {
            Self::Gc => {
                func.instruction(Instruction::Call(0));
                func.instruction(Instruction::Drop);
                func.instruction(Instruction::Drop);
                func.instruction(Instruction::Drop);
            }
            Self::Get(x) => {
                func.instruction(Instruction::I32Const(*x % table_mod));
                func.instruction(Instruction::TableGet { table: 0 });
                func.instruction(Instruction::Drop);
            }
            Self::SetFromParam(x, y) => {
                func.instruction(Instruction::I32Const(*x % table_mod));
                func.instruction(Instruction::LocalGet(*y % num_params));
                func.instruction(Instruction::TableSet { table: 0 });
            }
            Self::SetFromGet(x, y) => {
                func.instruction(Instruction::I32Const(*x % table_mod));
                func.instruction(Instruction::I32Const(*y % table_mod));
                func.instruction(Instruction::TableGet { table: 0 });
                func.instruction(Instruction::TableSet { table: 0 });
            }
            Self::SetFromMake(x, y, z) => {
                func.instruction(Instruction::Call(2));

                func.instruction(Instruction::LocalSet(num_params));
                func.instruction(Instruction::I32Const(*x % table_mod));
                func.instruction(Instruction::LocalGet(num_params));
                func.instruction(Instruction::TableSet { table: 0 });

                func.instruction(Instruction::LocalSet(num_params));
                func.instruction(Instruction::I32Const(*y % table_mod));
                func.instruction(Instruction::LocalGet(num_params));
                func.instruction(Instruction::TableSet { table: 0 });

                func.instruction(Instruction::LocalSet(num_params));
                func.instruction(Instruction::I32Const(*z % table_mod));
                func.instruction(Instruction::LocalGet(num_params));
                func.instruction(Instruction::TableSet { table: 0 });
            }
            TableOp::Make => {
                func.instruction(Instruction::Call(2));
                func.instruction(Instruction::Drop);
                func.instruction(Instruction::Drop);
                func.instruction(Instruction::Drop);
            }
            TableOp::TakeFromParams(x, y, z) => {
                func.instruction(Instruction::LocalGet(x % num_params));
                func.instruction(Instruction::LocalGet(y % num_params));
                func.instruction(Instruction::LocalGet(z % num_params));
                func.instruction(Instruction::Call(1));
            }
            TableOp::TakeFromGet(x, y, z) => {
                func.instruction(Instruction::I32Const(*x % table_mod));
                func.instruction(Instruction::TableGet { table: 0 });

                func.instruction(Instruction::I32Const(*y % table_mod));
                func.instruction(Instruction::TableGet { table: 0 });

                func.instruction(Instruction::I32Const(*z % table_mod));
                func.instruction(Instruction::TableGet { table: 0 });

                func.instruction(Instruction::Call(1));
            }
            TableOp::TakeFromMake => {
                func.instruction(Instruction::Call(2));
                func.instruction(Instruction::Call(1));
            }
            Self::TakeFromGc => {
                func.instruction(Instruction::Call(0));
                func.instruction(Instruction::Call(1));
            }
        }
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,table_ops.rs,Rust,num_params & self,"    pub fn num_params(&self) -> u8 {
        let num_params = std::cmp::max(self.num_params, NUM_PARAMS_RANGE.start);
        let num_params = std::cmp::min(num_params, NUM_PARAMS_RANGE.end);
        num_params
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,table_ops.rs,Rust,table_size & self,"    pub fn table_size(&self) -> u32 {
        let table_size = std::cmp::max(self.table_size, TABLE_SIZE_RANGE.start);
        let table_size = std::cmp::min(table_size, TABLE_SIZE_RANGE.end);
        table_size
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"table_ops fuzz_config : crate :: generators :: Config , ops : crate :: generators :: table_ops :: TableOps ,","pub fn table_ops(
    fuzz_config: crate::generators::Config,
    ops: crate::generators::table_ops::TableOps,
) {
    let _ = env_logger::try_init();

    let expected_drops = Arc::new(AtomicUsize::new(ops.num_params() as usize));
    let num_dropped = Arc::new(AtomicUsize::new(0));

    {
        let mut config = fuzz_config.to_wasmtime();
        config.wasm_reference_types(true);
        config.consume_fuel(true);

        let engine = Engine::new(&config).unwrap();
        let mut store = create_store(&engine);
        store.add_fuel(100).unwrap();

        let wasm = ops.to_wasm_binary();
        log_wasm(&wasm);
        let module = match Module::new(&engine, &wasm) {
            Ok(m) => m,
            Err(_) => return,
        };

        let mut linker = Linker::new(&engine);

        // To avoid timeouts, limit the number of explicit GCs we perform per
        // test case.
        const MAX_GCS: usize = 5;

        let num_gcs = AtomicUsize::new(0);
        linker
            .define(
                """",
                ""gc"",
                // NB: use `Func::new` so that this can still compile on the old x86
                // backend, where `IntoFunc` isn't implemented for multi-value
                // returns.
                Func::new(
                    &mut store,
                    FuncType::new(
                        vec![],
                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],
                    ),
                    {
                        let num_dropped = num_dropped.clone();
                        let expected_drops = expected_drops.clone();
                        move |mut caller: Caller<'_, StoreLimits>, _params, results| {
                            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {
                                caller.gc();
                            }

                            expected_drops.fetch_add(3, SeqCst);
                            results[0] =
                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();
                            results[1] =
                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();
                            results[2] =
                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();
                            Ok(())
                        }
                    },
                ),
            )
            .unwrap();

        linker
            .func_wrap("""", ""take_refs"", {
                let expected_drops = expected_drops.clone();
                move |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {
                    // Do the assertion on each ref's inner data, even though it
                    // all points to the same atomic, so that if we happen to
                    // run into a use-after-free bug with one of these refs we
                    // are more likely to trigger a segfault.
                    if let Some(a) = a {
                        let a = a.data().downcast_ref::<CountDrops>().unwrap();
                        assert!(a.0.load(SeqCst) <= expected_drops.load(SeqCst));
                    }
                    if let Some(b) = b {
                        let b = b.data().downcast_ref::<CountDrops>().unwrap();
                        assert!(b.0.load(SeqCst) <= expected_drops.load(SeqCst));
                    }
                    if let Some(c) = c {
                        let c = c.data().downcast_ref::<CountDrops>().unwrap();
                        assert!(c.0.load(SeqCst) <= expected_drops.load(SeqCst));
                    }
                }
            })
            .unwrap();

        linker
            .define(
                """",
                ""make_refs"",
                // NB: use `Func::new` so that this can still compile on the old
                // x86 backend, where `IntoFunc` isn't implemented for
                // multi-value returns.
                Func::new(
                    &mut store,
                    FuncType::new(
                        vec![],
                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],
                    ),
                    {
                        let num_dropped = num_dropped.clone();
                        let expected_drops = expected_drops.clone();
                        move |_caller, _params, results| {
                            expected_drops.fetch_add(3, SeqCst);
                            results[0] =
                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();
                            results[1] =
                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();
                            results[2] =
                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();
                            Ok(())
                        }
                    },
                ),
            )
            .unwrap();

        let instance = linker.instantiate(&mut store, &module).unwrap();
        let run = instance.get_func(&mut store, ""run"").unwrap();

        let args: Vec<_> = (0..ops.num_params())
            .map(|_| Val::ExternRef(Some(ExternRef::new(CountDrops(num_dropped.clone())))))
            .collect();
        let _ = run.call(&mut store, &args);
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,log_wasm wasm : & [ u8 ],"fn log_wasm(wasm: &[u8]) {
    if !log::log_enabled!(log::Level::Debug) {
        return;
    }

    let i = CNT.fetch_add(1, SeqCst);
    let name = format!(""testcase{}.wasm"", i);
    std::fs::write(&name, wasm).expect(""failed to write wasm file"");
    log::debug!(""wrote wasm file to `{}`"", name);
    let wat = format!(""testcase{}.wat"", i);
    match wasmprinter::print_bytes(wasm) {
        Ok(s) => std::fs::write(&wat, s).expect(""failed to write wat file""),
        // If wasmprinter failed remove a `*.wat` file, if any, to avoid
        // confusing a preexisting one with this wasm which failed to get
        // printed.
        Err(_) => drop(std::fs::remove_file(&wat)),
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,create_store engine : & Engine,"fn create_store(engine: &Engine) -> Store<StoreLimits> {
    let mut store = Store::new(
        &engine,
        StoreLimits {
            // Limits tables/memories within a store to at most 1gb for now to
            // exercise some larger address but not overflow various limits.
            remaining_memory: 1 << 30,
            oom: false,
        },
    );
    store.limiter(|s| s as &mut dyn ResourceLimiter);
    return store;
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"alloc & mut self , amt : usize","    fn alloc(&mut self, amt: usize) -> bool {
        match self.remaining_memory.checked_sub(amt) {
            Some(mem) => {
                self.remaining_memory = mem;
                true
            }
            None => {
                self.oom = true;
                false
            }
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"memory_growing & mut self , current : usize , desired : usize , _maximum : Option < usize >","    fn memory_growing(&mut self, current: usize, desired: usize, _maximum: Option<usize>) -> bool {
        self.alloc(desired - current)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"table_growing & mut self , current : u32 , desired : u32 , _maximum : Option < u32 >","    fn table_growing(&mut self, current: u32, desired: u32, _maximum: Option<u32>) -> bool {
        let delta = (desired - current) as usize * std::mem::size_of::<usize>();
        self.alloc(delta)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"instantiate wasm : & [ u8 ] , known_valid : bool , strategy : Strategy","pub fn instantiate(wasm: &[u8], known_valid: bool, strategy: Strategy) {
    // Explicitly disable module linking for now since it's a breaking change to
    // pre-module-linking modules due to imports
    let mut cfg = crate::fuzz_default_config(strategy).unwrap();
    cfg.wasm_module_linking(false);
    instantiate_with_config(wasm, known_valid, cfg, Timeout::None);
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"instantiate_with_config wasm : & [ u8 ] , known_valid : bool , mut config : Config , timeout : Timeout ,","pub fn instantiate_with_config(
    wasm: &[u8],
    known_valid: bool,
    mut config: Config,
    timeout: Timeout,
) {
    crate::init_fuzzing();

    config.interruptable(match &timeout {
        Timeout::Time(_) => true,
        _ => false,
    });
    config.consume_fuel(match &timeout {
        Timeout::Fuel(_) => true,
        _ => false,
    });
    let engine = Engine::new(&config).unwrap();
    let mut store = create_store(&engine);

    let mut timeout_state = SignalOnDrop::default();
    match timeout {
        Timeout::Fuel(fuel) => store.add_fuel(fuel).unwrap(),
        // If a timeout is requested then we spawn a helper thread to wait for
        // the requested time and then send us a signal to get interrupted. We
        // also arrange for the thread's sleep to get interrupted if we return
        // early (or the wasm returns within the time limit), which allows the
        // thread to get torn down.
        //
        // This prevents us from creating a huge number of sleeping threads if
        // this function is executed in a loop, like it does on nightly fuzzing
        // infrastructure.
        Timeout::Time(timeout) => {
            let handle = store.interrupt_handle().unwrap();
            timeout_state.spawn_timeout(timeout, move || handle.interrupt());
        }
        Timeout::None => {}
    }

    log_wasm(wasm);
    let module = match Module::new(&engine, wasm) {
        Ok(module) => module,
        Err(_) if !known_valid => return,
        Err(e) => panic!(""failed to compile module: {:?}"", e),
    };

    instantiate_with_dummy(&mut store, &module);
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"instantiate_with_dummy store : & mut Store < StoreLimits > , module : & Module","fn instantiate_with_dummy(store: &mut Store<StoreLimits>, module: &Module) -> Option<Instance> {
    // Creation of imports can fail due to resource limit constraints, and then
    // instantiation can naturally fail for a number of reasons as well. Bundle
    // the two steps together to match on the error below.
    let instance =
        dummy::dummy_linker(store, module).and_then(|l| l.instantiate(&mut *store, module));

    let e = match instance {
        Ok(i) => return Some(i),
        Err(e) => e,
    };

    // If the instantiation hit OOM for some reason then that's ok, it's
    // expected that fuzz-generated programs try to allocate lots of
    // stuff.
    if store.data().oom {
        return None;
    }

    // Allow traps which can happen normally with `unreachable` or a
    // timeout or such
    if e.downcast_ref::<Trap>().is_some() {
        return None;
    }

    let string = e.to_string();
    // Also allow errors related to fuel consumption
    if string.contains(""all fuel consumed"")
        // Currently we instantiate with a `Linker` which can't instantiate
        // every single module under the sun due to using name-based resolution
        // rather than positional-based resolution
        || string.contains(""incompatible import type"")
    {
        return None;
    }

    // Everything else should be a bug in the fuzzer or a bug in wasmtime
    panic!(""failed to instantiate {:?}"", e);
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"compile wasm : & [ u8 ] , strategy : Strategy","pub fn compile(wasm: &[u8], strategy: Strategy) {
    crate::init_fuzzing();

    let engine = Engine::new(&crate::fuzz_default_config(strategy).unwrap()).unwrap();
    log_wasm(wasm);
    let _ = Module::new(&engine, wasm);
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"init_hang_limit store : & mut Store < T > , instance : Instance","    fn init_hang_limit<T>(store: &mut Store<T>, instance: Instance) {
        match instance.get_export(&mut *store, ""hangLimitInitializer"") {
            None => return,
            Some(Extern::Func(f)) => {
                f.call(store, &[])
                    .expect(""initializing the hang limit should not fail"");
            }
            Some(_) => panic!(""unexpected hangLimitInitializer export""),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"assert_same_export_func_result lhs : & Result < Box < [ Val ] > , Trap > , rhs : & Result < Box < [ Val ] > , Trap > , func_name : & str ,","    fn assert_same_export_func_result(
        lhs: &Result<Box<[Val]>, Trap>,
        rhs: &Result<Box<[Val]>, Trap>,
        func_name: &str,
    ) {
        let fail = || {
            panic!(
                ""differential fuzzing failed: exported func {} returned two \
                 different results: {:?} != {:?}"",
                func_name, lhs, rhs
            )
        };

        match (lhs, rhs) {
            (Err(_), Err(_)) => {}
            (Ok(lhs), Ok(rhs)) => {
                if lhs.len() != rhs.len() {
                    fail();
                }
                for (lhs, rhs) in lhs.iter().zip(rhs.iter()) {
                    match (lhs, rhs) {
                        (Val::I32(lhs), Val::I32(rhs)) if lhs == rhs => continue,
                        (Val::I64(lhs), Val::I64(rhs)) if lhs == rhs => continue,
                        (Val::V128(lhs), Val::V128(rhs)) if lhs == rhs => continue,
                        (Val::F32(lhs), Val::F32(rhs)) if f32_equal(*lhs, *rhs) => continue,
                        (Val::F64(lhs), Val::F64(rhs)) if f64_equal(*lhs, *rhs) => continue,
                        (Val::ExternRef(_), Val::ExternRef(_))
                        | (Val::FuncRef(_), Val::FuncRef(_)) => continue,
                        _ => fail(),
                    }
                }
            }
            _ => fail(),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"differential_execution module : & crate :: generators :: GeneratedModule , configs : & [ crate :: generators :: DifferentialConfig ] ,","pub fn differential_execution(
    module: &crate::generators::GeneratedModule,
    configs: &[crate::generators::DifferentialConfig],
) {
    use std::collections::{HashMap, HashSet};

    crate::init_fuzzing();

    // We need at least two configs.
    if configs.len() < 2
        // And all the configs should be unique.
        || configs.iter().collect::<HashSet<_>>().len() != configs.len()
    {
        return;
    }

    let configs: Vec<_> = match configs.iter().map(|c| c.to_wasmtime_config()).collect() {
        Ok(cs) => cs,
        // If the config is trying to use something that was turned off at
        // compile time, eg lightbeam, just continue to the next fuzz input.
        Err(_) => return,
    };

    let mut export_func_results: HashMap<String, Result<Box<[Val]>, Trap>> = Default::default();
    let wasm = module.module.to_bytes();
    log_wasm(&wasm);

    for mut config in configs {
        // Disable module linking since it isn't enabled by default for
        // `GeneratedModule` but is enabled by default for our fuzz config.
        // Since module linking is currently a breaking change this is required
        // to accept modules that would otherwise be broken by module linking.
        config.wasm_module_linking(false);

        let engine = Engine::new(&config).unwrap();
        let mut store = create_store(&engine);

        let module = Module::new(&engine, &wasm).unwrap();

        // TODO: we should implement tracing versions of these dummy imports
        // that record a trace of the order that imported functions were called
        // in and with what values. Like the results of exported functions,
        // calls to imports should also yield the same values for each
        // configuration, and we should assert that.
        let instance = match instantiate_with_dummy(&mut store, &module) {
            Some(instance) => instance,
            None => continue,
        };

        let exports = instance
            .exports(&mut store)
            .filter_map(|e| {
                let name = e.name().to_string();
                e.into_func().map(|f| (name, f))
            })
            .collect::<Vec<_>>();
        for (name, f) in exports {
            // Always call the hang limit initializer first, so that we don't
            // infinite loop when calling another export.
            init_hang_limit(&mut store, instance);

            let ty = f.ty(&store);
            let params = dummy::dummy_values(ty.params());
            let this_result = f
                .call(&mut store, &params)
                .map_err(|e| e.downcast::<Trap>().unwrap());

            let existing_result = export_func_results
                .entry(name.to_string())
                .or_insert_with(|| this_result.clone());
            assert_same_export_func_result(&existing_result, &this_result, &name);
        }
    }

    fn init_hang_limit<T>(store: &mut Store<T>, instance: Instance) {
        match instance.get_export(&mut *store, ""hangLimitInitializer"") {
            None => return,
            Some(Extern::Func(f)) => {
                f.call(store, &[])
                    .expect(""initializing the hang limit should not fail"");
            }
            Some(_) => panic!(""unexpected hangLimitInitializer export""),
        }
    }

    fn assert_same_export_func_result(
        lhs: &Result<Box<[Val]>, Trap>,
        rhs: &Result<Box<[Val]>, Trap>,
        func_name: &str,
    ) {
        let fail = || {
            panic!(
                ""differential fuzzing failed: exported func {} returned two \
                 different results: {:?} != {:?}"",
                func_name, lhs, rhs
            )
        };

        match (lhs, rhs) {
            (Err(_), Err(_)) => {}
            (Ok(lhs), Ok(rhs)) => {
                if lhs.len() != rhs.len() {
                    fail();
                }
                for (lhs, rhs) in lhs.iter().zip(rhs.iter()) {
                    match (lhs, rhs) {
                        (Val::I32(lhs), Val::I32(rhs)) if lhs == rhs => continue,
                        (Val::I64(lhs), Val::I64(rhs)) if lhs == rhs => continue,
                        (Val::V128(lhs), Val::V128(rhs)) if lhs == rhs => continue,
                        (Val::F32(lhs), Val::F32(rhs)) if f32_equal(*lhs, *rhs) => continue,
                        (Val::F64(lhs), Val::F64(rhs)) if f64_equal(*lhs, *rhs) => continue,
                        (Val::ExternRef(_), Val::ExternRef(_))
                        | (Val::FuncRef(_), Val::FuncRef(_)) => continue,
                        _ => fail(),
                    }
                }
            }
            _ => fail(),
        }
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"f32_equal a : u32 , b : u32","fn f32_equal(a: u32, b: u32) -> bool {
    let a = f32::from_bits(a);
    let b = f32::from_bits(b);
    a == b || (a.is_nan() && b.is_nan())
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"f64_equal a : u64 , b : u64","fn f64_equal(a: u64, b: u64) -> bool {
    let a = f64::from_bits(a);
    let b = f64::from_bits(b);
    a == b || (a.is_nan() && b.is_nan())
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,make_api_calls api : crate :: generators :: api :: ApiCalls,"pub fn make_api_calls(api: crate::generators::api::ApiCalls) {
    use crate::generators::api::ApiCall;
    use std::collections::HashMap;

    crate::init_fuzzing();

    let mut config: Option<Config> = None;
    let mut engine: Option<Engine> = None;
    let mut store: Option<Store<StoreLimits>> = None;
    let mut modules: HashMap<usize, Module> = Default::default();
    let mut instances: HashMap<usize, Instance> = Default::default();

    for call in api.calls {
        match call {
            ApiCall::ConfigNew => {
                log::trace!(""creating config"");
                assert!(config.is_none());
                config = Some(crate::fuzz_default_config(wasmtime::Strategy::Cranelift).unwrap());
            }

            ApiCall::ConfigDebugInfo(b) => {
                log::trace!(""enabling debuginfo"");
                config.as_mut().unwrap().debug_info(b);
            }

            ApiCall::ConfigInterruptable(b) => {
                log::trace!(""enabling interruption"");
                config.as_mut().unwrap().interruptable(b);
            }

            ApiCall::EngineNew => {
                log::trace!(""creating engine"");
                assert!(engine.is_none());
                engine = Some(Engine::new(config.as_ref().unwrap()).unwrap());
            }

            ApiCall::StoreNew => {
                log::trace!(""creating store"");
                assert!(store.is_none());
                store = Some(create_store(engine.as_ref().unwrap()));
            }

            ApiCall::ModuleNew { id, wasm } => {
                log::debug!(""creating module: {}"", id);
                let wasm = wasm.module.to_bytes();
                log_wasm(&wasm);
                let module = match Module::new(engine.as_ref().unwrap(), &wasm) {
                    Ok(m) => m,
                    Err(_) => continue,
                };
                let old = modules.insert(id, module);
                assert!(old.is_none());
            }

            ApiCall::ModuleDrop { id } => {
                log::trace!(""dropping module: {}"", id);
                drop(modules.remove(&id));
            }

            ApiCall::InstanceNew { id, module } => {
                log::trace!(""instantiating module {} as {}"", module, id);
                let module = match modules.get(&module) {
                    Some(m) => m,
                    None => continue,
                };

                let store = store.as_mut().unwrap();
                if let Some(instance) = instantiate_with_dummy(store, module) {
                    instances.insert(id, instance);
                }
            }

            ApiCall::InstanceDrop { id } => {
                log::trace!(""dropping instance {}"", id);
                drop(instances.remove(&id));
            }

            ApiCall::CallExportedFunc { instance, nth } => {
                log::trace!(""calling instance export {} / {}"", instance, nth);
                let instance = match instances.get(&instance) {
                    Some(i) => i,
                    None => {
                        // Note that we aren't guaranteed to instantiate valid
                        // modules, see comments in `InstanceNew` for details on
                        // that. But the API call generator can't know if
                        // instantiation failed, so we might not actually have
                        // this instance. When that's the case, just skip the
                        // API call and keep going.
                        continue;
                    }
                };
                let store = store.as_mut().unwrap();

                let funcs = instance
                    .exports(&mut *store)
                    .filter_map(|e| match e.into_extern() {
                        Extern::Func(f) => Some(f.clone()),
                        _ => None,
                    })
                    .collect::<Vec<_>>();

                if funcs.is_empty() {
                    continue;
                }

                let nth = nth % funcs.len();
                let f = &funcs[nth];
                let ty = f.ty(&store);
                let params = dummy::dummy_values(ty.params());
                let _ = f.call(store, &params);
            }
        }
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,"spectest fuzz_config : crate :: generators :: Config , test : crate :: generators :: SpecTest","pub fn spectest(fuzz_config: crate::generators::Config, test: crate::generators::SpecTest) {
    crate::init_fuzzing();
    log::debug!(""running {:?} with {:?}"", test.file, fuzz_config);
    let mut config = fuzz_config.to_wasmtime();
    config.wasm_memory64(false);
    config.wasm_reference_types(false);
    config.wasm_bulk_memory(false);
    config.wasm_module_linking(false);
    config.wasm_multi_memory(false);
    let mut store = create_store(&Engine::new(&config).unwrap());
    if fuzz_config.consume_fuel {
        store.add_fuel(u64::max_value()).unwrap();
    }
    let mut wast_context = WastContext::new(store);
    wast_context.register_spectest().unwrap();
    wast_context
        .run_buffer(test.file, test.contents.as_bytes())
        .unwrap();
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,oracles.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        if let Some(thread) = self.thread.take() {
            let (lock, cvar) = &*self.state;
            // Signal our thread that we've been dropped and wake it up if it's
            // blocked.
            let mut g = lock.lock().unwrap();
            *g = true;
            cvar.notify_one();
            drop(g);

            // ... and then wait for the thread to exit to ensure we clean up
            // after ourselves.
            thread.join().unwrap();
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,new,"    pub fn new() -> Self {
        let chunk = Self::new_chunk(Self::CHUNK_SIZE);
        let next = chunk.as_ptr() as *mut TableElem;
        let end = unsafe { next.add(chunk.len()) };

        VMExternRefActivationsTable {
            alloc: VMExternRefTableAlloc {
                next: UnsafeCell::new(NonNull::new(next).unwrap()),
                end: NonNull::new(end).unwrap(),
                chunk,
            },
            over_approximated_stack_roots: HashSet::with_capacity(Self::CHUNK_SIZE),
            precise_stack_roots: HashSet::with_capacity(Self::CHUNK_SIZE),
            stack_canary: None,
        }
    }",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"insert_with_gc & mut self , externref : VMExternRef , module_info_lookup : & dyn ModuleInfoLookup ,","    pub unsafe fn insert_with_gc(
        &mut self,
        externref: VMExternRef,
        module_info_lookup: &dyn ModuleInfoLookup,
    ) {
        if let Err(externref) = self.try_insert(externref) {
            self.gc_and_insert_slow(externref, module_info_lookup);
        }
    }",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"gc module_info_lookup : & dyn ModuleInfoLookup , externref_activations_table : & mut VMExternRefActivationsTable ,","pub unsafe fn gc(
    module_info_lookup: &dyn ModuleInfoLookup,
    externref_activations_table: &mut VMExternRefActivationsTable,
) {
    log::debug!(""start GC"");

    debug_assert!({
        // This set is only non-empty within this function. It is built up when
        // walking the stack and interpreting stack maps, and then drained back
        // into the activations table's bump-allocated space at the
        // end. Therefore, it should always be empty upon entering this
        // function.
        externref_activations_table.precise_stack_roots.is_empty()
    });

    // Whenever we call into Wasm from host code for the first time, we set a
    // stack canary. When we return to that host code, we unset the stack
    // canary. If there is *not* a stack canary, then there must be zero Wasm
    // frames on the stack. Therefore, we can simply reset the table without
    // walking the stack.
    let stack_canary = match externref_activations_table.stack_canary {
        None => {
            if cfg!(debug_assertions) {
                // Assert that there aren't any Wasm frames on the stack.
                backtrace::trace(|frame| {
                    assert!(module_info_lookup.lookup(frame.ip() as usize).is_none());
                    true
                });
            }
            externref_activations_table.sweep();
            log::debug!(""end GC"");
            return;
        }
        Some(canary) => canary,
    };

    // There is a stack canary, so there must be Wasm frames on the stack. The
    // rest of this function consists of:
    //
    // * walking the stack,
    //
    // * finding the precise set of roots inside Wasm frames via our stack maps,
    //   and
    //
    // * resetting our bump-allocated table's over-approximation to the
    //   newly-discovered precise set.

    // The SP of the previous (younger) frame we processed.
    let mut last_sp = None;

    // Whether we have found our stack canary or not yet.
    let mut found_canary = false;

    // The `activations_table_set` is used for `debug_assert!`s checking that
    // every reference we read out from the stack via stack maps is actually in
    // the table. If that weren't true, than either we forgot to insert a
    // reference in the table when passing it into Wasm (a bug) or we are
    // reading invalid references from the stack (another bug).
    let mut activations_table_set: DebugOnly<HashSet<_>> = Default::default();
    if cfg!(debug_assertions) {
        externref_activations_table.elements(|elem| {
            activations_table_set.insert(elem.as_raw() as *mut VMExternData);
        });
    }

    backtrace::trace(|frame| {
        let pc = frame.ip() as usize;
        let sp = frame.sp() as usize;

        if let Some(module_info) = module_info_lookup.lookup(pc) {
            if let Some(stack_map) = module_info.lookup_stack_map(pc) {
                debug_assert!(sp != 0, ""we should always get a valid SP for Wasm frames"");

                for i in 0..(stack_map.mapped_words() as usize) {
                    if stack_map.get_bit(i) {
                        // Stack maps have one bit per word in the frame, and the
                        // zero^th bit is the *lowest* addressed word in the frame,
                        // i.e. the closest to the SP. So to get the `i`^th word in
                        // this frame, we add `i * sizeof(word)` to the SP.
                        let ptr_to_ref = sp + i * mem::size_of::<usize>();

                        let r = std::ptr::read(ptr_to_ref as *const *mut VMExternData);
                        debug_assert!(
                            r.is_null() || activations_table_set.contains(&r),
                            ""every on-stack externref inside a Wasm frame should \
                            have an entry in the VMExternRefActivationsTable""
                        );
                        if let Some(r) = NonNull::new(r) {
                            VMExternRefActivationsTable::insert_precise_stack_root(
                                &mut externref_activations_table.precise_stack_roots,
                                r,
                            );
                        }
                    }
                }
            }
        }

        if let Some(last_sp) = last_sp {
            // We've found the stack canary when we walk over the frame that it
            // is contained within.
            found_canary |= last_sp <= stack_canary && stack_canary <= sp;
        }
        last_sp = Some(sp);

        // Keep walking the stack until we've found the canary, which is the
        // oldest frame before we ever called into Wasm. We can stop once we've
        // found it because there won't be any more Wasm frames, and therefore
        // there won't be anymore on-stack, inside-a-Wasm-frame roots.
        !found_canary
    });

    // Only sweep and reset the table if we found the stack canary, and
    // therefore know that we discovered all the on-stack, inside-a-Wasm-frame
    // roots. If we did *not* find the stack canary, then `libunwind` failed to
    // walk the whole stack, and we might be missing roots. Reseting the table
    // would free those missing roots while they are still in use, leading to
    // use-after-free.
    if found_canary {
        externref_activations_table.sweep();
    } else {
        log::warn!(""did not find stack canary; skipping GC sweep"");
        externref_activations_table.precise_stack_roots.clear();
    }

    log::debug!(""end GC"");
}",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,new,"    pub fn new() -> Self {
        let chunk = Self::new_chunk(Self::CHUNK_SIZE);
        let next = chunk.as_ptr() as *mut TableElem;
        let end = unsafe { next.add(chunk.len()) };

        VMExternRefActivationsTable {
            alloc: VMExternRefTableAlloc {
                next: UnsafeCell::new(NonNull::new(next).unwrap()),
                end: NonNull::new(end).unwrap(),
                chunk,
            },
            over_approximated_stack_roots: HashSet::with_capacity(Self::CHUNK_SIZE),
            precise_stack_roots: HashSet::with_capacity(Self::CHUNK_SIZE),
            stack_canary: None,
            #[cfg(debug_assertions)]
            gc_okay: true,
        }
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"set_gc_okay & mut self , okay : bool","    pub fn set_gc_okay(&mut self, okay: bool) -> bool {
        #[cfg(debug_assertions)]
        {
            return std::mem::replace(&mut self.gc_okay, okay);
        }
        #[cfg(not(debug_assertions))]
        {
            let _ = okay;
            return true;
        }
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"gc module_info_lookup : & dyn ModuleInfoLookup , externref_activations_table : & mut VMExternRefActivationsTable ,","pub unsafe fn gc(
    module_info_lookup: &dyn ModuleInfoLookup,
    externref_activations_table: &mut VMExternRefActivationsTable,
) {
    log::debug!(""start GC"");

    #[cfg(debug_assertions)]
    assert!(externref_activations_table.gc_okay);

    debug_assert!({
        // This set is only non-empty within this function. It is built up when
        // walking the stack and interpreting stack maps, and then drained back
        // into the activations table's bump-allocated space at the
        // end. Therefore, it should always be empty upon entering this
        // function.
        externref_activations_table.precise_stack_roots.is_empty()
    });

    // Whenever we call into Wasm from host code for the first time, we set a
    // stack canary. When we return to that host code, we unset the stack
    // canary. If there is *not* a stack canary, then there must be zero Wasm
    // frames on the stack. Therefore, we can simply reset the table without
    // walking the stack.
    let stack_canary = match externref_activations_table.stack_canary {
        None => {
            if cfg!(debug_assertions) {
                // Assert that there aren't any Wasm frames on the stack.
                backtrace::trace(|frame| {
                    assert!(module_info_lookup.lookup(frame.ip() as usize).is_none());
                    true
                });
            }
            externref_activations_table.sweep();
            log::debug!(""end GC"");
            return;
        }
        Some(canary) => canary,
    };

    // There is a stack canary, so there must be Wasm frames on the stack. The
    // rest of this function consists of:
    //
    // * walking the stack,
    //
    // * finding the precise set of roots inside Wasm frames via our stack maps,
    //   and
    //
    // * resetting our bump-allocated table's over-approximation to the
    //   newly-discovered precise set.

    // The SP of the previous (younger) frame we processed.
    let mut last_sp = None;

    // Whether we have found our stack canary or not yet.
    let mut found_canary = false;

    // The `activations_table_set` is used for `debug_assert!`s checking that
    // every reference we read out from the stack via stack maps is actually in
    // the table. If that weren't true, than either we forgot to insert a
    // reference in the table when passing it into Wasm (a bug) or we are
    // reading invalid references from the stack (another bug).
    let mut activations_table_set: DebugOnly<HashSet<_>> = Default::default();
    if cfg!(debug_assertions) {
        externref_activations_table.elements(|elem| {
            activations_table_set.insert(elem.as_raw() as *mut VMExternData);
        });
    }

    backtrace::trace(|frame| {
        let pc = frame.ip() as usize;
        let sp = frame.sp() as usize;

        if let Some(module_info) = module_info_lookup.lookup(pc) {
            if let Some(stack_map) = module_info.lookup_stack_map(pc) {
                debug_assert!(sp != 0, ""we should always get a valid SP for Wasm frames"");

                for i in 0..(stack_map.mapped_words() as usize) {
                    if stack_map.get_bit(i) {
                        // Stack maps have one bit per word in the frame, and the
                        // zero^th bit is the *lowest* addressed word in the frame,
                        // i.e. the closest to the SP. So to get the `i`^th word in
                        // this frame, we add `i * sizeof(word)` to the SP.
                        let ptr_to_ref = sp + i * mem::size_of::<usize>();

                        let r = std::ptr::read(ptr_to_ref as *const *mut VMExternData);
                        debug_assert!(
                            r.is_null() || activations_table_set.contains(&r),
                            ""every on-stack externref inside a Wasm frame should \
                            have an entry in the VMExternRefActivationsTable""
                        );
                        if let Some(r) = NonNull::new(r) {
                            VMExternRefActivationsTable::insert_precise_stack_root(
                                &mut externref_activations_table.precise_stack_roots,
                                r,
                            );
                        }
                    }
                }
            }
        }

        if let Some(last_sp) = last_sp {
            // We've found the stack canary when we walk over the frame that it
            // is contained within.
            found_canary |= last_sp <= stack_canary && stack_canary <= sp;
        }
        last_sp = Some(sp);

        // Keep walking the stack until we've found the canary, which is the
        // oldest frame before we ever called into Wasm. We can stop once we've
        // found it because there won't be any more Wasm frames, and therefore
        // there won't be anymore on-stack, inside-a-Wasm-frame roots.
        !found_canary
    });

    // Only sweep and reset the table if we found the stack canary, and
    // therefore know that we discovered all the on-stack, inside-a-Wasm-frame
    // roots. If we did *not* find the stack canary, then `libunwind` failed to
    // walk the whole stack, and we might be missing roots. Reseting the table
    // would free those missing roots while they are still in use, leading to
    // use-after-free.
    if found_canary {
        externref_activations_table.sweep();
    } else {
        log::warn!(""did not find stack canary; skipping GC sweep"");
        externref_activations_table.precise_stack_roots.clear();
    }

    log::debug!(""end GC"");
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,bump_capacity_remaining & self,"    pub fn bump_capacity_remaining(&self) -> usize {
        let end = self.alloc.end.as_ptr() as usize;
        let next = unsafe { *self.alloc.next.get() };
        end - next.as_ptr() as usize
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"insert_with_gc & mut self , externref : VMExternRef , module_info_lookup : & dyn ModuleInfoLookup ,","    pub unsafe fn insert_with_gc(
        &mut self,
        externref: VMExternRef,
        module_info_lookup: &dyn ModuleInfoLookup,
    ) {
        #[cfg(debug_assertions)]
        assert!(self.gc_okay);

        if let Err(externref) = self.try_insert(externref) {
            self.gc_and_insert_slow(externref, module_info_lookup);
        }
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"insert_slow_without_gc & mut self , externref : VMExternRef","    fn insert_slow_without_gc(&mut self, externref: VMExternRef) {
        self.over_approximated_stack_roots
            .insert(VMExternRefWithTraits(externref));
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"insert_without_gc & mut self , externref : VMExternRef","    pub fn insert_without_gc(&mut self, externref: VMExternRef) {
        if let Err(externref) = self.try_insert(externref) {
            self.insert_slow_without_gc(externref);
        }
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,clone & self,"    fn clone(&self) -> VMExternRef {
        self.extern_data().increment_ref_count();
        VMExternRef(self.0)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        let data = self.extern_data();

        // Note that the memory orderings here also match the standard library
        // itself. Documentation is more available in the implementation of
        // `Arc`, but the general idea is that this is a special pattern allowed
        // by the C standard with atomic orderings where we ""release"" for all
        // the decrements and only the final decrementer performs an acquire
        // fence. This properly ensures that the final thread, which actually
        // destroys the data, sees all the updates from all other threads.
        if data.ref_count.fetch_sub(1, Ordering::Release) != 1 {
            return;
        }
        atomic::fence(Ordering::Acquire);

        // Drop our live reference to `data` before we drop it itself.
        drop(data);
        unsafe {
            VMExternData::drop_and_dealloc(self.0);
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"layout_for value_size : usize , value_align : usize","    unsafe fn layout_for(value_size: usize, value_align: usize) -> (Layout, usize) {
        let extern_data_size = mem::size_of::<VMExternData>();
        let extern_data_align = mem::align_of::<VMExternData>();

        let value_and_padding_size = round_up_to_align(value_size, extern_data_align).unwrap();

        let alloc_align = std::cmp::max(value_align, extern_data_align);
        let alloc_size = value_and_padding_size + extern_data_size;

        debug_assert!(Layout::from_size_align(alloc_size, alloc_align).is_ok());
        (
            Layout::from_size_align_unchecked(alloc_size, alloc_align),
            value_and_padding_size,
        )
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,drop_and_dealloc mut data : NonNull < VMExternData >,"    pub(crate) unsafe fn drop_and_dealloc(mut data: NonNull<VMExternData>) {
        // Note: we introduce a block scope so that we drop the live
        // reference to the data before we free the heap allocation it
        // resides within after this block.
        let (alloc_ptr, layout) = {
            let data = data.as_mut();
            debug_assert_eq!(data.ref_count.load(Ordering::SeqCst), 0);

            // Same thing, but for the dropping the reference to `value` before
            // we drop it itself.
            let (layout, _) = {
                let value = data.value_ptr.as_ref();
                Self::layout_for(mem::size_of_val(value), mem::align_of_val(value))
            };

            ptr::drop_in_place(data.value_ptr.as_ptr());
            let alloc_ptr = data.value_ptr.cast::<u8>();

            (alloc_ptr, layout)
        };

        ptr::drop_in_place(data.as_ptr());
        std::alloc::dealloc(alloc_ptr.as_ptr(), layout);
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,increment_ref_count & self,"    fn increment_ref_count(&self) {
        // This is only using during cloning operations, and like the standard
        // library we use `Relaxed` here. The rationale is better documented in
        // libstd's implementation of `Arc`, but the general gist is that we're
        // creating a new pointer for our own thread, so there's no need to have
        // any synchronization with orderings. The synchronization with other
        // threads with respect to orderings happens when the pointer is sent to
        // another thread.
        self.ref_count.fetch_add(1, Ordering::Relaxed);
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"round_up_to_align n : usize , align : usize","fn round_up_to_align(n: usize, align: usize) -> Option<usize> {
    debug_assert!(align.is_power_of_two());
    let align_minus_one = align - 1;
    Some(n.checked_add(align_minus_one)? & !align_minus_one)
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,new value : T,"    pub fn new<T>(value: T) -> VMExternRef
    where
        T: 'static + Any + Send + Sync,
    {
        VMExternRef::new_with(|| value)
    }

    /// Construct a new `VMExternRef` in place by invoking `make_value`.
    pub fn new_with<T>(make_value: impl FnOnce() -> T) -> VMExternRef
    where
        T: 'static + Any + Send + Sync,
    {
        unsafe {
            let (layout, footer_offset) =
                VMExternData::layout_for(mem::size_of::<T>(), mem::align_of::<T>());

            let alloc_ptr = std::alloc::alloc(layout);
            let alloc_ptr = NonNull::new(alloc_ptr).unwrap_or_else(|| {
                std::alloc::handle_alloc_error(layout);
            });

            let value_ptr = alloc_ptr.cast::<T>();
            ptr::write(value_ptr.as_ptr(), make_value());

            let extern_data_ptr =
                alloc_ptr.cast::<u8>().as_ptr().add(footer_offset) as *mut VMExternData;
            ptr::write(
                extern_data_ptr,
                VMExternData {
                    ref_count: AtomicUsize::new(1),
                    // Cast from `*mut T` to `*mut dyn Any` here.
                    value_ptr: NonNull::new_unchecked(value_ptr.as_ptr()),
                },
            );

            VMExternRef(NonNull::new_unchecked(extern_data_ptr))
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,as_raw & self,"    pub fn as_raw(&self) -> *mut u8 {
        let ptr = self.0.cast::<u8>().as_ptr();
        ptr
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,into_raw self,"    pub unsafe fn into_raw(self) -> *mut u8 {
        let ptr = self.0.cast::<u8>().as_ptr();
        std::mem::forget(self);
        ptr
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,from_raw ptr : * mut u8,"    pub unsafe fn from_raw(ptr: *mut u8) -> Self {
        debug_assert!(!ptr.is_null());
        VMExternRef(NonNull::new_unchecked(ptr).cast())
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,clone_from_raw ptr : * mut u8,"    pub unsafe fn clone_from_raw(ptr: *mut u8) -> Self {
        debug_assert!(!ptr.is_null());
        let x = VMExternRef(NonNull::new_unchecked(ptr).cast());
        x.extern_data().increment_ref_count();
        x
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,strong_count & self,"    pub fn strong_count(&self) -> usize {
        self.extern_data().ref_count.load(Ordering::SeqCst)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,extern_data & self,"    fn extern_data(&self) -> &VMExternData {
        unsafe { self.0.as_ref() }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"eq a : & Self , b : & Self","    pub fn eq(a: &Self, b: &Self) -> bool {
        ptr::eq(a.0.as_ptr() as *const _, b.0.as_ptr() as *const _)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"hash externref : & Self , hasher : & mut H","    pub fn hash<H>(externref: &Self, hasher: &mut H)
    where
        H: Hasher,
    {
        ptr::hash(externref.0.as_ptr() as *const _, hasher);
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"cmp a : & Self , b : & Self","    pub fn cmp(a: &Self, b: &Self) -> cmp::Ordering {
        let a = a.0.as_ptr() as usize;
        let b = b.0.as_ptr() as usize;
        a.cmp(&b)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,deref & self,"    fn deref(&self) -> &dyn Any {
        unsafe { self.extern_data().value_ptr.as_ref() }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"hash & self , hasher : & mut H","    fn hash<H>(&self, hasher: &mut H)
    where
        H: Hasher,
    {
        VMExternRef::hash(&self.0, hasher)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"eq & self , other : & Self","    fn eq(&self, other: &Self) -> bool {
        VMExternRef::eq(&self.0, &other.0)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,_assert,    fn _assert<T: Send + Sync>() {},0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,_assert_send_sync,"fn _assert_send_sync() {
    fn _assert<T: Send + Sync>() {}
    _assert::<VMExternRefActivationsTable>();
    _assert::<VMExternRef>();
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,new_chunk size : usize,"    fn new_chunk(size: usize) -> Box<[UnsafeCell<Option<VMExternRef>>]> {
        assert!(size >= Self::CHUNK_SIZE);
        (0..size).map(|_| UnsafeCell::new(None)).collect()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"try_insert & mut self , externref : VMExternRef","    pub fn try_insert(&mut self, externref: VMExternRef) -> Result<(), VMExternRef> {
        unsafe {
            let next = *self.alloc.next.get();
            if next == self.alloc.end {
                return Err(externref);
            }

            debug_assert!(
                (*next.as_ref().get()).is_none(),
                ""slots >= the `next` bump finger are always `None`""
            );
            ptr::write(next.as_ptr(), UnsafeCell::new(Some(externref)));

            let next = NonNull::new_unchecked(next.as_ptr().add(1));
            debug_assert!(next <= self.alloc.end);
            *self.alloc.next.get() = next;

            Ok(())
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"gc_and_insert_slow & mut self , externref : VMExternRef , module_info_lookup : & dyn ModuleInfoLookup ,","    unsafe fn gc_and_insert_slow(
        &mut self,
        externref: VMExternRef,
        module_info_lookup: &dyn ModuleInfoLookup,
    ) {
        gc(module_info_lookup, self);

        // Might as well insert right into the hash set, rather than the bump
        // chunk, since we are already on a slow path and we get de-duplication
        // this way.
        self.over_approximated_stack_roots
            .insert(VMExternRefWithTraits(externref));
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,num_filled_in_bump_chunk & self,"    fn num_filled_in_bump_chunk(&self) -> usize {
        let next = unsafe { *self.alloc.next.get() };
        let bytes_unused = (self.alloc.end.as_ptr() as usize) - (next.as_ptr() as usize);
        let slots_unused = bytes_unused / mem::size_of::<TableElem>();
        self.alloc.chunk.len().saturating_sub(slots_unused)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"elements & self , mut f : impl FnMut & VMExternRef","    fn elements(&self, mut f: impl FnMut(&VMExternRef)) {
        for elem in self.over_approximated_stack_roots.iter() {
            f(&elem.0);
        }

        // The bump chunk is not all the way full, so we only iterate over its
        // filled-in slots.
        let num_filled = self.num_filled_in_bump_chunk();
        for slot in self.alloc.chunk.iter().take(num_filled) {
            if let Some(elem) = unsafe { &*slot.get() } {
                f(elem);
            }
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"insert_precise_stack_root precise_stack_roots : & mut HashSet < VMExternRefWithTraits > , root : NonNull < VMExternData > ,","    fn insert_precise_stack_root(
        precise_stack_roots: &mut HashSet<VMExternRefWithTraits>,
        root: NonNull<VMExternData>,
    ) {
        let root = unsafe { VMExternRef::clone_from_raw(root.as_ptr() as *mut _) };
        precise_stack_roots.insert(VMExternRefWithTraits(root));
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,sweep & mut self,"    fn sweep(&mut self) {
        // Sweep our bump chunk.
        let num_filled = self.num_filled_in_bump_chunk();
        unsafe {
            *self.alloc.next.get() = self.alloc.end;
        }
        for slot in self.alloc.chunk.iter().take(num_filled) {
            unsafe {
                *slot.get() = None;
            }
        }
        debug_assert!(
            self.alloc
                .chunk
                .iter()
                .all(|slot| unsafe { (*slot.get()).as_ref().is_none() }),
            ""after sweeping the bump chunk, all slots should be `None`""
        );

        // Reset our `next` finger to the start of the bump allocation chunk.
        unsafe {
            let next = self.alloc.chunk.as_ptr() as *mut TableElem;
            debug_assert!(!next.is_null());
            *self.alloc.next.get() = NonNull::new_unchecked(next);
        }

        // The current `precise_stack_roots` becomes our new over-appoximated
        // set for the next GC cycle.
        mem::swap(
            &mut self.precise_stack_roots,
            &mut self.over_approximated_stack_roots,
        );

        // And finally, the new `precise_stack_roots` should be cleared and
        // remain empty until the next GC cycle.
        //
        // Note that this may run arbitrary code as we run externref
        // destructors. Because of our `&mut` borrow above on this table,
        // though, we're guaranteed that nothing will touch this table.
        self.precise_stack_roots.clear();
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,stack_canary & self,"    pub fn stack_canary(&self) -> Option<usize> {
        self.stack_canary
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"set_stack_canary & mut self , canary : Option < usize >","    pub fn set_stack_canary(&mut self, canary: Option<usize>) {
        self.stack_canary = canary;
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,"lookup_stack_map & self , pc : usize","    fn lookup_stack_map(&self, pc: usize) -> Option<&StackMap>;
}

#[derive(Debug, Default)]
struct DebugOnly<T> {
    inner: T,
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,deref & self,"    fn deref(&self) -> &T {
        if cfg!(debug_assertions) {
            &self.inner
        } else {
            panic!(
                ""only deref `DebugOnly` when `cfg(debug_assertions)` or \
                 inside a `debug_assert!(..)`""
            )
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,deref_mut & mut self,"    fn deref_mut(&mut self) -> &mut T {
        if cfg!(debug_assertions) {
            &mut self.inner
        } else {
            panic!(
                ""only deref `DebugOnly` when `cfg(debug_assertions)` or \
                 inside a `debug_assert!(..)`""
            )
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,extern_ref_is_pointer_sized_and_aligned,"    fn extern_ref_is_pointer_sized_and_aligned() {
        assert_eq!(mem::size_of::<VMExternRef>(), mem::size_of::<*mut ()>());
        assert_eq!(mem::align_of::<VMExternRef>(), mem::align_of::<*mut ()>());
        assert_eq!(
            mem::size_of::<Option<VMExternRef>>(),
            mem::size_of::<*mut ()>()
        );
        assert_eq!(
            mem::align_of::<Option<VMExternRef>>(),
            mem::align_of::<*mut ()>()
        );
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,ref_count_is_at_correct_offset,"    fn ref_count_is_at_correct_offset() {
        let s = ""hi"";
        let s: &(dyn Any + Send + Sync) = &s as _;
        let s: *const (dyn Any + Send + Sync) = s as _;
        let s: *mut (dyn Any + Send + Sync) = s as _;

        let extern_data = VMExternData {
            ref_count: AtomicUsize::new(0),
            value_ptr: NonNull::new(s).unwrap(),
        };

        let extern_data_ptr = &extern_data as *const _;
        let ref_count_ptr = &extern_data.ref_count as *const _;

        let actual_offset = (ref_count_ptr as usize) - (extern_data_ptr as usize);

        let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {
            ptr: 8,
            num_signature_ids: 0,
            num_imported_functions: 0,
            num_imported_tables: 0,
            num_imported_memories: 0,
            num_imported_globals: 0,
            num_defined_functions: 0,
            num_defined_tables: 0,
            num_defined_memories: 0,
            num_defined_globals: 0,
        });
        assert_eq!(
            offsets.vm_extern_data_ref_count(),
            actual_offset.try_into().unwrap(),
        );
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,table_next_is_at_correct_offset,"    fn table_next_is_at_correct_offset() {
        let table = VMExternRefActivationsTable::new();

        let table_ptr = &table as *const _;
        let next_ptr = &table.alloc.next as *const _;

        let actual_offset = (next_ptr as usize) - (table_ptr as usize);

        let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {
            ptr: 8,
            num_signature_ids: 0,
            num_imported_functions: 0,
            num_imported_tables: 0,
            num_imported_memories: 0,
            num_imported_globals: 0,
            num_defined_functions: 0,
            num_defined_tables: 0,
            num_defined_memories: 0,
            num_defined_globals: 0,
        });
        assert_eq!(
            offsets.vm_extern_ref_activation_table_next() as usize,
            actual_offset
        );
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,externref.rs,Rust,table_end_is_at_correct_offset,"    fn table_end_is_at_correct_offset() {
        let table = VMExternRefActivationsTable::new();

        let table_ptr = &table as *const _;
        let end_ptr = &table.alloc.end as *const _;

        let actual_offset = (end_ptr as usize) - (table_ptr as usize);

        let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {
            ptr: 8,
            num_signature_ids: 0,
            num_imported_functions: 0,
            num_imported_tables: 0,
            num_imported_memories: 0,
            num_imported_globals: 0,
            num_defined_functions: 0,
            num_defined_tables: 0,
            num_defined_memories: 0,
            num_defined_globals: 0,
        });
        assert_eq!(
            offsets.vm_extern_ref_activation_table_end() as usize,
            actual_offset
        );
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,try_from ty : wasmparser :: FuncType,"    fn try_from(ty: wasmparser::FuncType) -> Result<Self, Self::Error> {
        Ok(Self {
            params: ty
                .params
                .into_vec()
                .into_iter()
                .map(WasmType::try_from)
                .collect::<Result<_, Self::Error>>()?,
            returns: ty
                .returns
                .into_vec()
                .into_iter()
                .map(WasmType::try_from)
                .collect::<Result<_, Self::Error>>()?,
        })
    }",1,True,False,"1,2,3,4,5,6,7,8,9,10,11,12,13,14"
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,returns & self,"    pub fn returns(&self) -> &[WasmType] {
        &self.returns
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,params & self,"    pub fn params(&self) -> &[WasmType] {
        &self.params
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,"new params : Box < [ WasmType ] > , returns : Box < [ WasmType ] >","    pub fn new(params: Box<[WasmType]>, returns: Box<[WasmType]>) -> Self {
        let externref_params_count = params.iter().filter(|p| **p == WasmType::ExternRef).count();
        let externref_returns_count = params.iter().filter(|r| **r == WasmType::ExternRef).count();
        WasmFuncType {
            params,
            externref_params_count,
            returns,
            externref_returns_count,
        }
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,externref_params_count & self,"    pub fn externref_params_count(&self) -> usize {
        self.externref_params_count
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,externref_returns_count & self,"    pub fn externref_returns_count(&self) -> usize {
        self.externref_returns_count
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,try_from ty : wasmparser :: FuncType,"    fn try_from(ty: wasmparser::FuncType) -> Result<Self, Self::Error> {
        let params = ty
            .params
            .into_vec()
            .into_iter()
            .map(WasmType::try_from)
            .collect::<Result<_, Self::Error>>()?;
        let returns = ty
            .returns
            .into_vec()
            .into_iter()
            .map(WasmType::try_from)
            .collect::<Result<_, Self::Error>>()?;
        Ok(Self::new(params, returns))
    }",0,False,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,try_from ty : wasmparser :: Type,"    fn try_from(ty: wasmparser::Type) -> Result<Self, Self::Error> {
        use wasmparser::Type::*;
        match ty {
            I32 => Ok(WasmType::I32),
            I64 => Ok(WasmType::I64),
            F32 => Ok(WasmType::F32),
            F64 => Ok(WasmType::F64),
            V128 => Ok(WasmType::V128),
            FuncRef => Ok(WasmType::FuncRef),
            ExternRef => Ok(WasmType::ExternRef),
            ExnRef => Ok(WasmType::ExnRef),
            EmptyBlockType | Func => Err(WasmError::InvalidWebAssembly {
                message: ""unexpected value type"".to_string(),
                offset: 0,
            }),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,from ty : WasmType,"    fn from(ty: WasmType) -> wasmparser::Type {
        match ty {
            WasmType::I32 => wasmparser::Type::I32,
            WasmType::I64 => wasmparser::Type::I64,
            WasmType::F32 => wasmparser::Type::F32,
            WasmType::F64 => wasmparser::Type::F64,
            WasmType::V128 => wasmparser::Type::V128,
            WasmType::FuncRef => wasmparser::Type::FuncRef,
            WasmType::ExternRef => wasmparser::Type::ExternRef,
            WasmType::ExnRef => wasmparser::Type::ExnRef,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,"new ty : wasmparser :: GlobalType , initializer : GlobalInit","    pub fn new(ty: wasmparser::GlobalType, initializer: GlobalInit) -> WasmResult<Global> {
        Ok(Global {
            wasm_ty: ty.content_type.try_into()?,
            mutability: ty.mutable,
            initializer,
        })
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,try_from ty : wasmparser :: TableType,"    fn try_from(ty: wasmparser::TableType) -> WasmResult<Table> {
        Ok(Table {
            wasm_ty: ty.element_type.try_into()?,
            minimum: ty.initial,
            maximum: ty.maximum,
        })
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,from ty : wasmparser :: MemoryType,"    fn from(ty: wasmparser::MemoryType) -> Memory {
        Memory {
            minimum: ty.initial,
            maximum: ty.maximum,
            shared: ty.shared,
            memory64: ty.memory64,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,lib.rs,Rust,from ty : wasmparser :: TagType,"    fn from(ty: wasmparser::TagType) -> Tag {
        Tag {
            ty: TypeIndex::from_u32(ty.type_index),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,func.rs,Rust,"new mut store : impl AsContextMut < Data = T > , ty : FuncType , func : impl Fn Caller < '_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + ' static , -> Self { let store = store . as_context_mut . 0 ; unsafe { let host = HostFunc :: new store . engine , ty , func ; host . into_func store } } #[cfg(all(feature = ""async"", feature = ""cranelift""))] #[cfg_attr(nightlydoc, doc(cfg(all(feature = ""async"", feature = ""cranelift""))))] pub fn new_async < T , F > store : impl AsContextMut < Data = T > , ty : FuncType , func : F -> Func where F : for < 'a> Fn(
                Caller<' a , T > , & 'a [Val],
                &' a mut [ Val ] ,","    pub fn new<T>(
        mut store: impl AsContextMut<Data = T>,
        ty: FuncType,
        func: impl Fn(Caller<'_, T>, &[Val], &mut [Val]) -> Result<(), Trap> + Send + Sync + 'static,
    ) -> Self {
        let store = store.as_context_mut().0;

        // part of this unsafety is about matching the `T` to a `Store<T>`,
        // which is done through the `AsContextMut` bound above.
        unsafe {
            let host = HostFunc::new(store.engine(), ty, func);
            host.into_func(store)
        }
    }

    /// Creates a new host-defined WebAssembly function which, when called,
    /// will run the asynchronous computation defined by `func` to completion
    /// and then return the result to WebAssembly.
    ///
    /// This function is the asynchronous analogue of [`Func::new`] and much of
    /// that documentation applies to this as well. The key difference is that
    /// `func` returns a future instead of simply a `Result`. Note that the
    /// returned future can close over any of the arguments, but it cannot close
    /// over the state of the closure itself. It's recommended to store any
    /// necessary async state in the `T` of the [`Store<T>`](crate::Store) which
    /// can be accessed through [`Caller::data`] or [`Caller::data_mut`].
    ///
    /// For more information on `Send + Sync + 'static`, see
    /// [`Func::wrap`](#why-send--sync--static).
    ///
    /// # Panics
    ///
    /// This function will panic if `store` is not associated with an [async
    /// config](crate::Config::async_support).
    ///
    /// # Examples
    ///
    /// ```
    /// # use wasmtime::*;
    /// # fn main() -> anyhow::Result<()> {
    /// // Simulate some application-specific state as well as asynchronous
    /// // functions to query that state.
    /// struct MyDatabase {
    ///     // ...
    /// }
    ///
    /// impl MyDatabase {
    ///     async fn get_row_count(&self) -> u32 {
    ///         // ...
    /// #       100
    ///     }
    /// }
    ///
    /// let my_database = MyDatabase {
    ///     // ...
    /// };
    ///
    /// // Using `new_async` we can hook up into calling our async
    /// // `get_row_count` function.
    /// let engine = Engine::new(Config::new().async_support(true))?;
    /// let mut store = Store::new(&engine, MyDatabase {
    ///     // ...
    /// });
    /// let get_row_count_type = wasmtime::FuncType::new(
    ///     None,
    ///     Some(wasmtime::ValType::I32),
    /// );
    /// let get = Func::new_async(&mut store, get_row_count_type, |caller, _params, results| {
    ///     Box::new(async move {
    ///         let count = caller.data().get_row_count().await;
    ///         results[0] = Val::I32(count as i32);
    ///         Ok(())
    ///     })
    /// });
    /// // ...
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(all(feature = ""async"", feature = ""cranelift""))]
    #[cfg_attr(nightlydoc, doc(cfg(all(feature = ""async"", feature = ""cranelift""))))]
    pub fn new_async<T, F>(store: impl AsContextMut<Data = T>, ty: FuncType, func: F) -> Func
    where
        F: for<'a> Fn(
                Caller<'a, T>,
                &'a [Val],
                &'a mut [Val],
            ) -> Box<dyn Future<Output = Result<(), Trap>> + Send + 'a>
            + Send
            + Sync
            + 'static,
    {
        assert!(
            store.as_context().async_support(),
            ""cannot use `new_async` without enabling async support in the config""
        );
        Func::new(store, ty, move |mut caller, params, results| {
            let async_cx = caller.store.as_context_mut().0.async_cx();
            let mut future = Pin::from(func(caller, params, results));
            match unsafe { async_cx.block_on(future.as_mut()) } {
                Ok(Ok(())) => Ok(()),
                Ok(Err(trap)) | Err(trap) => Err(trap),
            }
        })
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,func.rs,Rust,"from_caller_checked_anyfunc store : & mut StoreOpaque , anyfunc : * mut VMCallerCheckedAnyfunc ,","    pub(crate) unsafe fn from_caller_checked_anyfunc(
        store: &mut StoreOpaque,
        anyfunc: *mut VMCallerCheckedAnyfunc,
    ) -> Option<Self> {
        let anyfunc = NonNull::new(anyfunc)?;
        debug_assert!(anyfunc.as_ref().type_index != VMSharedSignatureIndex::default());
        let export = ExportFunction { anyfunc };
        Some(Func::from_wasmtime_function(export, store))
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,func.rs,Rust,"wrap mut store : impl AsContextMut < Data = T > , func : impl IntoFunc < T , Params , Results > ,","    pub fn wrap<T, Params, Results>(
        mut store: impl AsContextMut<Data = T>,
        func: impl IntoFunc<T, Params, Results>,
    ) -> Func {
        let store = store.as_context_mut().0;
        // part of this unsafety is about matching the `T` to a `Store<T>`,
        // which is done through the `AsContextMut` bound above.
        unsafe {
            let host = HostFunc::wrap(store.engine(), func);
            host.into_func(store)
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,func.rs,Rust,"ty & self , store : impl AsContext","    pub fn ty(&self, store: impl AsContext) -> FuncType {
        // Signatures should always be registered in the engine's registry of
        // shared signatures, so we should be able to unwrap safely here.
        let store = store.as_context();
        let sig_index = unsafe { store[self.0].export().anyfunc.as_ref().type_index };
        FuncType::from_wasm_func_type(
            store
                .engine()
                .signatures()
                .lookup_type(sig_index)
                .expect(""signature should be registered""),
        )
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,func.rs,Rust,"sig_index & self , data : & StoreData","    pub(crate) fn sig_index(&self, data: &StoreData) -> VMSharedSignatureIndex {
        unsafe { data[self.0].export().anyfunc.as_ref().type_index }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,func.rs,Rust,"call & self , mut store : impl AsContextMut , params : & [ Val ]","    pub fn call(&self, mut store: impl AsContextMut, params: &[Val]) -> Result<Box<[Val]>> {
        assert!(
            !store.as_context().async_support(),
            ""must use `call_async` when async support is enabled on the config"",
        );
        let my_ty = self.ty(&store);
        self.call_impl(&mut store.as_context_mut(), my_ty, params)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,func.rs,Rust,"call_async & self , mut store : impl AsContextMut < Data = T > , params : & [ Val ] ,","    pub async fn call_async<T>(
        &self,
        mut store: impl AsContextMut<Data = T>,
        params: &[Val],
    ) -> Result<Box<[Val]>>
    where
        T: Send,
    {
        let mut store = store.as_context_mut();
        assert!(
            store.0.async_support(),
            ""cannot use `call_async` without enabling async support in the config"",
        );
        let my_ty = self.ty(&store);
        let result = store
            .on_fiber(|store| self.call_impl(store, my_ty, params))
            .await??;
        Ok(result)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,typed.rs,Rust,clone & self,"    fn clone(&self) -> TypedFunc<Params, Results> {
        *self
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,typed.rs,Rust,new_unchecked func : Func,"    pub unsafe fn new_unchecked(func: Func) -> TypedFunc<Params, Results> {
        TypedFunc {
            _a: marker::PhantomData,
            func,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,typed.rs,Rust,func & self,"    pub fn func(&self) -> &Func {
        &self.func
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,typed.rs,Rust,"call & self , mut store : impl AsContextMut , params : Params","    pub fn call(&self, mut store: impl AsContextMut, params: Params) -> Result<Results, Trap> {
        let mut store = store.as_context_mut();
        assert!(
            !store.0.async_support(),
            ""must use `call_async` with async stores""
        );
        unsafe { self._call(&mut store, params) }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,typed.rs,Rust,"call_async & self , mut store : impl AsContextMut < Data = T > , params : Params ,","    pub async fn call_async<T>(
        &self,
        mut store: impl AsContextMut<Data = T>,
        params: Params,
    ) -> Result<Results, Trap>
    where
        T: Send,
    {
        let mut store = store.as_context_mut();
        assert!(
            store.0.async_support(),
            ""must use `call` with non-async stores""
        );
        store
            .on_fiber(|store| unsafe { self._call(store, params) })
            .await?
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,deref & self,"    fn deref(&self) -> &Self::Target {
        &self.inner
    }",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,deref_mut & mut self,"    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }",1,True,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,deref_mut & mut self,"    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.store
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,deref & self,"    fn deref(&self) -> &Self::Target {
        &self.store
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,new mut store : T,"    pub fn new(mut store: T) -> Self {
        #[cfg(debug_assertions)]
        {
            let prev_okay = store.externref_activations_table.set_gc_okay(false);
            return AutoAssertNoGc { store, prev_okay };
        }
        #[cfg(not(debug_assertions))]
        {
            return AutoAssertNoGc { store };
        }
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        #[cfg(debug_assertions)]
        {
            self.store
                .externref_activations_table
                .set_gc_okay(self.prev_okay);
        }
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,entering_host & self,"    pub fn entering_host(&self) -> bool {
        match self {
            CallHook::ReturningFromWasm | CallHook::CallingHost => true,
            _ => false,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,exiting_host & self,"    pub fn exiting_host(&self) -> bool {
        match self {
            CallHook::ReturningFromHost | CallHook::CallingWasm => true,
            _ => false,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,"new engine : & Engine , data : T","    pub fn new(engine: &Engine, data: T) -> Self {
        let functions = &Default::default();
        // Wasmtime uses the callee argument to host functions to learn about
        // the original pointer to the `Store` itself, allowing it to
        // reconstruct a `StoreContextMut<T>`. When we initially call a `Func`,
        // however, there's no ""callee"" to provide. To fix this we allocate a
        // single ""default callee"" for the entire `Store`. This is then used as
        // part of `Func::call` to guarantee that the `callee: *mut VMContext`
        // is never null.
        let default_callee = unsafe {
            OnDemandInstanceAllocator::default()
                .allocate(InstanceAllocationRequest {
                    host_state: Box::new(()),
                    image_base: 0,
                    functions,
                    shared_signatures: None.into(),
                    imports: Default::default(),
                    module: Arc::new(wasmtime_environ::Module::default()),
                    store: None,
                    wasm_data: &[],
                })
                .expect(""failed to allocate default callee"")
        };
        let mut inner = Box::new(StoreInner {
            inner: StoreOpaque {
                _marker: marker::PhantomPinned,
                engine: engine.clone(),
                interrupts: Default::default(),
                instances: Vec::new(),
                signal_handler: None,
                externref_activations_table: VMExternRefActivationsTable::new(),
                modules: ModuleRegistry::default(),
                host_trampolines: HashMap::default(),
                instance_count: 0,
                instance_limit: wasmtime_runtime::DEFAULT_INSTANCE_LIMIT,
                memory_count: 0,
                memory_limit: wasmtime_runtime::DEFAULT_MEMORY_LIMIT,
                table_count: 0,
                table_limit: wasmtime_runtime::DEFAULT_TABLE_LIMIT,
                fuel_adj: 0,
                #[cfg(feature = ""async"")]
                async_state: AsyncState {
                    current_suspend: UnsafeCell::new(ptr::null()),
                    current_poll_cx: UnsafeCell::new(ptr::null_mut()),
                },
                out_of_gas_behavior: OutOfGas::Trap,
                store_data: StoreData::new(),
                default_callee,
                hostcall_val_storage: Vec::new(),
            },
            limiter: None,
            call_hook: None,
            data: ManuallyDrop::new(data),
        });

        // Once we've actually allocated the store itself we can configure the
        // trait object pointer of the default callee. Note the erasure of the
        // lifetime here into `'static`, so in general usage of this trait
        // object must be strictly bounded to the `Store` itself, and is a
        // variant that we have to maintain throughout Wasmtime.
        unsafe {
            let traitobj = std::mem::transmute::<
                *mut (dyn wasmtime_runtime::Store + '_),
                *mut (dyn wasmtime_runtime::Store + 'static),
            >(&mut *inner);
            inner.default_callee.set_store(traitobj);
        }

        Self {
            inner: ManuallyDrop::new(inner),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,data & self,"    pub fn data(&self) -> &T {
        self.inner.data()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,data_mut & mut self,"    pub fn data_mut(&mut self) -> &mut T {
        self.inner.data_mut()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,store.rs,Rust,into_data mut self,"    pub fn into_data(mut self) -> T {
        // This is an unsafe operation because we want to avoid having a runtime
        // check or boolean for whether the data is actually contained within a
        // `Store`. The data itself is stored as `ManuallyDrop` since we're
        // manually managing the memory here, and there's also a `ManuallyDrop`
        // around the `Box<StoreInner<T>>`. The way this works though is a bit
        // tricky, so here's how things get dropped appropriately:
        //
        // * When a `Store<T>` is normally dropped, the custom destructor for
        //   `Store<T>` will drop `T`, then the `self.inner` field. The
        //   rustc-glue destructor runs for `Box<StoreInner<T>>` which drops
        //   `StoreInner<T>`. This cleans up all internal fields and doesn't
        //   touch `T` because it's wrapped in `ManuallyDrop`.
        //
        // * When calling this method we skip the top-level destructor for
        //   `Store<T>` with `mem::forget`. This skips both the destructor for
        //   `T` and the destructor for `StoreInner<T>`. We do, however, run the
        //   destructor for `Box<StoreInner<T>>` which, like above, will skip
        //   the destructor for `T` since it's `ManuallyDrop`.
        //
        // In both cases all the other fields of `StoreInner<T>` should all get
        // dropped, and the manual management of destructors is basically
        // between this method and `Drop for Store<T>`. Note that this also
        // means that `Drop for StoreInner<T>` cannot access `self.data`, so
        // there is a comment indicating this as well.
        unsafe {
            let mut inner = ManuallyDrop::take(&mut self.inner);
            std::mem::forget(self);
            ManuallyDrop::take(&mut inner.data)
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,params & self,"    pub fn params(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {
        self.sig.params.iter().map(ValType::from_wasm_type)
    }

    /// Returns the list of result types for this function.
    pub fn results(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {
        self.sig.returns.iter().map(ValType::from_wasm_type)
    }",1,True,False,"1,6"
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"new params : impl IntoIterator < Item = ValType > , results : impl IntoIterator < Item = ValType > ,","    pub fn new(
        params: impl IntoIterator<Item = ValType>,
        results: impl IntoIterator<Item = ValType>,
    ) -> FuncType {
        FuncType {
            sig: WasmFuncType {
                params: params.into_iter().map(|t| t.to_wasm_type()).collect(),
                returns: results.into_iter().map(|t| t.to_wasm_type()).collect(),
            },
        }
    }",1,True,False,"5,6,7,8"
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,params & self,"    pub fn params(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {
        self.sig.params().iter().map(ValType::from_wasm_type)
    }

    /// Returns the list of result types for this function.
    pub fn results(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {
        self.sig.returns().iter().map(ValType::from_wasm_type)
    }",0,False,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"new params : impl IntoIterator < Item = ValType > , results : impl IntoIterator < Item = ValType > ,","    pub fn new(
        params: impl IntoIterator<Item = ValType>,
        results: impl IntoIterator<Item = ValType>,
    ) -> FuncType {
        FuncType {
            sig: WasmFuncType::new(
                params.into_iter().map(|t| t.to_wasm_type()).collect(),
                results.into_iter().map(|t| t.to_wasm_type()).collect(),
            ),
        }
    }",0,False,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"fmt & self , f : & mut fmt :: Formatter","    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ValType::I32 => write!(f, ""i32""),
            ValType::I64 => write!(f, ""i64""),
            ValType::F32 => write!(f, ""f32""),
            ValType::F64 => write!(f, ""f64""),
            ValType::V128 => write!(f, ""v128""),
            ValType::ExternRef => write!(f, ""externref""),
            ValType::FuncRef => write!(f, ""funcref""),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,is_num & self,"    pub fn is_num(&self) -> bool {
        match self {
            ValType::I32 | ValType::I64 | ValType::F32 | ValType::F64 => true,
            _ => false,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,is_ref & self,"    pub fn is_ref(&self) -> bool {
        match self {
            ValType::ExternRef | ValType::FuncRef => true,
            _ => false,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,to_wasm_type & self,"    pub(crate) fn to_wasm_type(&self) -> WasmType {
        match self {
            Self::I32 => WasmType::I32,
            Self::I64 => WasmType::I64,
            Self::F32 => WasmType::F32,
            Self::F64 => WasmType::F64,
            Self::V128 => WasmType::V128,
            Self::FuncRef => WasmType::FuncRef,
            Self::ExternRef => WasmType::ExternRef,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from_wasm_type ty : & WasmType,"    pub(crate) fn from_wasm_type(ty: &WasmType) -> Self {
        match ty {
            WasmType::I32 => Self::I32,
            WasmType::I64 => Self::I64,
            WasmType::F32 => Self::F32,
            WasmType::F64 => Self::F64,
            WasmType::V128 => Self::V128,
            WasmType::FuncRef => Self::FuncRef,
            WasmType::ExternRef => Self::ExternRef,
            WasmType::ExnRef => unimplemented!(),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"from_wasmtime types : & TypeTables , ty : & EntityType","    pub(crate) fn from_wasmtime(types: &TypeTables, ty: &EntityType) -> ExternType {
        match ty {
            EntityType::Function(idx) => {
                FuncType::from_wasm_func_type(types.wasm_signatures[*idx].clone()).into()
            }
            EntityType::Global(ty) => GlobalType::from_wasmtime_global(ty).into(),
            EntityType::Memory(ty) => MemoryType::from_wasmtime_memory(ty).into(),
            EntityType::Table(ty) => TableType::from_wasmtime_table(ty).into(),
            EntityType::Module(ty) => {
                let ty = &types.module_signatures[*ty];
                ModuleType::from_wasmtime(types, ty).into()
            }
            EntityType::Instance(ty) => {
                let ty = &types.instance_signatures[*ty];
                InstanceType::from_wasmtime(types, ty).into()
            }
            EntityType::Tag(_) => unimplemented!(""wasm tag support""),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from ty : FuncType,"    fn from(ty: FuncType) -> ExternType {
        ExternType::Func(ty)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from ty : GlobalType,"    fn from(ty: GlobalType) -> ExternType {
        ExternType::Global(ty)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from ty : MemoryType,"    fn from(ty: MemoryType) -> ExternType {
        ExternType::Memory(ty)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from ty : TableType,"    fn from(ty: TableType) -> ExternType {
        ExternType::Table(ty)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from ty : ModuleType,"    fn from(ty: ModuleType) -> ExternType {
        ExternType::Module(ty)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from ty : InstanceType,"    fn from(ty: InstanceType) -> ExternType {
        ExternType::Instance(ty)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,as_wasm_func_type & self,"    pub(crate) fn as_wasm_func_type(&self) -> &WasmFuncType {
        &self.sig
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from_wasm_func_type sig : WasmFuncType,"    pub(crate) fn from_wasm_func_type(sig: WasmFuncType) -> FuncType {
        Self { sig }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"new content : ValType , mutability : Mutability","    pub fn new(content: ValType, mutability: Mutability) -> GlobalType {
        GlobalType {
            content,
            mutability,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,content & self,"    pub fn content(&self) -> &ValType {
        &self.content
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,mutability & self,"    pub fn mutability(&self) -> Mutability {
        self.mutability
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from_wasmtime_global global : & Global,"    pub(crate) fn from_wasmtime_global(global: &Global) -> GlobalType {
        let ty = ValType::from_wasm_type(&global.wasm_ty);
        let mutability = if global.mutability {
            Mutability::Var
        } else {
            Mutability::Const
        };
        GlobalType::new(ty, mutability)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"new element : ValType , min : u32 , max : Option < u32 >","    pub fn new(element: ValType, min: u32, max: Option<u32>) -> TableType {
        TableType {
            ty: Table {
                wasm_ty: element.to_wasm_type(),
                minimum: min,
                maximum: max,
            },
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,element & self,"    pub fn element(&self) -> ValType {
        ValType::from_wasm_type(&self.ty.wasm_ty)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,minimum & self,"    pub fn minimum(&self) -> u32 {
        self.ty.minimum
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,maximum & self,"    pub fn maximum(&self) -> Option<u32> {
        self.ty.maximum
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from_wasmtime_table table : & Table,"    pub(crate) fn from_wasmtime_table(table: &Table) -> TableType {
        TableType { ty: table.clone() }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,wasmtime_table & self,"    pub(crate) fn wasmtime_table(&self) -> &Table {
        &self.ty
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"new minimum : u32 , maximum : Option < u32 >","    pub fn new(minimum: u32, maximum: Option<u32>) -> MemoryType {
        MemoryType {
            ty: Memory {
                memory64: false,
                shared: false,
                minimum: minimum.into(),
                maximum: maximum.map(|i| i.into()),
            },
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"new64 minimum : u64 , maximum : Option < u64 >","    pub fn new64(minimum: u64, maximum: Option<u64>) -> MemoryType {
        MemoryType {
            ty: Memory {
                memory64: true,
                shared: false,
                minimum,
                maximum,
            },
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,is_64 & self,"    pub fn is_64(&self) -> bool {
        self.ty.memory64
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,minimum & self,"    pub fn minimum(&self) -> u64 {
        self.ty.minimum
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,maximum & self,"    pub fn maximum(&self) -> Option<u64> {
        self.ty.maximum
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,from_wasmtime_memory memory : & Memory,"    pub(crate) fn from_wasmtime_memory(memory: &Memory) -> MemoryType {
        MemoryType { ty: memory.clone() }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,wasmtime_memory & self,"    pub(crate) fn wasmtime_memory(&self) -> &Memory {
        &self.ty
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,new,"    pub fn new() -> ModuleType {
        ModuleType {
            imports: Vec::new(),
            exports: Vec::new(),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"add_named_export & mut self , name : & str , ty : ExternType","    pub fn add_named_export(&mut self, name: &str, ty: ExternType) {
        self.exports.push((name.to_string(), ty));
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"add_named_import & mut self , module : & str , field : Option < & str > , ty : ExternType","    pub fn add_named_import(&mut self, module: &str, field: Option<&str>, ty: ExternType) {
        self.imports
            .push((module.to_string(), field.map(|f| f.to_string()), ty));
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,imports & self,"    pub fn imports(&self) -> impl ExactSizeIterator<Item = ImportType<'_>> {
        self.imports.iter().map(|(name, field, ty)| ImportType {
            module: name,
            name: field.as_deref(),
            ty: EntityOrExtern::Extern(ty),
        })
    }

    /// Returns the list of exports associated with this module type.
    pub fn exports(&self) -> impl ExactSizeIterator<Item = ExportType<'_>> {
        self.exports.iter().map(|(name, ty)| ExportType {
            name,
            ty: EntityOrExtern::Extern(ty),
        })
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"from_wasmtime types : & TypeTables , ty : & wasmtime_environ :: ModuleSignature ,","    pub(crate) fn from_wasmtime(
        types: &TypeTables,
        ty: &wasmtime_environ::ModuleSignature,
    ) -> ModuleType {
        let exports = &types.instance_signatures[ty.exports].exports;
        ModuleType {
            exports: exports
                .iter()
                .map(|(name, ty)| (name.to_string(), ExternType::from_wasmtime(types, ty)))
                .collect(),
            imports: ty
                .imports
                .iter()
                .map(|(m, ty)| (m.to_string(), None, ExternType::from_wasmtime(types, ty)))
                .collect(),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,new,"    pub fn new() -> InstanceType {
        InstanceType {
            exports: Vec::new(),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,"add_named_export & mut self , name : & str , ty : ExternType","    pub fn add_named_export(&mut self, name: &str, ty: ExternType) {
        self.exports.push((name.to_string(), ty));
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,exports & self,"    pub fn exports(&self) -> impl ExactSizeIterator<Item = ExportType<'_>> {
        self.exports.iter().map(|(name, ty)| ExportType {
            name,
            ty: EntityOrExtern::Extern(ty),
        })
    }

    pub(crate) fn from_wasmtime(
        types: &TypeTables,
        ty: &wasmtime_environ::InstanceSignature,
    ) -> InstanceType {
        InstanceType {
            exports: ty
                .exports
                .iter()
                .map(|(name, ty)| (name.to_string(), ExternType::from_wasmtime(types, ty)))
                .collect(),
        }
    }
}

// Import Types

/// A descriptor for an imported value into a wasm module.
///
/// This type is primarily accessed from the
/// [`Module::imports`](crate::Module::imports) API. Each [`ImportType`]
/// describes an import into the wasm module with the module/name that it's
/// imported from as well as the type of item that's being imported.
#[derive(Clone)]
pub struct ImportType<'module> {
    /// The module of the import.
    module: &'module str,

    /// The field of the import.
    name: Option<&'module str>,

    /// The type of the import.
    ty: EntityOrExtern<'module>,
}

#[derive(Clone)]
enum EntityOrExtern<'a> {
    Entity(EntityType, &'a TypeTables),
    Extern(&'a ExternType),
}

impl<'module> ImportType<'module> {
    /// Creates a new import descriptor which comes from `module` and `name` and
    /// is of type `ty`.
    pub(crate) fn new(
        module: &'module str,
        name: Option<&'module str>,
        ty: EntityType,
        types: &'module TypeTables,
    ) -> ImportType<'module> {
        ImportType {
            module,
            name,
            ty: EntityOrExtern::Entity(ty, types),
        }
    }

    /// Returns the module name that this import is expected to come from.
    pub fn module(&self) -> &'module str {
        self.module
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,name & self,"    pub fn name(&self) -> Option<&'module str> {
        self.name
    }

    /// Returns the expected type of this import.
    pub fn ty(&self) -> ExternType {
        match &self.ty {
            EntityOrExtern::Entity(e, types) => ExternType::from_wasmtime(types, e),
            EntityOrExtern::Extern(e) => (*e).clone(),
        }
    }
}

impl<'module> fmt::Debug for ImportType<'module> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct(""ImportType"")
            .field(""module"", &self.module())
            .field(""name"", &self.name())
            .field(""ty"", &self.ty())
            .finish()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,types.rs,Rust,name & self,"    pub fn name(&self) -> &'module str {
        self.name
    }

    /// Returns the type of this export.
    pub fn ty(&self) -> ExternType {
        match &self.ty {
            EntityOrExtern::Entity(e, types) => ExternType::from_wasmtime(types, e),
            EntityOrExtern::Extern(e) => (*e).clone(),
        }
    }
}

impl<'module> fmt::Debug for ExportType<'module> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct(""ExportType"")
            .field(""name"", &self.name().to_owned())
            .field(""ty"", &self.ty())
            .finish()
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,"write_value_to & self , store : & mut StoreOpaque , p : * mut u128","    pub(crate) unsafe fn write_value_to(&self, store: &mut StoreOpaque, p: *mut u128) {
        match self {
            Val::I32(i) => ptr::write(p as *mut i32, *i),
            Val::I64(i) => ptr::write(p as *mut i64, *i),
            Val::F32(u) => ptr::write(p as *mut u32, *u),
            Val::F64(u) => ptr::write(p as *mut u64, *u),
            Val::V128(b) => ptr::write(p as *mut u128, *b),
            Val::ExternRef(None) => ptr::write(p, 0),
            Val::ExternRef(Some(x)) => {
                let externref_ptr = x.inner.as_raw();
                store.insert_vmexternref(x.inner.clone());
                ptr::write(p as *mut *mut u8, externref_ptr)
            }
            Val::FuncRef(f) => ptr::write(
                p as *mut *mut runtime::VMCallerCheckedAnyfunc,
                if let Some(f) = f {
                    f.caller_checked_anyfunc(store).as_ptr()
                } else {
                    ptr::null_mut()
                },
            ),
        }
    }",1,True,False,"0,1,2,3,4,5,6,8,10"
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,"write_value_without_gc & self , store : & mut StoreOpaque , p : * mut u128","    pub(crate) unsafe fn write_value_without_gc(&self, store: &mut StoreOpaque, p: *mut u128) {
        match *self {
            Val::I32(i) => ptr::write(p as *mut i32, i),
            Val::I64(i) => ptr::write(p as *mut i64, i),
            Val::F32(u) => ptr::write(p as *mut u32, u),
            Val::F64(u) => ptr::write(p as *mut u64, u),
            Val::V128(b) => ptr::write(p as *mut u128, b),
            Val::ExternRef(None) => ptr::write(p, 0),
            Val::ExternRef(Some(ref x)) => {
                let externref_ptr = x.inner.as_raw();
                store.insert_vmexternref_without_gc(x.clone().inner);
                ptr::write(p as *mut *mut u8, externref_ptr)
            }
            Val::FuncRef(f) => ptr::write(
                p as *mut *mut runtime::VMCallerCheckedAnyfunc,
                if let Some(f) = f {
                    f.caller_checked_anyfunc(store).as_ptr()
                } else {
                    ptr::null_mut()
                },
            ),
        }
    }",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,null,"    pub fn null() -> Val {
        Val::ExternRef(None)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,ty & self,"    pub fn ty(&self) -> ValType {
        match self {
            Val::I32(_) => ValType::I32,
            Val::I64(_) => ValType::I64,
            Val::F32(_) => ValType::F32,
            Val::F64(_) => ValType::F64,
            Val::ExternRef(_) => ValType::ExternRef,
            Val::FuncRef(_) => ValType::FuncRef,
            Val::V128(_) => ValType::V128,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,"read_value_from store : & mut StoreOpaque , p : * const u128 , ty : ValType ,","    pub(crate) unsafe fn read_value_from(
        store: &mut StoreOpaque,
        p: *const u128,
        ty: ValType,
    ) -> Val {
        match ty {
            ValType::I32 => Val::I32(ptr::read(p as *const i32)),
            ValType::I64 => Val::I64(ptr::read(p as *const i64)),
            ValType::F32 => Val::F32(ptr::read(p as *const u32)),
            ValType::F64 => Val::F64(ptr::read(p as *const u64)),
            ValType::V128 => Val::V128(ptr::read(p as *const u128)),
            ValType::ExternRef => {
                let raw = ptr::read(p as *const *mut u8);
                if raw.is_null() {
                    Val::ExternRef(None)
                } else {
                    Val::ExternRef(Some(ExternRef {
                        inner: VMExternRef::clone_from_raw(raw),
                    }))
                }
            }
            ValType::FuncRef => {
                let func = ptr::read(p as *const *mut runtime::VMCallerCheckedAnyfunc);
                from_checked_anyfunc(func, store)
            }
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,externref & self,"    pub fn externref(&self) -> Option<Option<ExternRef>> {
        match self {
            Val::ExternRef(e) => Some(e.clone()),
            _ => None,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,unwrap_externref & self,"    pub fn unwrap_externref(&self) -> Option<ExternRef> {
        self.externref().expect(""expected externref"")
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,"into_table_element self , store : & mut StoreOpaque , ty : ValType ,","    pub(crate) fn into_table_element(
        self,
        store: &mut StoreOpaque,
        ty: ValType,
    ) -> Result<runtime::TableElement> {
        match (self, ty) {
            (Val::FuncRef(Some(f)), ValType::FuncRef) => {
                if !f.comes_from_same_store(store) {
                    bail!(""cross-`Store` values are not supported in tables"");
                }
                Ok(runtime::TableElement::FuncRef(
                    f.caller_checked_anyfunc(store).as_ptr(),
                ))
            }
            (Val::FuncRef(None), ValType::FuncRef) => {
                Ok(runtime::TableElement::FuncRef(ptr::null_mut()))
            }
            (Val::ExternRef(Some(x)), ValType::ExternRef) => {
                Ok(runtime::TableElement::ExternRef(Some(x.inner)))
            }
            (Val::ExternRef(None), ValType::ExternRef) => {
                Ok(runtime::TableElement::ExternRef(None))
            }
            _ => bail!(""value does not match table element type""),
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,"comes_from_same_store & self , store : & StoreOpaque","    pub(crate) fn comes_from_same_store(&self, store: &StoreOpaque) -> bool {
        match self {
            Val::FuncRef(Some(f)) => f.comes_from_same_store(store),
            Val::FuncRef(None) => true,

            // Integers, floats, vectors, and `externref`s have no association
            // with any particular store, so they're always considered as ""yes I
            // came from that store"",
            Val::I32(_)
            | Val::I64(_)
            | Val::F32(_)
            | Val::F64(_)
            | Val::V128(_)
            | Val::ExternRef(_) => true,
        }
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,from val : i32,"    fn from(val: i32) -> Val {
        Val::I32(val)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,from val : i64,"    fn from(val: i64) -> Val {
        Val::I64(val)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,from val : f32,"    fn from(val: f32) -> Val {
        Val::F32(val.to_bits())
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,from val : f64,"    fn from(val: f64) -> Val {
        Val::F64(val.to_bits())
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,from val : ExternRef,"    fn from(val: ExternRef) -> Val {
        Val::ExternRef(Some(val))
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,from val : Option < ExternRef >,"    fn from(val: Option<ExternRef>) -> Val {
        Val::ExternRef(val)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,from val : Option < Func >,"    fn from(val: Option<Func>) -> Val {
        Val::FuncRef(val)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,from val : Func,"    fn from(val: Func) -> Val {
        Val::FuncRef(Some(val))
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,from val : u128,"    fn from(val: u128) -> Val {
        Val::V128(val)
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,"into_checked_anyfunc val : Val , store : & mut StoreOpaque ,","pub(crate) fn into_checked_anyfunc(
    val: Val,
    store: &mut StoreOpaque,
) -> Result<*mut wasmtime_runtime::VMCallerCheckedAnyfunc> {
    if !val.comes_from_same_store(store) {
        bail!(""cross-`Store` values are not supported"");
    }
    Ok(match val {
        Val::FuncRef(None) => ptr::null_mut(),
        Val::FuncRef(Some(f)) => f.caller_checked_anyfunc(store).as_ptr(),
        _ => bail!(""val is not funcref""),
    })
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,values.rs,Rust,"from_checked_anyfunc anyfunc : * mut wasmtime_runtime :: VMCallerCheckedAnyfunc , store : & mut StoreOpaque ,","pub(crate) unsafe fn from_checked_anyfunc(
    anyfunc: *mut wasmtime_runtime::VMCallerCheckedAnyfunc,
    store: &mut StoreOpaque,
) -> Val {
    Val::FuncRef(Func::from_caller_checked_anyfunc(store, anyfunc))
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,no_gc_middle_of_args,"fn no_gc_middle_of_args() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (import """" ""return_some"" (func $return (result externref externref externref)))
                (import """" ""take_some"" (func $take (param externref externref externref)))
                (func (export ""run"")
                    (local i32)
                    i32.const 1000
                    local.set 0
                    loop
                        call $return
                        call $take
                        local.get 0
                        i32.const -1
                        i32.add
                        local.tee 0
                        br_if 0
                    end
                )
            )
        ""#,
    )?;

    let mut linker = Linker::new(store.engine());
    linker.func_wrap("""", ""return_some"", || {
        (
            Some(ExternRef::new(""a"".to_string())),
            Some(ExternRef::new(""b"".to_string())),
            Some(ExternRef::new(""c"".to_string())),
        )
    })?;
    linker.func_wrap(
        """",
        ""take_some"",
        |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {
            let a = a.unwrap();
            let b = b.unwrap();
            let c = c.unwrap();
            assert_eq!(a.data().downcast_ref::<String>().unwrap(), ""a"");
            assert_eq!(b.data().downcast_ref::<String>().unwrap(), ""b"");
            assert_eq!(c.data().downcast_ref::<String>().unwrap(), ""c"");
        },
    )?;

    let instance = linker.instantiate(&mut store, &module)?;
    let func = instance.get_typed_func::<(), (), _>(&mut store, ""run"")?;
    func.call(&mut store, ())?;

    Ok(())
}",0,False,True,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        self.0.store(true, SeqCst);
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,smoke_test_gc,"fn smoke_test_gc() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (import """" """" (func $do_gc))
                (func $recursive (export ""func"") (param i32 externref) (result externref)
                    local.get 0
                    i32.eqz
                    if (result externref)
                        call $do_gc
                        local.get 1
                    else
                        local.get 0
                        i32.const 1
                        i32.sub
                        local.get 1
                        call $recursive
                    end
                )
            )
        ""#,
    )?;

    let do_gc = Func::wrap(&mut store, |mut caller: Caller<'_, _>| {
        // Do a GC with `externref`s on the stack in Wasm frames.
        caller.gc();
    });
    let instance = Instance::new(&mut store, &module, &[do_gc.into()])?;
    let func = instance.get_func(&mut store, ""func"").unwrap();

    let inner_dropped = Arc::new(AtomicBool::new(false));
    let r = ExternRef::new(SetFlagOnDrop(inner_dropped.clone()));
    {
        let args = [Val::I32(5), Val::ExternRef(Some(r.clone()))];
        func.call(&mut store, &args)?;
    }

    // Still held alive by the `VMExternRefActivationsTable` (potentially in
    // multiple slots within the table) and by this `r` local.
    assert!(r.strong_count() >= 2);

    // Doing a GC should see that there aren't any `externref`s on the stack in
    // Wasm frames anymore.
    store.gc();
    assert_eq!(r.strong_count(), 1);

    // Dropping `r` should drop the inner `SetFlagOnDrop` value.
    drop(r);
    assert!(inner_dropped.load(SeqCst));

    Ok(())
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,drop & mut self,"        fn drop(&mut self) {
            self.0.fetch_add(1, SeqCst);
        }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,wasm_dropping_refs,"fn wasm_dropping_refs() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (func (export ""drop_ref"") (param externref)
                    nop
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let drop_ref = instance.get_func(&mut store, ""drop_ref"").unwrap();

    let num_refs_dropped = Arc::new(AtomicUsize::new(0));

    // NB: 4096 is greater than the initial `VMExternRefActivationsTable`
    // capacity, so this will trigger at least one GC.
    for _ in 0..4096 {
        let r = ExternRef::new(CountDrops(num_refs_dropped.clone()));
        let args = [Val::ExternRef(Some(r))];
        drop_ref.call(&mut store, &args)?;
    }

    assert!(num_refs_dropped.load(SeqCst) > 0);

    // And after doing a final GC, all the refs should have been dropped.
    store.gc();
    assert_eq!(num_refs_dropped.load(SeqCst), 4096);

    return Ok(());

    struct CountDrops(Arc<AtomicUsize>);

    impl Drop for CountDrops {
        fn drop(&mut self) {
            self.0.fetch_add(1, SeqCst);
        }
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,new live_refs : Arc < AtomicUsize >,"        fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,drop & mut self,"        fn drop(&mut self) {
            self.live_refs.fetch_sub(1, SeqCst);
        }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,many_live_refs,"fn many_live_refs() -> anyhow::Result<()> {
    let mut wat = r#""
        (module
            ;; Make new `externref`s.
            (import """" ""make_ref"" (func $make_ref (result externref)))

            ;; Observe an `externref` so it is kept live.
            (import """" ""observe_ref"" (func $observe_ref (param externref)))

            (func (export ""many_live_refs"")
    ""#
    .to_string();

    // This is more than the initial `VMExternRefActivationsTable` capacity, so
    // it will need to allocate additional bump chunks.
    const NUM_LIVE_REFS: usize = 1024;

    // Push `externref`s onto the stack.
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $make_ref)\n"");
    }

    // Pop `externref`s from the stack. Because we pass each of them to a
    // function call here, they are all live references for the duration of
    // their lifetimes.
    for _ in 0..NUM_LIVE_REFS {
        wat.push_str(""(call $observe_ref)\n"");
    }

    wat.push_str(
        ""
            ) ;; func
        ) ;; module
        "",
    );

    let (mut store, module) = ref_types_module(&wat)?;

    let live_refs = Arc::new(AtomicUsize::new(0));

    let make_ref = Func::wrap(&mut store, {
        let live_refs = live_refs.clone();
        move || Some(ExternRef::new(CountLiveRefs::new(live_refs.clone())))
    });

    let observe_ref = Func::wrap(&mut store, |r: Option<ExternRef>| {
        let r = r.unwrap();
        let r = r.data().downcast_ref::<CountLiveRefs>().unwrap();
        assert!(r.live_refs.load(SeqCst) > 0);
    });

    let instance = Instance::new(&mut store, &module, &[make_ref.into(), observe_ref.into()])?;
    let many_live_refs = instance.get_func(&mut store, ""many_live_refs"").unwrap();

    many_live_refs.call(&mut store, &[])?;

    store.gc();
    assert_eq!(live_refs.load(SeqCst), 0);

    return Ok(());

    struct CountLiveRefs {
        live_refs: Arc<AtomicUsize>,
    }

    impl CountLiveRefs {
        fn new(live_refs: Arc<AtomicUsize>) -> Self {
            live_refs.fetch_add(1, SeqCst);
            Self { live_refs }
        }
    }

    impl Drop for CountLiveRefs {
        fn drop(&mut self) {
            self.live_refs.fetch_sub(1, SeqCst);
        }
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,drop_externref_via_table_set,"fn drop_externref_via_table_set() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (table $t 1 externref)

                (func (export ""table-set"") (param externref)
                  (table.set $t (i32.const 0) (local.get 0))
                )
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let table_set = instance.get_func(&mut store, ""table-set"").unwrap();

    let foo_is_dropped = Arc::new(AtomicBool::new(false));
    let bar_is_dropped = Arc::new(AtomicBool::new(false));

    let foo = ExternRef::new(SetFlagOnDrop(foo_is_dropped.clone()));
    let bar = ExternRef::new(SetFlagOnDrop(bar_is_dropped.clone()));

    {
        let args = vec![Val::ExternRef(Some(foo))];
        table_set.call(&mut store, &args)?;
    }
    store.gc();
    assert!(!foo_is_dropped.load(SeqCst));
    assert!(!bar_is_dropped.load(SeqCst));

    {
        let args = vec![Val::ExternRef(Some(bar))];
        table_set.call(&mut store, &args)?;
    }
    store.gc();
    assert!(foo_is_dropped.load(SeqCst));
    assert!(!bar_is_dropped.load(SeqCst));

    table_set.call(&mut store, &[Val::ExternRef(None)])?;
    assert!(foo_is_dropped.load(SeqCst));
    assert!(bar_is_dropped.load(SeqCst));

    Ok(())
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,test_engine engine : & Engine,"    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Global::new(
            &mut store,
            GlobalType::new(ValType::ExternRef, Mutability::Const),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
                (module
                    (global (mut externref) (ref.null extern))

                    (func (export ""run"") (param externref)
                        local.get 0
                        global.set 0
                    )
                )
            ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,global_drops_externref,"fn global_drops_externref() -> anyhow::Result<()> {
    test_engine(&Engine::default())?;

    if !skip_pooling_allocator_tests() {
        test_engine(&Engine::new(
            Config::new().allocation_strategy(InstanceAllocationStrategy::pooling()),
        )?)?;
    }

    return Ok(());

    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Global::new(
            &mut store,
            GlobalType::new(ValType::ExternRef, Mutability::Const),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
                (module
                    (global (mut externref) (ref.null extern))

                    (func (export ""run"") (param externref)
                        local.get 0
                        global.set 0
                    )
                )
            ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,test_engine engine : & Engine,"    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Table::new(
            &mut store,
            TableType::new(ValType::ExternRef, 1, None),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
            (module
                (table 1 externref)

                (func (export ""run"") (param externref)
                    i32.const 0
                    local.get 0
                    table.set 0
                )
            )
        ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,table_drops_externref,"fn table_drops_externref() -> anyhow::Result<()> {
    test_engine(&Engine::default())?;

    if !skip_pooling_allocator_tests() {
        test_engine(&Engine::new(
            Config::new().allocation_strategy(InstanceAllocationStrategy::pooling()),
        )?)?;
    }

    return Ok(());

    fn test_engine(engine: &Engine) -> anyhow::Result<()> {
        let mut store = Store::new(&engine, ());
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        Table::new(
            &mut store,
            TableType::new(ValType::ExternRef, 1, None),
            externref.into(),
        )?;
        drop(store);
        assert!(flag.load(SeqCst));

        let mut store = Store::new(&engine, ());
        let module = Module::new(
            &engine,
            r#""
            (module
                (table 1 externref)

                (func (export ""run"") (param externref)
                    i32.const 0
                    local.get 0
                    table.set 0
                )
            )
        ""#,
        )?;
        let instance = Instance::new(&mut store, &module, &[])?;
        let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;
        let flag = Arc::new(AtomicBool::new(false));
        let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
        run.call(&mut store, Some(externref))?;
        drop(store);
        assert!(flag.load(SeqCst));
        Ok(())
    }
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,gee_i_sure_hope_refcounting_is_atomic,"fn gee_i_sure_hope_refcounting_is_atomic() -> anyhow::Result<()> {
    let mut config = Config::new();
    config.wasm_reference_types(true);
    config.interruptable(true);
    let engine = Engine::new(&config)?;
    let mut store = Store::new(&engine, ());
    let module = Module::new(
        &engine,
        r#""
            (module
                (global (mut externref) (ref.null extern))
                (table 1 externref)

                (func (export ""run"") (param externref)
                    local.get 0
                    global.set 0
                    i32.const 0
                    local.get 0
                    table.set 0
                    loop
                        global.get 0
                        global.set 0

                        i32.const 0
                        i32.const 0
                        table.get
                        table.set

                        local.get 0
                        call $f

                        br 0
                    end
                )

                (func $f (param externref))
            )
        ""#,
    )?;

    let instance = Instance::new(&mut store, &module, &[])?;
    let run = instance.get_typed_func::<Option<ExternRef>, (), _>(&mut store, ""run"")?;

    let flag = Arc::new(AtomicBool::new(false));
    let externref = ExternRef::new(SetFlagOnDrop(flag.clone()));
    let externref2 = externref.clone();
    let handle = store.interrupt_handle()?;

    let child = std::thread::spawn(move || run.call(&mut store, Some(externref2)));

    for _ in 0..10000 {
        drop(externref.clone());
    }
    handle.interrupt();

    assert!(child.join().unwrap().is_err());
    assert!(!flag.load(SeqCst));
    assert_eq!(externref.strong_count(), 1);
    drop(externref);
    assert!(flag.load(SeqCst));

    Ok(())
}",0,True,False,
https://github.com/bytecodealliance/wasmtime.git,d2ce1ac753afc059e32798bac3383b81a6d04456,Nick Fitzgerald,2021-09-14 14:23:42-07:00,True,gc.rs,Rust,global_init_no_leak,"fn global_init_no_leak() -> anyhow::Result<()> {
    let (mut store, module) = ref_types_module(
        r#""
            (module
                (import """" """" (global externref))
                (global externref (global.get 0))
            )
        ""#,
    )?;

    let externref = ExternRef::new(());
    let global = Global::new(
        &mut store,
        GlobalType::new(ValType::ExternRef, Mutability::Const),
        externref.clone().into(),
    )?;
    Instance::new(&mut store, &module, &[global.into()])?;
    drop(store);
    assert_eq!(externref.strong_count(), 1);

    Ok(())
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,parse_quoted_text input : & str,"fn parse_quoted_text(input: &str) -> Result<Cow<'_, str>, ParseErrorKind> {
    Ok(match input.as_bytes()[0] {
        b'""' => {
            let mut s = strip_first_last(input);
            let mut buf = String::new();

            loop {
                let mut chars = s.chars();
                match chars.next() {
                    Some('\\') => match chars.next() {
                        Some('\\') => {
                            buf.push('\\');
                            s = &s[1..];
                        }
                        Some('""') => {
                            buf.push('""');
                            s = &s[1..];
                        }
                        _ => {
                            return Err(ParseErrorKind::InvalidEscapeInStringAt(
                                input.len() - s.len(),
                            ));
                        }
                    },
                    Some(c) => buf.push(c),
                    None => break,
                }
                s = &s[1..];
            }
            Cow::Owned(buf)
        }
        _ => Cow::Borrowed(strip_first_last(input)),
    })
}

fn try_map<'i, 'b, O1, O2, P, M, EM>(
    mut parser: P,
    mut map: M,
    err_kind: EM,
) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>
where
    P: Parser<Input<'i, 'b>, O1, ParseError>,
    M: FnMut(O1) -> Result<O2, ParseErrorKind>,
    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,
{
    move |input| {
        let span = input.span();
        let (rest, o1) = parser.parse(input)?;
        let o2 = map(o1).map_err(|e| err_kind(e.at(span)))?;
        Ok((rest, o2))
    }
}

fn try_map2<'i, 'b, O1, O2, P, M, EM>(
    mut parser: P,
    mut map: M,
    err_kind: EM,
) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>
where
    P: Parser<Input<'i, 'b>, O1, ParseError>,
    M: FnMut(O1) -> Result<O2, ParseError>,
    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,
{
    move |input| {
        let (rest, o1) = parser.parse(input)?;
        let o2 = map(o1).map_err(err_kind)?;
        Ok((rest, o2))
    }
}

fn err<'i, 'b, T>(
    mut error_fn: impl FnMut() -> ParseErrorKind,
) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, T, ParseError> {
    move |input| Err(nom::Err::Error(error_fn().at(input.span())))
}",1,True,False,"9,10,11,12,14,15,16,17,18,19,20,21,22,23,24,27"
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,parse_quoted_text input : & str,"fn parse_quoted_text(input: &str) -> Result<Cow<'_, str>, ParseErrorKind> {
    Ok(match input.as_bytes()[0] {
        b'""' => {
            let mut s = strip_first_last(input);
            let mut buf = String::new();

            loop {
                let mut chars = s.chars();
                let char_len;
                match chars.next() {
                    Some('\\') => {
                        char_len = 1;
                        match chars.next() {
                            Some('\\') => {
                                buf.push('\\');
                                s = &s[1..];
                            }
                            Some('""') => {
                                buf.push('""');
                                s = &s[1..];
                            }
                            _ => {
                                return Err(ParseErrorKind::InvalidEscapeInStringAt(
                                    input.len() - s.len(),
                                ));
                            }
                        }
                    }
                    Some(c) => {
                        char_len = c.len_utf8();
                        buf.push(c)
                    }
                    None => break,
                }
                s = &s[char_len..];
            }
            Cow::Owned(buf)
        }
        _ => Cow::Borrowed(strip_first_last(input)),
    })
}

fn try_map<'i, 'b, O1, O2, P, M, EM>(
    mut parser: P,
    mut map: M,
    err_kind: EM,
) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>
where
    P: Parser<Input<'i, 'b>, O1, ParseError>,
    M: FnMut(O1) -> Result<O2, ParseErrorKind>,
    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,
{
    move |input| {
        let span = input.span();
        let (rest, o1) = parser.parse(input)?;
        let o2 = map(o1).map_err(|e| err_kind(e.at(span)))?;
        Ok((rest, o2))
    }
}

fn try_map2<'i, 'b, O1, O2, P, M, EM>(
    mut parser: P,
    mut map: M,
    err_kind: EM,
) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>
where
    P: Parser<Input<'i, 'b>, O1, ParseError>,
    M: FnMut(O1) -> Result<O2, ParseError>,
    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,
{
    move |input| {
        let (rest, o1) = parser.parse(input)?;
        let o2 = map(o1).map_err(err_kind)?;
        Ok((rest, o2))
    }
}

fn err<'i, 'b, T>(
    mut error_fn: impl FnMut() -> ParseErrorKind,
) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, T, ParseError> {
    move |input| Err(nom::Err::Error(error_fn().at(input.span())))
}",0,False,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,parse source : & str,"pub(crate) fn parse(source: &str) -> Result<Rule<'_>, ParseError> {
    let tokens = super::tokenize::tokenize(source);
    let input = Input::from(source, &tokens)?;

    let (rest, rules) = parse_modified(input)?;
    if rest.is_empty() {
        Ok(rules)
    } else {
        Err(ParseErrorKind::LeftoverTokens.at(rest.span()))
    }
}

pub(super) fn parse_modified<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    enum ModifierKind {
        Enable,
        Disable,
    }

    try_map2(
        pair(
            many0(alt((
                map(
                    tuple((
                        alt((
                            map(""enable"", |(_, span)| (ModifierKind::Enable, span)),
                            map(""disable"", |(_, span)| (ModifierKind::Disable, span)),
                        )),
                        value(BooleanSetting::Lazy, ""lazy""),
                        Token::Semicolon,
                    )),
                    |((kind, span_start), value, (_, span_end))| {
                        let stmt = match kind {
                            ModifierKind::Enable => Stmt::Enable(value),
                            ModifierKind::Disable => Stmt::Disable(value),
                        };
                        (stmt, span_start.join(span_end))
                    },
                ),
                map(
                    tuple((
                        ""let"",
                        cut(Token::Identifier),
                        cut(Token::Equals),
                        cut(parse_or),
                        cut(Token::Semicolon),
                    )),
                    |((_, span_start), (name, name_span), _, rule, (_, span_end))| {
                        (Stmt::Let(Let::new(name, rule, name_span)), span_start.join(span_end))
                    },
                ),
            ))),
            parse_or,
        ),
        |(stmts, mut rule): (Vec<(Stmt, Span)>, _)| {
            if stmts.len() > 1 {
                let mut set = HashSet::new();
                for (stmt, _) in &stmts {
                    if let Stmt::Let(l) = stmt {
                        if set.contains(l.name()) {
                            return Err(ParseErrorKind::LetBindingExists.at(l.name_span));
                        }
                        set.insert(l.name());
                    }
                }
            }

            let span_end = rule.span();
            for (stmt, span) in stmts.into_iter().rev() {
                rule = Rule::StmtExpr(Box::new(StmtExpr::new(stmt, rule, span.join(span_end))));
            }
            Ok(rule)
        },
        nom::Err::Failure,
    )(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,"parse_or input : Input < 'i, ' b >","pub(super) fn parse_or<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    map(separated_list0(Token::Pipe, parse_sequence), |mut rules| {
        if rules.len() == 1 {
            rules.pop().unwrap()
        } else {
            Alternation::new_rulex(rules)
        }
    })(input)
}

pub(super) fn parse_sequence<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    map(many1(parse_fixes), |mut rules| {
        if rules.len() == 1 {
            rules.pop().unwrap()
        } else {
            let start = rules.first().map(|f| f.span()).unwrap_or_default();
            let end = rules.last().map(|f| f.span()).unwrap_or_default();

            Rule::Group(Group::new(rules, None, start.join(end)))
        }
    })(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,"parse_fixes input : Input < 'i, ' b >","pub(super) fn parse_fixes<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    alt((
        try_map(
            pair(Token::Not, opt(parse_fixes)),
            |(_, rule)| {
                if let Some(mut rule) = rule {
                    rule.negate()?;
                    Ok(rule)
                } else {
                    Err(ParseErrorKind::Expected(""expression""))
                }
            },
            nom::Err::Failure,
        ),
        map(pair(parse_lookaround, parse_modified), |((kind, span), rule)| {
            let span = span.join(rule.span());
            Rule::Lookaround(Box::new(Lookaround::new(rule, kind, span)))
        }),
        try_map2(
            pair(parse_atom, many0(parse_repetition)),
            |(mut rule, repetitions)| {
                let mut prev_syntax = RepSyntax::ExplicitQuantifier;
                for (kind, quantifier, span, syntax) in repetitions {
                    if matches!(
                        (&prev_syntax, &syntax),
                        (RepSyntax::Other | RepSyntax::QuestionMark, RepSyntax::QuestionMark)
                    ) {
                        return Err(ParseErrorKind::Repetition(
                            RepetitionError::QuestionMarkAfterRepetition,
                        )
                        .at(span));
                    }
                    prev_syntax = syntax;

                    let span = rule.span().join(span);
                    rule =
                        Rule::Repetition(Box::new(Repetition::new(rule, kind, quantifier, span)));
                }
                Ok(rule)
            },
            nom::Err::Failure,
        ),
    ))(input)
}

pub(super) fn parse_lookaround<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (LookaroundKind, Span)> {
    alt((
        map(Token::LookAhead, |(_, span)| (LookaroundKind::Ahead, span)),
        map(Token::LookBehind, |(_, span)| (LookaroundKind::Behind, span)),
    ))(input)
}

pub(super) enum RepSyntax {
    ExplicitQuantifier,
    QuestionMark,
    Other,
}

pub(super) fn parse_repetition<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (RepetitionKind, Quantifier, Span, RepSyntax)> {
    map(
        pair(
            alt((
                map(Token::QuestionMark, |(_, span)| {
                    (RepetitionKind::zero_one(), span, RepSyntax::QuestionMark)
                }),
                map(Token::Star, |(_, span)| (RepetitionKind::zero_inf(), span, RepSyntax::Other)),
                map(Token::Plus, |(_, span)| (RepetitionKind::one_inf(), span, RepSyntax::Other)),
                parse_braced_repetition,
            )),
            map(
                opt(alt((
                    map(""greedy"", |(_, span)| (Quantifier::Greedy, span)),
                    map(""lazy"", |(_, span)| (Quantifier::Lazy, span)),
                ))),
                |a| match a {
                    Some((q, span)) => (q, span, RepSyntax::ExplicitQuantifier),
                    None => (Quantifier::Default, Span::default(), RepSyntax::Other),
                },
            ),
        ),
        |((kind, span1, rs1), (quantifier, span2, rs2))| {
            (
                kind,
                quantifier,
                span1.join(span2),
                match (rs1, rs2) {
                    (_, RepSyntax::ExplicitQuantifier) => RepSyntax::ExplicitQuantifier,
                    (RepSyntax::QuestionMark, _) => RepSyntax::QuestionMark,
                    _ => RepSyntax::Other,
                },
            )
        },
    )(input)
}

pub(super) fn parse_braced_repetition<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (RepetitionKind, Span, RepSyntax)> {
    fn parse_u32<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, u32> {
        try_map(Token::Number, |(s, _)| from_str(s), nom::Err::Failure)(input)
    }

    map(
        tuple((
            Token::OpenBrace,
            cut(alt((
                try_map(
                    separated_pair(opt(parse_u32), Token::Comma, opt(parse_u32)),
                    |(lower, upper)| Ok(RepetitionKind::try_from((lower.unwrap_or(0), upper))?),
                    nom::Err::Failure,
                ),
                map(parse_u32, RepetitionKind::fixed),
            ))),
            cut(Token::CloseBrace),
        )),
        |((_, start), rep, (_, end))| (rep, start.join(end), RepSyntax::Other),
    )(input)
}

pub(super) fn parse_atom<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    alt((
        parse_group,
        parse_string,
        parse_char_class,
        parse_boundary,
        parse_reference,
        map(parse_code_point, |(c, span)| {
            Rule::CharClass(CharClass::new(CharGroup::from_char(c), span))
        }),
        parse_range,
        parse_variable,
        try_map(Token::Dot, |_| Err(ParseErrorKind::Dot), nom::Err::Failure),
        err(|| ParseErrorKind::Expected(""expression"")),
    ))(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,"parse_group input : Input < 'i, ' b >","pub(super) fn parse_group<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    fn parse_capture<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (Capture<'i>, Span)> {
        map(pair(Token::Colon, opt(Token::Identifier)), |((_, span1), name)| {
            (Capture::new(name.map(|(s, _)| s)), span1)
        })(input)
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,"parse_string input : Input < 'i, ' b >","pub(super) fn parse_string<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    try_map(
        Token::String,
        |(s, span)| Ok(Rule::Literal(Literal::new(parse_quoted_text(s)?, span))),
        nom::Err::Failure,
    )(input)
}

pub(super) fn parse_char_class<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    #[derive(Clone, Copy)]
    enum StringOrChar<'i> {
        String(&'i str),
        Char(char),
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,"parse_chars_or_range input : Input < 'i, ' b >","    fn parse_chars_or_range<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, CharGroup> {
        // this is not clean code, but using the combinators results in worse error
        // spans
        let span1 = input.span();
        let (input, first) = parse_string_or_char(input)?;

        if let Ok((input, _)) = Token::Dash.parse(input.clone()) {
            let span2 = input.span();
            let (input, last) = cut(parse_string_or_char)(input)?;

            let first = first.to_char().map_err(|e| nom::Err::Failure(e.at(span1)))?;
            let last = last.to_char().map_err(|e| nom::Err::Failure(e.at(span2)))?;

            let group = CharGroup::try_from_range(first, last).ok_or_else(|| {
                nom::Err::Failure(
                    ParseErrorKind::CharClass(CharClassError::DescendingRange(first, last))
                        .at(span1.join(span2)),
                )
            })?;
            Ok((input, group))
        } else {
            let group = match first {
                StringOrChar::String(s) => CharGroup::from_chars(
                    parse_quoted_text(s).map_err(|k| nom::Err::Failure(k.at(span1)))?.borrow(),
                ),
                StringOrChar::Char(c) => CharGroup::from_char(c),
            };
            Ok((input, group))
        }
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,"parse_char_group input : Input < 'i, ' b >","    fn parse_char_group<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, CharGroup> {
        let span1 = input.span();

        let (input, ranges) = many1(alt((
            parse_chars_or_range,
            value(CharGroup::Dot, Token::Dot),
            try_map(
                pair(opt(Token::Not), Token::Identifier),
                |(not, (s, _))| {
                    // FIXME: When this fails on a negative item, the span of the exclamation mark
                    // is used instead of the identifier's span
                    CharGroup::try_from_group_name(s, not.is_some())
                        .map_err(ParseErrorKind::CharClass)
                },
                nom::Err::Failure,
            ),
            err(|| ParseErrorKind::CharClass(CharClassError::Invalid)),
        )))(input)?;

        let mut iter = ranges.into_iter();
        let mut class = iter.next().unwrap();

        for range in iter {
            class.add(range).map_err(|e| {
                nom::Err::Failure(ParseErrorKind::CharClass(e).at(span1.join(input.span().start())))
            })?;
        }
        Ok((input, class))
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,"parse_code_point input : Input < 'i, ' b >","pub(super) fn parse_code_point<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (char, Span)> {
    alt((
        try_map(
            Token::CodePoint,
            |(s, span)| {
                let hex = &s[2..];
                if hex.len() > 6 {
                    Err(ParseErrorKind::CodePoint(CodePointError::Invalid))
                } else {
                    u32::from_str_radix(hex, 16)
                        .ok()
                        .and_then(|n| char::try_from(n).ok())
                        .map(|c| (c, span))
                        .ok_or(ParseErrorKind::CodePoint(CodePointError::Invalid))
                }
            },
            nom::Err::Failure,
        ),
        try_map(
            Token::Identifier,
            |(str, span)| {
                if let Some(rest) = str.strip_prefix('U') {
                    if let Ok(n) = u32::from_str_radix(rest, 16) {
                        if let Ok(c) = char::try_from(n) {
                            return Ok((c, span));
                        } else {
                            return Err(ParseErrorKind::CodePoint(CodePointError::Invalid));
                        }
                    }
                }
                Err(ParseErrorKind::ExpectedToken(Token::CodePoint))
            },
            nom::Err::Error,
        ),
    ))(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,"parse_range input : Input < 'i, ' b >","pub(super) fn parse_range<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    fn parse_base<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (u8, Span)> {
        preceded(
            ""base"",
            try_map(
                cut(Token::Number),
                |(s, span)| {
                    let n = s.parse().map_err(NumberError::from)?;
                    if n > 36 {
                        Err(ParseErrorKind::Number(NumberError::TooLarge))
                    } else if n < 2 {
                        Err(ParseErrorKind::Number(NumberError::TooSmall))
                    } else {
                        Ok((n, span))
                    }
                },
                nom::Err::Failure,
            ),
        )(input)
    }

    fn parse_number(src: &str, radix: u8) -> Result<Vec<u8>, NumberError> {
        let mut digits = Vec::with_capacity(src.len());
        for c in src.bytes() {
            let n = match c {
                b'0'..=b'9' => c - b'0',
                b'a'..=b'z' => c - b'a' + 10,
                b'A'..=b'Z' => c - b'A' + 10,
                _ => return Err(NumberError::InvalidDigit),
            };
            if n >= radix {
                return Err(NumberError::InvalidDigit);
            }
            digits.push(n);
        }
        Ok(digits)
    }

    map(
        pair(
            ""range"",
            try_map(
                pair(
                    cut(separated_pair(Token::String, Token::Dash, Token::String)),
                    opt(parse_base),
                ),
                |(((start, span1), (end, span2)), base)| {
                    let (radix, span) = match base {
                        Some((base, span3)) => (base, span1.join(span3)),
                        None => (10, span1.join(span2)),
                    };
                    let start = parse_number(strip_first_last(start), radix)?;
                    let end = parse_number(strip_first_last(end), radix)?;

                    if start.len() > end.len() || (start.len() == end.len() && start > end) {
                        return Err(ParseErrorKind::RangeIsNotIncreasing);
                    }

                    Ok(Range::new(start, end, radix, span))
                },
                nom::Err::Failure,
            ),
        ),
        |((_, span), mut range)| {
            range.span = range.span.join(span);
            Rule::Range(range)
        },
    )(input)
}

pub(super) fn parse_variable<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    map(Token::Identifier, |(name, span)| Rule::Variable(Variable::new(name, span)))(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,"parse_special_char input : Input < 'i, ' b >","pub(super) fn parse_special_char<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, char> {
    try_map(
        Token::Identifier,
        |(s, _)| {
            Ok(match s {
                ""n"" => '\n',
                ""r"" => '\r',
                ""t"" => '\t',
                ""a"" => '\u{07}',
                ""e"" => '\u{1B}',
                ""f"" => '\u{0C}',
                _ => return Err(ParseErrorKind::Incomplete),
            })
        },
        nom::Err::Error,
    )(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,"parse_boundary input : Input < 'i, ' b >","pub(super) fn parse_boundary<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    map(
        alt((
            map(Token::BStart, |(_, span)| Boundary::new(BoundaryKind::Start, span)),
            map(Token::BEnd, |(_, span)| Boundary::new(BoundaryKind::End, span)),
            map(Token::BWord, |(_, span)| Boundary::new(BoundaryKind::Word, span)),
            map(pair(Token::Not, Token::BWord), |((_, span1), (_, span2))| {
                Boundary::new(BoundaryKind::NotWord, span1.join(span2))
            }),
        )),
        Rule::Boundary,
    )(input)
}

pub(super) fn parse_reference<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    preceded(
        Token::Backref,
        alt((
            try_map(
                Token::Number,
                |(s, span)| {
                    let target = ReferenceTarget::Number(from_str(s)?);
                    Ok(Rule::Reference(Reference::new(target, span)))
                },
                nom::Err::Failure,
            ),
            map(Token::Identifier, |(s, span)| {
                let target = ReferenceTarget::Named(s);
                Rule::Reference(Reference::new(target, span))
            }),
            try_map(
                pair(alt((Token::Plus, Token::Dash)), Token::Number),
                |((sign, span1), (s, span2))| {
                    let num = if sign == ""-"" { from_str(&format!(""-{s}"")) } else { from_str(s) }?;
                    let target = ReferenceTarget::Relative(num);
                    Ok(Rule::Reference(Reference::new(target, span1.join(span2))))
                },
                nom::Err::Failure,
            ),
            err(|| ParseErrorKind::Expected(""number or group name"")),
        )),
    )(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,from_str s : & str,"fn from_str<T: FromStr>(s: &str) -> Result<T, ParseErrorKind> {
    str::parse(s).map_err(|_| ParseErrorKind::Number(NumberError::TooLarge))
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,parsers.rs,Rust,strip_first_last s : & str,"fn strip_first_last(s: &str) -> &str {
    &s[1..s.len() - 1]
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,tokenize.rs,Rust,tokenize mut input : & str,"pub(crate) fn tokenize(mut input: &str) -> Vec<(Token, Span)> {
    let mut result = vec![];
    let mut offset = 0;

    loop {
        let input_len = input.len();
        input = input.trim_start();
        while input.starts_with('#') {
            input = input.trim_start_matches(|c| c != '\n').trim_start();
        }
        offset += input_len - input.len();

        match input.chars().next() {
            None => break,
            Some(c) => {
                let (len, token) = consume_chain! {
                    input, c;

                    if input.starts_with(""<%"") => (2, Token::BStart);
                    if input.starts_with(""%>"") => (2, Token::BEnd);
                    if input.starts_with("">>"") => (2, Token::LookAhead);
                    if input.starts_with(""<<"") => (2, Token::LookBehind);
                    if input.starts_with(""::"") => (2, Token::Backref);

                    if c == '%' => (1, Token::BWord);
                    if c == '*' => (1, Token::Star);
                    if c == '+' => (1, Token::Plus);
                    if c == '?' => (1, Token::QuestionMark);
                    if c == '|' => (1, Token::Pipe);
                    if c == ':' => (1, Token::Colon);
                    if c == ')' => (1, Token::CloseParen);
                    if c == '{' => (1, Token::OpenBrace);
                    if c == '}' => (1, Token::CloseBrace);
                    if c == ',' => (1, Token::Comma);
                    if c == '!' => (1, Token::Not);
                    if c == '[' => (1, Token::OpenBracket);
                    if c == '-' => (1, Token::Dash);
                    if c == ']' => (1, Token::CloseBracket);
                    if c == '.' => (1, Token::Dot);
                    if c == ';' => (1, Token::Semicolon);
                    if c == '=' => (1, Token::Equals);

                    if c == '\'' => match input[1..].find('\'') {
                        Some(len_inner) => (len_inner + 2, Token::String),
                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),
                    };

                    if c == '""' => match find_unescaped_quote(&input[1..]) {
                        Some(len_inner) => (len_inner + 2, Token::String),
                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),
                    };

                    if let Some(rest) = input.strip_prefix(""U+"") => {
                        match rest.find(|c: char| !c.is_ascii_hexdigit()) {
                            Some(0) => (1, Token::Error),
                            Some(len_inner) => (len_inner + 2, Token::CodePoint),
                            None => (input.len(), Token::CodePoint),
                        }
                    };

                    if matches!(c, '0'..='9') => (
                        input.find(|c: char| !matches!(c, '0'..='9')).unwrap_or(input.len()),
                        Token::Number,
                    );

                    if c.is_alphabetic() || c == '_' => (
                        input.find(|c: char| !c.is_alphanumeric() && c != '_').unwrap_or(input.len()),
                        Token::Identifier,
                    );

                    if c == '^' => (1, Token::ErrorMsg(ParseErrorMsg::Caret));
                    if c == '$' => (1, Token::ErrorMsg(ParseErrorMsg::Dollar));

                    if let Some(rest) = input.strip_prefix(""(?"") => (
                        match rest.chars().next() {
                            Some('<') => {
                                let name_len = rest.chars()
                                    .skip(1)
                                    .take_while(char::is_ascii_alphanumeric)
                                    .count();

                                if name_len > 0 && matches!(rest.chars().nth(1 + name_len), Some('>')) {
                                    4 + name_len
                                } else if let Some('=' | '!') = rest.chars().nth(1) {
                                    4
                                } else {
                                    3
                                }
                            }
                            Some('P') if matches!(rest.chars().nth(1), Some('<')) => {
                                let name_len = rest.chars()
                                    .skip(2)
                                    .take_while(char::is_ascii_alphanumeric)
                                    .count();

                                if name_len > 0 && matches!(rest.chars().nth(2 + name_len), Some('>')) {
                                    5 + name_len
                                } else {
                                    4
                                }
                            },
                            Some('>' | '!' | ':' | '=' | '(' | '|') => 3,
                            _ => 2,
                        },
                        Token::ErrorMsg(ParseErrorMsg::SpecialGroup),
                    );
                    if c == '(' => (1, Token::OpenParen);

                    if c == '\\' => {
                        if input.starts_with(""\\u{"") || input.starts_with(""\\x{"") {
                            match input[3..].find('}') {
                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashUnicode)),
                                None => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\u"") {
                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {
                                4.. => (6, Token::ErrorMsg(ParseErrorMsg::BackslashU4)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\x"") {
                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {
                                2.. => (4, Token::ErrorMsg(ParseErrorMsg::BackslashX2)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\k<"") {
                            match rest.find('>') {
                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashK)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if input.len() >= 2 {
                            (2, Token::ErrorMsg(ParseErrorMsg::Backslash))
                        } else {
                            (1, Token::Error)
                        }
                    };
                };

                let start = offset;
                offset += len;
                input = &input[len..];
                result.push((token, Span::new(start, offset)));
            }
        }
    }

    result
}",1,True,False,"129,130"
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,tokenize.rs,Rust,tokenize mut input : & str,"pub(crate) fn tokenize(mut input: &str) -> Vec<(Token, Span)> {
    let mut result = vec![];
    let mut offset = 0;

    loop {
        let input_len = input.len();
        input = input.trim_start();
        while input.starts_with('#') {
            input = input.trim_start_matches(|c| c != '\n').trim_start();
        }
        offset += input_len - input.len();

        match input.chars().next() {
            None => break,
            Some(c) => {
                let (len, token) = consume_chain! {
                    input, c;

                    if input.starts_with(""<%"") => (2, Token::BStart);
                    if input.starts_with(""%>"") => (2, Token::BEnd);
                    if input.starts_with("">>"") => (2, Token::LookAhead);
                    if input.starts_with(""<<"") => (2, Token::LookBehind);
                    if input.starts_with(""::"") => (2, Token::Backref);

                    if c == '%' => (1, Token::BWord);
                    if c == '*' => (1, Token::Star);
                    if c == '+' => (1, Token::Plus);
                    if c == '?' => (1, Token::QuestionMark);
                    if c == '|' => (1, Token::Pipe);
                    if c == ':' => (1, Token::Colon);
                    if c == ')' => (1, Token::CloseParen);
                    if c == '{' => (1, Token::OpenBrace);
                    if c == '}' => (1, Token::CloseBrace);
                    if c == ',' => (1, Token::Comma);
                    if c == '!' => (1, Token::Not);
                    if c == '[' => (1, Token::OpenBracket);
                    if c == '-' => (1, Token::Dash);
                    if c == ']' => (1, Token::CloseBracket);
                    if c == '.' => (1, Token::Dot);
                    if c == ';' => (1, Token::Semicolon);
                    if c == '=' => (1, Token::Equals);

                    if c == '\'' => match input[1..].find('\'') {
                        Some(len_inner) => (len_inner + 2, Token::String),
                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),
                    };

                    if c == '""' => match find_unescaped_quote(&input[1..]) {
                        Some(len_inner) => (len_inner + 2, Token::String),
                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),
                    };

                    if let Some(rest) = input.strip_prefix(""U+"") => {
                        match rest.find(|c: char| !c.is_ascii_hexdigit()) {
                            Some(0) => (1, Token::Error),
                            Some(len_inner) => (len_inner + 2, Token::CodePoint),
                            None => (input.len(), Token::CodePoint),
                        }
                    };

                    if matches!(c, '0'..='9') => (
                        input.find(|c: char| !matches!(c, '0'..='9')).unwrap_or(input.len()),
                        Token::Number,
                    );

                    if c.is_alphabetic() || c == '_' => (
                        input.find(|c: char| !c.is_alphanumeric() && c != '_').unwrap_or(input.len()),
                        Token::Identifier,
                    );

                    if c == '^' => (1, Token::ErrorMsg(ParseErrorMsg::Caret));
                    if c == '$' => (1, Token::ErrorMsg(ParseErrorMsg::Dollar));

                    if let Some(rest) = input.strip_prefix(""(?"") => (
                        match rest.chars().next() {
                            Some('<') => {
                                let name_len = rest.chars()
                                    .skip(1)
                                    .take_while(char::is_ascii_alphanumeric)
                                    .count();

                                if name_len > 0 && matches!(rest.chars().nth(1 + name_len), Some('>')) {
                                    4 + name_len
                                } else if let Some('=' | '!') = rest.chars().nth(1) {
                                    4
                                } else {
                                    3
                                }
                            }
                            Some('P') if matches!(rest.chars().nth(1), Some('<')) => {
                                let name_len = rest.chars()
                                    .skip(2)
                                    .take_while(char::is_ascii_alphanumeric)
                                    .count();

                                if name_len > 0 && matches!(rest.chars().nth(2 + name_len), Some('>')) {
                                    5 + name_len
                                } else {
                                    4
                                }
                            },
                            Some('>' | '!' | ':' | '=' | '(' | '|') => 3,
                            _ => 2,
                        },
                        Token::ErrorMsg(ParseErrorMsg::SpecialGroup),
                    );
                    if c == '(' => (1, Token::OpenParen);

                    if c == '\\' => {
                        if input.starts_with(""\\u{"") || input.starts_with(""\\x{"") {
                            match input[3..].find('}') {
                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashUnicode)),
                                None => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\u"") {
                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {
                                4.. => (6, Token::ErrorMsg(ParseErrorMsg::BackslashU4)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\x"") {
                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {
                                2.. => (4, Token::ErrorMsg(ParseErrorMsg::BackslashX2)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(rest) = input.strip_prefix(""\\k<"") {
                            match rest.find('>') {
                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashK)),
                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),
                            }
                        } else if let Some(next) = input.chars().nth(1) {
                            (1 + next.len_utf8(), Token::ErrorMsg(ParseErrorMsg::Backslash))
                        } else {
                            (1, Token::Error)
                        }
                    };
                };

                let start = offset;
                offset += len;
                input = &input[len..];
                result.push((token, Span::new(start, offset)));
            }
        }
    }

    result
}",0,False,False,
https://github.com/pomsky-lang/pomsky.git,fac6d58b25c6f9f8c0a6cdc4dec75b37b219f1d6,Ludwig Stecher,2022-06-18 22:20:58+02:00,False,tokenize.rs,Rust,find_unescaped_quote input : & str,"fn find_unescaped_quote(input: &str) -> Option<usize> {
    let mut s = input;

    loop {
        match s.find(|c| c == '\\' || c == '""') {
            Some(n) => {
                if s.as_bytes()[n] == b'""' {
                    return Some(n + (input.len() - s.len()));
                } else if n + 2 <= s.len() {
                    s = &s[n + 2..];
                } else {
                    return None;
                }
            }
            None => return None,
        }
    }
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parse_error.rs,Rust,"fmt & self , f : & mut std :: fmt :: Formatter < '_>) -> std::fmt::Result {
        if let Some(span) = self.span {
            write!(f, ""{}\n  at {}"", self.kind, span)
        } else {
            self.kind.fmt(f)
        }
    }
}

impl From<nom::Err<ParseError>> for ParseError {
    fn from(e: nom::Err<ParseError>) -> Self {
        match e {
            nom::Err::Incomplete(_) => ParseErrorKind::Incomplete.unknown_index(),
            nom::Err::Error(e) | nom::Err::Failure(e) => e,
        }
    }
}

impl<' i , 'b> nom::error::ParseError<Input<' i , 'b>> for ParseError {
    fn from_error_kind(i: Input<' i , 'b>, kind: nom::error::ErrorKind) -> Self {
        ParseErrorKind::Nom(kind).at(i.span())
    }

    fn append(_: Input<' i , 'b>, _: nom::error::ErrorKind, other: Self) -> Self {
        other
    }
}

/// An error kind (without a span) than can occur only during parsing
#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
#[non_exhaustive]
pub(crate) enum ParseErrorKind {
    #[error(""Unknown token"")]
    UnknownToken,
    #[error(transparent)]
    LexErrorWithMessage(ParseErrorMsg),
    #[error(""Unexpected dot. Use `[.]` instead"")]
    Dot,

    #[error(""Expected {}"", .0)]
    Expected(&' static str","    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(span) = self.span {
            write!(f, ""{}\n  at {}"", self.kind, span)
        } else {
            self.kind.fmt(f)
        }
    }
}

impl From<nom::Err<ParseError>> for ParseError {
    fn from(e: nom::Err<ParseError>) -> Self {
        match e {
            nom::Err::Incomplete(_) => ParseErrorKind::Incomplete.unknown_index(),
            nom::Err::Error(e) | nom::Err::Failure(e) => e,
        }
    }
}

impl<'i, 'b> nom::error::ParseError<Input<'i, 'b>> for ParseError {
    fn from_error_kind(i: Input<'i, 'b>, kind: nom::error::ErrorKind) -> Self {
        ParseErrorKind::Nom(kind).at(i.span())
    }

    fn append(_: Input<'i, 'b>, _: nom::error::ErrorKind, other: Self) -> Self {
        other
    }
}

/// An error kind (without a span) than can occur only during parsing
#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
#[non_exhaustive]
pub(crate) enum ParseErrorKind {
    #[error(""Unknown token"")]
    UnknownToken,
    #[error(transparent)]
    LexErrorWithMessage(ParseErrorMsg),
    #[error(""Unexpected dot. Use `[.]` instead"")]
    Dot,

    #[error(""Expected {}"", .0)]
    Expected(&'static str),
    #[error(""There are leftover tokens that couldn't be parsed"")]
    LeftoverTokens,
    #[error(""Expected {}"", .0)]
    ExpectedToken(Token),
    #[error(""Expected code point or character"")]
    ExpectedCodePointOrChar,
    #[error(""The first number in a range must be smaller than the second"")]
    RangeIsNotIncreasing,
    #[error(""This expression can't be negated"")]
    UnallowedNot,
    #[error(""An expression can't be negated twice"")]
    UnallowedDoubleNot,
    #[error(""Range is too big, it isn't allowed to contain more than {} digits"", .0)]
    RangeIsTooBig(u8),
    #[error(""A variable with the same name already exists in this scope"")]
    LetBindingExists,
    #[error(""Unsupported escape sequence in string"")]
    InvalidEscapeInStringAt(usize),
    #[error(transparent)]
    CharString(CharStringError),
    #[error(transparent)]
    CharClass(CharClassError),
    #[error(transparent)]
    CodePoint(CodePointError),
    #[error(transparent)]
    Number(#[from] NumberError),
    #[error(transparent)]
    Repetition(RepetitionError),
    #[error(transparent)]
    Unsupported(UnsupportedError),

    #[error(""Unknown error: {:?}"", .0)]
    Nom(nom::error::ErrorKind),
    #[error(""Incomplete parse"")]
    Incomplete,
}

impl ParseErrorKind {
    pub(crate) fn at(self, span: Span) -> ParseError {
        ParseError { kind: self, span: Some(span) }
    }

    pub(crate) fn unknown_index(self) -> ParseError {
        ParseError { kind: self, span: None }
    }
}",1,True,True,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parse_error.rs,Rust,"fmt & self , f : & mut std :: fmt :: Formatter < '_>) -> std::fmt::Result {
        if let Some(span) = self.span {
            write!(f, ""{}\n  at {}"", self.kind, span)
        } else {
            self.kind.fmt(f)
        }
    }
}

impl From<nom::Err<ParseError>> for ParseError {
    fn from(e: nom::Err<ParseError>) -> Self {
        match e {
            nom::Err::Incomplete(_) => ParseErrorKind::Incomplete.unknown_index(),
            nom::Err::Error(e) | nom::Err::Failure(e) => e,
        }
    }
}

impl<' i , 'b> nom::error::ParseError<Input<' i , 'b>> for ParseError {
    fn from_error_kind(i: Input<' i , 'b>, kind: nom::error::ErrorKind) -> Self {
        ParseErrorKind::Nom(kind).at(i.span())
    }

    fn append(_: Input<' i , 'b>, _: nom::error::ErrorKind, other: Self) -> Self {
        other
    }
}

/// An error kind (without a span) than can occur only during parsing
#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
#[non_exhaustive]
pub(crate) enum ParseErrorKind {
    #[error(""Unknown token"")]
    UnknownToken,
    #[error(transparent)]
    LexErrorWithMessage(ParseErrorMsg),
    #[error(""Unexpected dot. Use `[.]` instead"")]
    Dot,

    #[error(""Expected {}"", .0)]
    Expected(&' static str","    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(span) = self.span {
            write!(f, ""{}\n  at {}"", self.kind, span)
        } else {
            self.kind.fmt(f)
        }
    }
}

impl From<nom::Err<ParseError>> for ParseError {
    fn from(e: nom::Err<ParseError>) -> Self {
        match e {
            nom::Err::Incomplete(_) => ParseErrorKind::Incomplete.unknown_index(),
            nom::Err::Error(e) | nom::Err::Failure(e) => e,
        }
    }
}

impl<'i, 'b> nom::error::ParseError<Input<'i, 'b>> for ParseError {
    fn from_error_kind(i: Input<'i, 'b>, kind: nom::error::ErrorKind) -> Self {
        ParseErrorKind::Nom(kind).at(i.span())
    }

    fn append(_: Input<'i, 'b>, _: nom::error::ErrorKind, other: Self) -> Self {
        other
    }
}

/// An error kind (without a span) than can occur only during parsing
#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
#[non_exhaustive]
pub(crate) enum ParseErrorKind {
    #[error(""Unknown token"")]
    UnknownToken,
    #[error(transparent)]
    LexErrorWithMessage(ParseErrorMsg),
    #[error(""Unexpected dot. Use `[.]` instead"")]
    Dot,

    #[error(""Expected {}"", .0)]
    Expected(&'static str),
    #[error(""There are leftover tokens that couldn't be parsed"")]
    LeftoverTokens,
    #[error(""Expected {}"", .0)]
    ExpectedToken(Token),
    #[error(""Expected code point or character"")]
    ExpectedCodePointOrChar,
    #[error(""The first number in a range must be smaller than the second"")]
    RangeIsNotIncreasing,
    #[error(""This expression can't be negated"")]
    UnallowedNot,
    #[error(""An expression can't be negated twice"")]
    UnallowedDoubleNot,
    #[error(""Range is too big, it isn't allowed to contain more than {} digits"", .0)]
    RangeIsTooBig(u8),
    #[error(""A variable with the same name already exists in this scope"")]
    LetBindingExists,
    #[error(""Unsupported escape sequence in string"")]
    InvalidEscapeInStringAt(usize),
    #[error(transparent)]
    CharString(CharStringError),
    #[error(transparent)]
    CharClass(CharClassError),
    #[error(transparent)]
    CodePoint(CodePointError),
    #[error(transparent)]
    Number(#[from] NumberError),
    #[error(transparent)]
    Repetition(RepetitionError),
    #[error(transparent)]
    Unsupported(UnsupportedError),

    #[error(""Recursion limit reached. Try a less nested expression"")]
    RecursionLimit,

    #[error(""Unknown error: {:?}"", .0)]
    Nom(nom::error::ErrorKind),
    #[error(""Incomplete parse"")]
    Incomplete,
}

impl ParseErrorKind {
    pub(crate) fn at(self, span: Span) -> ParseError {
        ParseError { kind: self, span: Some(span) }
    }

    pub(crate) fn unknown_index(self) -> ParseError {
        ParseError { kind: self, span: None }
    }
}",0,False,True,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parse_error.rs,Rust,"diagnostic self , source_code : & str","    pub fn diagnostic(self, source_code: &str) -> Diagnostic {
        Diagnostic::from_parse_error(self, source_code)
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parse_error.rs,Rust,"at self , span : Span","    pub(crate) fn at(self, span: Span) -> ParseError {
        ParseError { kind: self, span: Some(span) }
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parse_error.rs,Rust,unknown_index self,"    pub(crate) fn unknown_index(self) -> ParseError {
        ParseError { kind: self, span: None }
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parse_error.rs,Rust,from e : RepetitionError,"    fn from(e: RepetitionError) -> Self {
        ParseErrorKind::Repetition(e)
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parse_error.rs,Rust,from e : ParseIntError,"    fn from(e: ParseIntError) -> Self {
        match e.kind() {
            IntErrorKind::Empty => NumberError::Empty,
            IntErrorKind::InvalidDigit => NumberError::InvalidDigit,
            IntErrorKind::PosOverflow => NumberError::TooLarge,
            IntErrorKind::NegOverflow => NumberError::TooSmall,
            IntErrorKind::Zero => NumberError::Zero,
            _ => unimplemented!(),
        }
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,lib.rs,Rust,"parse input : & 'i str, options: ParseOptions) -> Result<Self, ParseError> {
        let rule = parse::parse(input)?;
        rule.validate(&options)?;
        Ok(Rulex(rule))
    }

    /// Compile a `Rulex` that has been parsed, to a regex
    pub fn compile(&self, options: CompileOptions) -> Result<String, CompileError> {
        let mut used_names = HashMap::new();
        let mut groups_count = 0;
        self.0.get_capturing_groups(&mut groups_count, &mut used_names, false)?;

        let empty_span = Span::new(0, 0);

        let start = Rule::Boundary(Boundary::new(BoundaryKind::Start, empty_span));
        let end = Rule::Boundary(Boundary::new(BoundaryKind::End, empty_span));
        let grapheme = Rule::Grapheme(Grapheme { span: empty_span });
        let codepoint = Rule::CharClass(CharClass::new(CharGroup::CodePoint, empty_span));

        let builtins = vec![
            (""Start"", &start),
            (""End"", &end),
            (""Grapheme"", &grapheme),
            (""G"", &grapheme),
            (""Codepoint"", &codepoint),
            (""C"", &codepoint),
        ];

        let mut state = CompileState {
            next_idx: 1,
            used_names,
            groups_count,
            default_quantifier: RegexQuantifier::Greedy,
            variables: builtins,
            current_vars: Default::default(),
        };
        let compiled = self.0.comp(options, &mut state)?;

        let mut buf = String::new();
        compiled.codegen(&mut buf, options.flavor);
        Ok(buf)
    }

    /// Parse a string to a `Rulex` and compile it to a regex.
    pub fn parse_and_compile(
        input: &' i str , parse_options : ParseOptions , compile_options : CompileOptions ,","    pub fn parse(input: &'i str, options: ParseOptions) -> Result<Self, ParseError> {
        let rule = parse::parse(input)?;
        rule.validate(&options)?;
        Ok(Rulex(rule))
    }

    /// Compile a `Rulex` that has been parsed, to a regex
    pub fn compile(&self, options: CompileOptions) -> Result<String, CompileError> {
        let mut used_names = HashMap::new();
        let mut groups_count = 0;
        self.0.get_capturing_groups(&mut groups_count, &mut used_names, false)?;

        let empty_span = Span::new(0, 0);

        let start = Rule::Boundary(Boundary::new(BoundaryKind::Start, empty_span));
        let end = Rule::Boundary(Boundary::new(BoundaryKind::End, empty_span));
        let grapheme = Rule::Grapheme(Grapheme { span: empty_span });
        let codepoint = Rule::CharClass(CharClass::new(CharGroup::CodePoint, empty_span));

        let builtins = vec![
            (""Start"", &start),
            (""End"", &end),
            (""Grapheme"", &grapheme),
            (""G"", &grapheme),
            (""Codepoint"", &codepoint),
            (""C"", &codepoint),
        ];

        let mut state = CompileState {
            next_idx: 1,
            used_names,
            groups_count,
            default_quantifier: RegexQuantifier::Greedy,
            variables: builtins,
            current_vars: Default::default(),
        };
        let compiled = self.0.comp(options, &mut state)?;

        let mut buf = String::new();
        compiled.codegen(&mut buf, options.flavor);
        Ok(buf)
    }

    /// Parse a string to a `Rulex` and compile it to a regex.
    pub fn parse_and_compile(
        input: &'i str,
        parse_options: ParseOptions,
        compile_options: CompileOptions,
    ) -> Result<String, CompileError> {
        let parsed = Self::parse(input, parse_options)?;
        parsed.compile(compile_options)
    }",1,True,False,1
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,lib.rs,Rust,"parse input : & 'i str, options: ParseOptions) -> Result<Self, ParseError> {
        let rule = parse::parse(input, 256)?;
        rule.validate(&options)?;
        Ok(Rulex(rule))
    }

    /// Compile a `Rulex` that has been parsed, to a regex
    pub fn compile(&self, options: CompileOptions) -> Result<String, CompileError> {
        let mut used_names = HashMap::new();
        let mut groups_count = 0;
        self.0.get_capturing_groups(&mut groups_count, &mut used_names, false)?;

        let empty_span = Span::new(0, 0);

        let start = Rule::Boundary(Boundary::new(BoundaryKind::Start, empty_span));
        let end = Rule::Boundary(Boundary::new(BoundaryKind::End, empty_span));
        let grapheme = Rule::Grapheme(Grapheme { span: empty_span });
        let codepoint = Rule::CharClass(CharClass::new(CharGroup::CodePoint, empty_span));

        let builtins = vec![
            (""Start"", &start),
            (""End"", &end),
            (""Grapheme"", &grapheme),
            (""G"", &grapheme),
            (""Codepoint"", &codepoint),
            (""C"", &codepoint),
        ];

        let mut state = CompileState {
            next_idx: 1,
            used_names,
            groups_count,
            default_quantifier: RegexQuantifier::Greedy,
            variables: builtins,
            current_vars: Default::default(),
        };
        let compiled = self.0.comp(options, &mut state)?;

        let mut buf = String::new();
        compiled.codegen(&mut buf, options.flavor);
        Ok(buf)
    }

    /// Parse a string to a `Rulex` and compile it to a regex.
    pub fn parse_and_compile(
        input: &' i str , parse_options : ParseOptions , compile_options : CompileOptions ,","    pub fn parse(input: &'i str, options: ParseOptions) -> Result<Self, ParseError> {
        let rule = parse::parse(input, 256)?;
        rule.validate(&options)?;
        Ok(Rulex(rule))
    }

    /// Compile a `Rulex` that has been parsed, to a regex
    pub fn compile(&self, options: CompileOptions) -> Result<String, CompileError> {
        let mut used_names = HashMap::new();
        let mut groups_count = 0;
        self.0.get_capturing_groups(&mut groups_count, &mut used_names, false)?;

        let empty_span = Span::new(0, 0);

        let start = Rule::Boundary(Boundary::new(BoundaryKind::Start, empty_span));
        let end = Rule::Boundary(Boundary::new(BoundaryKind::End, empty_span));
        let grapheme = Rule::Grapheme(Grapheme { span: empty_span });
        let codepoint = Rule::CharClass(CharClass::new(CharGroup::CodePoint, empty_span));

        let builtins = vec![
            (""Start"", &start),
            (""End"", &end),
            (""Grapheme"", &grapheme),
            (""G"", &grapheme),
            (""Codepoint"", &codepoint),
            (""C"", &codepoint),
        ];

        let mut state = CompileState {
            next_idx: 1,
            used_names,
            groups_count,
            default_quantifier: RegexQuantifier::Greedy,
            variables: builtins,
            current_vars: Default::default(),
        };
        let compiled = self.0.comp(options, &mut state)?;

        let mut buf = String::new();
        compiled.codegen(&mut buf, options.flavor);
        Ok(buf)
    }

    /// Parse a string to a `Rulex` and compile it to a regex.
    pub fn parse_and_compile(
        input: &'i str,
        parse_options: ParseOptions,
        compile_options: CompileOptions,
    ) -> Result<String, CompileError> {
        let parsed = Self::parse(input, parse_options)?;
        parsed.compile(compile_options)
    }",0,False,True,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,iter_elements & self,"    fn iter_elements(&self) -> Self::IterElem {
        Input { source: self.source, tokens: self.tokens }
    }",1,True,False,1
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,"take_split & self , count : usize","    fn take_split(&self, count: usize) -> (Self, Self) {
        let (left, right) = self.tokens.split_at(count);

        (Input { source: self.source, tokens: left }, Input { source: self.source, tokens: right })
    }",1,True,False,3
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,"take & self , count : usize","    fn take(&self, count: usize) -> Self {
        let tokens = &self.tokens[..count];

        Input { source: self.source, tokens }
    }",1,True,False,3
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,"from source : & 'i str, tokens: &' b [ Token , Span ]","    pub(super) fn from(source: &'i str, tokens: &'b [(Token, Span)]) -> Result<Self, ParseError> {
        let error = tokens.iter().find_map(|&(t, span)| match t {
            Token::Error => Some((span, None)),
            Token::ErrorMsg(m) => Some((span, Some(m))),
            _ => None,
        });
        if let Some((span, msg)) = error {
            return match msg {
                Some(msg) => Err(ParseErrorKind::LexErrorWithMessage(msg).at(span)),
                None => Err(ParseErrorKind::UnknownToken.at(span)),
            };
        }

        Ok(Input { source, tokens })
    }",1,True,False,"0,13"
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,"take_split & self , count : usize","    fn take_split(&self, count: usize) -> (Self, Self) {
        let (left, right) = self.tokens.split_at(count);

        (Input { tokens: left, ..*self }, Input { tokens: right, ..*self })
    }",0,False,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,recursion_start & mut self,"    pub(super) fn recursion_start(&mut self) -> Result<(), ParseError> {
        self.recursion = self
            .recursion
            .checked_sub(1)
            .ok_or_else(|| ParseErrorKind::RecursionLimit.at(self.span()))?;
        Ok(())
    }",0,False,True,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,"from source : & 'i str,
        tokens: &' b [ Token , Span ] , recursion : u16 ,","    pub(super) fn from(
        source: &'i str,
        tokens: &'b [(Token, Span)],
        recursion: u16,
    ) -> Result<Self, ParseError> {
        let error = tokens.iter().find_map(|&(t, span)| match t {
            Token::Error => Some((span, None)),
            Token::ErrorMsg(m) => Some((span, Some(m))),
            _ => None,
        });
        if let Some((span, msg)) = error {
            return match msg {
                Some(msg) => Err(ParseErrorKind::LexErrorWithMessage(msg).at(span)),
                None => Err(ParseErrorKind::UnknownToken.at(span)),
            };
        }

        Ok(Input { source, tokens, recursion })
    }",0,False,True,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,"take & self , count : usize","    fn take(&self, count: usize) -> Self {
        let tokens = &self.tokens[..count];

        Input { tokens, ..*self }
    }",0,False,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,iter_elements & self,"    fn iter_elements(&self) -> Self::IterElem {
        Input { ..*self }
    }",0,False,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,recursion_end & mut self,"    pub(super) fn recursion_end(&mut self) {
        self.recursion += 1;
    }",0,False,True,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,is_empty & self,"    pub(super) fn is_empty(&self) -> bool {
        self.tokens.is_empty()
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,span & self,"    pub(crate) fn span(&self) -> Span {
        self.tokens
            .first()
            .map(|&(_, span)| span)
            .unwrap_or_else(|| (self.source.len()..self.source.len()).into())
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,peek & self,"    pub(super) fn peek(&self) -> Option<(Token, &'i str)> {
        self.iter_elements().next()
    }
}

impl<'i, 'b> PartialEq for Input<'i, 'b> {
    fn eq(&self, other: &Self) -> bool {
        Iterator::eq(self.iter_elements(), other.iter_elements())
    }
}

#[cfg(feature = ""dbg"")]
impl<'i, 'b> core::fmt::Debug for Input<'i, 'b> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        struct FmtHelper<'a>(Token, &'a str);

        impl core::fmt::Debug for FmtHelper<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                write!(f, ""{:?} {:?}"", self.0, self.1)
            }
        }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,iter_indices & self,"    fn iter_indices(&self) -> Self::Iter {
        self.iter_elements().enumerate()
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,"position & self , predicate : P","    fn position<P>(&self, predicate: P) -> Option<usize>
    where
        P: Fn(Self::Item) -> bool,
    {
        let mut iter = self.iter_elements();
        Iterator::position(&mut iter, predicate)
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,"slice_index & self , count : usize","    fn slice_index(&self, count: usize) -> Result<usize, nom::Needed> {
        if count <= self.tokens.len() {
            Ok(count)
        } else {
            Err(nom::Needed::Size((count - self.tokens.len()).try_into().unwrap()))
        }
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,input.rs,Rust,input_len & self,"    fn input_len(&self) -> usize {
        self.tokens.len()
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,parse source : & str,"pub(crate) fn parse(source: &str) -> Result<Rule<'_>, ParseError> {
    let tokens = super::tokenize::tokenize(source);
    let input = Input::from(source, &tokens)?;

    let (rest, rules) = parse_modified(input)?;
    if rest.is_empty() {
        Ok(rules)
    } else {
        Err(ParseErrorKind::LeftoverTokens.at(rest.span()))
    }
}

pub(super) fn parse_modified<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    enum ModifierKind {
        Enable,
        Disable,
    }

    try_map2(
        pair(
            many0(alt((
                map(
                    tuple((
                        alt((
                            map(""enable"", |(_, span)| (ModifierKind::Enable, span)),
                            map(""disable"", |(_, span)| (ModifierKind::Disable, span)),
                        )),
                        value(BooleanSetting::Lazy, ""lazy""),
                        Token::Semicolon,
                    )),
                    |((kind, span_start), value, (_, span_end))| {
                        let stmt = match kind {
                            ModifierKind::Enable => Stmt::Enable(value),
                            ModifierKind::Disable => Stmt::Disable(value),
                        };
                        (stmt, span_start.join(span_end))
                    },
                ),
                map(
                    tuple((
                        ""let"",
                        cut(Token::Identifier),
                        cut(Token::Equals),
                        cut(parse_or),
                        cut(Token::Semicolon),
                    )),
                    |((_, span_start), (name, name_span), _, rule, (_, span_end))| {
                        (Stmt::Let(Let::new(name, rule, name_span)), span_start.join(span_end))
                    },
                ),
            ))),
            parse_or,
        ),
        |(stmts, mut rule): (Vec<(Stmt, Span)>, _)| {
            if stmts.len() > 1 {
                let mut set = HashSet::new();
                for (stmt, _) in &stmts {
                    if let Stmt::Let(l) = stmt {
                        if set.contains(l.name()) {
                            return Err(ParseErrorKind::LetBindingExists.at(l.name_span));
                        }
                        set.insert(l.name());
                    }
                }
            }

            let span_end = rule.span();
            for (stmt, span) in stmts.into_iter().rev() {
                rule = Rule::StmtExpr(Box::new(StmtExpr::new(stmt, rule, span.join(span_end))));
            }
            Ok(rule)
        },
        nom::Err::Failure,
    )(input)
}",1,True,False,"0,2,43,51"
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_fixes input : Input < 'i, ' b >","pub(super) fn parse_fixes<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    alt((
        try_map(
            pair(Token::Not, opt(parse_fixes)),
            |(_, rule)| {
                if let Some(mut rule) = rule {
                    rule.negate()?;
                    Ok(rule)
                } else {
                    Err(ParseErrorKind::Expected(""expression""))
                }
            },
            nom::Err::Failure,
        ),
        map(pair(parse_lookaround, parse_modified), |((kind, span), rule)| {
            let span = span.join(rule.span());
            Rule::Lookaround(Box::new(Lookaround::new(rule, kind, span)))
        }),
        try_map2(
            pair(parse_atom, many0(parse_repetition)),
            |(mut rule, repetitions)| {
                let mut prev_syntax = RepSyntax::ExplicitQuantifier;
                for (kind, quantifier, span, syntax) in repetitions {
                    if matches!(
                        (&prev_syntax, &syntax),
                        (RepSyntax::Other | RepSyntax::QuestionMark, RepSyntax::QuestionMark)
                    ) {
                        return Err(ParseErrorKind::Repetition(
                            RepetitionError::QuestionMarkAfterRepetition,
                        )
                        .at(span));
                    }
                    prev_syntax = syntax;

                    let span = rule.span().join(span);
                    rule =
                        Rule::Repetition(Box::new(Repetition::new(rule, kind, quantifier, span)));
                }
                Ok(rule)
            },
            nom::Err::Failure,
        ),
    ))(input)
}

pub(super) fn parse_lookaround<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (LookaroundKind, Span)> {
    alt((
        map(Token::LookAhead, |(_, span)| (LookaroundKind::Ahead, span)),
        map(Token::LookBehind, |(_, span)| (LookaroundKind::Behind, span)),
    ))(input)
}

pub(super) enum RepSyntax {
    ExplicitQuantifier,
    QuestionMark,
    Other,
}

pub(super) fn parse_repetition<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (RepetitionKind, Quantifier, Span, RepSyntax)> {
    map(
        pair(
            alt((
                map(Token::QuestionMark, |(_, span)| {
                    (RepetitionKind::zero_one(), span, RepSyntax::QuestionMark)
                }),
                map(Token::Star, |(_, span)| (RepetitionKind::zero_inf(), span, RepSyntax::Other)),
                map(Token::Plus, |(_, span)| (RepetitionKind::one_inf(), span, RepSyntax::Other)),
                parse_braced_repetition,
            )),
            map(
                opt(alt((
                    map(""greedy"", |(_, span)| (Quantifier::Greedy, span)),
                    map(""lazy"", |(_, span)| (Quantifier::Lazy, span)),
                ))),
                |a| match a {
                    Some((q, span)) => (q, span, RepSyntax::ExplicitQuantifier),
                    None => (Quantifier::Default, Span::default(), RepSyntax::Other),
                },
            ),
        ),
        |((kind, span1, rs1), (quantifier, span2, rs2))| {
            (
                kind,
                quantifier,
                span1.join(span2),
                match (rs1, rs2) {
                    (_, RepSyntax::ExplicitQuantifier) => RepSyntax::ExplicitQuantifier,
                    (RepSyntax::QuestionMark, _) => RepSyntax::QuestionMark,
                    _ => RepSyntax::Other,
                },
            )
        },
    )(input)
}

pub(super) fn parse_braced_repetition<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (RepetitionKind, Span, RepSyntax)> {
    fn parse_u32<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, u32> {
        try_map(Token::Number, |(s, _)| from_str(s), nom::Err::Failure)(input)
    }

    map(
        tuple((
            Token::OpenBrace,
            cut(alt((
                try_map(
                    separated_pair(opt(parse_u32), Token::Comma, opt(parse_u32)),
                    |(lower, upper)| Ok(RepetitionKind::try_from((lower.unwrap_or(0), upper))?),
                    nom::Err::Failure,
                ),
                map(parse_u32, RepetitionKind::fixed),
            ))),
            cut(Token::CloseBrace),
        )),
        |((_, start), rep, (_, end))| (rep, start.join(end), RepSyntax::Other),
    )(input)
}

pub(super) fn parse_atom<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    alt((
        parse_group,
        parse_string,
        parse_char_class,
        parse_boundary,
        parse_reference,
        map(parse_code_point, |(c, span)| {
            Rule::CharClass(CharClass::new(CharGroup::from_char(c), span))
        }),
        parse_range,
        parse_variable,
        try_map(Token::Dot, |_| Err(ParseErrorKind::Dot), nom::Err::Failure),
        err(|| ParseErrorKind::Expected(""expression"")),
    ))(input)
}",1,True,False,"3,14"
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse source : & str , recursion : u16","pub(crate) fn parse(source: &str, recursion: u16) -> Result<Rule<'_>, ParseError> {
    let tokens = super::tokenize::tokenize(source);
    let input = Input::from(source, &tokens, recursion)?;

    let (rest, rules) = parse_modified(input)?;
    if rest.is_empty() {
        Ok(rules)
    } else {
        Err(ParseErrorKind::LeftoverTokens.at(rest.span()))
    }
}

fn recurse<'i, 'b, O>(
    mut parser: impl Parser<Input<'i, 'b>, O, ParseError>,
) -> impl FnMut(Input<'i, 'b>) -> PResult<'i, 'b, O> {
    move |mut input| {
        input.recursion_start().map_err(nom::Err::Failure)?;

        match parser.parse(input) {
            Ok((mut input, output)) => {
                input.recursion_end();
                Ok((input, output))
            }
            Err(e) => Err(e),
        }
    }
}

pub(super) fn parse_modified<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    enum ModifierKind {
        Enable,
        Disable,
    }

    try_map2(
        pair(
            many0(alt((
                map(
                    tuple((
                        alt((
                            map(""enable"", |(_, span)| (ModifierKind::Enable, span)),
                            map(""disable"", |(_, span)| (ModifierKind::Disable, span)),
                        )),
                        value(BooleanSetting::Lazy, ""lazy""),
                        Token::Semicolon,
                    )),
                    |((kind, span_start), value, (_, span_end))| {
                        let stmt = match kind {
                            ModifierKind::Enable => Stmt::Enable(value),
                            ModifierKind::Disable => Stmt::Disable(value),
                        };
                        (stmt, span_start.join(span_end))
                    },
                ),
                map(
                    tuple((
                        ""let"",
                        cut(Token::Identifier),
                        cut(Token::Equals),
                        cut(recurse(parse_or)),
                        cut(Token::Semicolon),
                    )),
                    |((_, span_start), (name, name_span), _, rule, (_, span_end))| {
                        (Stmt::Let(Let::new(name, rule, name_span)), span_start.join(span_end))
                    },
                ),
            ))),
            recurse(parse_or),
        ),
        |(stmts, mut rule): (Vec<(Stmt, Span)>, _)| {
            if stmts.len() > 1 {
                let mut set = HashSet::new();
                for (stmt, _) in &stmts {
                    if let Stmt::Let(l) = stmt {
                        if set.contains(l.name()) {
                            return Err(ParseErrorKind::LetBindingExists.at(l.name_span));
                        }
                        set.insert(l.name());
                    }
                }
            }

            let span_end = rule.span();
            for (stmt, span) in stmts.into_iter().rev() {
                rule = Rule::StmtExpr(Box::new(StmtExpr::new(stmt, rule, span.join(span_end))));
            }
            Ok(rule)
        },
        nom::Err::Failure,
    )(input)
}",0,False,True,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_fixes input : Input < 'i, ' b >","pub(super) fn parse_fixes<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    alt((
        try_map(
            pair(Token::Not, opt(recurse(parse_fixes))),
            |(_, rule)| {
                if let Some(mut rule) = rule {
                    rule.negate()?;
                    Ok(rule)
                } else {
                    Err(ParseErrorKind::Expected(""expression""))
                }
            },
            nom::Err::Failure,
        ),
        map(pair(parse_lookaround, recurse(parse_modified)), |((kind, span), rule)| {
            let span = span.join(rule.span());
            Rule::Lookaround(Box::new(Lookaround::new(rule, kind, span)))
        }),
        try_map2(
            pair(parse_atom, many0(parse_repetition)),
            |(mut rule, repetitions)| {
                let mut prev_syntax = RepSyntax::ExplicitQuantifier;
                for (kind, quantifier, span, syntax) in repetitions {
                    if matches!(
                        (&prev_syntax, &syntax),
                        (RepSyntax::Other | RepSyntax::QuestionMark, RepSyntax::QuestionMark)
                    ) {
                        return Err(ParseErrorKind::Repetition(
                            RepetitionError::QuestionMarkAfterRepetition,
                        )
                        .at(span));
                    }
                    prev_syntax = syntax;

                    let span = rule.span().join(span);
                    rule =
                        Rule::Repetition(Box::new(Repetition::new(rule, kind, quantifier, span)));
                }
                Ok(rule)
            },
            nom::Err::Failure,
        ),
    ))(input)
}

pub(super) fn parse_lookaround<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (LookaroundKind, Span)> {
    alt((
        map(Token::LookAhead, |(_, span)| (LookaroundKind::Ahead, span)),
        map(Token::LookBehind, |(_, span)| (LookaroundKind::Behind, span)),
    ))(input)
}

pub(super) enum RepSyntax {
    ExplicitQuantifier,
    QuestionMark,
    Other,
}

pub(super) fn parse_repetition<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (RepetitionKind, Quantifier, Span, RepSyntax)> {
    map(
        pair(
            alt((
                map(Token::QuestionMark, |(_, span)| {
                    (RepetitionKind::zero_one(), span, RepSyntax::QuestionMark)
                }),
                map(Token::Star, |(_, span)| (RepetitionKind::zero_inf(), span, RepSyntax::Other)),
                map(Token::Plus, |(_, span)| (RepetitionKind::one_inf(), span, RepSyntax::Other)),
                parse_braced_repetition,
            )),
            map(
                opt(alt((
                    map(""greedy"", |(_, span)| (Quantifier::Greedy, span)),
                    map(""lazy"", |(_, span)| (Quantifier::Lazy, span)),
                ))),
                |a| match a {
                    Some((q, span)) => (q, span, RepSyntax::ExplicitQuantifier),
                    None => (Quantifier::Default, Span::default(), RepSyntax::Other),
                },
            ),
        ),
        |((kind, span1, rs1), (quantifier, span2, rs2))| {
            (
                kind,
                quantifier,
                span1.join(span2),
                match (rs1, rs2) {
                    (_, RepSyntax::ExplicitQuantifier) => RepSyntax::ExplicitQuantifier,
                    (RepSyntax::QuestionMark, _) => RepSyntax::QuestionMark,
                    _ => RepSyntax::Other,
                },
            )
        },
    )(input)
}

pub(super) fn parse_braced_repetition<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (RepetitionKind, Span, RepSyntax)> {
    fn parse_u32<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, u32> {
        try_map(Token::Number, |(s, _)| from_str(s), nom::Err::Failure)(input)
    }

    map(
        tuple((
            Token::OpenBrace,
            cut(alt((
                try_map(
                    separated_pair(opt(parse_u32), Token::Comma, opt(parse_u32)),
                    |(lower, upper)| Ok(RepetitionKind::try_from((lower.unwrap_or(0), upper))?),
                    nom::Err::Failure,
                ),
                map(parse_u32, RepetitionKind::fixed),
            ))),
            cut(Token::CloseBrace),
        )),
        |((_, start), rep, (_, end))| (rep, start.join(end), RepSyntax::Other),
    )(input)
}

pub(super) fn parse_atom<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    alt((
        parse_group,
        parse_string,
        parse_char_class,
        parse_boundary,
        parse_reference,
        map(parse_code_point, |(c, span)| {
            Rule::CharClass(CharClass::new(CharGroup::from_char(c), span))
        }),
        parse_range,
        parse_variable,
        try_map(Token::Dot, |_| Err(ParseErrorKind::Dot), nom::Err::Failure),
        err(|| ParseErrorKind::Expected(""expression"")),
    ))(input)
}",0,False,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_or input : Input < 'i, ' b >","pub(super) fn parse_or<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    map(separated_list0(Token::Pipe, parse_sequence), |mut rules| {
        if rules.len() == 1 {
            rules.pop().unwrap()
        } else {
            Alternation::new_rulex(rules)
        }
    })(input)
}

pub(super) fn parse_sequence<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    map(many1(parse_fixes), |mut rules| {
        if rules.len() == 1 {
            rules.pop().unwrap()
        } else {
            let start = rules.first().map(|f| f.span()).unwrap_or_default();
            let end = rules.last().map(|f| f.span()).unwrap_or_default();

            Rule::Group(Group::new(rules, None, start.join(end)))
        }
    })(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_group input : Input < 'i, ' b >","pub(super) fn parse_group<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    fn parse_capture<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (Capture<'i>, Span)> {
        map(pair(Token::Colon, opt(Token::Identifier)), |((_, span1), name)| {
            (Capture::new(name.map(|(s, _)| s)), span1)
        })(input)
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_string input : Input < 'i, ' b >","pub(super) fn parse_string<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    try_map(
        Token::String,
        |(s, span)| Ok(Rule::Literal(Literal::new(parse_quoted_text(s)?, span))),
        nom::Err::Failure,
    )(input)
}

pub(super) fn parse_char_class<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    #[derive(Clone, Copy)]
    enum StringOrChar<'i> {
        String(&'i str),
        Char(char),
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_chars_or_range input : Input < 'i, ' b >","    fn parse_chars_or_range<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, CharGroup> {
        // this is not clean code, but using the combinators results in worse error
        // spans
        let span1 = input.span();
        let (input, first) = parse_string_or_char(input)?;

        if let Ok((input, _)) = Token::Dash.parse(input.clone()) {
            let span2 = input.span();
            let (input, last) = cut(parse_string_or_char)(input)?;

            let first = first.to_char().map_err(|e| nom::Err::Failure(e.at(span1)))?;
            let last = last.to_char().map_err(|e| nom::Err::Failure(e.at(span2)))?;

            let group = CharGroup::try_from_range(first, last).ok_or_else(|| {
                nom::Err::Failure(
                    ParseErrorKind::CharClass(CharClassError::DescendingRange(first, last))
                        .at(span1.join(span2)),
                )
            })?;
            Ok((input, group))
        } else {
            let group = match first {
                StringOrChar::String(s) => CharGroup::from_chars(
                    parse_quoted_text(s).map_err(|k| nom::Err::Failure(k.at(span1)))?.borrow(),
                ),
                StringOrChar::Char(c) => CharGroup::from_char(c),
            };
            Ok((input, group))
        }
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_char_group input : Input < 'i, ' b >","    fn parse_char_group<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, CharGroup> {
        let span1 = input.span();

        let (input, ranges) = many1(alt((
            parse_chars_or_range,
            value(CharGroup::Dot, Token::Dot),
            try_map(
                pair(opt(Token::Not), Token::Identifier),
                |(not, (s, _))| {
                    // FIXME: When this fails on a negative item, the span of the exclamation mark
                    // is used instead of the identifier's span
                    CharGroup::try_from_group_name(s, not.is_some())
                        .map_err(ParseErrorKind::CharClass)
                },
                nom::Err::Failure,
            ),
            err(|| ParseErrorKind::CharClass(CharClassError::Invalid)),
        )))(input)?;

        let mut iter = ranges.into_iter();
        let mut class = iter.next().unwrap();

        for range in iter {
            class.add(range).map_err(|e| {
                nom::Err::Failure(ParseErrorKind::CharClass(e).at(span1.join(input.span().start())))
            })?;
        }
        Ok((input, class))
    }",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_code_point input : Input < 'i, ' b >","pub(super) fn parse_code_point<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (char, Span)> {
    alt((
        try_map(
            Token::CodePoint,
            |(s, span)| {
                let hex = &s[2..];
                if hex.len() > 6 {
                    Err(ParseErrorKind::CodePoint(CodePointError::Invalid))
                } else {
                    u32::from_str_radix(hex, 16)
                        .ok()
                        .and_then(|n| char::try_from(n).ok())
                        .map(|c| (c, span))
                        .ok_or(ParseErrorKind::CodePoint(CodePointError::Invalid))
                }
            },
            nom::Err::Failure,
        ),
        try_map(
            Token::Identifier,
            |(str, span)| {
                if let Some(rest) = str.strip_prefix('U') {
                    if let Ok(n) = u32::from_str_radix(rest, 16) {
                        if let Ok(c) = char::try_from(n) {
                            return Ok((c, span));
                        } else {
                            return Err(ParseErrorKind::CodePoint(CodePointError::Invalid));
                        }
                    }
                }
                Err(ParseErrorKind::ExpectedToken(Token::CodePoint))
            },
            nom::Err::Error,
        ),
    ))(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_range input : Input < 'i, ' b >","pub(super) fn parse_range<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    fn parse_base<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (u8, Span)> {
        preceded(
            ""base"",
            try_map(
                cut(Token::Number),
                |(s, span)| {
                    let n = s.parse().map_err(NumberError::from)?;
                    if n > 36 {
                        Err(ParseErrorKind::Number(NumberError::TooLarge))
                    } else if n < 2 {
                        Err(ParseErrorKind::Number(NumberError::TooSmall))
                    } else {
                        Ok((n, span))
                    }
                },
                nom::Err::Failure,
            ),
        )(input)
    }

    fn parse_number(src: &str, radix: u8) -> Result<Vec<u8>, NumberError> {
        let mut digits = Vec::with_capacity(src.len());
        for c in src.bytes() {
            let n = match c {
                b'0'..=b'9' => c - b'0',
                b'a'..=b'z' => c - b'a' + 10,
                b'A'..=b'Z' => c - b'A' + 10,
                _ => return Err(NumberError::InvalidDigit),
            };
            if n >= radix {
                return Err(NumberError::InvalidDigit);
            }
            digits.push(n);
        }
        Ok(digits)
    }

    map(
        pair(
            ""range"",
            try_map(
                pair(
                    cut(separated_pair(Token::String, Token::Dash, Token::String)),
                    opt(parse_base),
                ),
                |(((start, span1), (end, span2)), base)| {
                    let (radix, span) = match base {
                        Some((base, span3)) => (base, span1.join(span3)),
                        None => (10, span1.join(span2)),
                    };
                    let start = parse_number(strip_first_last(start), radix)?;
                    let end = parse_number(strip_first_last(end), radix)?;

                    if start.len() > end.len() || (start.len() == end.len() && start > end) {
                        return Err(ParseErrorKind::RangeIsNotIncreasing);
                    }

                    Ok(Range::new(start, end, radix, span))
                },
                nom::Err::Failure,
            ),
        ),
        |((_, span), mut range)| {
            range.span = range.span.join(span);
            Rule::Range(range)
        },
    )(input)
}

pub(super) fn parse_variable<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    map(Token::Identifier, |(name, span)| Rule::Variable(Variable::new(name, span)))(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_special_char input : Input < 'i, ' b >","pub(super) fn parse_special_char<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, char> {
    try_map(
        Token::Identifier,
        |(s, _)| {
            Ok(match s {
                ""n"" => '\n',
                ""r"" => '\r',
                ""t"" => '\t',
                ""a"" => '\u{07}',
                ""e"" => '\u{1B}',
                ""f"" => '\u{0C}',
                _ => return Err(ParseErrorKind::Incomplete),
            })
        },
        nom::Err::Error,
    )(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,"parse_boundary input : Input < 'i, ' b >","pub(super) fn parse_boundary<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    map(
        alt((
            map(Token::BStart, |(_, span)| Boundary::new(BoundaryKind::Start, span)),
            map(Token::BEnd, |(_, span)| Boundary::new(BoundaryKind::End, span)),
            map(Token::BWord, |(_, span)| Boundary::new(BoundaryKind::Word, span)),
            map(pair(Token::Not, Token::BWord), |((_, span1), (_, span2))| {
                Boundary::new(BoundaryKind::NotWord, span1.join(span2))
            }),
        )),
        Rule::Boundary,
    )(input)
}

pub(super) fn parse_reference<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    preceded(
        Token::Backref,
        alt((
            try_map(
                Token::Number,
                |(s, span)| {
                    let target = ReferenceTarget::Number(from_str(s)?);
                    Ok(Rule::Reference(Reference::new(target, span)))
                },
                nom::Err::Failure,
            ),
            map(Token::Identifier, |(s, span)| {
                let target = ReferenceTarget::Named(s);
                Rule::Reference(Reference::new(target, span))
            }),
            try_map(
                pair(alt((Token::Plus, Token::Dash)), Token::Number),
                |((sign, span1), (s, span2))| {
                    let num = if sign == ""-"" { from_str(&format!(""-{s}"")) } else { from_str(s) }?;
                    let target = ReferenceTarget::Relative(num);
                    Ok(Rule::Reference(Reference::new(target, span1.join(span2))))
                },
                nom::Err::Failure,
            ),
            err(|| ParseErrorKind::Expected(""number or group name"")),
        )),
    )(input)
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,from_str s : & str,"fn from_str<T: FromStr>(s: &str) -> Result<T, ParseErrorKind> {
    str::parse(s).map_err(|_| ParseErrorKind::Number(NumberError::TooLarge))
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,strip_first_last s : & str,"fn strip_first_last(s: &str) -> &str {
    &s[1..s.len() - 1]
}",0,True,False,
https://github.com/pomsky-lang/pomsky.git,60aa2dc03a22d69c8800fec81f99c96958a11363,Ludwig Stecher,2022-06-19 00:16:30+02:00,False,parsers.rs,Rust,parse_quoted_text input : & str,"fn parse_quoted_text(input: &str) -> Result<Cow<'_, str>, ParseErrorKind> {
    Ok(match input.as_bytes()[0] {
        b'""' => {
            let mut s = strip_first_last(input);
            let mut buf = String::new();

            loop {
                let mut chars = s.chars();
                let char_len;
                match chars.next() {
                    Some('\\') => {
                        char_len = 1;
                        match chars.next() {
                            Some('\\') => {
                                buf.push('\\');
                                s = &s[1..];
                            }
                            Some('""') => {
                                buf.push('""');
                                s = &s[1..];
                            }
                            _ => {
                                return Err(ParseErrorKind::InvalidEscapeInStringAt(
                                    input.len() - s.len(),
                                ));
                            }
                        }
                    }
                    Some(c) => {
                        char_len = c.len_utf8();
                        buf.push(c)
                    }
                    None => break,
                }
                s = &s[char_len..];
            }
            Cow::Owned(buf)
        }
        _ => Cow::Borrowed(strip_first_last(input)),
    })
}

fn try_map<'i, 'b, O1, O2, P, M, EM>(
    mut parser: P,
    mut map: M,
    err_kind: EM,
) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>
where
    P: Parser<Input<'i, 'b>, O1, ParseError>,
    M: FnMut(O1) -> Result<O2, ParseErrorKind>,
    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,
{
    move |input| {
        let span = input.span();
        let (rest, o1) = parser.parse(input)?;
        let o2 = map(o1).map_err(|e| err_kind(e.at(span)))?;
        Ok((rest, o2))
    }
}

fn try_map2<'i, 'b, O1, O2, P, M, EM>(
    mut parser: P,
    mut map: M,
    err_kind: EM,
) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>
where
    P: Parser<Input<'i, 'b>, O1, ParseError>,
    M: FnMut(O1) -> Result<O2, ParseError>,
    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,
{
    move |input| {
        let (rest, o1) = parser.parse(input)?;
        let o2 = map(o1).map_err(err_kind)?;
        Ok((rest, o2))
    }
}

fn err<'i, 'b, T>(
    mut error_fn: impl FnMut() -> ParseErrorKind,
) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, T, ParseError> {
    move |input| Err(nom::Err::Error(error_fn().at(input.span())))
}",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,"decode_chunk input : & [ u8 ] , index_at_start_of_input : usize , decode_table : & [ u8 ; 256 ] , output : & mut [ u8 ] ,","fn decode_chunk(
    input: &[u8],
    index_at_start_of_input: usize,
    decode_table: &[u8; 256],
    output: &mut [u8],
) -> Result<(), DecodeError> {
    let mut accum: u64;

    let morsel = decode_table[input[0] as usize];
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(index_at_start_of_input, input[0]));
    }
    accum = (morsel as u64) << 58;

    let morsel = decode_table[input[1] as usize];
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 1,
            input[1],
        ));
    }
    accum |= (morsel as u64) << 52;

    let morsel = decode_table[input[2] as usize];
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 2,
            input[2],
        ));
    }
    accum |= (morsel as u64) << 46;

    let morsel = decode_table[input[3] as usize];
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 3,
            input[3],
        ));
    }
    accum |= (morsel as u64) << 40;

    let morsel = decode_table[input[4] as usize];
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 4,
            input[4],
        ));
    }
    accum |= (morsel as u64) << 34;

    let morsel = decode_table[input[5] as usize];
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 5,
            input[5],
        ));
    }
    accum |= (morsel as u64) << 28;

    let morsel = decode_table[input[6] as usize];
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 6,
            input[6],
        ));
    }
    accum |= (morsel as u64) << 22;

    let morsel = decode_table[input[7] as usize];
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 7,
            input[7],
        ));
    }
    accum |= (morsel as u64) << 16;

    write_u64(output, accum);

    Ok(())
}",1,True,True,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,"decode_chunk input : & [ u8 ] , index_at_start_of_input : usize , decode_table : & [ u8 ; 256 ] , output : & mut [ u8 ] ,","fn decode_chunk(
    input: &[u8],
    index_at_start_of_input: usize,
    decode_table: &[u8; 256],
    output: &mut [u8],
) -> Result<(), DecodeError> {
    let mut accum: u64;

    #[cfg(not(feature = ""slow_but_safe""))]
    let morsel = decode_table[input[0] as usize];
    #[cfg(feature = ""slow_but_safe"")]
    let morsel = decode_aligned(input[0], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(index_at_start_of_input, input[0]));
    }
    accum = (morsel as u64) << 58;

    #[cfg(not(feature = ""slow_but_safe""))]
    let morsel = decode_table[input[1] as usize];
    #[cfg(feature = ""slow_but_safe"")]
    let morsel = decode_aligned(input[1], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 1,
            input[1],
        ));
    }
    accum |= (morsel as u64) << 52;

    #[cfg(not(feature = ""slow_but_safe""))]
    let morsel = decode_table[input[2] as usize];
    #[cfg(feature = ""slow_but_safe"")]
    let morsel = decode_aligned(input[2], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 2,
            input[2],
        ));
    }
    accum |= (morsel as u64) << 46;

    #[cfg(not(feature = ""slow_but_safe""))]
    let morsel = decode_table[input[3] as usize];
    #[cfg(feature = ""slow_but_safe"")]
    let morsel = decode_aligned(input[3], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 3,
            input[3],
        ));
    }
    accum |= (morsel as u64) << 40;

    #[cfg(not(feature = ""slow_but_safe""))]
    let morsel = decode_table[input[4] as usize];
    #[cfg(feature = ""slow_but_safe"")]
    let morsel = decode_aligned(input[4], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 4,
            input[4],
        ));
    }
    accum |= (morsel as u64) << 34;

    #[cfg(not(feature = ""slow_but_safe""))]
    let morsel = decode_table[input[5] as usize];
    #[cfg(feature = ""slow_but_safe"")]
    let morsel = decode_aligned(input[5], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 5,
            input[5],
        ));
    }
    accum |= (morsel as u64) << 28;

    #[cfg(not(feature = ""slow_but_safe""))]
    let morsel = decode_table[input[6] as usize];
    #[cfg(feature = ""slow_but_safe"")]
    let morsel = decode_aligned(input[6], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 6,
            input[6],
        ));
    }
    accum |= (morsel as u64) << 22;

    #[cfg(not(feature = ""slow_but_safe""))]
    let morsel = decode_table[input[7] as usize];
    #[cfg(feature = ""slow_but_safe"")]
    let morsel = decode_aligned(input[7], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 7,
            input[7],
        ));
    }
    accum |= (morsel as u64) << 16;

    write_u64(output, accum);

    Ok(())
}",0,False,True,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,"decode_aligned b64ch : u8 , decode_table : & [ u8 ; 256 ]","fn decode_aligned(b64ch: u8, decode_table: &[u8; 256]) -> u8 {
    let mut result: u8 = 0x00;
    let mut mask: u8;
    let idx: [u8;2] = [ b64ch % 64, b64ch % 64 + 64];
    for i in 0..2  {
        mask = 0xFF ^ (((idx[i] == b64ch) as i8 - 1) as u8);
        result = result | (decode_table[idx[i] as usize] & mask);
    }
    result
}",0,False,True,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,"fmt & self , f : & mut fmt :: Formatter","    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            DecodeError::InvalidByte(index, byte) => {
                write!(f, ""Invalid byte {}, offset {}."", byte, index)
            }
            DecodeError::InvalidLength => write!(f, ""Encoded text cannot have a 6-bit remainder.""),
            DecodeError::InvalidLastSymbol(index, byte) => {
                write!(f, ""Invalid last symbol {}, offset {}."", byte, index)
            }
        }
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,description & self,"    fn description(&self) -> &str {
        match *self {
            DecodeError::InvalidByte(_, _) => ""invalid byte"",
            DecodeError::InvalidLength => ""invalid length"",
            DecodeError::InvalidLastSymbol(_, _) => ""invalid last symbol"",
        }
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,cause & self,"    fn cause(&self) -> Option<&dyn error::Error> {
        None
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,decode input : T,"pub fn decode<T: AsRef<[u8]>>(input: T) -> Result<Vec<u8>, DecodeError> {
    decode_config(input, STANDARD)
}",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,"decode_config input : T , config : Config","pub fn decode_config<T: AsRef<[u8]>>(input: T, config: Config) -> Result<Vec<u8>, DecodeError> {
    let mut buffer = Vec::<u8>::with_capacity(input.as_ref().len() * 4 / 3);

    decode_config_buf(input, config, &mut buffer).map(|_| buffer)
}",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,"decode_config_buf input : T , config : Config , buffer : & mut Vec < u8 > ,","pub fn decode_config_buf<T: AsRef<[u8]>>(
    input: T,
    config: Config,
    buffer: &mut Vec<u8>,
) -> Result<(), DecodeError> {
    let input_bytes = input.as_ref();

    let starting_output_len = buffer.len();

    let num_chunks = num_chunks(input_bytes);
    let decoded_len_estimate = num_chunks
        .checked_mul(DECODED_CHUNK_LEN)
        .and_then(|p| p.checked_add(starting_output_len))
        .expect(""Overflow when calculating output buffer length"");
    buffer.resize(decoded_len_estimate, 0);

    let bytes_written;
    {
        let buffer_slice = &mut buffer.as_mut_slice()[starting_output_len..];
        bytes_written = decode_helper(input_bytes, num_chunks, config, buffer_slice)?;
    }

    buffer.truncate(starting_output_len + bytes_written);

    Ok(())
}",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,"decode_config_slice input : T , config : Config , output : & mut [ u8 ] ,","pub fn decode_config_slice<T: AsRef<[u8]>>(
    input: T,
    config: Config,
    output: &mut [u8],
) -> Result<usize, DecodeError> {
    let input_bytes = input.as_ref();

    decode_helper(input_bytes, num_chunks(input_bytes), config, output)
}",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,num_chunks input : & [ u8 ],"fn num_chunks(input: &[u8]) -> usize {
    input
        .len()
        .checked_add(INPUT_CHUNK_LEN - 1)
        .expect(""Overflow when calculating number of chunks in input"")
        / INPUT_CHUNK_LEN
}",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,"decode_helper input : & [ u8 ] , num_chunks : usize , config : Config , output : & mut [ u8 ] ,","fn decode_helper(
    input: &[u8],
    num_chunks: usize,
    config: Config,
    output: &mut [u8],
) -> Result<usize, DecodeError> {
    let char_set = config.char_set;
    let decode_table = char_set.decode_table();

    let remainder_len = input.len() % INPUT_CHUNK_LEN;

    // Because the fast decode loop writes in groups of 8 bytes (unrolled to
    // CHUNKS_PER_FAST_LOOP_BLOCK times 8 bytes, where possible) and outputs 8 bytes at a time (of
    // which only 6 are valid data), we need to be sure that we stop using the fast decode loop
    // soon enough that there will always be 2 more bytes of valid data written after that loop.
    let trailing_bytes_to_skip = match remainder_len {
        // if input is a multiple of the chunk size, ignore the last chunk as it may have padding,
        // and the fast decode logic cannot handle padding
        0 => INPUT_CHUNK_LEN,
        // 1 and 5 trailing bytes are illegal: can't decode 6 bits of input into a byte
        1 | 5 => {
            // trailing whitespace is so common that it's worth it to check the last byte to
            // possibly return a better error message
            if let Some(b) = input.last() {
                if *b != PAD_BYTE && decode_table[*b as usize] == tables::INVALID_VALUE {
                    return Err(DecodeError::InvalidByte(input.len() - 1, *b));
                }
            }

            return Err(DecodeError::InvalidLength);
        }
        // This will decode to one output byte, which isn't enough to overwrite the 2 extra bytes
        // written by the fast decode loop. So, we have to ignore both these 2 bytes and the
        // previous chunk.
        2 => INPUT_CHUNK_LEN + 2,
        // If this is 3 unpadded chars, then it would actually decode to 2 bytes. However, if this
        // is an erroneous 2 chars + 1 pad char that would decode to 1 byte, then it should fail
        // with an error, not panic from going past the bounds of the output slice, so we let it
        // use stage 3 + 4.
        3 => INPUT_CHUNK_LEN + 3,
        // This can also decode to one output byte because it may be 2 input chars + 2 padding
        // chars, which would decode to 1 byte.
        4 => INPUT_CHUNK_LEN + 4,
        // Everything else is a legal decode len (given that we don't require padding), and will
        // decode to at least 2 bytes of output.
        _ => remainder_len,
    };

    // rounded up to include partial chunks
    let mut remaining_chunks = num_chunks;

    let mut input_index = 0;
    let mut output_index = 0;

    {
        let length_of_fast_decode_chunks = input.len().saturating_sub(trailing_bytes_to_skip);

        // Fast loop, stage 1
        // manual unroll to CHUNKS_PER_FAST_LOOP_BLOCK of u64s to amortize slice bounds checks
        if let Some(max_start_index) = length_of_fast_decode_chunks.checked_sub(INPUT_BLOCK_LEN) {
            while input_index <= max_start_index {
                let input_slice = &input[input_index..(input_index + INPUT_BLOCK_LEN)];
                let output_slice = &mut output[output_index..(output_index + DECODED_BLOCK_LEN)];

                decode_chunk(
                    &input_slice[0..],
                    input_index,
                    decode_table,
                    &mut output_slice[0..],
                )?;
                decode_chunk(
                    &input_slice[8..],
                    input_index + 8,
                    decode_table,
                    &mut output_slice[6..],
                )?;
                decode_chunk(
                    &input_slice[16..],
                    input_index + 16,
                    decode_table,
                    &mut output_slice[12..],
                )?;
                decode_chunk(
                    &input_slice[24..],
                    input_index + 24,
                    decode_table,
                    &mut output_slice[18..],
                )?;

                input_index += INPUT_BLOCK_LEN;
                output_index += DECODED_BLOCK_LEN - DECODED_CHUNK_SUFFIX;
                remaining_chunks -= CHUNKS_PER_FAST_LOOP_BLOCK;
            }
        }

        // Fast loop, stage 2 (aka still pretty fast loop)
        // 8 bytes at a time for whatever we didn't do in stage 1.
        if let Some(max_start_index) = length_of_fast_decode_chunks.checked_sub(INPUT_CHUNK_LEN) {
            while input_index < max_start_index {
                decode_chunk(
                    &input[input_index..(input_index + INPUT_CHUNK_LEN)],
                    input_index,
                    decode_table,
                    &mut output
                        [output_index..(output_index + DECODED_CHUNK_LEN + DECODED_CHUNK_SUFFIX)],
                )?;

                output_index += DECODED_CHUNK_LEN;
                input_index += INPUT_CHUNK_LEN;
                remaining_chunks -= 1;
            }
        }
    }

    // Stage 3
    // If input length was such that a chunk had to be deferred until after the fast loop
    // because decoding it would have produced 2 trailing bytes that wouldn't then be
    // overwritten, we decode that chunk here. This way is slower but doesn't write the 2
    // trailing bytes.
    // However, we still need to avoid the last chunk (partial or complete) because it could
    // have padding, so we always do 1 fewer to avoid the last chunk.
    for _ in 1..remaining_chunks {
        decode_chunk_precise(
            &input[input_index..],
            input_index,
            decode_table,
            &mut output[output_index..(output_index + DECODED_CHUNK_LEN)],
        )?;

        input_index += INPUT_CHUNK_LEN;
        output_index += DECODED_CHUNK_LEN;
    }

    // always have one more (possibly partial) block of 8 input
    debug_assert!(input.len() - input_index > 1 || input.is_empty());
    debug_assert!(input.len() - input_index <= 8);

    // Stage 4
    // Finally, decode any leftovers that aren't a complete input block of 8 bytes.
    // Use a u64 as a stack-resident 8 byte buffer.
    let mut leftover_bits: u64 = 0;
    let mut morsels_in_leftover = 0;
    let mut padding_bytes = 0;
    let mut first_padding_index: usize = 0;
    let mut last_symbol = 0_u8;
    let start_of_leftovers = input_index;
    for (i, b) in input[start_of_leftovers..].iter().enumerate() {
        // '=' padding
        if *b == PAD_BYTE {
            // There can be bad padding in a few ways:
            // 1 - Padding with non-padding characters after it
            // 2 - Padding after zero or one non-padding characters before it
            //     in the current quad.
            // 3 - More than two characters of padding. If 3 or 4 padding chars
            //     are in the same quad, that implies it will be caught by #2.
            //     If it spreads from one quad to another, it will be caught by
            //     #2 in the second quad.

            if i % 4 < 2 {
                // Check for case #2.
                let bad_padding_index = start_of_leftovers
                    + if padding_bytes > 0 {
                        // If we've already seen padding, report the first padding index.
                        // This is to be consistent with the faster logic above: it will report an
                        // error on the first padding character (since it doesn't expect to see
                        // anything but actual encoded data).
                        first_padding_index
                    } else {
                        // haven't seen padding before, just use where we are now
                        i
                    };
                return Err(DecodeError::InvalidByte(bad_padding_index, *b));
            }

            if padding_bytes == 0 {
                first_padding_index = i;
            }

            padding_bytes += 1;
            continue;
        }

        // Check for case #1.
        // To make '=' handling consistent with the main loop, don't allow
        // non-suffix '=' in trailing chunk either. Report error as first
        // erroneous padding.
        if padding_bytes > 0 {
            return Err(DecodeError::InvalidByte(
                start_of_leftovers + first_padding_index,
                PAD_BYTE,
            ));
        }
        last_symbol = *b;

        // can use up to 8 * 6 = 48 bits of the u64, if last chunk has no padding.
        // To minimize shifts, pack the leftovers from left to right.
        let shift = 64 - (morsels_in_leftover + 1) * 6;
        // tables are all 256 elements, lookup with a u8 index always succeeds
        let morsel = decode_table[*b as usize];
        if morsel == tables::INVALID_VALUE {
            return Err(DecodeError::InvalidByte(start_of_leftovers + i, *b));
        }

        leftover_bits |= (morsel as u64) << shift;
        morsels_in_leftover += 1;
    }

    let leftover_bits_ready_to_append = match morsels_in_leftover {
        0 => 0,
        2 => 8,
        3 => 16,
        4 => 24,
        6 => 32,
        7 => 40,
        8 => 48,
        _ => unreachable!(
            ""Impossible: must only have 0 to 8 input bytes in last chunk, with no invalid lengths""
        ),
    };

    // if there are bits set outside the bits we care about, last symbol encodes trailing bits that
    // will not be included in the output
    let mask = !0 >> leftover_bits_ready_to_append;
    if !config.decode_allow_trailing_bits && (leftover_bits & mask) != 0 {
        // last morsel is at `morsels_in_leftover` - 1
        return Err(DecodeError::InvalidLastSymbol(
            start_of_leftovers + morsels_in_leftover - 1,
            last_symbol,
        ));
    }

    let mut leftover_bits_appended_to_buf = 0;
    while leftover_bits_appended_to_buf < leftover_bits_ready_to_append {
        // `as` simply truncates the higher bits, which is what we want here
        let selected_bits = (leftover_bits >> (56 - leftover_bits_appended_to_buf)) as u8;
        output[output_index] = selected_bits;
        output_index += 1;

        leftover_bits_appended_to_buf += 8;
    }

    Ok(output_index)
}",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,"write_u64 output : & mut [ u8 ] , value : u64","fn write_u64(output: &mut [u8], value: u64) {
    output[..8].copy_from_slice(&value.to_be_bytes());
}",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,"decode_chunk_precise input : & [ u8 ] , index_at_start_of_input : usize , decode_table : & [ u8 ; 256 ] , output : & mut [ u8 ] ,","fn decode_chunk_precise(
    input: &[u8],
    index_at_start_of_input: usize,
    decode_table: &[u8; 256],
    output: &mut [u8],
) -> Result<(), DecodeError> {
    let mut tmp_buf = [0_u8; 8];

    decode_chunk(
        input,
        index_at_start_of_input,
        decode_table,
        &mut tmp_buf[..],
    )?;

    output[0..6].copy_from_slice(&tmp_buf[0..6]);

    Ok(())
}",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,decode_chunk_precise_writes_only_6_bytes,"    fn decode_chunk_precise_writes_only_6_bytes() {
        let input = b""Zm9vYmFy""; // ""foobar""
        let mut output = [0_u8, 1, 2, 3, 4, 5, 6, 7];
        decode_chunk_precise(&input[..], 0, tables::STANDARD_DECODE, &mut output).unwrap();
        assert_eq!(&vec![b'f', b'o', b'o', b'b', b'a', b'r', 6, 7], &output);
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,decode_chunk_writes_8_bytes,"    fn decode_chunk_writes_8_bytes() {
        let input = b""Zm9vYmFy""; // ""foobar""
        let mut output = [0_u8, 1, 2, 3, 4, 5, 6, 7];
        decode_chunk(&input[..], 0, tables::STANDARD_DECODE, &mut output).unwrap();
        assert_eq!(&vec![b'f', b'o', b'o', b'b', b'a', b'r', 0, 0], &output);
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,decode_into_nonempty_vec_doesnt_clobber_existing_prefix,"    fn decode_into_nonempty_vec_doesnt_clobber_existing_prefix() {
        let mut orig_data = Vec::new();
        let mut encoded_data = String::new();
        let mut decoded_with_prefix = Vec::new();
        let mut decoded_without_prefix = Vec::new();
        let mut prefix = Vec::new();

        let prefix_len_range = Uniform::new(0, 1000);
        let input_len_range = Uniform::new(0, 1000);

        let mut rng = rand::rngs::SmallRng::from_entropy();

        for _ in 0..10_000 {
            orig_data.clear();
            encoded_data.clear();
            decoded_with_prefix.clear();
            decoded_without_prefix.clear();
            prefix.clear();

            let input_len = input_len_range.sample(&mut rng);

            for _ in 0..input_len {
                orig_data.push(rng.gen());
            }

            let config = random_config(&mut rng);
            encode_config_buf(&orig_data, config, &mut encoded_data);
            assert_encode_sanity(&encoded_data, config, input_len);

            let prefix_len = prefix_len_range.sample(&mut rng);

            // fill the buf with a prefix
            for _ in 0..prefix_len {
                prefix.push(rng.gen());
            }

            decoded_with_prefix.resize(prefix_len, 0);
            decoded_with_prefix.copy_from_slice(&prefix);

            // decode into the non-empty buf
            decode_config_buf(&encoded_data, config, &mut decoded_with_prefix).unwrap();
            // also decode into the empty buf
            decode_config_buf(&encoded_data, config, &mut decoded_without_prefix).unwrap();

            assert_eq!(
                prefix_len + decoded_without_prefix.len(),
                decoded_with_prefix.len()
            );
            assert_eq!(orig_data, decoded_without_prefix);

            // append plain decode onto prefix
            prefix.append(&mut decoded_without_prefix);

            assert_eq!(prefix, decoded_with_prefix);
        }
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,decode_into_slice_doesnt_clobber_existing_prefix_or_suffix,"    fn decode_into_slice_doesnt_clobber_existing_prefix_or_suffix() {
        let mut orig_data = Vec::new();
        let mut encoded_data = String::new();
        let mut decode_buf = Vec::new();
        let mut decode_buf_copy: Vec<u8> = Vec::new();

        let input_len_range = Uniform::new(0, 1000);

        let mut rng = rand::rngs::SmallRng::from_entropy();

        for _ in 0..10_000 {
            orig_data.clear();
            encoded_data.clear();
            decode_buf.clear();
            decode_buf_copy.clear();

            let input_len = input_len_range.sample(&mut rng);

            for _ in 0..input_len {
                orig_data.push(rng.gen());
            }

            let config = random_config(&mut rng);
            encode_config_buf(&orig_data, config, &mut encoded_data);
            assert_encode_sanity(&encoded_data, config, input_len);

            // fill the buffer with random garbage, long enough to have some room before and after
            for _ in 0..5000 {
                decode_buf.push(rng.gen());
            }

            // keep a copy for later comparison
            decode_buf_copy.extend(decode_buf.iter());

            let offset = 1000;

            // decode into the non-empty buf
            let decode_bytes_written =
                decode_config_slice(&encoded_data, config, &mut decode_buf[offset..]).unwrap();

            assert_eq!(orig_data.len(), decode_bytes_written);
            assert_eq!(
                orig_data,
                &decode_buf[offset..(offset + decode_bytes_written)]
            );
            assert_eq!(&decode_buf_copy[0..offset], &decode_buf[0..offset]);
            assert_eq!(
                &decode_buf_copy[offset + decode_bytes_written..],
                &decode_buf[offset + decode_bytes_written..]
            );
        }
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,decode_into_slice_fits_in_precisely_sized_slice,"    fn decode_into_slice_fits_in_precisely_sized_slice() {
        let mut orig_data = Vec::new();
        let mut encoded_data = String::new();
        let mut decode_buf = Vec::new();

        let input_len_range = Uniform::new(0, 1000);

        let mut rng = rand::rngs::SmallRng::from_entropy();

        for _ in 0..10_000 {
            orig_data.clear();
            encoded_data.clear();
            decode_buf.clear();

            let input_len = input_len_range.sample(&mut rng);

            for _ in 0..input_len {
                orig_data.push(rng.gen());
            }

            let config = random_config(&mut rng);
            encode_config_buf(&orig_data, config, &mut encoded_data);
            assert_encode_sanity(&encoded_data, config, input_len);

            decode_buf.resize(input_len, 0);

            // decode into the non-empty buf
            let decode_bytes_written =
                decode_config_slice(&encoded_data, config, &mut decode_buf[..]).unwrap();

            assert_eq!(orig_data.len(), decode_bytes_written);
            assert_eq!(orig_data, decode_buf);
        }
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,detect_invalid_last_symbol_two_bytes,"    fn detect_invalid_last_symbol_two_bytes() {
        let decode =
            |input, forgiving| decode_config(input, STANDARD.decode_allow_trailing_bits(forgiving));

        // example from https://github.com/marshallpierce/rust-base64/issues/75
        assert!(decode(""iYU="", false).is_ok());
        // trailing 01
        assert_eq!(
            Err(DecodeError::InvalidLastSymbol(2, b'V')),
            decode(""iYV="", false)
        );
        assert_eq!(Ok(vec![137, 133]), decode(""iYV="", true));
        // trailing 10
        assert_eq!(
            Err(DecodeError::InvalidLastSymbol(2, b'W')),
            decode(""iYW="", false)
        );
        assert_eq!(Ok(vec![137, 133]), decode(""iYV="", true));
        // trailing 11
        assert_eq!(
            Err(DecodeError::InvalidLastSymbol(2, b'X')),
            decode(""iYX="", false)
        );
        assert_eq!(Ok(vec![137, 133]), decode(""iYV="", true));

        // also works when there are 2 quads in the last block
        assert_eq!(
            Err(DecodeError::InvalidLastSymbol(6, b'X')),
            decode(""AAAAiYX="", false)
        );
        assert_eq!(Ok(vec![0, 0, 0, 137, 133]), decode(""AAAAiYX="", true));
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,detect_invalid_last_symbol_one_byte,"    fn detect_invalid_last_symbol_one_byte() {
        // 0xFF -> ""/w=="", so all letters > w, 0-9, and '+', '/' should get InvalidLastSymbol

        assert!(decode(""/w=="").is_ok());
        // trailing 01
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'x')), decode(""/x==""));
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'z')), decode(""/z==""));
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'0')), decode(""/0==""));
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'9')), decode(""/9==""));
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'+')), decode(""/+==""));
        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'/')), decode(""//==""));

        // also works when there are 2 quads in the last block
        assert_eq!(
            Err(DecodeError::InvalidLastSymbol(5, b'x')),
            decode(""AAAA/x=="")
        );
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,detect_invalid_last_symbol_every_possible_three_symbols,"    fn detect_invalid_last_symbol_every_possible_three_symbols() {
        let mut base64_to_bytes = ::std::collections::HashMap::new();

        let mut bytes = [0_u8; 2];
        for b1 in 0_u16..256 {
            bytes[0] = b1 as u8;
            for b2 in 0_u16..256 {
                bytes[1] = b2 as u8;
                let mut b64 = vec![0_u8; 4];
                assert_eq!(4, encode_config_slice(&bytes, STANDARD, &mut b64[..]));
                let mut v = ::std::vec::Vec::with_capacity(2);
                v.extend_from_slice(&bytes[..]);

                assert!(base64_to_bytes.insert(b64, v).is_none());
            }
        }

        // every possible combination of symbols must either decode to 2 bytes or get InvalidLastSymbol

        let mut symbols = [0_u8; 4];
        for &s1 in STANDARD.char_set.encode_table().iter() {
            symbols[0] = s1;
            for &s2 in STANDARD.char_set.encode_table().iter() {
                symbols[1] = s2;
                for &s3 in STANDARD.char_set.encode_table().iter() {
                    symbols[2] = s3;
                    symbols[3] = PAD_BYTE;

                    match base64_to_bytes.get(&symbols[..]) {
                        Some(bytes) => {
                            assert_eq!(Ok(bytes.to_vec()), decode_config(&symbols, STANDARD))
                        }
                        None => assert_eq!(
                            Err(DecodeError::InvalidLastSymbol(2, s3)),
                            decode_config(&symbols[..], STANDARD)
                        ),
                    }
                }
            }
        }
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,decode.rs,Rust,detect_invalid_last_symbol_every_possible_two_symbols,"    fn detect_invalid_last_symbol_every_possible_two_symbols() {
        let mut base64_to_bytes = ::std::collections::HashMap::new();

        for b in 0_u16..256 {
            let mut b64 = vec![0_u8; 4];
            assert_eq!(4, encode_config_slice(&[b as u8], STANDARD, &mut b64[..]));
            let mut v = ::std::vec::Vec::with_capacity(1);
            v.push(b as u8);

            assert!(base64_to_bytes.insert(b64, v).is_none());
        }

        // every possible combination of symbols must either decode to 1 byte or get InvalidLastSymbol

        let mut symbols = [0_u8; 4];
        for &s1 in STANDARD.char_set.encode_table().iter() {
            symbols[0] = s1;
            for &s2 in STANDARD.char_set.encode_table().iter() {
                symbols[1] = s2;
                symbols[2] = PAD_BYTE;
                symbols[3] = PAD_BYTE;

                match base64_to_bytes.get(&symbols[..]) {
                    Some(bytes) => {
                        assert_eq!(Ok(bytes.to_vec()), decode_config(&symbols, STANDARD))
                    }
                    None => assert_eq!(
                        Err(DecodeError::InvalidLastSymbol(1, s2)),
                        decode_config(&symbols[..], STANDARD)
                    ),
                }
            }
        }
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,lib.rs,Rust,encode_table self,"    fn encode_table(self) -> &'static [u8; 64] {
        match self {
            CharacterSet::Standard => tables::STANDARD_ENCODE,
            CharacterSet::UrlSafe => tables::URL_SAFE_ENCODE,
            CharacterSet::Crypt => tables::CRYPT_ENCODE,
            CharacterSet::Bcrypt => tables::BCRYPT_ENCODE,
            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_ENCODE,
            CharacterSet::BinHex => tables::BINHEX_ENCODE,
        }
    }

    fn decode_table(self) -> &'static [u8; 256] {
        match self {
            CharacterSet::Standard => tables::STANDARD_DECODE,
            CharacterSet::UrlSafe => tables::URL_SAFE_DECODE,
            CharacterSet::Crypt => tables::CRYPT_DECODE,
            CharacterSet::Bcrypt => tables::BCRYPT_DECODE,
            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_DECODE,
            CharacterSet::BinHex => tables::BINHEX_DECODE,
        }
    }",1,True,False,"13,14,15,16,17,18"
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,lib.rs,Rust,encode_table self,"    fn encode_table(self) -> &'static [u8; 64] {
        match self {
            CharacterSet::Standard => tables::STANDARD_ENCODE,
            CharacterSet::UrlSafe => tables::URL_SAFE_ENCODE,
            CharacterSet::Crypt => tables::CRYPT_ENCODE,
            CharacterSet::Bcrypt => tables::BCRYPT_ENCODE,
            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_ENCODE,
            CharacterSet::BinHex => tables::BINHEX_ENCODE,
        }
    }

    fn decode_table(self) -> &'static [u8; 256] {
        match self {
            CharacterSet::Standard => &tables::STANDARD_DECODE_HOLDER.data,
            CharacterSet::UrlSafe => &tables::URL_SAFE_DECODE_HOLDER.data,
            CharacterSet::Crypt => &tables::CRYPT_DECODE_HOLDER.data,
            CharacterSet::Bcrypt => &tables::BCRYPT_DECODE_HOLDER.data,
            CharacterSet::ImapMutf7 => &tables::IMAP_MUTF7_DECODE_HOLDER.data,
            CharacterSet::BinHex => &tables::BINHEX_DECODE_HOLDER.data,
        }
    }",0,False,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,lib.rs,Rust,"new char_set : CharacterSet , pad : bool","    pub const fn new(char_set: CharacterSet, pad: bool) -> Config {
        Config {
            char_set,
            pad,
            decode_allow_trailing_bits: false,
        }
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,lib.rs,Rust,"pad self , pad : bool","    pub const fn pad(self, pad: bool) -> Config {
        Config { pad, ..self }
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,lib.rs,Rust,"decode_allow_trailing_bits self , allow : bool","    pub const fn decode_allow_trailing_bits(self, allow: bool) -> Config {
        Config {
            decode_allow_trailing_bits: allow,
            ..self
        }
    }",0,True,False,
https://github.com/dingelish/rust-base64.git,a554b7ae880553db6dde8a387101a093911d5b2a,Yu Ding,2021-01-17 22:29:18-08:00,False,tables.rs,Rust,alignment_check,"fn alignment_check() {
    let p: *const u8 = STANDARD_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
    let p: *const u8 = URL_SAFE_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
    let p: *const u8 = CRYPT_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
    let p: *const u8 = BCRYPT_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
    let p: *const u8 = IMAP_MUTF7_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
    let p: *const u8 = BINHEX_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
}",0,False,True,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c & mut self , expr : & Hir","    fn c(&mut self, expr: &Hir) -> ResultOrEmpty {
        use crate::prog;
        use regex_syntax::hir::HirKind::*;

        self.check_size()?;
        match *expr.kind() {
            Empty => Ok(None),
            Literal(hir::Literal::Unicode(c)) => self.c_char(c),
            Literal(hir::Literal::Byte(b)) => {
                assert!(self.compiled.uses_bytes());
                self.c_byte(b)
            }
            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),
            Class(hir::Class::Bytes(ref cls)) => {
                if self.compiled.uses_bytes() {
                    self.c_class_bytes(cls.ranges())
                } else {
                    assert!(cls.is_all_ascii());
                    let mut char_ranges = vec![];
                    for r in cls.iter() {
                        let (s, e) = (r.start() as char, r.end() as char);
                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));
                    }
                    self.c_class(&char_ranges)
                }
            }
            Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::EndLine)
            }
            Anchor(hir::Anchor::StartLine) => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::StartLine)
            }
            Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::StartLine)
            }
            Anchor(hir::Anchor::EndLine) => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::EndLine)
            }
            Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {
                self.c_empty_look(prog::EmptyLook::EndText)
            }
            Anchor(hir::Anchor::StartText) => {
                self.c_empty_look(prog::EmptyLook::StartText)
            }
            Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {
                self.c_empty_look(prog::EmptyLook::StartText)
            }
            Anchor(hir::Anchor::EndText) => {
                self.c_empty_look(prog::EmptyLook::EndText)
            }
            WordBoundary(hir::WordBoundary::Unicode) => {
                if !cfg!(feature = ""unicode-perl"") {
                    return Err(Error::Syntax(
                        ""Unicode word boundaries are unavailable when \
                         the unicode-perl feature is disabled""
                            .to_string(),
                    ));
                }
                self.compiled.has_unicode_word_boundary = true;
                self.byte_classes.set_word_boundary();
                // We also make sure that all ASCII bytes are in a different
                // class from non-ASCII bytes. Otherwise, it's possible for
                // ASCII bytes to get lumped into the same class as non-ASCII
                // bytes. This in turn may cause the lazy DFA to falsely start
                // when it sees an ASCII byte that maps to a byte class with
                // non-ASCII bytes. This ensures that never happens.
                self.byte_classes.set_range(0, 0x7F);
                self.c_empty_look(prog::EmptyLook::WordBoundary)
            }
            WordBoundary(hir::WordBoundary::UnicodeNegate) => {
                if !cfg!(feature = ""unicode-perl"") {
                    return Err(Error::Syntax(
                        ""Unicode word boundaries are unavailable when \
                         the unicode-perl feature is disabled""
                            .to_string(),
                    ));
                }
                self.compiled.has_unicode_word_boundary = true;
                self.byte_classes.set_word_boundary();
                // See comments above for why we set the ASCII range here.
                self.byte_classes.set_range(0, 0x7F);
                self.c_empty_look(prog::EmptyLook::NotWordBoundary)
            }
            WordBoundary(hir::WordBoundary::Ascii) => {
                self.byte_classes.set_word_boundary();
                self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)
            }
            WordBoundary(hir::WordBoundary::AsciiNegate) => {
                self.byte_classes.set_word_boundary();
                self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)
            }
            Group(ref g) => match g.kind {
                hir::GroupKind::NonCapturing => self.c(&g.hir),
                hir::GroupKind::CaptureIndex(index) => {
                    if index as usize >= self.compiled.captures.len() {
                        self.compiled.captures.push(None);
                    }
                    self.c_capture(2 * index as usize, &g.hir)
                }
                hir::GroupKind::CaptureName { index, ref name } => {
                    if index as usize >= self.compiled.captures.len() {
                        let n = name.to_string();
                        self.compiled.captures.push(Some(n.clone()));
                        self.capture_name_idx.insert(n, index as usize);
                    }
                    self.c_capture(2 * index as usize, &g.hir)
                }
            },
            Concat(ref es) => {
                if self.compiled.is_reverse {
                    self.c_concat(es.iter().rev())
                } else {
                    self.c_concat(es)
                }
            }
            Alternation(ref es) => self.c_alternate(&**es),
            Repetition(ref rep) => self.c_repeat(rep),
        }
    }",1,True,False,6
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,c_empty & mut self,"    fn c_empty(&mut self) -> ResultOrEmpty {
        // See: https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8
        // See: CVE-2022-24713
        //
        // Since 'empty' sub-expressions don't increase the size of
        // the actual compiled object, we ""fake"" an increase in its
        // size so that our 'check_size_limit' routine will eventually
        // stop compilation if there are too many empty sub-expressions
        // (e.g., via a large repetition).
        self.extra_inst_bytes += std::mem::size_of::<Inst>();
        Ok(None)
    }",0,False,True,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c & mut self , expr : & Hir","    fn c(&mut self, expr: &Hir) -> ResultOrEmpty {
        use crate::prog;
        use regex_syntax::hir::HirKind::*;

        self.check_size()?;
        match *expr.kind() {
            Empty => self.c_empty(),
            Literal(hir::Literal::Unicode(c)) => self.c_char(c),
            Literal(hir::Literal::Byte(b)) => {
                assert!(self.compiled.uses_bytes());
                self.c_byte(b)
            }
            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),
            Class(hir::Class::Bytes(ref cls)) => {
                if self.compiled.uses_bytes() {
                    self.c_class_bytes(cls.ranges())
                } else {
                    assert!(cls.is_all_ascii());
                    let mut char_ranges = vec![];
                    for r in cls.iter() {
                        let (s, e) = (r.start() as char, r.end() as char);
                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));
                    }
                    self.c_class(&char_ranges)
                }
            }
            Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::EndLine)
            }
            Anchor(hir::Anchor::StartLine) => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::StartLine)
            }
            Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::StartLine)
            }
            Anchor(hir::Anchor::EndLine) => {
                self.byte_classes.set_range(b'\n', b'\n');
                self.c_empty_look(prog::EmptyLook::EndLine)
            }
            Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {
                self.c_empty_look(prog::EmptyLook::EndText)
            }
            Anchor(hir::Anchor::StartText) => {
                self.c_empty_look(prog::EmptyLook::StartText)
            }
            Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {
                self.c_empty_look(prog::EmptyLook::StartText)
            }
            Anchor(hir::Anchor::EndText) => {
                self.c_empty_look(prog::EmptyLook::EndText)
            }
            WordBoundary(hir::WordBoundary::Unicode) => {
                if !cfg!(feature = ""unicode-perl"") {
                    return Err(Error::Syntax(
                        ""Unicode word boundaries are unavailable when \
                         the unicode-perl feature is disabled""
                            .to_string(),
                    ));
                }
                self.compiled.has_unicode_word_boundary = true;
                self.byte_classes.set_word_boundary();
                // We also make sure that all ASCII bytes are in a different
                // class from non-ASCII bytes. Otherwise, it's possible for
                // ASCII bytes to get lumped into the same class as non-ASCII
                // bytes. This in turn may cause the lazy DFA to falsely start
                // when it sees an ASCII byte that maps to a byte class with
                // non-ASCII bytes. This ensures that never happens.
                self.byte_classes.set_range(0, 0x7F);
                self.c_empty_look(prog::EmptyLook::WordBoundary)
            }
            WordBoundary(hir::WordBoundary::UnicodeNegate) => {
                if !cfg!(feature = ""unicode-perl"") {
                    return Err(Error::Syntax(
                        ""Unicode word boundaries are unavailable when \
                         the unicode-perl feature is disabled""
                            .to_string(),
                    ));
                }
                self.compiled.has_unicode_word_boundary = true;
                self.byte_classes.set_word_boundary();
                // See comments above for why we set the ASCII range here.
                self.byte_classes.set_range(0, 0x7F);
                self.c_empty_look(prog::EmptyLook::NotWordBoundary)
            }
            WordBoundary(hir::WordBoundary::Ascii) => {
                self.byte_classes.set_word_boundary();
                self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)
            }
            WordBoundary(hir::WordBoundary::AsciiNegate) => {
                self.byte_classes.set_word_boundary();
                self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)
            }
            Group(ref g) => match g.kind {
                hir::GroupKind::NonCapturing => self.c(&g.hir),
                hir::GroupKind::CaptureIndex(index) => {
                    if index as usize >= self.compiled.captures.len() {
                        self.compiled.captures.push(None);
                    }
                    self.c_capture(2 * index as usize, &g.hir)
                }
                hir::GroupKind::CaptureName { index, ref name } => {
                    if index as usize >= self.compiled.captures.len() {
                        let n = name.to_string();
                        self.compiled.captures.push(Some(n.clone()));
                        self.capture_name_idx.insert(n, index as usize);
                    }
                    self.c_capture(2 * index as usize, &g.hir)
                }
            },
            Concat(ref es) => {
                if self.compiled.is_reverse {
                    self.c_concat(es.iter().rev())
                } else {
                    self.c_concat(es)
                }
            }
            Alternation(ref es) => self.c_alternate(&**es),
            Repetition(ref rep) => self.c_repeat(rep),
        }
    }",0,False,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,new,"    pub fn new() -> Self {
        Compiler {
            insts: vec![],
            compiled: Program::new(),
            capture_name_idx: HashMap::new(),
            num_exprs: 0,
            size_limit: 10 * (1 << 20),
            suffix_cache: SuffixCache::new(1000),
            utf8_seqs: Some(Utf8Sequences::new('\x00', '\x00')),
            byte_classes: ByteClassSet::new(),
            extra_inst_bytes: 0,
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"size_limit mut self , size_limit : usize","    pub fn size_limit(mut self, size_limit: usize) -> Self {
        self.size_limit = size_limit;
        self
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"bytes mut self , yes : bool","    pub fn bytes(mut self, yes: bool) -> Self {
        self.compiled.is_bytes = yes;
        self
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"only_utf8 mut self , yes : bool","    pub fn only_utf8(mut self, yes: bool) -> Self {
        self.compiled.only_utf8 = yes;
        self
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"dfa mut self , yes : bool","    pub fn dfa(mut self, yes: bool) -> Self {
        self.compiled.is_dfa = yes;
        self
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"reverse mut self , yes : bool","    pub fn reverse(mut self, yes: bool) -> Self {
        self.compiled.is_reverse = yes;
        self
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"compile mut self , exprs : & [ Hir ]","    pub fn compile(mut self, exprs: &[Hir]) -> result::Result<Program, Error> {
        debug_assert!(!exprs.is_empty());
        self.num_exprs = exprs.len();
        if exprs.len() == 1 {
            self.compile_one(&exprs[0])
        } else {
            self.compile_many(exprs)
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"compile_one mut self , expr : & Hir","    fn compile_one(mut self, expr: &Hir) -> result::Result<Program, Error> {
        // If we're compiling a forward DFA and we aren't anchored, then
        // add a `.*?` before the first capture group.
        // Other matching engines handle this by baking the logic into the
        // matching engine itself.
        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };
        self.compiled.is_anchored_start = expr.is_anchored_start();
        self.compiled.is_anchored_end = expr.is_anchored_end();
        if self.compiled.needs_dotstar() {
            dotstar_patch = self.c_dotstar()?;
            self.compiled.start = dotstar_patch.entry;
        }
        self.compiled.captures = vec![None];
        let patch = self.c_capture(0, expr)?.unwrap_or(self.next_inst());
        if self.compiled.needs_dotstar() {
            self.fill(dotstar_patch.hole, patch.entry);
        } else {
            self.compiled.start = patch.entry;
        }
        self.fill_to_next(patch.hole);
        self.compiled.matches = vec![self.insts.len()];
        self.push_compiled(Inst::Match(0));
        self.compile_finish()
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"compile_many mut self , exprs : & [ Hir ] ,","    fn compile_many(
        mut self,
        exprs: &[Hir],
    ) -> result::Result<Program, Error> {
        debug_assert!(exprs.len() > 1);

        self.compiled.is_anchored_start =
            exprs.iter().all(|e| e.is_anchored_start());
        self.compiled.is_anchored_end =
            exprs.iter().all(|e| e.is_anchored_end());
        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };
        if self.compiled.needs_dotstar() {
            dotstar_patch = self.c_dotstar()?;
            self.compiled.start = dotstar_patch.entry;
        } else {
            self.compiled.start = 0; // first instruction is always split
        }
        self.fill_to_next(dotstar_patch.hole);

        let mut prev_hole = Hole::None;
        for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {
            self.fill_to_next(prev_hole);
            let split = self.push_split_hole();
            let Patch { hole, entry } =
                self.c_capture(0, expr)?.unwrap_or(self.next_inst());
            self.fill_to_next(hole);
            self.compiled.matches.push(self.insts.len());
            self.push_compiled(Inst::Match(i));
            prev_hole = self.fill_split(split, Some(entry), None);
        }
        let i = exprs.len() - 1;
        let Patch { hole, entry } =
            self.c_capture(0, &exprs[i])?.unwrap_or(self.next_inst());
        self.fill(prev_hole, entry);
        self.fill_to_next(hole);
        self.compiled.matches.push(self.insts.len());
        self.push_compiled(Inst::Match(i));
        self.compile_finish()
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,compile_finish mut self,"    fn compile_finish(mut self) -> result::Result<Program, Error> {
        self.compiled.insts =
            self.insts.into_iter().map(|inst| inst.unwrap()).collect();
        self.compiled.byte_classes = self.byte_classes.byte_classes();
        self.compiled.capture_name_idx = Arc::new(self.capture_name_idx);
        Ok(self.compiled)
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_capture & mut self , first_slot : usize , expr : & Hir","    fn c_capture(&mut self, first_slot: usize, expr: &Hir) -> ResultOrEmpty {
        if self.num_exprs > 1 || self.compiled.is_dfa {
            // Don't ever compile Save instructions for regex sets because
            // they are never used. They are also never used in DFA programs
            // because DFAs can't handle captures.
            self.c(expr)
        } else {
            let entry = self.insts.len();
            let hole = self.push_hole(InstHole::Save { slot: first_slot });
            let patch = self.c(expr)?.unwrap_or(self.next_inst());
            self.fill(hole, patch.entry);
            self.fill_to_next(patch.hole);
            let hole = self.push_hole(InstHole::Save { slot: first_slot + 1 });
            Ok(Some(Patch { hole: hole, entry: entry }))
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,c_dotstar & mut self,"    fn c_dotstar(&mut self) -> Result {
        Ok(if !self.compiled.only_utf8() {
            self.c(&Hir::repetition(hir::Repetition {
                kind: hir::RepetitionKind::ZeroOrMore,
                greedy: false,
                hir: Box::new(Hir::any(true)),
            }))?
            .unwrap()
        } else {
            self.c(&Hir::repetition(hir::Repetition {
                kind: hir::RepetitionKind::ZeroOrMore,
                greedy: false,
                hir: Box::new(Hir::any(false)),
            }))?
            .unwrap()
        })
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_char & mut self , c : char","    fn c_char(&mut self, c: char) -> ResultOrEmpty {
        if self.compiled.uses_bytes() {
            if c.is_ascii() {
                let b = c as u8;
                let hole =
                    self.push_hole(InstHole::Bytes { start: b, end: b });
                self.byte_classes.set_range(b, b);
                Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))
            } else {
                self.c_class(&[hir::ClassUnicodeRange::new(c, c)])
            }
        } else {
            let hole = self.push_hole(InstHole::Char { c: c });
            Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_class & mut self , ranges : & [ hir :: ClassUnicodeRange ]","    fn c_class(&mut self, ranges: &[hir::ClassUnicodeRange]) -> ResultOrEmpty {
        use std::mem::size_of;

        assert!(!ranges.is_empty());
        if self.compiled.uses_bytes() {
            Ok(Some(CompileClass { c: self, ranges: ranges }.compile()?))
        } else {
            let ranges: Vec<(char, char)> =
                ranges.iter().map(|r| (r.start(), r.end())).collect();
            let hole = if ranges.len() == 1 && ranges[0].0 == ranges[0].1 {
                self.push_hole(InstHole::Char { c: ranges[0].0 })
            } else {
                self.extra_inst_bytes +=
                    ranges.len() * (size_of::<char>() * 2);
                self.push_hole(InstHole::Ranges { ranges: ranges })
            };
            Ok(Some(Patch { hole: hole, entry: self.insts.len() - 1 }))
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_byte & mut self , b : u8","    fn c_byte(&mut self, b: u8) -> ResultOrEmpty {
        self.c_class_bytes(&[hir::ClassBytesRange::new(b, b)])
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_class_bytes & mut self , ranges : & [ hir :: ClassBytesRange ] ,","    fn c_class_bytes(
        &mut self,
        ranges: &[hir::ClassBytesRange],
    ) -> ResultOrEmpty {
        debug_assert!(!ranges.is_empty());

        let first_split_entry = self.insts.len();
        let mut holes = vec![];
        let mut prev_hole = Hole::None;
        for r in &ranges[0..ranges.len() - 1] {
            self.fill_to_next(prev_hole);
            let split = self.push_split_hole();
            let next = self.insts.len();
            self.byte_classes.set_range(r.start(), r.end());
            holes.push(self.push_hole(InstHole::Bytes {
                start: r.start(),
                end: r.end(),
            }));
            prev_hole = self.fill_split(split, Some(next), None);
        }
        let next = self.insts.len();
        let r = &ranges[ranges.len() - 1];
        self.byte_classes.set_range(r.start(), r.end());
        holes.push(
            self.push_hole(InstHole::Bytes { start: r.start(), end: r.end() }),
        );
        self.fill(prev_hole, next);
        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_empty_look & mut self , look : EmptyLook","    fn c_empty_look(&mut self, look: EmptyLook) -> ResultOrEmpty {
        let hole = self.push_hole(InstHole::EmptyLook { look: look });
        Ok(Some(Patch { hole: hole, entry: self.insts.len() - 1 }))
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_alternate & mut self , exprs : & [ Hir ]","    fn c_alternate(&mut self, exprs: &[Hir]) -> ResultOrEmpty {
        debug_assert!(
            exprs.len() >= 2,
            ""alternates must have at least 2 exprs""
        );

        // Initial entry point is always the first split.
        let first_split_entry = self.insts.len();

        // Save up all of the holes from each alternate. They will all get
        // patched to point to the same location.
        let mut holes = vec![];

        // true indicates that the hole is a split where we want to fill
        // the second branch.
        let mut prev_hole = (Hole::None, false);
        for e in &exprs[0..exprs.len() - 1] {
            if prev_hole.1 {
                let next = self.insts.len();
                self.fill_split(prev_hole.0, None, Some(next));
            } else {
                self.fill_to_next(prev_hole.0);
            }
            let split = self.push_split_hole();
            if let Some(Patch { hole, entry }) = self.c(e)? {
                holes.push(hole);
                prev_hole = (self.fill_split(split, Some(entry), None), false);
            } else {
                let (split1, split2) = split.dup_one();
                holes.push(split1);
                prev_hole = (split2, true);
            }
        }
        if let Some(Patch { hole, entry }) = self.c(&exprs[exprs.len() - 1])? {
            holes.push(hole);
            if prev_hole.1 {
                self.fill_split(prev_hole.0, None, Some(entry));
            } else {
                self.fill(prev_hole.0, entry);
            }
        } else {
            // We ignore prev_hole.1. When it's true, it means we have two
            // empty branches both pushing prev_hole.0 into holes, so both
            // branches will go to the same place anyway.
            holes.push(prev_hole.0);
        }
        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_repeat & mut self , rep : & hir :: Repetition","    fn c_repeat(&mut self, rep: &hir::Repetition) -> ResultOrEmpty {
        use regex_syntax::hir::RepetitionKind::*;
        match rep.kind {
            ZeroOrOne => self.c_repeat_zero_or_one(&rep.hir, rep.greedy),
            ZeroOrMore => self.c_repeat_zero_or_more(&rep.hir, rep.greedy),
            OneOrMore => self.c_repeat_one_or_more(&rep.hir, rep.greedy),
            Range(hir::RepetitionRange::Exactly(min_max)) => {
                self.c_repeat_range(&rep.hir, rep.greedy, min_max, min_max)
            }
            Range(hir::RepetitionRange::AtLeast(min)) => {
                self.c_repeat_range_min_or_more(&rep.hir, rep.greedy, min)
            }
            Range(hir::RepetitionRange::Bounded(min, max)) => {
                self.c_repeat_range(&rep.hir, rep.greedy, min, max)
            }
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_repeat_zero_or_one & mut self , expr : & Hir , greedy : bool ,","    fn c_repeat_zero_or_one(
        &mut self,
        expr: &Hir,
        greedy: bool,
    ) -> ResultOrEmpty {
        let split_entry = self.insts.len();
        let split = self.push_split_hole();
        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {
            Some(p) => p,
            None => return self.pop_split_hole(),
        };
        let split_hole = if greedy {
            self.fill_split(split, Some(entry_rep), None)
        } else {
            self.fill_split(split, None, Some(entry_rep))
        };
        let holes = vec![hole_rep, split_hole];
        Ok(Some(Patch { hole: Hole::Many(holes), entry: split_entry }))
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_repeat_zero_or_more & mut self , expr : & Hir , greedy : bool ,","    fn c_repeat_zero_or_more(
        &mut self,
        expr: &Hir,
        greedy: bool,
    ) -> ResultOrEmpty {
        let split_entry = self.insts.len();
        let split = self.push_split_hole();
        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {
            Some(p) => p,
            None => return self.pop_split_hole(),
        };

        self.fill(hole_rep, split_entry);
        let split_hole = if greedy {
            self.fill_split(split, Some(entry_rep), None)
        } else {
            self.fill_split(split, None, Some(entry_rep))
        };
        Ok(Some(Patch { hole: split_hole, entry: split_entry }))
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_repeat_one_or_more & mut self , expr : & Hir , greedy : bool ,","    fn c_repeat_one_or_more(
        &mut self,
        expr: &Hir,
        greedy: bool,
    ) -> ResultOrEmpty {
        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {
            Some(p) => p,
            None => return Ok(None),
        };
        self.fill_to_next(hole_rep);
        let split = self.push_split_hole();

        let split_hole = if greedy {
            self.fill_split(split, Some(entry_rep), None)
        } else {
            self.fill_split(split, None, Some(entry_rep))
        };
        Ok(Some(Patch { hole: split_hole, entry: entry_rep }))
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_repeat_range_min_or_more & mut self , expr : & Hir , greedy : bool , min : u32 ,","    fn c_repeat_range_min_or_more(
        &mut self,
        expr: &Hir,
        greedy: bool,
        min: u32,
    ) -> ResultOrEmpty {
        let min = u32_to_usize(min);
        // Using next_inst() is ok, because we can't return it (concat would
        // have to return Some(_) while c_repeat_range_min_or_more returns
        // None).
        let patch_concat = self
            .c_concat(iter::repeat(expr).take(min))?
            .unwrap_or(self.next_inst());
        if let Some(patch_rep) = self.c_repeat_zero_or_more(expr, greedy)? {
            self.fill(patch_concat.hole, patch_rep.entry);
            Ok(Some(Patch { hole: patch_rep.hole, entry: patch_concat.entry }))
        } else {
            Ok(None)
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_repeat_range & mut self , expr : & Hir , greedy : bool , min : u32 , max : u32 ,","    fn c_repeat_range(
        &mut self,
        expr: &Hir,
        greedy: bool,
        min: u32,
        max: u32,
    ) -> ResultOrEmpty {
        let (min, max) = (u32_to_usize(min), u32_to_usize(max));
        debug_assert!(min <= max);
        let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;
        if min == max {
            return Ok(patch_concat);
        }
        // Same reasoning as in c_repeat_range_min_or_more (we know that min <
        // max at this point).
        let patch_concat = patch_concat.unwrap_or(self.next_inst());
        let initial_entry = patch_concat.entry;
        // It is much simpler to compile, e.g., `a{2,5}` as:
        //
        //     aaa?a?a?
        //
        // But you end up with a sequence of instructions like this:
        //
        //     0: 'a'
        //     1: 'a',
        //     2: split(3, 4)
        //     3: 'a'
        //     4: split(5, 6)
        //     5: 'a'
        //     6: split(7, 8)
        //     7: 'a'
        //     8: MATCH
        //
        // This is *incredibly* inefficient because the splits end
        // up forming a chain, which has to be resolved everything a
        // transition is followed.
        let mut holes = vec![];
        let mut prev_hole = patch_concat.hole;
        for _ in min..max {
            self.fill_to_next(prev_hole);
            let split = self.push_split_hole();
            let Patch { hole, entry } = match self.c(expr)? {
                Some(p) => p,
                None => return self.pop_split_hole(),
            };
            prev_hole = hole;
            if greedy {
                holes.push(self.fill_split(split, Some(entry), None));
            } else {
                holes.push(self.fill_split(split, None, Some(entry)));
            }
        }
        holes.push(prev_hole);
        Ok(Some(Patch { hole: Hole::Many(holes), entry: initial_entry }))
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,next_inst & self,"    fn next_inst(&self) -> Patch {
        Patch { hole: Hole::None, entry: self.insts.len() }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"fill & mut self , hole : Hole , goto : InstPtr","    fn fill(&mut self, hole: Hole, goto: InstPtr) {
        match hole {
            Hole::None => {}
            Hole::One(pc) => {
                self.insts[pc].fill(goto);
            }
            Hole::Many(holes) => {
                for hole in holes {
                    self.fill(hole, goto);
                }
            }
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"fill_to_next & mut self , hole : Hole","    fn fill_to_next(&mut self, hole: Hole) {
        let next = self.insts.len();
        self.fill(hole, next);
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"fill_split & mut self , hole : Hole , goto1 : Option < InstPtr > , goto2 : Option < InstPtr > ,","    fn fill_split(
        &mut self,
        hole: Hole,
        goto1: Option<InstPtr>,
        goto2: Option<InstPtr>,
    ) -> Hole {
        match hole {
            Hole::None => Hole::None,
            Hole::One(pc) => match (goto1, goto2) {
                (Some(goto1), Some(goto2)) => {
                    self.insts[pc].fill_split(goto1, goto2);
                    Hole::None
                }
                (Some(goto1), None) => {
                    self.insts[pc].half_fill_split_goto1(goto1);
                    Hole::One(pc)
                }
                (None, Some(goto2)) => {
                    self.insts[pc].half_fill_split_goto2(goto2);
                    Hole::One(pc)
                }
                (None, None) => unreachable!(
                    ""at least one of the split \
                     holes must be filled""
                ),
            },
            Hole::Many(holes) => {
                let mut new_holes = vec![];
                for hole in holes {
                    new_holes.push(self.fill_split(hole, goto1, goto2));
                }
                if new_holes.is_empty() {
                    Hole::None
                } else if new_holes.len() == 1 {
                    new_holes.pop().unwrap()
                } else {
                    Hole::Many(new_holes)
                }
            }
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"push_compiled & mut self , inst : Inst","    fn push_compiled(&mut self, inst: Inst) {
        self.insts.push(MaybeInst::Compiled(inst));
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"push_hole & mut self , inst : InstHole","    fn push_hole(&mut self, inst: InstHole) -> Hole {
        let hole = self.insts.len();
        self.insts.push(MaybeInst::Uncompiled(inst));
        Hole::One(hole)
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,push_split_hole & mut self,"    fn push_split_hole(&mut self) -> Hole {
        let hole = self.insts.len();
        self.insts.push(MaybeInst::Split);
        Hole::One(hole)
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,pop_split_hole & mut self,"    fn pop_split_hole(&mut self) -> ResultOrEmpty {
        self.insts.pop();
        Ok(None)
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,check_size & self,"    fn check_size(&self) -> result::Result<(), Error> {
        use std::mem::size_of;

        let size =
            self.extra_inst_bytes + (self.insts.len() * size_of::<Inst>());
        if size > self.size_limit {
            Err(Error::CompiledTooBig(self.size_limit))
        } else {
            Ok(())
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,dup_one self,"    fn dup_one(self) -> (Self, Self) {
        match self {
            Hole::One(pc) => (Hole::One(pc), Hole::One(pc)),
            Hole::None | Hole::Many(_) => {
                unreachable!(""must be called on single hole"")
            }
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"fill & mut self , goto : InstPtr","    fn fill(&mut self, goto: InstPtr) {
        let maybeinst = match *self {
            MaybeInst::Split => MaybeInst::Split1(goto),
            MaybeInst::Uncompiled(ref inst) => {
                MaybeInst::Compiled(inst.fill(goto))
            }
            MaybeInst::Split1(goto1) => {
                MaybeInst::Compiled(Inst::Split(InstSplit {
                    goto1: goto1,
                    goto2: goto,
                }))
            }
            MaybeInst::Split2(goto2) => {
                MaybeInst::Compiled(Inst::Split(InstSplit {
                    goto1: goto,
                    goto2: goto2,
                }))
            }
            _ => unreachable!(
                ""not all instructions were compiled! \
                 found uncompiled instruction: {:?}"",
                self
            ),
        };
        *self = maybeinst;
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"fill_split & mut self , goto1 : InstPtr , goto2 : InstPtr","    fn fill_split(&mut self, goto1: InstPtr, goto2: InstPtr) {
        let filled = match *self {
            MaybeInst::Split => {
                Inst::Split(InstSplit { goto1: goto1, goto2: goto2 })
            }
            _ => unreachable!(
                ""must be called on Split instruction, \
                 instead it was called on: {:?}"",
                self
            ),
        };
        *self = MaybeInst::Compiled(filled);
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"half_fill_split_goto1 & mut self , goto1 : InstPtr","    fn half_fill_split_goto1(&mut self, goto1: InstPtr) {
        let half_filled = match *self {
            MaybeInst::Split => goto1,
            _ => unreachable!(
                ""must be called on Split instruction, \
                 instead it was called on: {:?}"",
                self
            ),
        };
        *self = MaybeInst::Split1(half_filled);
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"half_fill_split_goto2 & mut self , goto2 : InstPtr","    fn half_fill_split_goto2(&mut self, goto2: InstPtr) {
        let half_filled = match *self {
            MaybeInst::Split => goto2,
            _ => unreachable!(
                ""must be called on Split instruction, \
                 instead it was called on: {:?}"",
                self
            ),
        };
        *self = MaybeInst::Split2(half_filled);
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,unwrap self,"    fn unwrap(self) -> Inst {
        match self {
            MaybeInst::Compiled(inst) => inst,
            _ => unreachable!(
                ""must be called on a compiled instruction, \
                 instead it was called on: {:?}"",
                self
            ),
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"fill & self , goto : InstPtr","    fn fill(&self, goto: InstPtr) -> Inst {
        match *self {
            InstHole::Save { slot } => {
                Inst::Save(InstSave { goto: goto, slot: slot })
            }
            InstHole::EmptyLook { look } => {
                Inst::EmptyLook(InstEmptyLook { goto: goto, look: look })
            }
            InstHole::Char { c } => Inst::Char(InstChar { goto: goto, c: c }),
            InstHole::Ranges { ref ranges } => Inst::Ranges(InstRanges {
                goto: goto,
                ranges: ranges.clone().into_boxed_slice(),
            }),
            InstHole::Bytes { start, end } => {
                Inst::Bytes(InstBytes { goto: goto, start: start, end: end })
            }
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,compile mut self,"    fn compile(mut self) -> Result {
        let mut holes = vec![];
        let mut initial_entry = None;
        let mut last_split = Hole::None;
        let mut utf8_seqs = self.c.utf8_seqs.take().unwrap();
        self.c.suffix_cache.clear();

        for (i, range) in self.ranges.iter().enumerate() {
            let is_last_range = i + 1 == self.ranges.len();
            utf8_seqs.reset(range.start(), range.end());
            let mut it = (&mut utf8_seqs).peekable();
            loop {
                let utf8_seq = match it.next() {
                    None => break,
                    Some(utf8_seq) => utf8_seq,
                };
                if is_last_range && it.peek().is_none() {
                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;
                    holes.push(hole);
                    self.c.fill(last_split, entry);
                    last_split = Hole::None;
                    if initial_entry.is_none() {
                        initial_entry = Some(entry);
                    }
                } else {
                    if initial_entry.is_none() {
                        initial_entry = Some(self.c.insts.len());
                    }
                    self.c.fill_to_next(last_split);
                    last_split = self.c.push_split_hole();
                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;
                    holes.push(hole);
                    last_split =
                        self.c.fill_split(last_split, Some(entry), None);
                }
            }
        }
        self.c.utf8_seqs = Some(utf8_seqs);
        Ok(Patch { hole: Hole::Many(holes), entry: initial_entry.unwrap() })
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"c_utf8_seq & mut self , seq : & Utf8Sequence","    fn c_utf8_seq(&mut self, seq: &Utf8Sequence) -> Result {
        if self.c.compiled.is_reverse {
            self.c_utf8_seq_(seq)
        } else {
            self.c_utf8_seq_(seq.into_iter().rev())
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,new size : usize,"    fn new(size: usize) -> Self {
        SuffixCache {
            sparse: vec![0usize; size].into(),
            dense: Vec::with_capacity(size),
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"get & mut self , key : SuffixCacheKey , pc : InstPtr","    fn get(&mut self, key: SuffixCacheKey, pc: InstPtr) -> Option<InstPtr> {
        let hash = self.hash(&key);
        let pos = &mut self.sparse[hash];
        if let Some(entry) = self.dense.get(*pos) {
            if entry.key == key {
                return Some(entry.pc);
            }
        }
        *pos = self.dense.len();
        self.dense.push(SuffixCacheEntry { key: key, pc: pc });
        None
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,clear & mut self,"    fn clear(&mut self) {
        self.dense.clear();
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"hash & self , suffix : & SuffixCacheKey","    fn hash(&self, suffix: &SuffixCacheKey) -> usize {
        // Basic FNV-1a hash as described:
        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
        const FNV_PRIME: u64 = 1099511628211;
        let mut h = 14695981039346656037;
        h = (h ^ (suffix.from_inst as u64)).wrapping_mul(FNV_PRIME);
        h = (h ^ (suffix.start as u64)).wrapping_mul(FNV_PRIME);
        h = (h ^ (suffix.end as u64)).wrapping_mul(FNV_PRIME);
        (h as usize) % self.sparse.len()
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,new,"    fn new() -> Self {
        ByteClassSet([false; 256])
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,"set_range & mut self , start : u8 , end : u8","    fn set_range(&mut self, start: u8, end: u8) {
        debug_assert!(start <= end);
        if start > 0 {
            self.0[start as usize - 1] = true;
        }
        self.0[end as usize] = true;
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,set_word_boundary & mut self,"    fn set_word_boundary(&mut self) {
        // We need to mark all ranges of bytes whose pairs result in
        // evaluating \b differently.
        let iswb = is_word_byte;
        let mut b1: u16 = 0;
        let mut b2: u16;
        while b1 <= 255 {
            b2 = b1 + 1;
            while b2 <= 255 && iswb(b1 as u8) == iswb(b2 as u8) {
                b2 += 1;
            }
            self.set_range(b1 as u8, (b2 - 1) as u8);
            b1 = b2;
        }
    }",0,True,False,
https://github.com/rust-lang/regex.git,ae70b41d4f46641dbc45c7a4f87954aea356283e,Andrew Gallant,2022-03-03 10:05:00-05:00,False,compile.rs,Rust,byte_classes & self,"    fn byte_classes(&self) -> Vec<u8> {
        // N.B. If you're debugging the DFA, it's useful to simply return
        // `(0..256).collect()`, which effectively removes the byte classes
        // and makes the transitions easier to read.
        // (0usize..256).map(|x| x as u8).collect()
        let mut byte_classes = vec![0; 256];
        let mut class = 0u8;
        let mut i = 0;
        loop {
            byte_classes[i] = class as u8;
            if i >= 255 {
                break;
            }
            if self.0[i] {
                class = class.checked_add(1).unwrap();
            }
            i += 1;
        }
        byte_classes
    }",0,True,False,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,"set & mut self , offset : usize , value : & [ u8 ] , target_size : Option < usize >","	pub fn set(
		&mut self,
		offset: usize,
		value: &[u8],
		target_size: Option<usize>
	) -> Result<(), ExitFatal> {
		let target_size = target_size.unwrap_or(value.len());

		if offset.checked_add(target_size)
			.map(|pos| pos > self.limit).unwrap_or(true)
		{
			return Err(ExitFatal::NotSupported)
		}

		if self.data.len() < offset + target_size {
			self.data.resize(offset + target_size, 0);
		}

		for index in 0..target_size {
			if self.data.len() > offset + index && value.len() > index {
				self.data[offset + index] = value[index];
			} else {
				self.data[offset + index] = 0;
			}
		}

		Ok(())
	}",1,True,True,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,"set & mut self , offset : usize , value : & [ u8 ] , target_size : Option < usize >","	pub fn set(
		&mut self,
		offset: usize,
		value: &[u8],
		target_size: Option<usize>
	) -> Result<(), ExitFatal> {
		if value.is_empty() {
			return Ok(())
		}
		
		let target_size = target_size.unwrap_or(value.len());

		if offset.checked_add(target_size)
			.map(|pos| pos > self.limit).unwrap_or(true)
		{
			return Err(ExitFatal::NotSupported)
		}

		if self.data.len() < offset + target_size {
			self.data.resize(offset + target_size, 0);
		}

		for index in 0..target_size {
			if self.data.len() > offset + index && value.len() > index {
				self.data[offset + index] = value[index];
			} else {
				self.data[offset + index] = 0;
			}
		}

		Ok(())
	}",0,False,True,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,new limit : usize,"	pub fn new(limit: usize) -> Self {
		Self {
			data: Vec::new(),
			effective_len: U256::zero(),
			limit,
		}
	}",0,True,False,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,limit & self,"	pub fn limit(&self) -> usize {
		self.limit
	}",0,True,False,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,len & self,"	pub fn len(&self) -> usize {
		self.data.len()
	}",0,True,False,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,effective_len & self,"	pub fn effective_len(&self) -> U256 {
		self.effective_len
	}",0,True,False,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,is_empty & self,"	pub fn is_empty(&self) -> bool {
		self.len() == 0
	}",0,True,False,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,data & self,"	pub fn data(&self) -> &Vec<u8> {
		&self.data
	}",0,True,False,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,"resize_offset & mut self , offset : U256 , len : U256","	pub fn resize_offset(&mut self, offset: U256, len: U256) -> Result<(), ExitError> {
		if len == U256::zero() {
			return Ok(())
		}

		if let Some(end) = offset.checked_add(len) {
			self.resize_end(end)
		} else {
			Err(ExitError::InvalidRange)
		}
	}",0,True,False,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,"resize_end & mut self , mut end : U256","	pub fn resize_end(&mut self, mut end: U256) -> Result<(), ExitError> {
		while end % U256::from(32) != U256::zero() {
			end = match end.checked_add(U256::one()) {
				Some(end) => end,
				None => return Err(ExitError::InvalidRange)
			};
		}

		self.effective_len = max(self.effective_len, end);
		Ok(())
	}",0,True,False,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,"get & self , offset : usize , size : usize","	pub fn get(&self, offset: usize, size: usize) -> Vec<u8> {
		let mut ret = Vec::new();
		ret.resize(size, 0);

		for index in 0..size {
			let position = offset + index;
			if position >= self.data.len() {
				break
			}

			ret[index] = self.data[position];
		}

		ret
	}",0,True,False,
https://github.com/rust-blockchain/evm.git,19ade858c430ab13eb562764a870ac9f8506f8dd,GitHub,2021-05-11 17:33:30+02:00,False,memory.rs,Rust,"copy_large & mut self , memory_offset : U256 , data_offset : U256 , len : U256 , data : & [ u8 ]","	pub fn copy_large(
		&mut self,
		memory_offset: U256,
		data_offset: U256,
		len: U256,
		data: &[u8]
	) -> Result<(), ExitFatal> {
		let memory_offset = if memory_offset > U256::from(usize::max_value()) {
			return Err(ExitFatal::NotSupported)
		} else {
			memory_offset.as_usize()
		};

		let ulen = if len > U256::from(usize::max_value()) {
			return Err(ExitFatal::NotSupported)
		} else {
			len.as_usize()
		};

		let data = if let Some(end) = data_offset.checked_add(len) {
			if end > U256::from(usize::max_value()) {
				&[]
			} else {
				let data_offset = data_offset.as_usize();
				let end = end.as_usize();

				if data_offset > data.len() {
					&[]
				} else {
					&data[data_offset..min(end, data.len())]
				}
			}
		} else {
			&[]
		};

		self.set(memory_offset, data, Some(ulen))
	}",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        if self.needs_inst_drop {
            unsafe {
                let inst = self.inst.as_mut();

                // Grab a handle to the region to ensure it outlives `inst`.
                //
                // This ensures that the region won't be dropped by `inst` being
                // dropped, which could result in `inst` being unmapped by the
                // Region *during* drop of the Instance's fields.
                let region: Arc<dyn RegionInternal> = inst.alloc().region.clone();

                // drop the actual instance
                std::ptr::drop_in_place(inst);

                // and now we can drop what may be the last Arc<Region>. If it is
                // it can safely do what it needs with memory; we're not running
                // destructors on it anymore.
                mem::drop(region);
            }
        }
    }",1,True,False,"5,7,8,9,10,15,16,17,18"
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        if self.needs_inst_drop {
            unsafe {
                let inst = self.inst.as_mut();

                // The `inst.alloc` field manages the memory of the instance
                // itself. Note, though, that this field is in a `ManuallyDrop`
                // so it won't get dropped automatically in `drop_in_place`.
                // This is the point where we take over that precise drop.
                //
                // By using `take` here we're basically calling `ptr::read`
                // which ""duplicates"" the `alloc` since the `alloc` local
                // variable here is the exact same as `inst.alloc`. All we do
                // with `inst`, though, is call `drop_in_place`, which
                // invalidates every other field in `inst`.
                let alloc: Alloc = ManuallyDrop::take(&mut inst.alloc);

                // drop the actual instance
                std::ptr::drop_in_place(inst);

                // Now that we're 100% done with the instance, destructors and
                // all, we can release the memory of the instance back to the
                // original allocator from whence it came (be it mmap or uffd
                // based). This will run the ""official"" destructor for `Alloc`
                // which internally does the release. Note that after this
                // operation the `inst` pointer is invalid and can no longer be
                // used.
                drop(alloc);
            }
        }
    }",0,False,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"new_instance_handle instance : * mut Instance , module : Arc < dyn Module > , alloc : Alloc , embed_ctx : CtxMap ,","pub fn new_instance_handle(
    instance: *mut Instance,
    module: Arc<dyn Module>,
    alloc: Alloc,
    embed_ctx: CtxMap,
) -> Result<InstanceHandle, Error> {
    let inst = NonNull::new(instance)
        .ok_or_else(|| lucet_format_err!(""instance pointer is null; this is a bug""))?;

    lucet_ensure!(
        unsafe { inst.as_ref().magic } != LUCET_INSTANCE_MAGIC,
        ""created a new instance handle in memory with existing instance magic; this is a bug""
    );

    let mut handle = InstanceHandle {
        inst,
        needs_inst_drop: false,
    };

    let inst = Instance::new(alloc, module, embed_ctx);

    unsafe {
        // this is wildly unsafe! you must be very careful to not let the drop impls run on the
        // uninitialized fields; see
        // <https://doc.rust-lang.org/std/mem/fn.forget.html#use-case-1>

        // write the whole struct into place over the uninitialized page
        ptr::write(&mut *handle, inst);
    };

    handle.needs_inst_drop = true;

    handle.reset()?;

    Ok(handle)
}",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,instance_handle_to_raw mut inst : InstanceHandle,"pub fn instance_handle_to_raw(mut inst: InstanceHandle) -> *mut Instance {
    inst.needs_inst_drop = false;
    inst.inst.as_ptr()
}",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"instance_handle_from_raw ptr : * mut Instance , needs_inst_drop : bool ,","pub unsafe fn instance_handle_from_raw(
    ptr: *mut Instance,
    needs_inst_drop: bool,
) -> InstanceHandle {
    InstanceHandle {
        inst: NonNull::new_unchecked(ptr),
        needs_inst_drop,
    }
}",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,deref & self,"    fn deref(&self) -> &Self::Target {
        unsafe { self.inst.as_ref() }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,deref_mut & mut self,"    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { self.inst.as_mut() }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"memory_growing & mut self , current : usize , desired : usize","    async fn memory_growing(&mut self, current: usize, desired: usize) -> bool;
    fn memory_grow_failed(&mut self, _error: &Error) {}",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,returned self,"    pub fn returned(self) -> Result<UntypedRetVal, Error> {
        match self {
            RunResult::Returned(rv) => Ok(rv),
            RunResult::Yielded(_) => Err(Error::InstanceNotReturned),
        }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,returned_ref & self,"    pub fn returned_ref(&self) -> Result<&UntypedRetVal, Error> {
        match self {
            RunResult::Returned(rv) => Ok(rv),
            RunResult::Yielded(_) => Err(Error::InstanceNotReturned),
        }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,is_returned & self,"    pub fn is_returned(&self) -> bool {
        self.returned_ref().is_ok()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"expect_returned self , msg : & str","    pub fn expect_returned(self, msg: &str) -> UntypedRetVal {
        self.returned().expect(msg)
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,unwrap_returned self,"    pub fn unwrap_returned(self) -> UntypedRetVal {
        self.returned().unwrap()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,yielded self,"    pub fn yielded(self) -> Result<YieldedVal, Error> {
        match self {
            RunResult::Returned(_) => Err(Error::InstanceNotYielded),
            RunResult::Yielded(yv) => Ok(yv),
        }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,yielded_ref & self,"    pub fn yielded_ref(&self) -> Result<&YieldedVal, Error> {
        match self {
            RunResult::Returned(_) => Err(Error::InstanceNotYielded),
            RunResult::Yielded(yv) => Ok(yv),
        }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,is_yielded & self,"    pub fn is_yielded(&self) -> bool {
        self.yielded_ref().is_ok()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,can_resume & self,"    pub fn can_resume(&self) -> bool {
        self.is_yielded()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,has_yielded & self,"    pub fn has_yielded<A: Any>(&self) -> bool {
        match self {
            RunResult::Yielded(yv) => yv.is::<A>(),
            _ => false,
        }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"expect_yielded self , msg : & str","    pub fn expect_yielded(self, msg: &str) -> YieldedVal {
        self.yielded().expect(msg)
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,unwrap_yielded self,"    pub fn unwrap_yielded(self) -> YieldedVal {
        self.yielded().unwrap()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,unwrap self,"    pub(crate) fn unwrap(self) -> RunResult {
        match self {
            InternalRunResult::Normal(result) => result,
            InternalRunResult::BoundExpired => panic!(""should not have had a runtime bound""),
        }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,into self,"    fn into(self) -> InternalRunResult {
        InternalRunResult::Normal(self)
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,alloc & self,"    fn alloc(&self) -> &Alloc {
        &self.alloc
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,alloc_mut & mut self,"    fn alloc_mut(&mut self) -> &mut Alloc {
        &mut self.alloc
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,module & self,"    fn module(&self) -> &dyn Module {
        self.module.deref()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,state & self,"    fn state(&self) -> &State {
        &self.state
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,valid_magic & self,"    fn valid_magic(&self) -> bool {
        self.magic == LUCET_INSTANCE_MAGIC
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,alloc & self,"    fn alloc(&self) -> &Alloc;
    fn alloc_mut(&mut self) -> &mut Alloc;
    fn module(&self) -> &dyn Module;
    fn state(&self) -> &State;
    fn valid_magic(&self) -> bool;
}

impl InstanceInternal for Instance {
    /// Get a reference to the instance's `Alloc`.
    fn alloc(&self) -> &Alloc {
        &self.alloc
    }

    /// Get a mutable reference to the instance's `Alloc`.
    fn alloc_mut(&mut self) -> &mut Alloc {
        &mut self.alloc
    }

    /// Get a reference to the instance's `Module`.
    fn module(&self) -> &dyn Module {
        self.module.deref()
    }

    /// Get a reference to the instance's `State`.
    fn state(&self) -> &State {
        &self.state
    }

    /// Check whether the instance magic is valid.
    fn valid_magic(&self) -> bool {
        self.magic == LUCET_INSTANCE_MAGIC
    }
}",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"run & mut self , entrypoint : & str , args : & [ Val ]","    pub fn run(&mut self, entrypoint: &str, args: &[Val]) -> Result<RunResult, Error> {
        let func = self.module.get_export_func(entrypoint)?;
        Ok(self.run_func(func, &args, false, None)?.unwrap())
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"run_func_idx & mut self , table_idx : u32 , func_idx : u32 , args : & [ Val ] ,","    pub fn run_func_idx(
        &mut self,
        table_idx: u32,
        func_idx: u32,
        args: &[Val],
    ) -> Result<RunResult, Error> {
        let func = self.module.get_func_from_idx(table_idx, func_idx)?;
        Ok(self.run_func(func, &args, false, None)?.unwrap())
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,resume & mut self,"    pub fn resume(&mut self) -> Result<RunResult, Error> {
        self.resume_with_val(EmptyYieldVal)
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,run_start & mut self,"    pub fn run_start(&mut self) -> Result<(), Error> {
        if let Some(start) = self.module.get_start_func()? {
            if !self.is_not_started() {
                return Err(Error::StartAlreadyRun);
            }
            self.run_func(start, &[], false, None)?;
        }
        Ok(())
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,reset & mut self,"    pub fn reset(&mut self) -> Result<(), Error> {
        self.alloc.reset_heap(self.module.as_ref())?;
        let globals = unsafe { self.alloc.globals_mut() };
        let mod_globals = self.module.globals();
        for (i, v) in mod_globals.iter().enumerate() {
            globals[i] = match v.global() {
                Global::Import { .. } => {
                    return Err(Error::Unsupported(format!(
                        ""global imports are unsupported; found: {:?}"",
                        v
                    )));
                }
                Global::Def(def) => def.init_val(),
            };
        }

        if self.module.get_start_func()?.is_some() {
            self.state = State::NotStarted;
        } else {
            self.state = State::Ready;
        }

        #[cfg(feature = ""concurrent_testpoints"")]
        {
            self.kill_state = Arc::new(KillState::new(Arc::clone(&self.lock_testpoints)));
        }
        #[cfg(not(feature = ""concurrent_testpoints""))]
        {
            self.kill_state = Arc::new(KillState::new());
        }

        Ok(())
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"grow_memory & mut self , additional_pages : u32","    pub fn grow_memory(&mut self, additional_pages: u32) -> Result<u32, Error> {
        let additional_bytes = additional_pages
            .checked_mul(WASM_PAGE_SIZE)
            .ok_or_else(|| lucet_format_err!(""additional pages larger than wasm address space"",))?;
        let orig_len = self
            .alloc
            .expand_heap(additional_bytes, self.module.as_ref())?;
        Ok(orig_len / WASM_PAGE_SIZE)
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"aux instance : & mut Instance , vmctx : & Vmctx , additional_pages : u32 ,","        fn aux(
            instance: &mut Instance,
            vmctx: &Vmctx,
            additional_pages: u32,
        ) -> Result<u32, Error> {
            // Calculate current and desired bytes
            let current_bytes = instance.alloc.heap_len();
            let additional_bytes =
                additional_pages
                    .checked_mul(WASM_PAGE_SIZE)
                    .ok_or_else(|| {
                        lucet_format_err!(""additional pages larger than wasm address space"",)
                    })? as usize;
            let desired_bytes = additional_bytes
                .checked_add(current_bytes)
                .ok_or_else(|| lucet_format_err!(""desired bytes overflow"",))?;
            // Let the limiter reject the grow
            if let Some(ref mut limiter) = instance.memory_limiter {
                if !vmctx.block_on(async move {
                    limiter.memory_growing(current_bytes, desired_bytes).await
                }) {
                    lucet_bail!(""memory limiter denied growth"");
                }
            }
            // Try the grow itself
            instance.grow_memory(additional_pages)
        }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"grow_memory_from_hostcall & mut self , vmctx : & Vmctx , additional_pages : u32 ,","    pub fn grow_memory_from_hostcall(
        &mut self,
        vmctx: &Vmctx,
        additional_pages: u32,
    ) -> Result<u32, Error> {
        // Use a function so that we can report all Errs via memory_grow_failed.
        fn aux(
            instance: &mut Instance,
            vmctx: &Vmctx,
            additional_pages: u32,
        ) -> Result<u32, Error> {
            // Calculate current and desired bytes
            let current_bytes = instance.alloc.heap_len();
            let additional_bytes =
                additional_pages
                    .checked_mul(WASM_PAGE_SIZE)
                    .ok_or_else(|| {
                        lucet_format_err!(""additional pages larger than wasm address space"",)
                    })? as usize;
            let desired_bytes = additional_bytes
                .checked_add(current_bytes)
                .ok_or_else(|| lucet_format_err!(""desired bytes overflow"",))?;
            // Let the limiter reject the grow
            if let Some(ref mut limiter) = instance.memory_limiter {
                if !vmctx.block_on(async move {
                    limiter.memory_growing(current_bytes, desired_bytes).await
                }) {
                    lucet_bail!(""memory limiter denied growth"");
                }
            }
            // Try the grow itself
            instance.grow_memory(additional_pages)
        }

        match aux(self, vmctx, additional_pages) {
            Ok(n) => Ok(n),
            Err(e) => {
                if let Some(ref mut limiter) = self.memory_limiter {
                    limiter.memory_grow_failed(&e);
                    Err(e)
                } else {
                    Err(e)
                }
            }
        }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,heap & self,"    pub fn heap(&self) -> &[u8] {
        unsafe { self.alloc.heap() }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,heap_mut & mut self,"    pub fn heap_mut(&mut self) -> &mut [u8] {
        unsafe { self.alloc.heap_mut() }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,heap_u32 & self,"    pub fn heap_u32(&self) -> &[u32] {
        unsafe { self.alloc.heap_u32() }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,heap_u32_mut & mut self,"    pub fn heap_u32_mut(&mut self) -> &mut [u32] {
        unsafe { self.alloc.heap_u32_mut() }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,globals & self,"    pub fn globals(&self) -> &[GlobalValue] {
        unsafe { self.alloc.globals() }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,globals_mut & mut self,"    pub fn globals_mut(&mut self) -> &mut [GlobalValue] {
        unsafe { self.alloc.globals_mut() }
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"check_heap & self , ptr : * const T , len : usize","    pub fn check_heap<T>(&self, ptr: *const T, len: usize) -> bool {
        self.alloc.mem_in_heap(ptr, len)
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,contains_embed_ctx & self,"    pub fn contains_embed_ctx<T: Any>(&self) -> bool {
        self.embed_ctx.contains::<T>()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,get_embed_ctx & self,"    pub fn get_embed_ctx<T: Any>(&self) -> Option<Result<Ref<'_, T>, BorrowError>> {
        self.embed_ctx.try_get::<T>()
    }

    /// Get a mutable reference to a context value of a particular type, if it exists.
    pub fn get_embed_ctx_mut<T: Any>(&self) -> Option<Result<RefMut<'_, T>, BorrowMutError>> {
        self.embed_ctx.try_get_mut::<T>()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"insert_embed_ctx & mut self , x : T","    pub fn insert_embed_ctx<T: Any>(&mut self, x: T) -> Option<T> {
        self.embed_ctx.insert(x)
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,remove_embed_ctx & mut self,"    pub fn remove_embed_ctx<T: Any>(&mut self) -> Option<T> {
        self.embed_ctx.remove::<T>()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"set_signal_handler & mut self , handler : H","    pub fn set_signal_handler<H>(&mut self, handler: H)
    where
        H: 'static
            + Fn(
                &Instance,
                &Option<TrapCode>,
                libc::c_int,
                *const siginfo_t,
                *const c_void,
            ) -> SignalBehavior,
    {
        self.signal_handler = Box::new(handler) as Box<SignalHandler>;
    }

    /// Set the handler run for signals that do not arise from a known WebAssembly trap, or that
    /// involve memory outside of the current instance.
    ///
    /// Fatal signals are not only unrecoverable for the instance that raised them, but may
    /// compromise the correctness of the rest of the process if unhandled.
    ///
    /// The default fatal handler calls `panic!()`.
    pub fn set_fatal_handler(&mut self, handler: fn(&Instance) -> !) {
        self.fatal_handler = handler;
    }

    /// Set the fatal handler to a C-compatible function.
    ///
    /// This is a separate interface, because C functions can't return the `!` type. Like the
    /// regular `fatal_handler`, it is not expected to return, but we cannot enforce that through
    /// types.
    ///
    /// When a fatal error occurs, this handler is run first, and then the regular `fatal_handler`
    /// runs in case it returns.
    pub fn set_c_fatal_handler(&mut self, handler: unsafe extern ""C"" fn(*mut Instance)) {
        self.c_fatal_handler = Some(handler);
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"ensure_signal_handler_installed & mut self , ensure : bool","    pub fn ensure_signal_handler_installed(&mut self, ensure: bool) {
        self.ensure_signal_handler_installed = ensure;
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"ensure_sigstack_installed & mut self , ensure : bool","    pub fn ensure_sigstack_installed(&mut self, ensure: bool) {
        self.ensure_sigstack_installed = ensure;
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,kill_switch & self,"    pub fn kill_switch(&self) -> KillSwitch {
        KillSwitch::new(Arc::downgrade(&self.kill_state))
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,is_not_started & self,"    pub fn is_not_started(&self) -> bool {
        self.state.is_not_started()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,is_ready & self,"    pub fn is_ready(&self) -> bool {
        self.state.is_ready()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,is_yielded & self,"    pub fn is_yielded(&self) -> bool {
        self.state.is_yielded()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,is_bound_expired & self,"    pub fn is_bound_expired(&self) -> bool {
        self.state.is_bound_expired()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,is_faulted & self,"    pub fn is_faulted(&self) -> bool {
        self.state.is_faulted()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,is_terminated & self,"    pub fn is_terminated(&self) -> bool {
        self.state.is_terminated()
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"uninterruptable & mut self , f : F","    pub fn uninterruptable<T, F: FnOnce() -> T>(&mut self, f: F) -> T {
        self.kill_state.begin_hostcall();
        let res = f();
        let stop_reason = self.kill_state.end_hostcall();

        if let Some(termination_details) = stop_reason {
            // TODO: once we have unwinding, panic here instead so we unwind host frames
            unsafe {
                self.terminate(termination_details);
            }
        }

        res
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,get_instruction_count & self,"    pub fn get_instruction_count(&self) -> Option<u64> {
        if self.module.is_instruction_count_instrumented() {
            let implicits = self.get_instance_implicits();
            let sum = implicits.instruction_count_bound + implicits.instruction_count_adj;
            // This invariant is ensured as we always set up the fields to have a positive sum, and
            // generated code only increments `adj`.
            debug_assert!(sum >= 0);
            return Some(sum as u64);
        }
        None
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"set_instruction_count_and_bound & mut self , instruction_count : u64 , bound : u64","    pub fn set_instruction_count_and_bound(&mut self, instruction_count: u64, bound: u64) {
        let implicits = self.get_instance_implicits_mut();
        let instruction_count =
            i64::try_from(instruction_count).expect(""instruction count too large"");
        let bound = i64::try_from(bound).expect(""bound too large"");
        // These two sum to `instruction_count`, which must be non-negative.
        implicits.instruction_count_bound = bound;
        implicits.instruction_count_adj = instruction_count - bound;
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,"set_instruction_bound_delta & mut self , delta : Option < u64 >","    pub fn set_instruction_bound_delta(&mut self, delta: Option<u64>) {
        let implicits = self.get_instance_implicits_mut();
        let sum = implicits.instruction_count_adj + implicits.instruction_count_bound;
        let delta = delta.unwrap_or(i64::MAX as u64);
        let delta = i64::try_from(delta).expect(""delta too large"");
        implicits.instruction_count_bound = sum.wrapping_add(delta);
        implicits.instruction_count_adj = -delta;
    }",0,True,False,
https://github.com/bytecodealliance/lucet.git,7c7757c772fb709c61b1442bcc1e1fbee97bf4a8,GitHub,2021-11-29 15:00:02-08:00,False,instance.rs,Rust,set_hostcall_stack_reservation & mut self,"    pub fn set_hostcall_stack_reservation(&mut self) {
        let slot = self
            .alloc
            .slot
            .as_ref()
            .expect(""reachable instance has a slot"");

        let reservation = slot.limits.hostcall_reservation;

        // The `.stack` field is a pointer to the lowest address of the stack - the start of its
        // allocation. Because the stack grows downward, this is the end of the stack space. So the
        // limit we'll need to check for hostcalls is some reserved space upwards from here, to
        // meet some guest stack pointer early.
        self.get_instance_implicits_mut().stack_limit = slot.stack as u64 + reservation as u64;
    }",0,True,False,
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,clone_cstring_safely out_ptr : * const c_char,"    pub fn clone_cstring_safely(out_ptr: *const c_char) -> Result<CString> {
        if out_ptr.is_null() {
            return_errno!(EINVAL, ""NULL address is invalid"");
        }

        let cstr = unsafe { CStr::from_ptr(out_ptr) };
        let cstring = CString::from(cstr);
        if !is_inside_user_space(out_ptr as *const u8, cstring.as_bytes().len()) {
            return_errno!(EFAULT, ""the whole buffer is not in the user space"");
        }
        Ok(cstring)
    }",1,True,False,7
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,clone_cstring_safely out_ptr : * const c_char,"    pub fn clone_cstring_safely(out_ptr: *const c_char) -> Result<CString> {
        if out_ptr.is_null() {
            return_errno!(EINVAL, ""NULL address is invalid"");
        }

        // confirm that at least the fisrt byte of the string is from user
        check_ptr(out_ptr)?;

        let cstr = unsafe { CStr::from_ptr(out_ptr) };
        let cstring = CString::from(cstr);
        if !is_inside_user_space(out_ptr as *const u8, cstring.as_bytes_with_nul().len()) {
            return_errno!(EFAULT, ""the whole buffer is not in the user space"");
        }
        Ok(cstring)
    }",0,False,False,
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,check_ptr user_ptr : * const T,"    pub fn check_ptr<T>(user_ptr: *const T) -> Result<()> {
        if !is_inside_user_space(user_ptr as *const u8, size_of::<T>()) {
            return_errno!(EFAULT, ""pointer is not in the user space"");
        }
        Ok(())
    }",0,True,False,
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,check_mut_ptr user_ptr : * mut T,"    pub fn check_mut_ptr<T>(user_ptr: *mut T) -> Result<()> {
        // The user space is both readable and writable on SGX1.
        // TODO: Fine-tune the checking on SGX2.
        check_ptr(user_ptr)
    }",0,True,False,
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,"check_array user_buf : * const T , count : usize","    pub fn check_array<T>(user_buf: *const T, count: usize) -> Result<()> {
        let checked_len = count
            .checked_mul(size_of::<T>())
            .ok_or_else(|| errno!(EINVAL, ""the array is too long""))?;
        if !is_inside_user_space(user_buf as *const u8, checked_len) {
            return_errno!(EFAULT, ""the whole buffer is not in the user space"");
        }
        Ok(())
    }",0,True,False,
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,"check_mut_array user_buf : * mut T , count : usize","    pub fn check_mut_array<T>(user_buf: *mut T, count: usize) -> Result<()> {
        // The user space is both readable and writable on SGX1.
        // TODO: Fine-tune the checking on SGX2.
        check_array(user_buf, count)
    }",0,True,False,
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,clone_cstrings_safely user_ptr : * const * const c_char,"    pub fn clone_cstrings_safely(user_ptr: *const *const c_char) -> Result<Vec<CString>> {
        let mut cstrings = Vec::new();
        if user_ptr == ptr::null() {
            return Ok(cstrings);
        }

        let mut user_ptr = user_ptr;
        loop {
            check_ptr(user_ptr)?;

            let cstr_ptr = {
                let cstr_ptr = unsafe { *user_ptr };
                if cstr_ptr == ptr::null() {
                    break;
                }
                cstr_ptr
            };
            let cstring = clone_cstring_safely(cstr_ptr)?;
            cstrings.push(cstring);

            user_ptr = unsafe { user_ptr.offset(1) };
        }
        Ok(cstrings)
    }",0,True,False,
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,"is_inside_user_space addr : * const u8 , len : usize","    fn is_inside_user_space(addr: *const u8, len: usize) -> bool {
        let current = current!();
        let user_range = current.vm().get_process_range();
        let ur_start = user_range.start();
        let ur_end = user_range.end();
        let addr_start = addr as usize;
        addr_start >= ur_start && addr_start < ur_end && ur_end - addr_start >= len
    }",0,True,False,
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,check_ptr out_ptr : * const T,"    pub fn check_ptr<T>(out_ptr: *const T) -> Result<()> {
        if !sgx_trts::trts::rsgx_raw_is_outside_enclave(out_ptr as *const u8, size_of::<T>()) {
            return_errno!(EFAULT, ""the pointer is not outside enclave"");
        }
        Ok(())
    }",0,True,False,
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,"check_array out_ptr : * const T , count : usize","    pub fn check_array<T>(out_ptr: *const T, count: usize) -> Result<()> {
        let checked_len = count
            .checked_mul(size_of::<T>())
            .ok_or_else(|| errno!(EINVAL, ""the array is too long""))?;
        if !sgx_trts::trts::rsgx_raw_is_outside_enclave(out_ptr as *const u8, checked_len) {
            return_errno!(EFAULT, ""the whole buffer is not outside enclave"");
        }
        Ok(())
    }",0,True,False,
https://github.com/occlum/occlum.git,36918e42bf6732c4d3996bc99eb013eb6b90b249,"Tate, Hongliang Tian",2021-11-29 14:14:54+08:00,False,mem_util.rs,Rust,clone_cstrings_safely out_ptr : * const * const c_char,"    pub fn clone_cstrings_safely(out_ptr: *const *const c_char) -> Result<Vec<CString>> {
        let mut cstrings = Vec::new();
        if out_ptr == ptr::null() {
            return Ok(cstrings);
        }

        let mut out_ptr = out_ptr;
        loop {
            check_ptr(out_ptr)?;

            let cstr_ptr = {
                let cstr_ptr = unsafe { *out_ptr };
                if cstr_ptr == ptr::null() {
                    break;
                }
                cstr_ptr
            };
            let cstring = clone_cstring_safely(cstr_ptr)?;
            cstrings.push(cstring);

            out_ptr = unsafe { out_ptr.offset(1) };
        }
        Ok(cstrings)
    }",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,"is_web_proxy_token_valid & self , token : & str","	fn is_web_proxy_token_valid(&self, token: &str) -> bool;
}

impl<F> WebProxyTokens for F where F: Fn(String) -> bool + Send + Sync {
	fn is_web_proxy_token_valid(&self, token: &str) -> bool { self(token.to_owned()) }
}",1,True,False,"0,3,4"
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,"domain & self , token : & str","	fn domain(&self, token: &str) -> Option<Origin>;
}

impl<F> WebProxyTokens for F where F: Fn(String) -> Option<Origin> + Send + Sync {
	fn domain(&self, token: &str) -> Option<Origin> { self(token.to_owned()) }
}",0,False,True,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,is_major_importing & self,	fn is_major_importing(&self) -> bool { self() },0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,is_major_importing & self,"	fn is_major_importing(&self) -> bool;
}

impl<F> SyncStatus for F where F: Fn() -> bool + Send + Sync {
	fn is_major_importing(&self) -> bool { self() }
}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,list & self,"	pub fn list(&self) -> Vec<apps::App> {
		self.endpoints.iter().filter_map(|(ref k, ref e)| {
			e.info().map(|ref info| apps::App::from_info(k, info))
		}).collect()
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,endpoints & self,"	pub fn endpoints(&self) -> Endpoints {
		Endpoints {
			endpoints: self.endpoints.clone(),
		}
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,"ui remote : Remote , registrar : Arc < ContractClient > , sync_status : Arc < SyncStatus > , fetch : F , dapps_domain : String ,","	pub fn ui<F: Fetch + Clone>(
		remote: Remote,
		registrar: Arc<ContractClient>,
		sync_status: Arc<SyncStatus>,
		fetch: F,
		dapps_domain: String,
	) -> Self {
		let content_fetcher = Arc::new(apps::fetcher::ContentFetcher::new(
			hash_fetch::urlhint::URLHintContract::new(registrar),
			sync_status,
			remote.clone(),
			fetch.clone(),
		).embeddable_on(None).allow_dapps(false));
		let special = {
			let mut special = special_endpoints(content_fetcher.clone());
			special.insert(router::SpecialEndpoint::Home, Some(apps::ui()));
			special
		};
		let router = router::Router::new(
			content_fetcher,
			None,
			special,
			None,
			dapps_domain,
		);

		Middleware {
			router: router,
			endpoints: Default::default(),
		}
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,"dapps remote : Remote , ui_address : Option < String , u16 > , dapps_path : PathBuf , extra_dapps : Vec < PathBuf > , dapps_domain : String , registrar : Arc < ContractClient > , sync_status : Arc < SyncStatus > , web_proxy_tokens : Arc < WebProxyTokens > , fetch : F ,","	pub fn dapps<F: Fetch + Clone>(
		remote: Remote,
		ui_address: Option<(String, u16)>,
		dapps_path: PathBuf,
		extra_dapps: Vec<PathBuf>,
		dapps_domain: String,
		registrar: Arc<ContractClient>,
		sync_status: Arc<SyncStatus>,
		web_proxy_tokens: Arc<WebProxyTokens>,
		fetch: F,
	) -> Self {
		let content_fetcher = Arc::new(apps::fetcher::ContentFetcher::new(
			hash_fetch::urlhint::URLHintContract::new(registrar),
			sync_status,
			remote.clone(),
			fetch.clone(),
		).embeddable_on(ui_address.clone()).allow_dapps(true));
		let endpoints = apps::all_endpoints(
			dapps_path,
			extra_dapps,
			dapps_domain.clone(),
			ui_address.clone(),
			web_proxy_tokens,
			remote.clone(),
			fetch.clone(),
		);

		let special = {
			let mut special = special_endpoints(content_fetcher.clone());
			special.insert(router::SpecialEndpoint::Home, Some(apps::ui_redirection(ui_address.clone())));
			special
		};

		let router = router::Router::new(
			content_fetcher,
			Some(endpoints.clone()),
			special,
			ui_address,
			dapps_domain,
		);

		Middleware {
			router: router,
			endpoints: endpoints,
		}
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,"on_request & self , req : & hyper :: server :: Request < hyper :: net :: HttpStream > , control : & hyper :: Control","	fn on_request(&self, req: &hyper::server::Request<hyper::net::HttpStream>, control: &hyper::Control) -> http::RequestMiddlewareAction {
		self.router.on_request(req, control)
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,special_endpoints content_fetcher : Arc < apps :: fetcher :: Fetcher >,"fn special_endpoints(content_fetcher: Arc<apps::fetcher::Fetcher>) -> HashMap<router::SpecialEndpoint, Option<Box<endpoint::Endpoint>>> {
	let mut special = HashMap::new();
	special.insert(router::SpecialEndpoint::Rpc, None);
	special.insert(router::SpecialEndpoint::Utils, Some(apps::utils()));
	special.insert(router::SpecialEndpoint::Api, Some(api::RestApi::new(content_fetcher)));
	special
}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,"address address : & String , u16","fn address(address: &(String, u16)) -> String {
	format!(""{}:{}"", address.0, address.1)
}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,lib.rs,Rust,random_filename,"fn random_filename() -> String {
	use ::rand::Rng;
	let mut rng = ::rand::OsRng::new().unwrap();
	rng.gen_ascii_chars().take(12).collect()
}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,web.rs,Rust,"extract_target_url & self , url : Option < Url >","	fn extract_target_url(&self, url: Option<Url>) -> Result<String, State<F>> {
		let token_and_url = self.path.app_params.get(0)
			.map(|encoded| encoded.replace('.', """"))
			.and_then(|encoded| base32::decode(base32::Alphabet::Crockford, &encoded.to_uppercase()))
			.and_then(|data| String::from_utf8(data).ok())
			.ok_or_else(|| State::Error(ContentHandler::error(
				StatusCode::BadRequest,
				""Invalid parameter"",
				""Couldn't parse given parameter:"",
				self.path.app_params.get(0).map(String::as_str),
				self.embeddable_on.clone()
			)))?;

		let mut token_it = token_and_url.split('+');
		let token = token_it.next();
		let target_url = token_it.next();

		// Check if token supplied in URL is correct.
		match token {
			Some(token) if self.web_proxy_tokens.is_web_proxy_token_valid(token) => {},
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, ""Invalid Access Token"", ""Invalid or old web proxy access token supplied."", Some(""Try refreshing the page.""), self.embeddable_on.clone()
				)));
			}
		}

		// Validate protocol
		let mut target_url = match target_url {
			Some(url) if url.starts_with(""http://"") || url.starts_with(""https://"") => url.to_owned(),
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, ""Invalid Protocol"", ""Invalid protocol used."", None, self.embeddable_on.clone()
				)));
			}
		};

		if !target_url.ends_with(""/"") {
			target_url = format!(""{}/"", target_url);
		}

		// TODO [ToDr] Should just use `path.app_params`
		let (path, query) = match (&url, self.path.using_dapps_domains) {
			(&Some(ref url), true) => (&url.path[..], &url.query),
			(&Some(ref url), false) => (&url.path[2..], &url.query),
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, ""Invalid URL"", ""Couldn't parse URL"", None, self.embeddable_on.clone()
				)));
			}
		};

		let query = match *query {
			Some(ref query) => format!(""?{}"", query),
			None => """".into(),
		};

		Ok(format!(""{}{}{}"", target_url, path.join(""/""), query))
	}",1,True,False,"18,19,25"
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,web.rs,Rust,"extract_target_url & self , url : Option < Url >","	fn extract_target_url(&self, url: Option<Url>) -> Result<String, State<F>> {
		let token_and_url = self.path.app_params.get(0)
			.map(|encoded| encoded.replace('.', """"))
			.and_then(|encoded| base32::decode(base32::Alphabet::Crockford, &encoded.to_uppercase()))
			.and_then(|data| String::from_utf8(data).ok())
			.ok_or_else(|| State::Error(ContentHandler::error(
				StatusCode::BadRequest,
				""Invalid parameter"",
				""Couldn't parse given parameter:"",
				self.path.app_params.get(0).map(String::as_str),
				self.embeddable_on.clone()
			)))?;

		let mut token_it = token_and_url.split('+');
		let token = token_it.next();
		let target_url = token_it.next();

		// Check if token supplied in URL is correct.
		let domain = match token.and_then(|token| self.web_proxy_tokens.domain(token)) {
			Some(domain) => domain,
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, ""Invalid Access Token"", ""Invalid or old web proxy access token supplied."", Some(""Try refreshing the page.""), self.embeddable_on.clone()
				)));
			}
		};

		// Validate protocol
		let mut target_url = match target_url {
			Some(url) if url.starts_with(""http://"") || url.starts_with(""https://"") => url.to_owned(),
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, ""Invalid Protocol"", ""Invalid protocol used."", None, self.embeddable_on.clone()
				)));
			}
		};

		if !target_url.starts_with(&*domain) {
			return Err(State::Error(ContentHandler::error(
				StatusCode::BadRequest, ""Invalid Domain"", ""Dapp attempted to access invalid domain."", Some(&target_url), self.embeddable_on.clone(),
			)));
		}

		if !target_url.ends_with(""/"") {
			target_url = format!(""{}/"", target_url);
		}

		// TODO [ToDr] Should just use `path.app_params`
		let (path, query) = match (&url, self.path.using_dapps_domains) {
			(&Some(ref url), true) => (&url.path[..], &url.query),
			(&Some(ref url), false) => (&url.path[2..], &url.query),
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, ""Invalid URL"", ""Couldn't parse URL"", None, self.embeddable_on.clone()
				)));
			}
		};

		let query = match *query {
			Some(ref query) => format!(""?{}"", query),
			None => """".into(),
		};

		Ok(format!(""{}{}{}"", target_url, path.join(""/""), query))
	}",0,False,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,web.rs,Rust,"boxed embeddable_on : Embeddable , web_proxy_tokens : Arc < WebProxyTokens > , remote : Remote , fetch : F","	pub fn boxed(embeddable_on: Embeddable, web_proxy_tokens: Arc<WebProxyTokens>, remote: Remote, fetch: F) -> Box<Endpoint> {
		Box::new(Web {
			embeddable_on: embeddable_on,
			web_proxy_tokens: web_proxy_tokens,
			remote: remote,
			fetch: fetch,
		})
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,web.rs,Rust,"to_async_handler & self , path : EndpointPath , control : hyper :: Control","	fn to_async_handler(&self, path: EndpointPath, control: hyper::Control) -> Box<Handler> {
		Box::new(WebHandler {
			control: control,
			state: State::Initial,
			path: path,
			remote: self.remote.clone(),
			fetch: self.fetch.clone(),
			web_proxy_tokens: self.web_proxy_tokens.clone(),
			embeddable_on: self.embeddable_on.clone(),
		})
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,web.rs,Rust,"validate_and_install & self , response : fetch :: Response","	fn validate_and_install(&self, response: fetch::Response) -> Result<ValidatorResponse, String> {
		let status = StatusCode::from_u16(response.status().to_u16());
		let is_html = response.is_html();
		let mime = response.content_type().unwrap_or(mime!(Text/Html));
		let mut handler = StreamingHandler::new(
			response,
			status,
			mime,
			self.embeddable_on.clone(),
		);
		if is_html {
			handler.set_initial_content(&format!(
				r#""<script src=""/{}/inject.js""></script><script>history.replaceState({{}}, """", ""/?{}{}/{}"")</script>""#,
				apps::UTILS_PATH,
				apps::URL_REFERER,
				apps::WEB_PATH,
				&self.referer,
			));
		}
		Ok(ValidatorResponse::Streaming(handler))
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,web.rs,Rust,"on_request & mut self , request : server :: Request < net :: HttpStream >","	fn on_request(&mut self, request: server::Request<net::HttpStream>) -> Next {
		let url = extract_url(&request);
		// First extract the URL (reject invalid URLs)
		let target_url = match self.extract_target_url(url) {
			Ok(url) => url,
			Err(error) => {
				self.state = error;
				return Next::write();
			}
		};

		let mut handler = ContentFetcherHandler::new(
			target_url,
			self.path.clone(),
			self.control.clone(),
			WebInstaller {
				embeddable_on: self.embeddable_on.clone(),
				referer: self.path.app_params.get(0)
					.expect(""`target_url` is valid; app_params is not empty;qed"")
					.to_owned(),
			},
			self.embeddable_on.clone(),
			self.remote.clone(),
			self.fetch.clone(),
		);
		let res = handler.on_request(request);
		self.state = State::Fetching(handler);

		res
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,web.rs,Rust,"on_request_readable & mut self , decoder : & mut Decoder < net :: HttpStream >","	fn on_request_readable(&mut self, decoder: &mut Decoder<net::HttpStream>) -> Next {
		match self.state {
			State::Initial => Next::end(),
			State::Error(ref mut handler) => handler.on_request_readable(decoder),
			State::Fetching(ref mut handler) => handler.on_request_readable(decoder),
		}
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,web.rs,Rust,"on_response & mut self , res : & mut server :: Response","	fn on_response(&mut self, res: &mut server::Response) -> Next {
		match self.state {
			State::Initial => Next::end(),
			State::Error(ref mut handler) => handler.on_response(res),
			State::Fetching(ref mut handler) => handler.on_response(res),
		}
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,web.rs,Rust,"on_response_writable & mut self , encoder : & mut Encoder < net :: HttpStream >","	fn on_response_writable(&mut self, encoder: &mut Encoder<net::HttpStream>) -> Next {
		match self.state {
			State::Initial => Next::end(),
			State::Error(ref mut handler) => handler.on_response_writable(encoder),
			State::Fetching(ref mut handler) => handler.on_response_writable(encoder),
		}
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"dapps_middleware deps : Dependencies , dapps_path : PathBuf , extra_dapps : Vec < PathBuf > , dapps_domain : String ,","	pub fn dapps_middleware(
		deps: Dependencies,
		dapps_path: PathBuf,
		extra_dapps: Vec<PathBuf>,
		dapps_domain: String,
	) -> Result<Middleware, String> {
		let signer = deps.signer;
		let parity_remote = parity_reactor::Remote::new(deps.remote.clone());
		let web_proxy_tokens = Arc::new(move |token| signer.is_valid_web_proxy_access_token(&token));

		Ok(parity_dapps::Middleware::dapps(
			parity_remote,
			deps.ui_address,
			dapps_path,
			extra_dapps,
			dapps_domain,
			deps.contract_client,
			deps.sync_status,
			web_proxy_tokens,
			deps.fetch,
		))
	}",1,True,False,8
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"dapps_middleware deps : Dependencies , dapps_path : PathBuf , extra_dapps : Vec < PathBuf > , dapps_domain : String ,","	pub fn dapps_middleware(
		deps: Dependencies,
		dapps_path: PathBuf,
		extra_dapps: Vec<PathBuf>,
		dapps_domain: String,
	) -> Result<Middleware, String> {
		let signer = deps.signer;
		let parity_remote = parity_reactor::Remote::new(deps.remote.clone());
		let web_proxy_tokens = Arc::new(move |token| signer.web_proxy_access_token_domain(&token));

		Ok(parity_dapps::Middleware::dapps(
			parity_remote,
			deps.ui_address,
			dapps_path,
			extra_dapps,
			dapps_domain,
			deps.contract_client,
			deps.sync_status,
			web_proxy_tokens,
			deps.fetch,
		))
	}",0,False,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,default,"	fn default() -> Self {
		let data_dir = default_data_path();
		Configuration {
			enabled: true,
			dapps_path: replace_home(&data_dir, ""$BASE/dapps"").into(),
			extra_dapps: vec![],
		}
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"address & self , address : Option < String , u16 >","	pub fn address(&self, address: Option<(String, u16)>) -> Option<(String, u16)> {
		match self.enabled {
			true => address,
			false => None,
		}
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,registrar & self,"	fn registrar(&self) -> Result<Address, String> {
		self.client.additional_params().get(""registrar"")
			 .ok_or_else(|| ""Registrar not defined."".into())
			 .and_then(|registrar| {
				 registrar.parse().map_err(|e| format!(""Invalid registrar address: {:?}"", e))
			 })
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"call & self , address : Address , data : Bytes","	fn call(&self, address: Address, data: Bytes) -> BoxFuture<Bytes, String> {
		self.client.call_contract(BlockId::Latest, address, data)
			.into_future()
			.boxed()
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,registrar & self,"	fn registrar(&self) -> Result<Address, String> {
		self.client.engine().additional_params().get(""registrar"")
			 .ok_or_else(|| ""Registrar not defined."".into())
			 .and_then(|registrar| {
				 registrar.parse().map_err(|e| format!(""Invalid registrar address: {:?}"", e))
			 })
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"call & self , address : Address , data : Bytes","	fn call(&self, address: Address, data: Bytes) -> BoxFuture<Bytes, String> {
		let (header, env_info) = (self.client.best_block_header(), self.client.latest_env_info());

		let maybe_future = self.sync.with_context(move |ctx| {
			self.on_demand
				.request(ctx, on_demand::request::TransactionProof {
					tx: Transaction {
						nonce: self.client.engine().account_start_nonce(),
						action: Action::Call(address),
						gas: 50_000_000.into(),
						gas_price: 0.into(),
						value: 0.into(),
						data: data,
					}.fake_sign(Address::default()),
					header: header.into(),
					env_info: env_info,
					engine: self.client.engine().clone(),
				})
				.expect(""No back-references; therefore all back-refs valid; qed"")
				.then(|res| match res {
					Ok(Ok(executed)) => Ok(executed.output),
					Ok(Err(e)) => Err(format!(""Failed to execute transaction: {}"", e)),
					Err(_) => Err(format!(""On-demand service dropped request unexpectedly."")),
				})
		});

		match maybe_future {
			Some(fut) => fut.boxed(),
			None => future::err(""cannot query registry: network disabled"".into()).boxed(),
		}
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"new configuration : Configuration , deps : Dependencies","pub fn new(configuration: Configuration, deps: Dependencies) -> Result<Option<Middleware>, String> {
	if !configuration.enabled {
		return Ok(None);
	}

	server::dapps_middleware(
		deps,
		configuration.dapps_path,
		configuration.extra_dapps,
		rpc::DAPPS_DOMAIN.into(),
	).map(Some)
}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"new_ui enabled : bool , deps : Dependencies","pub fn new_ui(enabled: bool, deps: Dependencies) -> Result<Option<Middleware>, String> {
	if !enabled {
		return Ok(None);
	}

	server::ui_middleware(
		deps,
		rpc::DAPPS_DOMAIN.into(),
	).map(Some)
}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"on_request & self , _req : & hyper :: server :: Request < hyper :: net :: HttpStream > , _control : & hyper :: Control","		fn on_request(
			&self, _req: &hyper::server::Request<hyper::net::HttpStream>, _control: &hyper::Control
		) -> RequestMiddlewareAction {
			unreachable!()
		}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"dapps_middleware _deps : Dependencies , _dapps_path : PathBuf , _extra_dapps : Vec < PathBuf > , _dapps_domain : String ,","	pub fn dapps_middleware(
		_deps: Dependencies,
		_dapps_path: PathBuf,
		_extra_dapps: Vec<PathBuf>,
		_dapps_domain: String,
	) -> Result<Middleware, String> {
		Err(""Your Parity version has been compiled without WebApps support."".into())
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"ui_middleware _deps : Dependencies , _dapps_domain : String ,","	pub fn ui_middleware(
		_deps: Dependencies,
		_dapps_domain: String,
	) -> Result<Middleware, String> {
		Err(""Your Parity version has been compiled without UI support."".into())
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,service _ : & Option < Middleware >,"	pub fn service(_: &Option<Middleware>) -> Option<Arc<rpc_apis::DappsService>> {
		None
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,"ui_middleware deps : Dependencies , dapps_domain : String ,","	pub fn ui_middleware(
		deps: Dependencies,
		dapps_domain: String,
	) -> Result<Middleware, String> {
		let parity_remote = parity_reactor::Remote::new(deps.remote.clone());
		Ok(parity_dapps::Middleware::ui(
			parity_remote,
			deps.contract_client,
			deps.sync_status,
			deps.fetch,
			dapps_domain,
		))
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,service middleware : & Option < Middleware >,"	pub fn service(middleware: &Option<Middleware>) -> Option<Arc<rpc_apis::DappsService>> {
		middleware.as_ref().map(|m| Arc::new(DappsServiceWrapper {
			endpoints: m.endpoints()
		}) as Arc<rpc_apis::DappsService>)
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,dapps.rs,Rust,list_dapps & self,"		fn list_dapps(&self) -> Vec<rpc_apis::LocalDapp> {
			self.endpoints.list()
				.into_iter()
				.map(|app| rpc_apis::LocalDapp {
					id: app.id,
					name: app.name,
					description: app.description,
					version: app.version,
					author: app.author,
					icon_url: app.icon_url,
				})
				.collect()
		}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,generate_web_proxy_access_token & self,"	pub fn generate_web_proxy_access_token(&self) -> String {
		let token = random_string(16);
		let mut tokens = self.web_proxy_tokens.lock();
		tokens.prune();
		tokens.insert(token.clone(), ());
		token
	}",1,True,False,"0,4"
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"is_valid_web_proxy_access_token & self , token : & String","	pub fn is_valid_web_proxy_access_token(&self, token: &String) -> bool {
		self.web_proxy_tokens.lock().contains_key(&token)
	}",1,True,False,"0,1"
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"generate_web_proxy_access_token & self , domain : Origin","	pub fn generate_web_proxy_access_token(&self, domain: Origin) -> String {
		let token = random_string(16);
		let mut tokens = self.web_proxy_tokens.lock();
		tokens.prune();
		tokens.insert(token.clone(), domain);
		token
	}",0,False,True,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"web_proxy_access_token_domain & self , token : & String","	pub fn web_proxy_access_token_domain(&self, token: &String) -> Option<Origin> {
		self.web_proxy_tokens.lock().get(token).cloned()
	}",0,False,True,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,generate_token & self,"	pub fn generate_token(&self) -> Result<String, String> {
		(self.generate_new_token)()
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,queue & self,"	pub fn queue(&self) -> Arc<ConfirmationsQueue> {
		self.queue.clone()
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,is_enabled & self,"	pub fn is_enabled(&self) -> bool {
		self.is_enabled
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,new_test is_enabled : bool,"	pub fn new_test(is_enabled: bool) -> Self {
		SignerService::new(|| Ok(""new_token"".into()), is_enabled)
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,deref & self,"	fn deref(&self) -> &Self::Target {
		&self.queue
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,generate_web_proxy_token & self,"	fn generate_web_proxy_token(&self) -> Result<String, Error> {
		Ok(self.signer.generate_web_proxy_access_token())
	}",1,True,False,"0,1"
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"generate_web_proxy_token & self , domain : String","	fn generate_web_proxy_token(&self, domain: String) -> Result<String, Error> {
		Ok(self.signer.generate_web_proxy_access_token(domain.into()))
	}",0,False,True,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"verify_transaction bytes : Bytes , request : FilledTransactionRequest , process : F","	fn verify_transaction<F>(bytes: Bytes, request: FilledTransactionRequest, process: F) -> Result<ConfirmationResponse, Error> where
		F: FnOnce(PendingTransaction) -> Result<ConfirmationResponse, Error>,
	{
		let signed_transaction = UntrustedRlp::new(&bytes.0).as_val().map_err(errors::from_rlp_error)?;
		let signed_transaction = SignedTransaction::new(signed_transaction).map_err(|e| errors::invalid_params(""Invalid signature."", e))?;
		let sender = signed_transaction.sender();

		// Verification
		let sender_matches = sender == request.from;
		let data_matches = signed_transaction.data == request.data;
		let value_matches = signed_transaction.value == request.value;
		let nonce_matches = match request.nonce {
			Some(nonce) => signed_transaction.nonce == nonce,
			None => true,
		};

		// Dispatch if everything is ok
		if sender_matches && data_matches && value_matches && nonce_matches {
			let pending_transaction = PendingTransaction::new(signed_transaction, request.condition.map(Into::into));
			process(pending_transaction)
		} else {
			let mut error = Vec::new();
			if !sender_matches { error.push(""from"") }
			if !data_matches { error.push(""data"") }
			if !value_matches { error.push(""value"") }
			if !nonce_matches { error.push(""nonce"") }

			Err(errors::invalid_params(""Sent transaction does not match the request."", error))
		}
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,requests_to_confirm & self,"	fn requests_to_confirm(&self) -> Result<Vec<ConfirmationRequest>, Error> {
		Ok(self.signer.requests()
			.into_iter()
			.map(Into::into)
			.collect()
		)
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"confirm_request & self , id : U256 , modification : TransactionModification , pass : String","	fn confirm_request(&self, id: U256, modification: TransactionModification, pass: String)
		-> BoxFuture<ConfirmationResponse, Error>
	{
		self.confirm_internal(id, modification, move |dis, accounts, payload| {
			dispatch::execute(dis, accounts, payload, dispatch::SignWith::Password(pass))
		}).map(|v| v.into_value()).boxed()
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"confirm_request_with_token & self , id : U256 , modification : TransactionModification , token : String","	fn confirm_request_with_token(&self, id: U256, modification: TransactionModification, token: String)
		-> BoxFuture<ConfirmationResponseWithToken, Error>
	{
		self.confirm_internal(id, modification, move |dis, accounts, payload| {
			dispatch::execute(dis, accounts, payload, dispatch::SignWith::Token(token))
		}).and_then(|v| match v {
			WithToken::No(_) => Err(errors::internal(""Unexpected response without token."", """")),
			WithToken::Yes(response, token) => Ok(ConfirmationResponseWithToken {
				result: response,
				token: token,
			}),
		}).boxed()
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"confirm_request_raw & self , id : U256 , bytes : Bytes","	fn confirm_request_raw(&self, id: U256, bytes: Bytes) -> Result<ConfirmationResponse, Error> {
		let id = id.into();

		self.signer.peek(&id).map(|confirmation| {
			let result = match confirmation.payload {
				ConfirmationPayload::SendTransaction(request) => {
					Self::verify_transaction(bytes, request, |pending_transaction| {
						self.dispatcher.dispatch_transaction(pending_transaction)
							.map(Into::into)
							.map(ConfirmationResponse::SendTransaction)
					})
				},
				ConfirmationPayload::SignTransaction(request) => {
					Self::verify_transaction(bytes, request, |pending_transaction| {
						Ok(ConfirmationResponse::SignTransaction(pending_transaction.transaction.into()))
					})
				},
				ConfirmationPayload::EthSignMessage(address, data) => {
					let expected_hash = eth_data_hash(data);
					let signature = ethkey::Signature::from_electrum(&bytes.0);
					match ethkey::verify_address(&address, &signature, &expected_hash) {
						Ok(true) => Ok(ConfirmationResponse::Signature(bytes.0.as_slice().into())),
						Ok(false) => Err(errors::invalid_params(""Sender address does not match the signature."", ())),
						Err(err) => Err(errors::invalid_params(""Invalid signature received."", err)),
					}
				},
				ConfirmationPayload::Decrypt(_address, _data) => {
					// TODO [ToDr]: Decrypt can we verify if the answer is correct?
					Ok(ConfirmationResponse::Decrypt(bytes))
				},
			};
			if let Ok(ref response) = result {
				self.signer.request_confirmed(id, Ok(response.clone()));
			}
			result
		}).unwrap_or_else(|| Err(errors::invalid_params(""Unknown RequestID"", id)))
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"reject_request & self , id : U256","	fn reject_request(&self, id: U256) -> Result<bool, Error> {
		let res = self.signer.request_rejected(id.into());
		Ok(res.is_some())
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,generate_token & self,"	fn generate_token(&self) -> Result<String, Error> {
		self.signer.generate_token()
			.map_err(|e| errors::token(e))
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"subscribe_pending & self , _meta : Self :: Metadata , sub : Subscriber < Vec < ConfirmationRequest > >","	fn subscribe_pending(&self, _meta: Self::Metadata, sub: Subscriber<Vec<ConfirmationRequest>>) {
		self.subscribers.lock().push(sub)
	}",0,True,False,
https://github.com/openethereum/parity-ethereum.git,53609f703e2f1af76441344ac3b72811c726a215,Gav Wood,2017-06-22 20:05:40+02:00,False,signer.rs,Rust,"unsubscribe_pending & self , id : SubscriptionId","	fn unsubscribe_pending(&self, id: SubscriptionId) -> BoxFuture<bool, Error> {
		let res = self.subscribers.lock().remove(&id).is_some();
		futures::future::ok(res).boxed()
	}",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,"ready & mut self , poll : & mut mio :: Poll , ev : & mio :: Event","    fn ready(&mut self, poll: &mut mio::Poll, ev: &mio::Event) {
        // If we're readable: read some TLS.  Then
        // see if that yielded new plaintext.  Then
        // see if the backend is readable too.
        if ev.readiness().is_readable() {
            self.do_tls_read();
            self.try_plain_read();
            self.try_back_read();
        }

        if ev.readiness().is_writable() {
            self.do_tls_write_and_handle_error();
        }

        if self.closing && !self.tls_session.wants_write() {
            let _ = self.socket.shutdown(Shutdown::Both);
            self.close_back();
            self.closed = true;
        } else {
            self.reregister(poll);
        }
    }",1,True,False,14
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,"ready & mut self , poll : & mut mio :: Poll , ev : & mio :: Event","    fn ready(&mut self, poll: &mut mio::Poll, ev: &mio::Event) {
        // If we're readable: read some TLS.  Then
        // see if that yielded new plaintext.  Then
        // see if the backend is readable too.
        if ev.readiness().is_readable() {
            self.do_tls_read();
            self.try_plain_read();
            self.try_back_read();
        }

        if ev.readiness().is_writable() {
            self.do_tls_write_and_handle_error();
        }

        if self.closing {
            let _ = self.socket.shutdown(Shutdown::Both);
            self.close_back();
            self.closed = true;
        } else {
            self.reregister(poll);
        }
    }",0,False,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,"new server : TcpListener , mode : ServerMode , cfg : Arc < rustls :: ServerConfig >","    fn new(server: TcpListener, mode: ServerMode, cfg: Arc<rustls::ServerConfig>) -> TlsServer {
        TlsServer {
            server,
            connections: HashMap::new(),
            next_id: 2,
            tls_config: cfg,
            mode,
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,"accept & mut self , poll : & mut mio :: Poll","    fn accept(&mut self, poll: &mut mio::Poll) -> bool {
        match self.server.accept() {
            Ok((socket, addr)) => {
                debug!(""Accepting new connection from {:?}"", addr);

                let tls_session = rustls::ServerSession::new(&self.tls_config);
                let mode = self.mode.clone();

                let token = mio::Token(self.next_id);
                self.next_id += 1;

                self.connections.insert(token, Connection::new(socket, token, mode, tls_session));
                self.connections[&token].register(poll);
                true
            }
            Err(e) => {
                println!(""encountered error while accepting connection; err={:?}"", e);
                false
            }
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,"conn_event & mut self , poll : & mut mio :: Poll , event : & mio :: Event","    fn conn_event(&mut self, poll: &mut mio::Poll, event: &mio::Event) {
        let token = event.token();

        if self.connections.contains_key(&token) {
            self.connections
                .get_mut(&token)
                .unwrap()
                .ready(poll, event);

            if self.connections[&token].is_closed() {
                self.connections.remove(&token);
            }
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,open_back mode : & ServerMode,"fn open_back(mode: &ServerMode) -> Option<TcpStream> {
    match *mode {
        ServerMode::Forward(ref port) => {
            let addr = net::SocketAddrV4::new(net::Ipv4Addr::new(127, 0, 0, 1), *port);
            let conn = TcpStream::connect(&net::SocketAddr::V4(addr)).unwrap();
            Some(conn)
        }
        _ => None,
    }
}",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,try_read r : io :: Result < usize >,"fn try_read(r: io::Result<usize>) -> io::Result<Option<usize>> {
    match r {
        Ok(len) => Ok(Some(len)),
        Err(e) => {
            if e.kind() == io::ErrorKind::WouldBlock {
                Ok(None)
            } else {
                Err(e)
            }
        }
    }
}",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,"new socket : TcpStream , token : mio :: Token , mode : ServerMode , tls_session : rustls :: ServerSession","    fn new(socket: TcpStream,
           token: mio::Token,
           mode: ServerMode,
           tls_session: rustls::ServerSession)
           -> Connection {
        let back = open_back(&mode);
        Connection {
            socket,
            token,
            closing: false,
            closed: false,
            mode,
            tls_session,
            back,
            sent_http_response: false,
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,close_back & mut self,"    fn close_back(&mut self) {
        if self.back.is_some() {
            let back = self.back.as_mut().unwrap();
            back.shutdown(Shutdown::Both).unwrap();
        }
        self.back = None;
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,do_tls_read & mut self,"    fn do_tls_read(&mut self) {
        // Read some TLS data.
        let rc = self.tls_session.read_tls(&mut self.socket);
        if rc.is_err() {
            let err = rc.unwrap_err();

            if let io::ErrorKind::WouldBlock = err.kind() {
                return;
            }

            error!(""read error {:?}"", err);
            self.closing = true;
            return;
        }

        if rc.unwrap() == 0 {
            debug!(""eof"");
            self.closing = true;
            return;
        }

        // Process newly-received TLS messages.
        let processed = self.tls_session.process_new_packets();
        if processed.is_err() {
            error!(""cannot process packet: {:?}"", processed);

            // last gasp write to send any alerts
            self.do_tls_write_and_handle_error();

            self.closing = true;
            return;
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,try_plain_read & mut self,"    fn try_plain_read(&mut self) {
        // Read and process all available plaintext.
        let mut buf = Vec::new();

        let rc = self.tls_session.read_to_end(&mut buf);
        if rc.is_err() {
            error!(""plaintext read failed: {:?}"", rc);
            self.closing = true;
            return;
        }

        if !buf.is_empty() {
            debug!(""plaintext read {:?}"", buf.len());
            self.incoming_plaintext(&buf);
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,try_back_read & mut self,"    fn try_back_read(&mut self) {
        if self.back.is_none() {
            return;
        }

        // Try a non-blocking read.
        let mut buf = [0u8; 1024];
        let back = self.back.as_mut().unwrap();
        let rc = try_read(back.read(&mut buf));

        if rc.is_err() {
            error!(""backend read failed: {:?}"", rc);
            self.closing = true;
            return;
        }

        let maybe_len = rc.unwrap();

        // If we have a successful but empty read, that's an EOF.
        // Otherwise, we shove the data into the TLS session.
        match maybe_len {
            Some(len) if len == 0 => {
                debug!(""back eof"");
                self.closing = true;
            }
            Some(len) => {
                self.tls_session.write_all(&buf[..len]).unwrap();
            }
            None => {}
        };
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,"incoming_plaintext & mut self , buf : & [ u8 ]","    fn incoming_plaintext(&mut self, buf: &[u8]) {
        match self.mode {
            ServerMode::Echo => {
                self.tls_session.write_all(buf).unwrap();
            }
            ServerMode::Http => {
                self.send_http_response_once();
            }
            ServerMode::Forward(_) => {
                self.back.as_mut().unwrap().write_all(buf).unwrap();
            }
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,send_http_response_once & mut self,"    fn send_http_response_once(&mut self) {
        let response = b""HTTP/1.0 200 OK\r\nConnection: close\r\n\r\nHello world from rustls tlsserver\r\n"";
        if !self.sent_http_response {
            self.tls_session
                .write_all(response)
                .unwrap();
            self.sent_http_response = true;
            self.tls_session.send_close_notify();
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,tls_write & mut self,"    fn tls_write(&mut self) -> io::Result<usize> {
        self.tls_session.write_tls(&mut self.socket)
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,tls_write & mut self,"    fn tls_write(&mut self) -> io::Result<usize> {
        use crate::util::WriteVAdapter;
        self.tls_session.writev_tls(&mut WriteVAdapter::new(&mut self.socket))
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,do_tls_write_and_handle_error & mut self,"    fn do_tls_write_and_handle_error(&mut self) {
        let rc = self.tls_write();
        if rc.is_err() {
            error!(""write failed {:?}"", rc);
            self.closing = true;
            return;
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,"register & self , poll : & mut mio :: Poll","    fn register(&self, poll: &mut mio::Poll) {
        poll.register(&self.socket,
                      self.token,
                      self.event_set(),
                      mio::PollOpt::level() | mio::PollOpt::oneshot())
            .unwrap();

        if self.back.is_some() {
            poll.register(self.back.as_ref().unwrap(),
                          self.token,
                          mio::Ready::readable(),
                          mio::PollOpt::level() | mio::PollOpt::oneshot())
                .unwrap();
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,"reregister & self , poll : & mut mio :: Poll","    fn reregister(&self, poll: &mut mio::Poll) {
        poll.reregister(&self.socket,
                        self.token,
                        self.event_set(),
                        mio::PollOpt::level() | mio::PollOpt::oneshot())
            .unwrap();

        if self.back.is_some() {
            poll.reregister(self.back.as_ref().unwrap(),
                            self.token,
                            mio::Ready::readable(),
                            mio::PollOpt::level() | mio::PollOpt::oneshot())
                .unwrap();
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,event_set & self,"    fn event_set(&self) -> mio::Ready {
        let rd = self.tls_session.wants_read();
        let wr = self.tls_session.wants_write();

        if rd && wr {
            mio::Ready::readable() | mio::Ready::writable()
        } else if wr {
            mio::Ready::writable()
        } else {
            mio::Ready::readable()
        }
    }",0,True,False,
https://github.com/rustls/rustls.git,a93ee1abd2ab19ebe4bf9d684d56637ee54a6074,Joseph Birr-Pixton,2019-08-10 09:47:06+01:00,False,tlsserver.rs,Rust,is_closed & self,"    fn is_closed(&self) -> bool {
        self.closed
    }",0,True,False,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,strip_comments string : & str,"fn strip_comments(string: &str) -> String {
    // Remove line comments
    let line_comments = Regex::new(r""(?m)//.*$"").unwrap();
    line_comments.replace_all(string, ""$1"").into_owned()
}",1,True,False,"0,1,2,3"
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,parse_module modules_str : & str,"pub fn parse_module(modules_str: &str) -> Result<ast::ModuleDefinition> {
    let stripped_string = &strip_comments(modules_str);
    let parser = syntax::ModuleParser::new();
    match parser.parse(stripped_string) {
        Ok(module) => Ok(module),
        Err(e) => handle_error(e, modules_str),
    }
}",1,True,False,"1,5"
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,parse_program program_str : & str,"pub fn parse_program(program_str: &str) -> Result<ast::Program> {
    let stripped_string = &strip_comments(program_str);
    let parser = syntax::ProgramParser::new();
    match parser.parse(stripped_string) {
        Ok(program) => Ok(program),
        Err(e) => handle_error(e, program_str),
    }
}",1,True,False,"1,5"
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,"parse_cmd cmd_str : & str , _sender_address : AccountAddress","pub fn parse_cmd(cmd_str: &str, _sender_address: AccountAddress) -> Result<ast::Cmd> {
    let stripped_string = &strip_comments(cmd_str);
    let parser = syntax::CmdParser::new();
    match parser.parse(stripped_string) {
        Ok(cmd) => Ok(cmd),
        Err(e) => handle_error(e, cmd_str),
    }
}",1,True,False,"1,5"
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,parse_script script_str : & str,"pub fn parse_script(script_str: &str) -> Result<ast::Script> {
    let stripped_string = &strip_comments(script_str);
    let parser = syntax::ScriptParser::new();
    match parser.parse(stripped_string) {
        Ok(script) => Ok(script),
        Err(e) => handle_error(e, script_str),
    }
}",1,True,False,"1,5"
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,is_permitted_newline_char c : char,"pub fn is_permitted_newline_char(c: char) -> bool {
    let x = c as u32;
    x == 0x0A
}",0,False,True,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,parse_program program_str : & str,"pub fn parse_program(program_str: &str) -> Result<ast::Program> {
    let stripped_string = &strip_comments_and_verify(program_str)?;
    let parser = syntax::ProgramParser::new();
    match parser.parse(stripped_string) {
        Ok(program) => Ok(program),
        Err(e) => handle_error(e, stripped_string),
    }
}",0,False,False,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,parse_module modules_str : & str,"pub fn parse_module(modules_str: &str) -> Result<ast::ModuleDefinition> {
    let stripped_string = &strip_comments_and_verify(modules_str)?;
    let parser = syntax::ModuleParser::new();
    match parser.parse(stripped_string) {
        Ok(module) => Ok(module),
        Err(e) => handle_error(e, stripped_string),
    }
}",0,False,False,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,strip_comments source : & str,"fn strip_comments(source: &str) -> String {
    const SLASH: char = '/';
    const SPACE: char = ' ';

    let mut in_comment = false;
    let mut acc = String::with_capacity(source.len());
    let mut char_iter = source.chars().peekable();

    while let Some(chr) = char_iter.next() {
        let at_newline = is_permitted_newline_char(chr);
        let at_or_after_slash_slash =
            in_comment || (chr == SLASH && char_iter.peek().map(|c| *c == SLASH).unwrap_or(false));
        in_comment = !at_newline && at_or_after_slash_slash;
        acc.push(if in_comment { SPACE } else { chr });
    }

    acc
}",0,False,True,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,"parse_cmd cmd_str : & str , _sender_address : AccountAddress","pub fn parse_cmd(cmd_str: &str, _sender_address: AccountAddress) -> Result<ast::Cmd> {
    let stripped_string = &strip_comments_and_verify(cmd_str)?;
    let parser = syntax::CmdParser::new();
    match parser.parse(stripped_string) {
        Ok(cmd) => Ok(cmd),
        Err(e) => handle_error(e, stripped_string),
    }
}",0,False,False,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,parse_script script_str : & str,"pub fn parse_script(script_str: &str) -> Result<ast::Script> {
    let stripped_string = &strip_comments_and_verify(script_str)?;
    let parser = syntax::ScriptParser::new();
    match parser.parse(stripped_string) {
        Ok(script) => Ok(script),
        Err(e) => handle_error(e, stripped_string),
    }
}",0,False,False,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,strip_comments_and_verify string : & str,"fn strip_comments_and_verify(string: &str) -> Result<String> {
    verify_string(string)?;
    Ok(strip_comments(string))
}",0,False,True,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,verify_string string : & str,"fn verify_string(string: &str) -> Result<()> {
    match string.chars().find(|c| !is_permitted_char(*c)) {
        None => Ok(()),
        Some(chr) => bail!(
            ""Parser Error: invalid character {} found when reading file.\
             Only ascii printable, tabs (\\t), and \\n line ending characters are permitted."",
            chr
        ),
    }
}",0,False,True,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,is_permitted_printable_char c : char,"pub fn is_permitted_printable_char(c: char) -> bool {
    let x = c as u32;
    let is_above_space = x >= 0x20; // Don't allow meta characters
    let is_below_tilde = x <= 0x7E; // Don't allow DEL meta character
    let is_tab = x == 0x09; // Allow tabs
    (is_above_space && is_below_tilde) || is_tab
}",0,False,True,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,is_permitted_char c : char,"pub fn is_permitted_char(c: char) -> bool {
    is_permitted_printable_char(c) || is_permitted_newline_char(c)
}",0,False,True,
https://github.com/diem/diem.git,7efb0221989f17fdf7f8486730898ed947a1e19e,Tim Zakian,2019-09-03 12:20:28-07:00,False,parser.rs,Rust,parse_script_or_module s : & str,"pub fn parse_script_or_module(s: &str) -> Result<ast::ScriptOrModule> {
    let stripped_string = &strip_comments(s);
    let parser = syntax::ScriptOrModuleParser::new();
    match parser.parse(stripped_string) {
        Ok(result) => Ok(result),
        Err(e) => handle_error(e, s),
    }
}",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,from_secret_key seckey : & SecretKey,"    pub fn from_secret_key(seckey: &SecretKey) -> PublicKey {
        let mut pj = Jacobian::default();
        ECMULT_GEN_CONTEXT.ecmult_gen(&mut pj, &seckey.0);
        let mut p = Affine::default();
        p.set_gej(&pj);
        PublicKey(p)
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,"parse_slice p : & [ u8 ] , format : Option < PublicKeyFormat >","    pub fn parse_slice(p: &[u8], format: Option<PublicKeyFormat>) -> Result<PublicKey, Error> {
        let format = match (p.len(), format) {
            (util::FULL_PUBLIC_KEY_SIZE, None) |
            (util::FULL_PUBLIC_KEY_SIZE, Some(PublicKeyFormat::Full)) =>
                PublicKeyFormat::Full,
            (util::COMPRESSED_PUBLIC_KEY_SIZE, None) |
            (util::COMPRESSED_PUBLIC_KEY_SIZE, Some(PublicKeyFormat::Compressed)) =>
                PublicKeyFormat::Compressed,
            (util::RAW_PUBLIC_KEY_SIZE, None) |
            (util::RAW_PUBLIC_KEY_SIZE, Some(PublicKeyFormat::Raw)) =>
                PublicKeyFormat::Raw,
            _ => return Err(Error::InvalidInputLength),
        };

        match format {
            PublicKeyFormat::Full => {
                let mut a = [0; util::FULL_PUBLIC_KEY_SIZE];
                a.copy_from_slice(p);
                Self::parse(&a)
            },
            PublicKeyFormat::Raw => {
                use util::TAG_PUBKEY_FULL;

                let mut a = [0; util::FULL_PUBLIC_KEY_SIZE];
                a[0] = TAG_PUBKEY_FULL;
                a[1..].copy_from_slice(p);
                Self::parse(&a)
            },
            PublicKeyFormat::Compressed => {
                let mut a = [0; util::COMPRESSED_PUBLIC_KEY_SIZE];
                a.copy_from_slice(p);
                Self::parse_compressed(&a)
            },
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse p : & [ u8 ; util :: FULL_PUBLIC_KEY_SIZE ],"    pub fn parse(p: &[u8; util::FULL_PUBLIC_KEY_SIZE]) -> Result<PublicKey, Error> {
        use util::{TAG_PUBKEY_FULL, TAG_PUBKEY_HYBRID_EVEN, TAG_PUBKEY_HYBRID_ODD};

        if !(p[0] == TAG_PUBKEY_FULL || p[0] == TAG_PUBKEY_HYBRID_EVEN || p[0] == TAG_PUBKEY_HYBRID_ODD) {
            return Err(Error::InvalidPublicKey);
        }
        let mut x = Field::default();
        let mut y = Field::default();
        if !x.set_b32(array_ref!(p, 1, 32)) {
            return Err(Error::InvalidPublicKey);
        }
        if !y.set_b32(array_ref!(p, 33, 32)) {
            return Err(Error::InvalidPublicKey);
        }
        let mut elem = Affine::default();
        elem.set_xy(&x, &y);
        if (p[0] == TAG_PUBKEY_HYBRID_EVEN || p[0] == TAG_PUBKEY_HYBRID_ODD) &&
            (y.is_odd() != (p[0] == TAG_PUBKEY_HYBRID_ODD))
        {
            return Err(Error::InvalidPublicKey);
        }
        if elem.is_infinity() {
            return Err(Error::InvalidPublicKey);
        }
        if elem.is_valid_var() {
            return Ok(PublicKey(elem));
        } else {
            return Err(Error::InvalidPublicKey);
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse_compressed p : & [ u8 ; util :: COMPRESSED_PUBLIC_KEY_SIZE ],"    pub fn parse_compressed(p: &[u8; util::COMPRESSED_PUBLIC_KEY_SIZE]) -> Result<PublicKey, Error> {
        use util::{TAG_PUBKEY_EVEN, TAG_PUBKEY_ODD};

        if !(p[0] == TAG_PUBKEY_EVEN || p[0] == TAG_PUBKEY_ODD) {
            return Err(Error::InvalidPublicKey);
        }
        let mut x = Field::default();
        if !x.set_b32(array_ref!(p, 1, 32)) {
            return Err(Error::InvalidPublicKey);
        }
        let mut elem = Affine::default();
        elem.set_xo_var(&x, p[0] == TAG_PUBKEY_ODD);
        if elem.is_infinity() {
            return Err(Error::InvalidPublicKey);
        }
        if elem.is_valid_var() {
            return Ok(PublicKey(elem));
        } else {
            return Err(Error::InvalidPublicKey);
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,serialize & self,"    pub fn serialize(&self) -> [u8; util::FULL_PUBLIC_KEY_SIZE] {
        use util::TAG_PUBKEY_FULL;

        debug_assert!(!self.0.is_infinity());

        let mut ret = [0u8; 65];
        let mut elem = self.0.clone();

        elem.x.normalize_var();
        elem.y.normalize_var();
        elem.x.fill_b32(array_mut_ref!(ret, 1, 32));
        elem.y.fill_b32(array_mut_ref!(ret, 33, 32));
        ret[0] = TAG_PUBKEY_FULL;

        ret
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,serialize_compressed & self,"    pub fn serialize_compressed(&self) -> [u8; util::COMPRESSED_PUBLIC_KEY_SIZE] {
        use util::{TAG_PUBKEY_ODD, TAG_PUBKEY_EVEN};

        debug_assert!(!self.0.is_infinity());

        let mut ret = [0u8; 33];
        let mut elem = self.0.clone();

        elem.x.normalize_var();
        elem.y.normalize_var();
        elem.x.fill_b32(array_mut_ref!(ret, 1, 32));
        ret[0] = if elem.y.is_odd() {
            TAG_PUBKEY_ODD
        } else {
            TAG_PUBKEY_EVEN
        };

        ret
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,"tweak_add_assign & mut self , tweak : & SecretKey","    pub fn tweak_add_assign(&mut self, tweak: &SecretKey) -> Result<(), Error> {
        let mut r = Jacobian::default();
        let a = Jacobian::from_ge(&self.0);
        let one = Scalar::from_int(1);
        ECMULT_CONTEXT.ecmult(&mut r, &a, &one, &tweak.0);

        if r.is_infinity() {
            return Err(Error::TweakOutOfRange);
        }

        self.0.set_gej(&r);
        Ok(())
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,"tweak_mul_assign & mut self , tweak : & SecretKey","    pub fn tweak_mul_assign(&mut self, tweak: &SecretKey) -> Result<(), Error> {
        if tweak.0.is_zero() {
            return Err(Error::TweakOutOfRange);
        }

        let mut r = Jacobian::default();
        let zero = Scalar::from_int(0);
        let pt = Jacobian::from_ge(&self.0);
        ECMULT_CONTEXT.ecmult(&mut r, &pt, &tweak.0, &zero);

        self.0.set_gej(&r);
        Ok(())
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,combine keys : & [ PublicKey ],"    pub fn combine(keys: &[PublicKey]) -> Result<Self, Error> {
        let mut qj = Jacobian::default();
        qj.set_infinity();

        for key in keys {
            qj = qj.add_ge(&key.0);
        }

        if qj.is_infinity() {
            return Err(Error::InvalidPublicKey);
        }

        let q = Affine::from_gej(&qj);
        Ok(PublicKey(q))
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,into self,"    fn into(self) -> Affine {
        self.0
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse p : & [ u8 ; util :: SECRET_KEY_SIZE ],"    pub fn parse(p: &[u8; util::SECRET_KEY_SIZE]) -> Result<SecretKey, Error> {
        let mut elem = Scalar::default();
        if !elem.set_b32(p) && !elem.is_zero() {
            Ok(SecretKey(elem))
        } else {
            Err(Error::InvalidSecretKey)
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse_slice p : & [ u8 ],"    pub fn parse_slice(p: &[u8]) -> Result<SecretKey, Error> {
        if p.len() != util::SECRET_KEY_SIZE {
            return Err(Error::InvalidInputLength);
        }

        let mut a = [0; 32];
        a.copy_from_slice(p);
        Self::parse(&a)
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,random rng : & mut R,"    pub fn random<R: Rng>(rng: &mut R) -> SecretKey {
        loop {
            let mut ret = [0u8; util::SECRET_KEY_SIZE];
            rng.fill_bytes(&mut ret);

            match Self::parse(&ret) {
                Ok(key) => return key,
                Err(_) => (),
            }
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,serialize & self,"    pub fn serialize(&self) -> [u8; util::SECRET_KEY_SIZE] {
        self.0.b32()
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,"tweak_add_assign & mut self , tweak : & SecretKey","    pub fn tweak_add_assign(&mut self, tweak: &SecretKey) -> Result<(), Error> {
        let v = &self.0 + &tweak.0;
        if v.is_zero() {
            return Err(Error::TweakOutOfRange);
        }
        self.0 = v;
        Ok(())
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,"tweak_mul_assign & mut self , tweak : & SecretKey","    pub fn tweak_mul_assign(&mut self, tweak: &SecretKey) -> Result<(), Error> {
        if tweak.0.is_zero() {
            return Err(Error::TweakOutOfRange);
        }

        self.0 *= &tweak.0;
        Ok(())
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,inv & self,"    pub fn inv(&self) -> Self {
        SecretKey(self.0.inv())
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,default,"    fn default() -> SecretKey {
        let mut elem = Scalar::default();
        let overflowed = elem.set_b32(
            &[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
              0x00,0x00,0x00,0x00,0x00,0x01]
        );
        debug_assert!(!overflowed);
        debug_assert!(!elem.is_zero());
        SecretKey(elem)
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,into self,"    fn into(self) -> Scalar {
        self.0.clone()
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,drop & mut self,"    fn drop(&mut self) {
        self.0.clear();
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse p : & [ u8 ; util :: SIGNATURE_SIZE ],"    pub fn parse(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {
        let mut r = Scalar::default();
        let mut s = Scalar::default();

        // Okay for signature to overflow
        let _ = r.set_b32(array_ref!(p, 0, 32));
        let _ = s.set_b32(array_ref!(p, 32, 32));

        Signature { r, s }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse_slice p : & [ u8 ],"    pub fn parse_slice(p: &[u8]) -> Result<Signature, Error> {
        if p.len() != util::SIGNATURE_SIZE {
            return Err(Error::InvalidInputLength);
        }

        let mut a = [0; util::SIGNATURE_SIZE];
        a.copy_from_slice(p);
        Ok(Self::parse(&a))
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse_der p : & [ u8 ],"    pub fn parse_der(p: &[u8]) -> Result<Signature, Error> {
        let mut decoder = der::Decoder::new(p);

        decoder.read_constructed_sequence()?;
        let rlen = decoder.read_len()?;

        if rlen != decoder.remaining_len() {
            return Err(Error::InvalidSignature);
        }

        let r = decoder.read_integer()?;
        let s = decoder.read_integer()?;

        if decoder.remaining_len() != 0 {
            return Err(Error::InvalidSignature);
        }

        Ok(Signature { r, s })
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse_der_lax p : & [ u8 ],"    pub fn parse_der_lax(p: &[u8]) -> Result<Signature, Error> {
        let mut decoder = der::Decoder::new(p);

        decoder.read_constructed_sequence()?;
        decoder.read_seq_len_lax()?;

        let r = decoder.read_integer_lax()?;
        let s = decoder.read_integer_lax()?;

        Ok(Signature { r, s })
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,normalize_s & mut self,"    pub fn normalize_s(&mut self) {
        if self.s.is_high() {
            let s = self.s.clone();
            self.s.neg_in_place(&s);
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,serialize & self,"    pub fn serialize(&self) -> [u8; util::SIGNATURE_SIZE] {
        let mut ret = [0u8; 64];
        self.r.fill_b32(array_mut_ref!(ret, 0, 32));
        self.s.fill_b32(array_mut_ref!(ret, 32, 32));
        ret
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,fill_scalar_with_leading_zero scalar : & Scalar,"        fn fill_scalar_with_leading_zero(scalar: &Scalar) -> [u8; 33] {
            let mut ret = [0u8; 33];
            scalar.fill_b32(array_mut_ref!(ret, 1, 32));
            ret
        }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,integer_slice full : & [ u8 ; 33 ],"        fn integer_slice(full: &[u8; 33]) -> &[u8] {
            let mut len = 33;
            while len > 1 &&
                full[full.len() - len] == 0 &&
                full[full.len() - len + 1] < 0x80
            {
                len -= 1;
            }
            &full[(full.len() - len)..]
        }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,serialize_der & self,"    pub fn serialize_der(&self) -> der::SignatureArray {
        fn fill_scalar_with_leading_zero(scalar: &Scalar) -> [u8; 33] {
            let mut ret = [0u8; 33];
            scalar.fill_b32(array_mut_ref!(ret, 1, 32));
            ret
        }

        let r_full = fill_scalar_with_leading_zero(&self.r);
        let s_full = fill_scalar_with_leading_zero(&self.s);

        fn integer_slice(full: &[u8; 33]) -> &[u8] {
            let mut len = 33;
            while len > 1 &&
                full[full.len() - len] == 0 &&
                full[full.len() - len + 1] < 0x80
            {
                len -= 1;
            }
            &full[(full.len() - len)..]
        }

        let r = integer_slice(&r_full);
        let s = integer_slice(&s_full);

        let mut ret = der::SignatureArray::new(6 + r.len() + s.len());
        {
            let l = ret.as_mut();
            l[0] = 0x30;
            l[1] = 4 + r.len() as u8 + s.len() as u8;
            l[2] = 0x02;
            l[3] = r.len() as u8;
            l[4..(4 + r.len())].copy_from_slice(r);
            l[4 + r.len()] = 0x02;
            l[5 + r.len()] = s.len() as u8;
            l[(6 + r.len())..(6 + r.len() + s.len())].copy_from_slice(s);
        }

        ret
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse p : & [ u8 ; util :: MESSAGE_SIZE ],"    pub fn parse(p: &[u8; util::MESSAGE_SIZE]) -> Message {
        let mut m = Scalar::default();

        // Okay for message to overflow.
        let _ = m.set_b32(p);

        Message(m)
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse_slice p : & [ u8 ],"    pub fn parse_slice(p: &[u8]) -> Result<Message, Error> {
        if p.len() != util::MESSAGE_SIZE {
            return Err(Error::InvalidInputLength);
        }

        let mut a = [0; util::MESSAGE_SIZE];
        a.copy_from_slice(p);
        Ok(Self::parse(&a))
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,serialize & self,"    pub fn serialize(&self) -> [u8; util::MESSAGE_SIZE] {
        self.0.b32()
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse p : u8,"    pub fn parse(p: u8) -> Result<RecoveryId, Error> {
        if p < 4 {
            Ok(RecoveryId(p))
        } else {
            Err(Error::InvalidRecoveryId)
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,parse_rpc p : u8,"    pub fn parse_rpc(p: u8) -> Result<RecoveryId, Error> {
        if p >= 27 && p < 27 + 4 {
            RecoveryId::parse(p - 27)
        } else {
            Err(Error::InvalidRecoveryId)
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,serialize & self,"    pub fn serialize(&self) -> u8 {
        self.0
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,into self,"    fn into(self) -> u8 {
        self.0
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,into self,"    fn into(self) -> i32 {
        self.0 as i32
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,"new pubkey : & PublicKey , seckey : & SecretKey","    pub fn new(pubkey: &PublicKey, seckey: &SecretKey) -> Result<SharedSecret, Error> {
        let inner = match ECMULT_CONTEXT.ecdh_raw(&pubkey.0, &seckey.0) {
            Some(val) => val,
            None => return Err(Error::InvalidSecretKey),
        };

        Ok(SharedSecret(inner))
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,as_ref & self,"    fn as_ref(&self) -> &[u8] {
        &self.0
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,drop & mut self,"    fn drop(&mut self) {
         unsafe {
            core::ptr::write_volatile(&mut self.0, [0u8; 32]);
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,"verify message : & Message , signature : & Signature , pubkey : & PublicKey","pub fn verify(message: &Message, signature: &Signature, pubkey: &PublicKey) -> bool {
    ECMULT_CONTEXT.verify_raw(&signature.r, &signature.s, &pubkey.0, &message.0)
}",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,"recover message : & Message , signature : & Signature , recovery_id : & RecoveryId","pub fn recover(message: &Message, signature: &Signature, recovery_id: &RecoveryId) -> Result<PublicKey, Error> {
    ECMULT_CONTEXT.recover_raw(&signature.r, &signature.s, recovery_id.0, &message.0).map(|v| PublicKey(v))
}",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,lib.rs,Rust,"sign message : & Message , seckey : & SecretKey","pub fn sign(message: &Message, seckey: &SecretKey) -> (Signature, RecoveryId) {
    let seckey_b32 = seckey.0.b32();
    let message_b32 = message.0.b32();

    let mut drbg = HmacDRBG::<Sha256>::new(&seckey_b32, &message_b32, &[]);
    let mut nonce = Scalar::default();
    let mut overflow;

    let result;
    loop {
        let generated = drbg.generate::<U32>(None);
        overflow = nonce.set_b32(array_ref!(generated, 0, 32));

        if !overflow && !nonce.is_zero() {
            match ECMULT_GEN_CONTEXT.sign_raw(&seckey.0, &message.0, &nonce) {
                Ok(val) => {
                    result = val;
                    break
                },
                Err(_) => (),
            }
        }
    }

    #[allow(unused_assignments)]
    {
        nonce = Scalar::default();
    }
    let (sigr, sigs, recid) = result;

    (Signature {
        r: sigr,
        s: sigs,
    }, RecoveryId(recid))
}",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,check_overflow & self,"    fn check_overflow(&self) -> bool {
        let mut yes: bool = false;
        let mut no: bool = false;
        no = no || (self.0[7] < SECP256K1_N_7); /* No need for a > check. */
        no = no || (self.0[6] < SECP256K1_N_6); /* No need for a > check. */
        no = no || (self.0[5] < SECP256K1_N_5); /* No need for a > check. */
        no = no || (self.0[4] < SECP256K1_N_4);
        yes = yes || ((self.0[4] > SECP256K1_N_4) && !no);
        no = no || ((self.0[3] < SECP256K1_N_3) && !yes);
        yes = yes || ((self.0[3] > SECP256K1_N_3) && !no);
        no = no || ((self.0[2] < SECP256K1_N_2) && !yes);
        yes = yes || ((self.0[2] > SECP256K1_N_2) && !no);
        no = no || ((self.0[1] < SECP256K1_N_1) && !yes);
        yes = yes || ((self.0[1] > SECP256K1_N_1) && !no);
        yes = yes || ((self.0[0] >= SECP256K1_N_0) && !no);
        return yes;
    }",1,True,False,"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,check_overflow & self,"    fn check_overflow(&self) -> bool {
        let mut yes: Choice = 0.into();
        let mut no: Choice = 0.into();
        no |= Choice::from((self.0[7] < SECP256K1_N_7) as u8); /* No need for a > check. */
        no |= Choice::from((self.0[6] < SECP256K1_N_6) as u8); /* No need for a > check. */
        no |= Choice::from((self.0[5] < SECP256K1_N_5) as u8); /* No need for a > check. */
        no |= Choice::from((self.0[4] < SECP256K1_N_4) as u8);
        yes |= Choice::from((self.0[4] > SECP256K1_N_4) as u8) & !no;
        no |= Choice::from((self.0[3] < SECP256K1_N_3) as u8) & !yes;
        yes |= Choice::from((self.0[3] > SECP256K1_N_3) as u8) & !no;
        no |= Choice::from((self.0[2] < SECP256K1_N_2) as u8) & !yes;
        yes |= Choice::from((self.0[2] > SECP256K1_N_2) as u8) & !no;
        no |= Choice::from((self.0[1] < SECP256K1_N_1) as u8) & !yes;
        yes |= Choice::from((self.0[1] > SECP256K1_N_1) as u8) & !no;
        yes |= Choice::from((self.0[0] >= SECP256K1_N_0) as u8) & !no;
        return yes.into();
    }",0,False,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,clear & mut self,"    pub fn clear(&mut self) {
        unsafe {
            core::ptr::write_volatile(&mut self.0, [0u32; 8]);
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"set_int & mut self , v : u32","    pub fn set_int(&mut self, v: u32) {
        self.0 = [v, 0, 0, 0, 0, 0, 0, 0];
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,from_int v : u32,"    pub fn from_int(v: u32) -> Self {
        let mut scalar = Self::default();
        scalar.set_int(v);
        scalar
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"bits & self , offset : usize , count : usize","    pub fn bits(&self, offset: usize, count: usize) -> u32 {
        debug_assert!((offset + count - 1) >> 5 == offset >> 5);
        (self.0[offset >> 5] >> (offset & 0x1F)) & ((1 << count) - 1)
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"bits_var & self , offset : usize , count : usize","    pub fn bits_var(&self, offset: usize, count: usize) -> u32 {
        debug_assert!(count < 32);
        debug_assert!(offset + count <= 256);
        if (offset + count - 1) >> 5 == offset >> 5 {
            return self.bits(offset, count);
        } else {
            debug_assert!((offset >> 5) + 1 < 8);
            return ((self.0[offset >> 5] >> (offset & 0x1f)) | (self.0[(offset >> 5) + 1] << (32 - (offset & 0x1f)))) & ((1 << count) - 1);
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"reduce & mut self , overflow : bool","    fn reduce(&mut self, overflow: bool) -> bool {
        let o: u64 = if overflow { 1 } else { 0 };
        let mut t: u64;
        t = (self.0[0] as u64) + o * (SECP256K1_N_C_0 as u64);
        self.0[0] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[1] as u64) + o * (SECP256K1_N_C_1 as u64);
        self.0[1] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[2] as u64) + o * (SECP256K1_N_C_2 as u64);
        self.0[2] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[3] as u64) + o * (SECP256K1_N_C_3 as u64);
        self.0[3] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[4] as u64) + o * (SECP256K1_N_C_4 as u64);
        self.0[4] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += self.0[5] as u64;
        self.0[5] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += self.0[6] as u64;
        self.0[6] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += self.0[7] as u64;
        self.0[7] = (t & 0xFFFFFFFF) as u32;
        overflow
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"add_in_place & mut self , a : & Scalar , b : & Scalar","    pub fn add_in_place(&mut self, a: &Scalar, b: &Scalar) -> bool {
        let mut overflow: u64;
        let mut t: u64 = (a.0[0] as u64) + (b.0[0] as u64);
        self.0[0] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[1] as u64) + (b.0[1] as u64);
        self.0[1] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[2] as u64) + (b.0[2] as u64);
        self.0[2] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[3] as u64) + (b.0[3] as u64);
        self.0[3] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[4] as u64) + (b.0[4] as u64);
        self.0[4] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[5] as u64) + (b.0[5] as u64);
        self.0[5] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[6] as u64) + (b.0[6] as u64);
        self.0[6] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (a.0[7] as u64) + (b.0[7] as u64);
        self.0[7] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        overflow = t + if self.check_overflow() { 1 } else { 0 };
        debug_assert!(overflow == 0 || overflow == 1);
        overflow = overflow | if self.reduce(overflow == 1) { 1 } else { 0 };
        return overflow == 1;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"cadd_bit & mut self , mut bit : usize , flag : bool","    pub fn cadd_bit(&mut self, mut bit: usize, flag: bool) {
        let mut t: u64;
        debug_assert!(bit < 256);
        bit += if flag { 0 } else { usize::max_value() } & 0x100;
        t = (self.0[0] as u64) + ((if (bit >> 5) == 0 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[0] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[1] as u64) + ((if (bit >> 5) == 1 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[1] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[2] as u64) + ((if (bit >> 5) == 2 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[2] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[3] as u64) + ((if (bit >> 5) == 3 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[3] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[4] as u64) + ((if (bit >> 5) == 4 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[4] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[5] as u64) + ((if (bit >> 5) == 5 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[5] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[6] as u64) + ((if (bit >> 5) == 6 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[6] = (t & 0xFFFFFFFF) as u32; t >>= 32;
        t += (self.0[7] as u64) + ((if (bit >> 5) == 7 { 1 } else { 0 }) << (bit & 0x1F));
        self.0[7] = (t & 0xFFFFFFFF) as u32;
        debug_assert!((t >> 32) == 0);
        debug_assert!(!self.check_overflow());
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"set_b32 & mut self , b32 : & [ u8 ; 32 ]","    pub fn set_b32(&mut self, b32: &[u8; 32]) -> bool {
        self.0[0] = (b32[31] as u32) | ((b32[30] as u32) << 8) | ((b32[29] as u32) << 16) | ((b32[28] as u32) << 24);
        self.0[1] = (b32[27] as u32) | ((b32[26] as u32) << 8) | ((b32[25] as u32) << 16) | ((b32[24] as u32) << 24);
        self.0[2] = (b32[23] as u32) | ((b32[22] as u32) << 8) | ((b32[21] as u32) << 16) | ((b32[20] as u32) << 24);
        self.0[3] = (b32[19] as u32) | ((b32[18] as u32) << 8) | ((b32[17] as u32) << 16) | ((b32[16] as u32) << 24);
        self.0[4] = (b32[15] as u32) | ((b32[14] as u32) << 8) | ((b32[13] as u32) << 16) | ((b32[12] as u32) << 24);
        self.0[5] = (b32[11] as u32) | ((b32[10] as u32) << 8) | ((b32[9] as u32) << 16) | ((b32[8] as u32) << 24);
        self.0[6] = (b32[7] as u32) | ((b32[6] as u32) << 8) | ((b32[5] as u32) << 16) | ((b32[4] as u32) << 24);
        self.0[7] = (b32[3] as u32) | ((b32[2] as u32) << 8) | ((b32[1] as u32) << 16) | ((b32[0] as u32) << 24);

        let overflow = self.check_overflow();
        self.reduce(overflow)
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,b32 & self,"    pub fn b32(&self) -> [u8; 32] {
        let mut bin = [0u8; 32];
        self.fill_b32(&mut bin);
        bin
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"fill_b32 & self , bin : & mut [ u8 ; 32 ]","    pub fn fill_b32(&self, bin: &mut [u8; 32]) {
        bin[0] = (self.0[7] >> 24) as u8; bin[1] = (self.0[7] >> 16) as u8; bin[2] = (self.0[7] >> 8) as u8; bin[3] = (self.0[7]) as u8;
        bin[4] = (self.0[6] >> 24) as u8; bin[5] = (self.0[6] >> 16) as u8; bin[6] = (self.0[6] >> 8) as u8; bin[7] = (self.0[6]) as u8;
        bin[8] = (self.0[5] >> 24) as u8; bin[9] = (self.0[5] >> 16) as u8; bin[10] = (self.0[5] >> 8) as u8; bin[11] = (self.0[5]) as u8;
        bin[12] = (self.0[4] >> 24) as u8; bin[13] = (self.0[4] >> 16) as u8; bin[14] = (self.0[4] >> 8) as u8; bin[15] = (self.0[4]) as u8;
        bin[16] = (self.0[3] >> 24) as u8; bin[17] = (self.0[3] >> 16) as u8; bin[18] = (self.0[3] >> 8) as u8; bin[19] = (self.0[3]) as u8;
        bin[20] = (self.0[2] >> 24) as u8; bin[21] = (self.0[2] >> 16) as u8; bin[22] = (self.0[2] >> 8) as u8; bin[23] = (self.0[2]) as u8;
        bin[24] = (self.0[1] >> 24) as u8; bin[25] = (self.0[1] >> 16) as u8; bin[26] = (self.0[1] >> 8) as u8; bin[27] = (self.0[1]) as u8;
        bin[28] = (self.0[0] >> 24) as u8; bin[29] = (self.0[0] >> 16) as u8; bin[30] = (self.0[0] >> 8) as u8; bin[31] = (self.0[0]) as u8;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,is_zero & self,"    pub fn is_zero(&self) -> bool {
        (self.0[0] | self.0[1] | self.0[2] | self.0[3] | self.0[4] | self.0[5] | self.0[6] | self.0[7]) == 0
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"neg_in_place & mut self , a : & Scalar","    pub fn neg_in_place(&mut self, a: &Scalar) {
        let nonzero: u64 = 0xFFFFFFFF * if !a.is_zero() { 1 } else { 0 };
        let mut t: u64 = (!a.0[0]) as u64 + (SECP256K1_N_0 + 1) as u64;
        self.0[0] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[1]) as u64 + SECP256K1_N_1 as u64;
        self.0[1] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[2]) as u64 + SECP256K1_N_2 as u64;
        self.0[2] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[3]) as u64 + SECP256K1_N_3 as u64;
        self.0[3] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[4]) as u64 + SECP256K1_N_4 as u64;
        self.0[4] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[5]) as u64 + SECP256K1_N_5 as u64;
        self.0[5] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[6]) as u64 + SECP256K1_N_6 as u64;
        self.0[6] = (t & nonzero) as u32; t >>= 32;
        t += (!a.0[7]) as u64 + SECP256K1_N_7 as u64;
        self.0[7] = (t & nonzero) as u32;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,neg & self,"    pub fn neg(&self) -> Scalar {
        let mut ret = Scalar::default();
        ret.neg_in_place(self);
        ret
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,is_one & self,"    pub fn is_one(&self) -> bool {
        ((self.0[0] ^ 1) |  self.0[1] | self.0[2] | self.0[3] | self.0[4] | self.0[5] | self.0[6] | self.0[7]) == 0
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,is_high & self,"    pub fn is_high(&self) -> bool {
        let mut yes: bool = false;
        let mut no: bool = false;
        no = no || (self.0[7] < SECP256K1_N_H_7);
        yes = yes || ((self.0[7] > SECP256K1_N_H_7) & !no);
        no = no || ((self.0[6] < SECP256K1_N_H_6) & !yes); /* No need for a > check. */
        no = no || ((self.0[5] < SECP256K1_N_H_5) & !yes); /* No need for a > check. */
        no = no || ((self.0[4] < SECP256K1_N_H_4) & !yes); /* No need for a > check. */
        no = no || ((self.0[3] < SECP256K1_N_H_3) & !yes);
        yes = yes || ((self.0[3] > SECP256K1_N_H_3) && !no);
        no = no || ((self.0[2] < SECP256K1_N_H_2) && !yes);
        yes = yes || ((self.0[2] > SECP256K1_N_H_2) && !no);
        no = no || ((self.0[1] < SECP256K1_N_H_1) && !yes);
        yes = yes || ((self.0[1] > SECP256K1_N_H_1) && !no);
        yes = yes || ((self.0[0] >= SECP256K1_N_H_0) && !no);
        return yes;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"cond_neg_mut & mut self , flag : bool","    pub fn cond_neg_mut(&mut self, flag: bool) -> isize {
        let mask = if flag { u32::max_value() } else { 0 };
        let nonzero: u64 = 0xFFFFFFFF * if !self.is_zero() { 1 } else { 0 };
        let mut t: u64 = (self.0[0] ^ mask) as u64 + ((SECP256K1_N_0 + 1) & mask) as u64;
        self.0[0] = (t & nonzero) as u32; t >>= 32;
        t += (self.0[1] ^ mask) as u64 + (SECP256K1_N_1 & mask) as u64;
        self.0[1] = (t & nonzero) as u32; t >>= 32;
        t += (self.0[2] ^ mask) as u64 + (SECP256K1_N_2 & mask) as u64;
        self.0[2] = (t & nonzero) as u32; t >>= 32;
        t += (self.0[3] ^ mask) as u64 + (SECP256K1_N_3 & mask) as u64;
        self.0[3] = (t & nonzero) as u32; t >>= 32;
        t += (self.0[4] ^ mask) as u64 + (SECP256K1_N_4 & mask) as u64;
        self.0[4] = (t & nonzero) as u32; t >>= 32;
        t += (self.0[5] ^ mask) as u64 + (SECP256K1_N_5 & mask) as u64;
        self.0[5] = (t & nonzero) as u32; t >>= 32;
        t += (self.0[6] ^ mask) as u64 + (SECP256K1_N_6 & mask) as u64;
        self.0[6] = (t & nonzero) as u32; t >>= 32;
        t += (self.0[7] ^ mask) as u64 + (SECP256K1_N_7 & mask) as u64;
        self.0[7] = (t & nonzero) as u32;

        if mask == 0 {
            return 1;
        } else {
            return -1;
        }
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"reduce_512 & mut self , l : & [ u32 ; 16 ]","    fn reduce_512(&mut self, l: &[u32; 16]) {
        let (mut c0, mut c1, mut c2): (u32, u32, u32);
        define_ops!(c0, c1, c2);

        let mut c: u64;
        let (n0, n1, n2, n3, n4, n5, n6, n7) = (l[8], l[9], l[10], l[11], l[12], l[13], l[14], l[15]);
        let (m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12): (u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32, u32);
        let (p0, p1, p2, p3, p4, p5, p6, p7, p8): (u32, u32, u32, u32, u32, u32, u32, u32, u32);

        c0 = l[0]; c1 = 0; c2 = 0;
        muladd_fast!(n0, SECP256K1_N_C_0);
        m0 = extract_fast!();
        sumadd_fast!(l[1]);
        muladd!(n1, SECP256K1_N_C_0);
        muladd!(n0, SECP256K1_N_C_1);
        m1 = extract!();
        sumadd!(l[2]);
        muladd!(n2, SECP256K1_N_C_0);
        muladd!(n1, SECP256K1_N_C_1);
        muladd!(n0, SECP256K1_N_C_2);
        m2 = extract!();
        sumadd!(l[3]);
        muladd!(n3, SECP256K1_N_C_0);
        muladd!(n2, SECP256K1_N_C_1);
        muladd!(n1, SECP256K1_N_C_2);
        muladd!(n0, SECP256K1_N_C_3);
        m3 = extract!();
        sumadd!(l[4]);
        muladd!(n4, SECP256K1_N_C_0);
        muladd!(n3, SECP256K1_N_C_1);
        muladd!(n2, SECP256K1_N_C_2);
        muladd!(n1, SECP256K1_N_C_3);
        sumadd!(n0);
        m4 = extract!();
        sumadd!(l[5]);
        muladd!(n5, SECP256K1_N_C_0);
        muladd!(n4, SECP256K1_N_C_1);
        muladd!(n3, SECP256K1_N_C_2);
        muladd!(n2, SECP256K1_N_C_3);
        sumadd!(n1);
        m5 = extract!();
        sumadd!(l[6]);
        muladd!(n6, SECP256K1_N_C_0);
        muladd!(n5, SECP256K1_N_C_1);
        muladd!(n4, SECP256K1_N_C_2);
        muladd!(n3, SECP256K1_N_C_3);
        sumadd!(n2);
        m6 = extract!();
        sumadd!(l[7]);
        muladd!(n7, SECP256K1_N_C_0);
        muladd!(n6, SECP256K1_N_C_1);
        muladd!(n5, SECP256K1_N_C_2);
        muladd!(n4, SECP256K1_N_C_3);
        sumadd!(n3);
        m7 = extract!();
        muladd!(n7, SECP256K1_N_C_1);
        muladd!(n6, SECP256K1_N_C_2);
        muladd!(n5, SECP256K1_N_C_3);
        sumadd!(n4);
        m8 = extract!();
        muladd!(n7, SECP256K1_N_C_2);
        muladd!(n6, SECP256K1_N_C_3);
        sumadd!(n5);
        m9 = extract!();
        muladd!(n7, SECP256K1_N_C_3);
        sumadd!(n6);
        m10 = extract!();
        sumadd_fast!(n7);
        m11 = extract_fast!();
        debug_assert!(c0 <= 1);
        m12 = c0;

        /* Reduce 385 bits into 258. */
        /* p[0..8] = m[0..7] + m[8..12] * SECP256K1_N_C. */
        c0 = m0; c1 = 0; c2 = 0;
        muladd_fast!(m8, SECP256K1_N_C_0);
        p0 = extract_fast!();
        sumadd_fast!(m1);
        muladd!(m9, SECP256K1_N_C_0);
        muladd!(m8, SECP256K1_N_C_1);
        p1 = extract!();
        sumadd!(m2);
        muladd!(m10, SECP256K1_N_C_0);
        muladd!(m9, SECP256K1_N_C_1);
        muladd!(m8, SECP256K1_N_C_2);
        p2 = extract!();
        sumadd!(m3);
        muladd!(m11, SECP256K1_N_C_0);
        muladd!(m10, SECP256K1_N_C_1);
        muladd!(m9, SECP256K1_N_C_2);
        muladd!(m8, SECP256K1_N_C_3);
        p3 = extract!();
        sumadd!(m4);
        muladd!(m12, SECP256K1_N_C_0);
        muladd!(m11, SECP256K1_N_C_1);
        muladd!(m10, SECP256K1_N_C_2);
        muladd!(m9, SECP256K1_N_C_3);
        sumadd!(m8);
        p4 = extract!();
        sumadd!(m5);
        muladd!(m12, SECP256K1_N_C_1);
        muladd!(m11, SECP256K1_N_C_2);
        muladd!(m10, SECP256K1_N_C_3);
        sumadd!(m9);
        p5 = extract!();
        sumadd!(m6);
        muladd!(m12, SECP256K1_N_C_2);
        muladd!(m11, SECP256K1_N_C_3);
        sumadd!(m10);
        p6 = extract!();
        sumadd_fast!(m7);
        muladd_fast!(m12, SECP256K1_N_C_3);
        sumadd_fast!(m11);
        p7 = extract_fast!();
        p8 = c0 + m12;
        debug_assert!(p8 <= 2);

        /* Reduce 258 bits into 256. */
        /* r[0..7] = p[0..7] + p[8] * SECP256K1_N_C. */
        c = p0 as u64 + SECP256K1_N_C_0 as u64 * p8 as u64;
        self.0[0] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p1 as u64 + SECP256K1_N_C_1 as u64 * p8 as u64;
        self.0[1] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p2 as u64 + SECP256K1_N_C_2 as u64 * p8 as u64;
        self.0[2] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p3 as u64 + SECP256K1_N_C_3 as u64 * p8 as u64;
        self.0[3] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p4 as u64 + p8 as u64;
        self.0[4] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p5 as u64;
        self.0[5] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p6 as u64;
        self.0[6] = (c & 0xFFFFFFFF) as u32; c >>= 32;
        c += p7 as u64;
        self.0[7] = (c & 0xFFFFFFFF) as u32; c >>= 32;

        let overflow = self.check_overflow();
        debug_assert!(c + if overflow { 1 } else { 0 } <= 1);
        let _ = self.reduce(c + if overflow { 1 } else { 0 } == 1);
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"mul_512 & self , b : & Scalar , l : & mut [ u32 ; 16 ]","    fn mul_512(&self, b: &Scalar, l: &mut [u32; 16]) {
        let (mut c0, mut c1, mut c2): (u32, u32, u32) = (0, 0, 0);
        define_ops!(c0, c1, c2);

        /* l[0..15] = a[0..7] * b[0..7]. */
        muladd_fast!(self.0[0], b.0[0]);
        l[0] = extract_fast!();
        muladd!(self.0[0], b.0[1]);
        muladd!(self.0[1], b.0[0]);
        l[1] = extract!();
        muladd!(self.0[0], b.0[2]);
        muladd!(self.0[1], b.0[1]);
        muladd!(self.0[2], b.0[0]);
        l[2] = extract!();
        muladd!(self.0[0], b.0[3]);
        muladd!(self.0[1], b.0[2]);
        muladd!(self.0[2], b.0[1]);
        muladd!(self.0[3], b.0[0]);
        l[3] = extract!();
        muladd!(self.0[0], b.0[4]);
        muladd!(self.0[1], b.0[3]);
        muladd!(self.0[2], b.0[2]);
        muladd!(self.0[3], b.0[1]);
        muladd!(self.0[4], b.0[0]);
        l[4] = extract!();
        muladd!(self.0[0], b.0[5]);
        muladd!(self.0[1], b.0[4]);
        muladd!(self.0[2], b.0[3]);
        muladd!(self.0[3], b.0[2]);
        muladd!(self.0[4], b.0[1]);
        muladd!(self.0[5], b.0[0]);
        l[5] = extract!();
        muladd!(self.0[0], b.0[6]);
        muladd!(self.0[1], b.0[5]);
        muladd!(self.0[2], b.0[4]);
        muladd!(self.0[3], b.0[3]);
        muladd!(self.0[4], b.0[2]);
        muladd!(self.0[5], b.0[1]);
        muladd!(self.0[6], b.0[0]);
        l[6] = extract!();
        muladd!(self.0[0], b.0[7]);
        muladd!(self.0[1], b.0[6]);
        muladd!(self.0[2], b.0[5]);
        muladd!(self.0[3], b.0[4]);
        muladd!(self.0[4], b.0[3]);
        muladd!(self.0[5], b.0[2]);
        muladd!(self.0[6], b.0[1]);
        muladd!(self.0[7], b.0[0]);
        l[7] = extract!();
        muladd!(self.0[1], b.0[7]);
        muladd!(self.0[2], b.0[6]);
        muladd!(self.0[3], b.0[5]);
        muladd!(self.0[4], b.0[4]);
        muladd!(self.0[5], b.0[3]);
        muladd!(self.0[6], b.0[2]);
        muladd!(self.0[7], b.0[1]);
        l[8] = extract!();
        muladd!(self.0[2], b.0[7]);
        muladd!(self.0[3], b.0[6]);
        muladd!(self.0[4], b.0[5]);
        muladd!(self.0[5], b.0[4]);
        muladd!(self.0[6], b.0[3]);
        muladd!(self.0[7], b.0[2]);
        l[9] = extract!();
        muladd!(self.0[3], b.0[7]);
        muladd!(self.0[4], b.0[6]);
        muladd!(self.0[5], b.0[5]);
        muladd!(self.0[6], b.0[4]);
        muladd!(self.0[7], b.0[3]);
        l[10] = extract!();
        muladd!(self.0[4], b.0[7]);
        muladd!(self.0[5], b.0[6]);
        muladd!(self.0[6], b.0[5]);
        muladd!(self.0[7], b.0[4]);
        l[11] = extract!();
        muladd!(self.0[5], b.0[7]);
        muladd!(self.0[6], b.0[6]);
        muladd!(self.0[7], b.0[5]);
        l[12] = extract!();
        muladd!(self.0[6], b.0[7]);
        muladd!(self.0[7], b.0[6]);
        l[13] = extract!();
        muladd_fast!(self.0[7], b.0[7]);
        l[14] = extract_fast!();
        debug_assert!(c1 == 0);
        l[15] = c0;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"sqr_512 & self , l : & mut [ u32 ; 16 ]","    fn sqr_512(&self, l: &mut [u32; 16]) {
        let (mut c0, mut c1, mut c2): (u32, u32, u32) = (0, 0, 0);
        define_ops!(c0, c1, c2);

        /* l[0..15] = a[0..7]^2. */
        muladd_fast!(self.0[0], self.0[0]);
        l[0] = extract_fast!();
        muladd2!(self.0[0], self.0[1]);
        l[1] = extract!();
        muladd2!(self.0[0], self.0[2]);
        muladd!(self.0[1], self.0[1]);
        l[2] = extract!();
        muladd2!(self.0[0], self.0[3]);
        muladd2!(self.0[1], self.0[2]);
        l[3] = extract!();
        muladd2!(self.0[0], self.0[4]);
        muladd2!(self.0[1], self.0[3]);
        muladd!(self.0[2], self.0[2]);
        l[4] = extract!();
        muladd2!(self.0[0], self.0[5]);
        muladd2!(self.0[1], self.0[4]);
        muladd2!(self.0[2], self.0[3]);
        l[5] = extract!();
        muladd2!(self.0[0], self.0[6]);
        muladd2!(self.0[1], self.0[5]);
        muladd2!(self.0[2], self.0[4]);
        muladd!(self.0[3], self.0[3]);
        l[6] = extract!();
        muladd2!(self.0[0], self.0[7]);
        muladd2!(self.0[1], self.0[6]);
        muladd2!(self.0[2], self.0[5]);
        muladd2!(self.0[3], self.0[4]);
        l[7] = extract!();
        muladd2!(self.0[1], self.0[7]);
        muladd2!(self.0[2], self.0[6]);
        muladd2!(self.0[3], self.0[5]);
        muladd!(self.0[4], self.0[4]);
        l[8] = extract!();
        muladd2!(self.0[2], self.0[7]);
        muladd2!(self.0[3], self.0[6]);
        muladd2!(self.0[4], self.0[5]);
        l[9] = extract!();
        muladd2!(self.0[3], self.0[7]);
        muladd2!(self.0[4], self.0[6]);
        muladd!(self.0[5], self.0[5]);
        l[10] = extract!();
        muladd2!(self.0[4], self.0[7]);
        muladd2!(self.0[5], self.0[6]);
        l[11] = extract!();
        muladd2!(self.0[5], self.0[7]);
        muladd!(self.0[6], self.0[6]);
        l[12] = extract!();
        muladd2!(self.0[6], self.0[7]);
        l[13] = extract!();
        muladd_fast!(self.0[7], self.0[7]);
        l[14] = extract_fast!();
        debug_assert!(c1 == 0);
        l[15] = c0;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"mul_in_place & mut self , a : & Scalar , b : & Scalar","    pub fn mul_in_place(&mut self, a: &Scalar, b: &Scalar) {
        let mut l = [0u32; 16];
        a.mul_512(b, &mut l);
        self.reduce_512(&l);
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"shr_int & mut self , n : usize","    pub fn shr_int(&mut self, n: usize) -> u32 {
        let ret: u32;
        debug_assert!(n > 0);
        debug_assert!(n < 16);
        ret = self.0[0] & ((1 << n) - 1);
        self.0[0] = (self.0[0] >> n) + (self.0[1] << (32 - n));
        self.0[1] = (self.0[1] >> n) + (self.0[2] << (32 - n));
        self.0[2] = (self.0[2] >> n) + (self.0[3] << (32 - n));
        self.0[3] = (self.0[3] >> n) + (self.0[4] << (32 - n));
        self.0[4] = (self.0[4] >> n) + (self.0[5] << (32 - n));
        self.0[5] = (self.0[5] >> n) + (self.0[6] << (32 - n));
        self.0[6] = (self.0[6] >> n) + (self.0[7] << (32 - n));
        self.0[7] = self.0[7] >> n;
        return ret;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"sqr_in_place & mut self , a : & Scalar","    pub fn sqr_in_place(&mut self, a: &Scalar) {
        let mut l = [0u32; 16];
        a.sqr_512(&mut l);
        self.reduce_512(&l);
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,sqr & self,"    pub fn sqr(&self) -> Scalar {
        let mut ret = Scalar::default();
        ret.sqr_in_place(self);
        ret
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"inv_in_place & mut self , x : & Scalar","    pub fn inv_in_place(&mut self, x: &Scalar) {
        let u2 = x.sqr();
        let x2 = &u2 * x;
        let u5 = &u2 * &x2;
        let x3 = &u5 * &u2;
        let u9 = &x3 * &u2;
        let u11 = &u9 * &u2;
        let u13 = &u11 * &u2;

        let mut x6 = u13.sqr();
        x6 = x6.sqr();
        x6 *= &u11;

        let mut x8 = x6.sqr();
        x8 = x8.sqr();
        x8 *= &x2;

        let mut x14 = x8.sqr();
        for _ in 0..5 {
            x14 = x14.sqr();
        }
        x14 *= &x6;

        let mut x28 = x14.sqr();
        for _ in 0..13 {
            x28 = x28.sqr();
        }
        x28 *= &x14;

        let mut x56 = x28.sqr();
        for _ in 0..27 {
            x56 = x56.sqr();
        }
        x56 *= &x28;

        let mut x112 = x56.sqr();
        for _ in 0..55 {
            x112 = x112.sqr();
        }
        x112 *= &x56;

        let mut x126 = x112.sqr();
        for _ in 0..13 {
            x126 = x126.sqr();
        }
        x126 *= &x14;

        let mut t = x126;
        for _ in 0..3 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &u11;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u11;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..3 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &u9;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u5;
        for _ in 0..10 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &x3;
        for _ in 0..9 {
            t = t.sqr();
        }
        t *= &x8;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &u9;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u11;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..5 {
            t = t.sqr();
        }
        t *= &x2;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..10 {
            t = t.sqr();
        }
        t *= &u13;
        for _ in 0..4 {
            t = t.sqr();
        }
        t *= &u9;
        for _ in 0..6 {
            t = t.sqr();
        }
        t *= x;
        for _ in 0..8 {
            t = t.sqr();
        }
        *self = &t * &x6;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,inv & self,"    pub fn inv(&self) -> Scalar {
        let mut ret = Scalar::default();
        ret.inv_in_place(self);
        ret
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,inv_var & self,"    pub fn inv_var(&self) -> Scalar {
        self.inv()
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,is_even & self,"    pub fn is_even(&self) -> bool {
        return self.0[0] & 1 == 0;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,default,"    fn default() -> Scalar {
        Scalar([0u32; 8])
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"add self , other : Scalar","    fn add(self, other: Scalar) -> Scalar {
        let mut ret = Scalar::default();
        let _ = ret.add_in_place(&self, &other);
        ret
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"add self , other : & 'a Scalar) -> Scalar {
        let mut ret = Scalar::default();
        let _ = ret.add_in_place(self, other);
        ret
    }
}

impl<' a > AddAssign < & 'a Scalar> for Scalar {
    fn add_assign(&mut self, other: &' a Scalar","    fn add(self, other: &'a Scalar) -> Scalar {
        let mut ret = Scalar::default();
        let _ = ret.add_in_place(self, other);
        ret
    }
}

impl<'a> AddAssign<&'a Scalar> for Scalar {
    fn add_assign(&mut self, other: &'a Scalar) {
        let mut ret = Scalar::default();
        let _ = ret.add_in_place(self, other);
        *self = ret;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"add_assign & mut self , other : Scalar","    fn add_assign(&mut self, other: Scalar) {
        self.add_assign(&other)
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"mul self , other : Scalar","    fn mul(self, other: Scalar) -> Scalar {
        let mut ret = Scalar::default();
        ret.mul_in_place(&self, &other);
        ret
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"mul self , other : & 'a Scalar) -> Scalar {
        let mut ret = Scalar::default();
        ret.mul_in_place(self, other);
        ret
    }
}

impl<' a > MulAssign < & 'a Scalar> for Scalar {
    fn mul_assign(&mut self, other: &' a Scalar","    fn mul(self, other: &'a Scalar) -> Scalar {
        let mut ret = Scalar::default();
        ret.mul_in_place(self, other);
        ret
    }
}

impl<'a> MulAssign<&'a Scalar> for Scalar {
    fn mul_assign(&mut self, other: &'a Scalar) {
        let mut ret = Scalar::default();
        ret.mul_in_place(self, other);
        *self = ret;
    }",0,True,False,
https://github.com/paritytech/libsecp256k1.git,11ba23a9766a5079918cd9f515bc100bc8164b50,Wei Tang,2019-10-02 18:31:32-07:00,False,scalar.rs,Rust,"mul_assign & mut self , other : Scalar","    fn mul_assign(&mut self, other: Scalar) {
        self.mul_assign(&other)
    }",0,True,False,
https://github.com/waycrate/swhkd.git,b4e6dc76f4845ab03104187a42ac6d1bbc1e0021,Shinyzenith,2022-03-25 20:28:47+05:18,False,daemon.rs,Rust,main,"async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = set_command_line_args().get_matches();
    env::set_var(""RUST_LOG"", ""swhkd=warn"");

    if args.is_present(""debug"") {
        env::set_var(""RUST_LOG"", ""swhkd=trace"");
    }

    env_logger::init();
    log::trace!(""Logger initialized."");

    let pidfile: String = String::from(""/tmp/swhkd.pid"");
    if Path::new(&pidfile).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pidfile);
        let swhkd_pid = match fs::read_to_string(&pidfile) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Swhkd is already running!"");
                log::error!(""pid of existing swhkd process: {}"", pid.to_string());
                log::error!(""To close the existing swhkd process, run `sudo killall swhkd`"");
                exit(1);
            }
        }
    }

    match fs::write(&pidfile, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pidfile, e);
            exit(1);
        }
    }

    if check_user_permissions().is_err() {
        exit(1);
    }

    let load_config = || {
        let config_file_path: std::path::PathBuf = if args.is_present(""config"") {
            Path::new(args.value_of(""config"").unwrap()).to_path_buf()
        } else {
            fetch_xdg_config_path()
        };

        log::debug!(""Using config file path: {:#?}"", config_file_path);

        if !config_file_path.exists() {
            log::error!(""{:#?} doesn't exist"", config_file_path);
            exit(1);
        }

        let hotkeys = match config::load(&config_file_path) {
            Err(e) => {
                log::error!(""Config Error: {}"", e);
                exit(1);
            }
            Ok(out) => out,
        };

        for hotkey in &hotkeys {
            log::debug!(""hotkey: {:#?}"", hotkey);
        }

        hotkeys
    };

    let mut hotkeys = load_config();

    log::trace!(""Attempting to find all keyboard file descriptors."");
    let keyboard_devices: Vec<Device> =
        evdev::enumerate().filter(check_device_is_keyboard).collect();

    let mut uinput_device = match uinput::create_uinput_device() {
        Ok(dev) => dev,
        Err(e) => {
            log::error!(""Err: {:#?}"", e);
            exit(1);
        }
    };

    if keyboard_devices.is_empty() {
        log::error!(""No valid keyboard device was detected!"");
        exit(1);
    }
    log::debug!(""{} Keyboard device(s) detected."", keyboard_devices.len());

    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTALT, config::Modifier::Alt),
        (Key::KEY_RIGHTALT, config::Modifier::Alt),
        (Key::KEY_LEFTCTRL, config::Modifier::Control),
        (Key::KEY_RIGHTCTRL, config::Modifier::Control),
        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),
        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),
    ]);

    let repeat_cooldown_duration: u64 = if args.is_present(""cooldown"") {
        args.value_of(""cooldown"").unwrap().parse::<u64>().unwrap()
    } else {
        250
    };

    let mut signals = Signals::new(&[
        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,
        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,
    ])?;

    let mut execution_is_paused = false;
    let mut last_hotkey: Option<config::Hotkey> = None;
    let mut pending_release: bool = false;
    let mut keyboard_states: Vec<KeyboardState> = Vec::new();
    let mut keyboard_stream_map = StreamMap::new();

    for (i, mut device) in keyboard_devices.into_iter().enumerate() {
        let _ = device.grab();
        keyboard_stream_map.insert(i, device.into_event_stream()?);
        keyboard_states.push(KeyboardState::new());
    }

    // The initial sleep duration is never read because last_hotkey is initialized to None
    let hotkey_repeat_timer = sleep(Duration::from_millis(0));
    tokio::pin!(hotkey_repeat_timer);

    loop {
        select! {
            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {
                let hotkey = last_hotkey.clone().unwrap();
                if hotkey.keybinding.on_release {
                    continue;
                }
                send_command(hotkey.clone());
                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
            }

            Some(signal) = signals.next() => {
                match signal {
                    SIGUSR1 => {
                        execution_is_paused = true;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                    }

                    SIGUSR2 => {
                        execution_is_paused = false;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.grab();
                        }
                    }

                    SIGHUP => {
                        hotkeys = load_config();
                    }

                    SIGINT => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                        log::warn!(""Received SIGINT signal, exiting..."");
                        exit(1);
                    }

                    _ => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }

                        log::warn!(""Received signal: {:#?}"", signal);
                        log::warn!(""Exiting..."");
                        exit(1);
                    }
                }
            }

            Some((i, Ok(event))) = keyboard_stream_map.next() => {
                let keyboard_state = &mut keyboard_states[i];

                let key = match event.kind() {
                    InputEventKind::Key(keycode) => keycode,
                    _ => continue
                };

                match event.value() {
                    // Key press
                    1 => {
                        if let Some(modifier) = modifiers_map.get(&key) {
                            keyboard_state.state_modifiers.insert(*modifier);
                        } else {
                            keyboard_state.state_keysyms.insert(key);
                        }
                    }

                    // Key release
                    0 => {
                        if last_hotkey.is_some() && pending_release {
                            pending_release = false;
                            send_command(last_hotkey.clone().unwrap());
                            last_hotkey = None;
                        }
                        if let Some(modifier) = modifiers_map.get(&key) {
                            if let Some(hotkey) = &last_hotkey {
                                if hotkey.modifiers().contains(modifier) {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_modifiers.remove(modifier);
                        } else if keyboard_state.state_keysyms.contains(key) {
                            if let Some(hotkey) = &last_hotkey {
                                if key == hotkey.keysym() {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_keysyms.remove(key);
                        }
                    }

                    _ => {}
                }

                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()
                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())
                    .collect();

                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {
                    hotkey.keysym().code() == event.code() &&
                    keyboard_state.state_modifiers
                        .iter()
                        .all(|x| hotkey.modifiers().contains(x)) &&
                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                    && !hotkey.is_send()
                        });

                // Don't emit event to virtual device if it's from a valid hotkey
                if !event_in_hotkeys {
                    uinput_device.emit(&[event]).unwrap();
                }

                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {
                    continue;
                }

                log::debug!(""state_modifiers: {:#?}"", keyboard_state.state_modifiers);
                log::debug!(""state_keysyms: {:#?}"", keyboard_state.state_keysyms);
                log::debug!(""hotkey: {:#?}"", possible_hotkeys);

                for hotkey in possible_hotkeys {
                    // this should check if state_modifiers and hotkey.modifiers have the same elements
                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))
                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                        && keyboard_state.state_keysyms.contains(hotkey.keysym())
                    {
                        last_hotkey = Some(hotkey.clone());
                        if pending_release { break; }
                        if hotkey.is_on_release() {
                            pending_release = true;
                            break;
                        }
                        send_command(hotkey.clone());
                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
                        break;
                    }
                }
            }
        }
    }
}",1,True,False,77
https://github.com/waycrate/swhkd.git,b4e6dc76f4845ab03104187a42ac6d1bbc1e0021,Shinyzenith,2022-03-25 20:28:47+05:18,False,daemon.rs,Rust,main,"async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = set_command_line_args().get_matches();
    env::set_var(""RUST_LOG"", ""swhkd=warn"");

    if args.is_present(""debug"") {
        env::set_var(""RUST_LOG"", ""swhkd=trace"");
    }

    env_logger::init();
    log::trace!(""Logger initialized."");

    let pidfile: String = String::from(""/tmp/swhkd.pid"");
    if Path::new(&pidfile).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pidfile);
        let swhkd_pid = match fs::read_to_string(&pidfile) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Swhkd is already running!"");
                log::error!(""pid of existing swhkd process: {}"", pid.to_string());
                log::error!(""To close the existing swhkd process, run `sudo killall swhkd`"");
                exit(1);
            }
        }
    }

    match fs::write(&pidfile, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pidfile, e);
            exit(1);
        }
    }

    if check_user_permissions().is_err() {
        exit(1);
    }

    let load_config = || {
        seteuid(env::var(""PKEXEC_UID"").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.
        let config_file_path: std::path::PathBuf = if args.is_present(""config"") {
            Path::new(args.value_of(""config"").unwrap()).to_path_buf()
        } else {
            fetch_xdg_config_path()
        };

        log::debug!(""Using config file path: {:#?}"", config_file_path);

        if !config_file_path.exists() {
            log::error!(""{:#?} doesn't exist"", config_file_path);
            exit(1);
        }

        let hotkeys = match config::load(&config_file_path) {
            Err(e) => {
                log::error!(""Config Error: {}"", e);
                exit(1);
            }
            Ok(out) => out,
        };

        for hotkey in &hotkeys {
            log::debug!(""hotkey: {:#?}"", hotkey);
        }

        hotkeys
    };

    let mut hotkeys = load_config();
    seteuid(0); // Escalating back to root after reading config file.
    log::trace!(""Attempting to find all keyboard file descriptors."");
    let keyboard_devices: Vec<Device> =
        evdev::enumerate().filter(check_device_is_keyboard).collect();

    let mut uinput_device = match uinput::create_uinput_device() {
        Ok(dev) => dev,
        Err(e) => {
            log::error!(""Err: {:#?}"", e);
            exit(1);
        }
    };

    if keyboard_devices.is_empty() {
        log::error!(""No valid keyboard device was detected!"");
        exit(1);
    }
    log::debug!(""{} Keyboard device(s) detected."", keyboard_devices.len());

    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTALT, config::Modifier::Alt),
        (Key::KEY_RIGHTALT, config::Modifier::Alt),
        (Key::KEY_LEFTCTRL, config::Modifier::Control),
        (Key::KEY_RIGHTCTRL, config::Modifier::Control),
        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),
        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),
    ]);

    let repeat_cooldown_duration: u64 = if args.is_present(""cooldown"") {
        args.value_of(""cooldown"").unwrap().parse::<u64>().unwrap()
    } else {
        250
    };

    let mut signals = Signals::new(&[
        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,
        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,
    ])?;

    let mut execution_is_paused = false;
    let mut last_hotkey: Option<config::Hotkey> = None;
    let mut pending_release: bool = false;
    let mut keyboard_states: Vec<KeyboardState> = Vec::new();
    let mut keyboard_stream_map = StreamMap::new();

    for (i, mut device) in keyboard_devices.into_iter().enumerate() {
        let _ = device.grab();
        keyboard_stream_map.insert(i, device.into_event_stream()?);
        keyboard_states.push(KeyboardState::new());
    }

    // The initial sleep duration is never read because last_hotkey is initialized to None
    let hotkey_repeat_timer = sleep(Duration::from_millis(0));
    tokio::pin!(hotkey_repeat_timer);

    loop {
        select! {
            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {
                let hotkey = last_hotkey.clone().unwrap();
                if hotkey.keybinding.on_release {
                    continue;
                }
                send_command(hotkey.clone());
                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
            }

            Some(signal) = signals.next() => {
                match signal {
                    SIGUSR1 => {
                        execution_is_paused = true;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                    }

                    SIGUSR2 => {
                        execution_is_paused = false;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.grab();
                        }
                    }

                    SIGHUP => {
                        hotkeys = load_config();
                    }

                    SIGINT => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                        log::warn!(""Received SIGINT signal, exiting..."");
                        exit(1);
                    }

                    _ => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }

                        log::warn!(""Received signal: {:#?}"", signal);
                        log::warn!(""Exiting..."");
                        exit(1);
                    }
                }
            }

            Some((i, Ok(event))) = keyboard_stream_map.next() => {
                let keyboard_state = &mut keyboard_states[i];

                let key = match event.kind() {
                    InputEventKind::Key(keycode) => keycode,
                    _ => continue
                };

                match event.value() {
                    // Key press
                    1 => {
                        if let Some(modifier) = modifiers_map.get(&key) {
                            keyboard_state.state_modifiers.insert(*modifier);
                        } else {
                            keyboard_state.state_keysyms.insert(key);
                        }
                    }

                    // Key release
                    0 => {
                        if last_hotkey.is_some() && pending_release {
                            pending_release = false;
                            send_command(last_hotkey.clone().unwrap());
                            last_hotkey = None;
                        }
                        if let Some(modifier) = modifiers_map.get(&key) {
                            if let Some(hotkey) = &last_hotkey {
                                if hotkey.modifiers().contains(modifier) {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_modifiers.remove(modifier);
                        } else if keyboard_state.state_keysyms.contains(key) {
                            if let Some(hotkey) = &last_hotkey {
                                if key == hotkey.keysym() {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_keysyms.remove(key);
                        }
                    }

                    _ => {}
                }

                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()
                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())
                    .collect();

                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {
                    hotkey.keysym().code() == event.code() &&
                    keyboard_state.state_modifiers
                        .iter()
                        .all(|x| hotkey.modifiers().contains(x)) &&
                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                    && !hotkey.is_send()
                        });

                // Don't emit event to virtual device if it's from a valid hotkey
                if !event_in_hotkeys {
                    uinput_device.emit(&[event]).unwrap();
                }

                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {
                    continue;
                }

                log::debug!(""state_modifiers: {:#?}"", keyboard_state.state_modifiers);
                log::debug!(""state_keysyms: {:#?}"", keyboard_state.state_keysyms);
                log::debug!(""hotkey: {:#?}"", possible_hotkeys);

                for hotkey in possible_hotkeys {
                    // this should check if state_modifiers and hotkey.modifiers have the same elements
                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))
                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                        && keyboard_state.state_keysyms.contains(hotkey.keysym())
                    {
                        last_hotkey = Some(hotkey.clone());
                        if pending_release { break; }
                        if hotkey.is_on_release() {
                            pending_release = true;
                            break;
                        }
                        send_command(hotkey.clone());
                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
                        break;
                    }
                }
            }
        }
    }
}",0,False,False,
https://github.com/waycrate/swhkd.git,b4e6dc76f4845ab03104187a42ac6d1bbc1e0021,Shinyzenith,2022-03-25 20:28:47+05:18,False,daemon.rs,Rust,seteuid uid : u32,"pub fn seteuid(uid: u32) {
    let uid = nix::unistd::Uid::from_raw(uid);
    match nix::unistd::seteuid(uid) {
        Ok(_) => log::debug!(""Dropping privileges...""),
        Err(e) => {
            log::error!(""Failed to set UID: {:#?}"", e);
            exit(1);
        }
    }
}",0,False,True,
https://github.com/waycrate/swhkd.git,b4e6dc76f4845ab03104187a42ac6d1bbc1e0021,Shinyzenith,2022-03-25 20:28:47+05:18,False,daemon.rs,Rust,new,"    fn new() -> KeyboardState {
        KeyboardState { state_modifiers: HashSet::new(), state_keysyms: AttributeSet::new() }
    }",0,True,False,
https://github.com/waycrate/swhkd.git,b4e6dc76f4845ab03104187a42ac6d1bbc1e0021,Shinyzenith,2022-03-25 20:28:47+05:18,False,daemon.rs,Rust,sock_send command : & str,"fn sock_send(command: &str) -> std::io::Result<()> {
    let mut stream = UnixStream::connect(""/tmp/swhkd.sock"")?;
    stream.write_all(command.as_bytes())?;
    Ok(())
}",0,True,False,
https://github.com/waycrate/swhkd.git,b4e6dc76f4845ab03104187a42ac6d1bbc1e0021,Shinyzenith,2022-03-25 20:28:47+05:18,False,daemon.rs,Rust,send_command hotkey : config :: Hotkey,"fn send_command(hotkey: config::Hotkey) {
    log::info!(""Hotkey pressed: {:#?}"", hotkey);
    if let Err(e) = sock_send(&hotkey.command) {
        log::error!(""Failed to send command to swhks through IPC."");
        log::error!(""Please make sure that swhks is running."");
        log::error!(""Err: {:#?}"", e)
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,b4e6dc76f4845ab03104187a42ac6d1bbc1e0021,Shinyzenith,2022-03-25 20:28:47+05:18,False,daemon.rs,Rust,check_user_permissions,"pub fn check_user_permissions() -> Result<(), ()> {
    if !Uid::current().is_root() {
        let groups = nix::unistd::getgroups();
        for (_, groups) in groups.iter().enumerate() {
            for group in groups {
                let group = Group::from_gid(*group);
                if group.unwrap().unwrap().name == ""input"" {
                    log::error!(""Note: INVOKING USER IS IN INPUT GROUP!!!!"");
                    log::error!(""THIS IS A HUGE SECURITY RISK!!!!"");
                }
            }
        }
        log::error!(""Consider using `pkexec swhkd ...`"");
        Err(())
    } else {
        log::warn!(""Running swhkd as root!"");
        Ok(())
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,b4e6dc76f4845ab03104187a42ac6d1bbc1e0021,Shinyzenith,2022-03-25 20:28:47+05:18,False,daemon.rs,Rust,check_device_is_keyboard device : & Device,"pub fn check_device_is_keyboard(device: &Device) -> bool {
    if device.supported_keys().map_or(false, |keys| keys.contains(Key::KEY_ENTER)) {
        if device.name() == Some(""swhkd virtual output"") {
            return false;
        }
        log::debug!(""Keyboard: {}"", device.name().unwrap(),);
        true
    } else {
        log::trace!(""Other: {}"", device.name().unwrap(),);
        false
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,b4e6dc76f4845ab03104187a42ac6d1bbc1e0021,Shinyzenith,2022-03-25 20:28:47+05:18,False,daemon.rs,Rust,set_command_line_args,"pub fn set_command_line_args() -> Command<'static> {
    let app = Command::new(""swhkd"")
        .version(env!(""CARGO_PKG_VERSION""))
        .author(env!(""CARGO_PKG_AUTHORS""))
        .about(""Simple Wayland HotKey Daemon"")
        .arg(
            arg!(-c --config <CONFIG_FILE_PATH>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom config file path.""),
        )
        .arg(
            arg!(-C --cooldown <COOLDOWN_IN_MS>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom repeat cooldown duration. Default is 250ms.""),
        )
        .arg(arg!(-d - -debug).required(false).help(""Enable debug mode.""));
    app
}",0,True,False,
https://github.com/waycrate/swhkd.git,b4e6dc76f4845ab03104187a42ac6d1bbc1e0021,Shinyzenith,2022-03-25 20:28:47+05:18,False,daemon.rs,Rust,fetch_xdg_config_path,"pub fn fetch_xdg_config_path() -> std::path::PathBuf {
    let config_file_path: std::path::PathBuf = match env::var(""XDG_CONFIG_HOME"") {
        Ok(val) => {
            log::debug!(""XDG_CONFIG_HOME exists: {:#?}"", val);
            Path::new(&val).join(""swhkd/swhkdrc"")
        }
        Err(_) => {
            log::error!(""XDG_CONFIG_HOME has not been set."");
            Path::new(""/etc/swhkd/swhkdrc"").to_path_buf()
        }
    };
    config_file_path
}",0,True,False,
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,main,"async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = set_command_line_args().get_matches();
    env::set_var(""RUST_LOG"", ""swhkd=warn"");

    if args.is_present(""debug"") {
        env::set_var(""RUST_LOG"", ""swhkd=trace"");
    }

    env_logger::init();
    log::trace!(""Logger initialized."");

    let pidfile: String = String::from(""/tmp/swhkd.pid"");
    if Path::new(&pidfile).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pidfile);
        let swhkd_pid = match fs::read_to_string(&pidfile) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Swhkd is already running!"");
                log::error!(""pid of existing swhkd process: {}"", pid.to_string());
                log::error!(""To close the existing swhkd process, run `sudo killall swhkd`"");
                exit(1);
            }
        }
    }

    match fs::write(&pidfile, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pidfile, e);
            exit(1);
        }
    }

    if check_user_permissions().is_err() {
        exit(1);
    }

    let load_config = || {
        seteuid(env::var(""PKEXEC_UID"").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.
        let config_file_path: std::path::PathBuf = if args.is_present(""config"") {
            Path::new(args.value_of(""config"").unwrap()).to_path_buf()
        } else {
            fetch_xdg_config_path()
        };

        log::debug!(""Using config file path: {:#?}"", config_file_path);

        if !config_file_path.exists() {
            log::error!(""{:#?} doesn't exist"", config_file_path);
            exit(1);
        }

        let hotkeys = match config::load(&config_file_path) {
            Err(e) => {
                log::error!(""Config Error: {}"", e);
                exit(1);
            }
            Ok(out) => out,
        };

        for hotkey in &hotkeys {
            log::debug!(""hotkey: {:#?}"", hotkey);
        }

        hotkeys
    };

    let mut hotkeys = load_config();
    seteuid(0); // Escalating back to root after reading config file.
    log::trace!(""Attempting to find all keyboard file descriptors."");
    let keyboard_devices: Vec<Device> =
        evdev::enumerate().filter(check_device_is_keyboard).collect();

    let mut uinput_device = match uinput::create_uinput_device() {
        Ok(dev) => dev,
        Err(e) => {
            log::error!(""Err: {:#?}"", e);
            exit(1);
        }
    };

    if keyboard_devices.is_empty() {
        log::error!(""No valid keyboard device was detected!"");
        exit(1);
    }
    log::debug!(""{} Keyboard device(s) detected."", keyboard_devices.len());

    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTALT, config::Modifier::Alt),
        (Key::KEY_RIGHTALT, config::Modifier::Alt),
        (Key::KEY_LEFTCTRL, config::Modifier::Control),
        (Key::KEY_RIGHTCTRL, config::Modifier::Control),
        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),
        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),
    ]);

    let repeat_cooldown_duration: u64 = if args.is_present(""cooldown"") {
        args.value_of(""cooldown"").unwrap().parse::<u64>().unwrap()
    } else {
        250
    };

    let mut signals = Signals::new(&[
        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,
        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,
    ])?;

    let mut execution_is_paused = false;
    let mut last_hotkey: Option<config::Hotkey> = None;
    let mut pending_release: bool = false;
    let mut keyboard_states: Vec<KeyboardState> = Vec::new();
    let mut keyboard_stream_map = StreamMap::new();

    for (i, mut device) in keyboard_devices.into_iter().enumerate() {
        let _ = device.grab();
        keyboard_stream_map.insert(i, device.into_event_stream()?);
        keyboard_states.push(KeyboardState::new());
    }

    // The initial sleep duration is never read because last_hotkey is initialized to None
    let hotkey_repeat_timer = sleep(Duration::from_millis(0));
    tokio::pin!(hotkey_repeat_timer);

    loop {
        select! {
            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {
                let hotkey = last_hotkey.clone().unwrap();
                if hotkey.keybinding.on_release {
                    continue;
                }
                send_command(hotkey.clone());
                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
            }

            Some(signal) = signals.next() => {
                match signal {
                    SIGUSR1 => {
                        execution_is_paused = true;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                    }

                    SIGUSR2 => {
                        execution_is_paused = false;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.grab();
                        }
                    }

                    SIGHUP => {
                        hotkeys = load_config();
                    }

                    SIGINT => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                        log::warn!(""Received SIGINT signal, exiting..."");
                        exit(1);
                    }

                    _ => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }

                        log::warn!(""Received signal: {:#?}"", signal);
                        log::warn!(""Exiting..."");
                        exit(1);
                    }
                }
            }

            Some((i, Ok(event))) = keyboard_stream_map.next() => {
                let keyboard_state = &mut keyboard_states[i];

                let key = match event.kind() {
                    InputEventKind::Key(keycode) => keycode,
                    _ => continue
                };

                match event.value() {
                    // Key press
                    1 => {
                        if let Some(modifier) = modifiers_map.get(&key) {
                            keyboard_state.state_modifiers.insert(*modifier);
                        } else {
                            keyboard_state.state_keysyms.insert(key);
                        }
                    }

                    // Key release
                    0 => {
                        if last_hotkey.is_some() && pending_release {
                            pending_release = false;
                            send_command(last_hotkey.clone().unwrap());
                            last_hotkey = None;
                        }
                        if let Some(modifier) = modifiers_map.get(&key) {
                            if let Some(hotkey) = &last_hotkey {
                                if hotkey.modifiers().contains(modifier) {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_modifiers.remove(modifier);
                        } else if keyboard_state.state_keysyms.contains(key) {
                            if let Some(hotkey) = &last_hotkey {
                                if key == hotkey.keysym() {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_keysyms.remove(key);
                        }
                    }

                    _ => {}
                }

                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()
                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())
                    .collect();

                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {
                    hotkey.keysym().code() == event.code() &&
                    keyboard_state.state_modifiers
                        .iter()
                        .all(|x| hotkey.modifiers().contains(x)) &&
                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                    && !hotkey.is_send()
                        });

                // Don't emit event to virtual device if it's from a valid hotkey
                if !event_in_hotkeys {
                    uinput_device.emit(&[event]).unwrap();
                }

                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {
                    continue;
                }

                log::debug!(""state_modifiers: {:#?}"", keyboard_state.state_modifiers);
                log::debug!(""state_keysyms: {:#?}"", keyboard_state.state_keysyms);
                log::debug!(""hotkey: {:#?}"", possible_hotkeys);

                for hotkey in possible_hotkeys {
                    // this should check if state_modifiers and hotkey.modifiers have the same elements
                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))
                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                        && keyboard_state.state_keysyms.contains(hotkey.keysym())
                    {
                        last_hotkey = Some(hotkey.clone());
                        if pending_release { break; }
                        if hotkey.is_on_release() {
                            pending_release = true;
                            break;
                        }
                        send_command(hotkey.clone());
                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
                        break;
                    }
                }
            }
        }
    }
}",1,True,False,"57,58,59,60,61"
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,sock_send command : & str,"fn sock_send(command: &str) -> std::io::Result<()> {
    let mut stream = UnixStream::connect(""/tmp/swhkd.sock"")?;
    stream.write_all(command.as_bytes())?;
    Ok(())
}",1,True,False,1
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,seteuid uid : u32,"pub fn seteuid(uid: u32) {
    let uid = nix::unistd::Uid::from_raw(uid);
    match nix::unistd::seteuid(uid) {
        Ok(_) => log::debug!(""Dropping privileges...""),
        Err(e) => {
            log::error!(""Failed to set UID: {:#?}"", e);
            exit(1);
        }
    }
}",1,True,False,"1,5"
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,sock_send command : & str,"fn sock_send(command: &str) -> std::io::Result<()> {
    let sock_file_path =
        String::from(format!(""/run/user/{}/swhkd.sock"", env::var(""PKEXEC_UID"").unwrap()));
    let mut stream = UnixStream::connect(sock_file_path)?;
    stream.write_all(command.as_bytes())?;
    Ok(())
}",0,False,False,
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,seteuid uid : u32,"pub fn seteuid(uid: u32) {
    let uid = Uid::from_raw(uid);
    match nix::unistd::seteuid(uid) {
        Ok(_) => log::debug!(""Dropping privileges...""),
        Err(e) => {
            log::error!(""Failed to set EUID: {:#?}"", e);
            exit(1);
        }
    }
}",0,False,False,
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,new,"    fn new() -> KeyboardState {
        KeyboardState { state_modifiers: HashSet::new(), state_keysyms: AttributeSet::new() }
    }",0,True,False,
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,send_command hotkey : config :: Hotkey,"fn send_command(hotkey: config::Hotkey) {
    log::info!(""Hotkey pressed: {:#?}"", hotkey);
    if let Err(e) = sock_send(&hotkey.command) {
        log::error!(""Failed to send command to swhks through IPC."");
        log::error!(""Please make sure that swhks is running."");
        log::error!(""Err: {:#?}"", e)
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,check_user_permissions,"pub fn check_user_permissions() -> Result<(), ()> {
    if !Uid::current().is_root() {
        let groups = nix::unistd::getgroups();
        for (_, groups) in groups.iter().enumerate() {
            for group in groups {
                let group = Group::from_gid(*group);
                if group.unwrap().unwrap().name == ""input"" {
                    log::error!(""Note: INVOKING USER IS IN INPUT GROUP!!!!"");
                    log::error!(""THIS IS A HUGE SECURITY RISK!!!!"");
                }
            }
        }
        log::error!(""Consider using `pkexec swhkd ...`"");
        Err(())
    } else {
        log::warn!(""Running swhkd as root!"");
        Ok(())
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,check_device_is_keyboard device : & Device,"pub fn check_device_is_keyboard(device: &Device) -> bool {
    if device.supported_keys().map_or(false, |keys| keys.contains(Key::KEY_ENTER)) {
        if device.name() == Some(""swhkd virtual output"") {
            return false;
        }
        log::debug!(""Keyboard: {}"", device.name().unwrap(),);
        true
    } else {
        log::trace!(""Other: {}"", device.name().unwrap(),);
        false
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,set_command_line_args,"pub fn set_command_line_args() -> Command<'static> {
    let app = Command::new(""swhkd"")
        .version(env!(""CARGO_PKG_VERSION""))
        .author(env!(""CARGO_PKG_AUTHORS""))
        .about(""Simple Wayland HotKey Daemon"")
        .arg(
            arg!(-c --config <CONFIG_FILE_PATH>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom config file path.""),
        )
        .arg(
            arg!(-C --cooldown <COOLDOWN_IN_MS>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom repeat cooldown duration. Default is 250ms.""),
        )
        .arg(arg!(-d - -debug).required(false).help(""Enable debug mode.""));
    app
}",0,True,False,
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,daemon.rs,Rust,fetch_xdg_config_path,"pub fn fetch_xdg_config_path() -> std::path::PathBuf {
    let config_file_path: std::path::PathBuf = match env::var(""XDG_CONFIG_HOME"") {
        Ok(val) => {
            log::debug!(""XDG_CONFIG_HOME exists: {:#?}"", val);
            Path::new(&val).join(""swhkd/swhkdrc"")
        }
        Err(_) => {
            log::error!(""XDG_CONFIG_HOME has not been set."");
            Path::new(""/etc/swhkd/swhkdrc"").to_path_buf()
        }
    };
    config_file_path
}",0,True,False,
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,server.rs,Rust,main,"fn main() -> std::io::Result<()> {
    env::set_var(""RUST_LOG"", ""swhks=trace"");
    env_logger::init();

    let pid_file_path = String::from(""/tmp/swhks.pid"");
    let sock_file_path = String::from(""/tmp/swhkd.sock"");

    if Path::new(&pid_file_path).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pid_file_path);
        let swhkd_pid = match fs::read_to_string(&pid_file_path) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Server is already running!"");
                exit(1);
            }
        }
    }

    if Path::new(&sock_file_path).exists() {
        log::trace!(""Sockfile exists, attempting to remove it."");
        match fs::remove_file(&sock_file_path) {
            Ok(_) => {
                log::debug!(""Removed old socket file"");
            }
            Err(e) => {
                log::error!(""Error removing the socket file!: {}"", e);
                log::error!(""You can manually remove the socket file: {}"", sock_file_path);
                exit(1);
            }
        };
    }

    match fs::write(&pid_file_path, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pid_file_path, e);
            exit(1);
        }
    }

    let listener = UnixListener::bind(sock_file_path)?;
    loop {
        match listener.accept() {
            Ok((mut socket, address)) => {
                let mut response = String::new();
                socket.read_to_string(&mut response)?;
                run_system_command(&response);
                log::debug!(""Socket: {:?} Address: {:?} Response: {}"", socket, address, response);
            }
            Err(e) => log::error!(""accept function failed: {:?}"", e),
        }
    }
}",1,True,False,5
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,server.rs,Rust,main,"fn main() -> std::io::Result<()> {
    env::set_var(""RUST_LOG"", ""swhks=trace"");
    env_logger::init();

    let pid_file_path = String::from(""/tmp/swhks.pid"");
    let sock_file_path = String::from(format!(""/run/user/{}/swhkd.sock"", unistd::Uid::current()));

    if Path::new(&pid_file_path).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pid_file_path);
        let swhkd_pid = match fs::read_to_string(&pid_file_path) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Server is already running!"");
                exit(1);
            }
        }
    }

    if Path::new(&sock_file_path).exists() {
        log::trace!(""Sockfile exists, attempting to remove it."");
        match fs::remove_file(&sock_file_path) {
            Ok(_) => {
                log::debug!(""Removed old socket file"");
            }
            Err(e) => {
                log::error!(""Error removing the socket file!: {}"", e);
                log::error!(""You can manually remove the socket file: {}"", sock_file_path);
                exit(1);
            }
        };
    }

    match fs::write(&pid_file_path, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pid_file_path, e);
            exit(1);
        }
    }

    let listener = UnixListener::bind(sock_file_path)?;
    loop {
        match listener.accept() {
            Ok((mut socket, address)) => {
                let mut response = String::new();
                socket.read_to_string(&mut response)?;
                run_system_command(&response);
                log::debug!(""Socket: {:?} Address: {:?} Response: {}"", socket, address, response);
            }
            Err(e) => log::error!(""accept function failed: {:?}"", e),
        }
    }
}",0,False,False,
https://github.com/waycrate/swhkd.git,f70b99dd575fab79d8a942111a6980431f006818,Shinyzenith,2022-03-25 20:35:56+05:18,False,server.rs,Rust,run_system_command command : & str,"fn run_system_command(command: &str) {
    match Command::new(""sh"")
        .arg(""-c"")
        .arg(command)
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
    {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Failed to execute {}"", command);
            log::error!(""Error, {}"", e);
        }
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,0b620a09605afb815c6d8d8953bbb7a10a8c0575,Shinyzenith,2022-03-25 20:38:01+05:18,False,server.rs,Rust,main,"fn main() -> std::io::Result<()> {
    env::set_var(""RUST_LOG"", ""swhks=trace"");
    env_logger::init();

    let pid_file_path = String::from(""/tmp/swhks.pid"");
    let sock_file_path = String::from(format!(""/run/user/{}/swhkd.sock"", unistd::Uid::current()));

    if Path::new(&pid_file_path).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pid_file_path);
        let swhkd_pid = match fs::read_to_string(&pid_file_path) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Server is already running!"");
                exit(1);
            }
        }
    }

    if Path::new(&sock_file_path).exists() {
        log::trace!(""Sockfile exists, attempting to remove it."");
        match fs::remove_file(&sock_file_path) {
            Ok(_) => {
                log::debug!(""Removed old socket file"");
            }
            Err(e) => {
                log::error!(""Error removing the socket file!: {}"", e);
                log::error!(""You can manually remove the socket file: {}"", sock_file_path);
                exit(1);
            }
        };
    }

    match fs::write(&pid_file_path, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pid_file_path, e);
            exit(1);
        }
    }

    let listener = UnixListener::bind(sock_file_path)?;
    loop {
        match listener.accept() {
            Ok((mut socket, address)) => {
                let mut response = String::new();
                socket.read_to_string(&mut response)?;
                run_system_command(&response);
                log::debug!(""Socket: {:?} Address: {:?} Response: {}"", socket, address, response);
            }
            Err(e) => log::error!(""accept function failed: {:?}"", e),
        }
    }
}",1,True,False,4
https://github.com/waycrate/swhkd.git,0b620a09605afb815c6d8d8953bbb7a10a8c0575,Shinyzenith,2022-03-25 20:38:01+05:18,False,server.rs,Rust,main,"fn main() -> std::io::Result<()> {
    env::set_var(""RUST_LOG"", ""swhks=trace"");
    env_logger::init();

    let pid_file_path = String::from(format!(""/run/user/{}/swhks.pid"", unistd::Uid::current()));
    let sock_file_path = String::from(format!(""/run/user/{}/swhkd.sock"", unistd::Uid::current()));

    if Path::new(&pid_file_path).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pid_file_path);
        let swhkd_pid = match fs::read_to_string(&pid_file_path) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Server is already running!"");
                exit(1);
            }
        }
    }

    if Path::new(&sock_file_path).exists() {
        log::trace!(""Sockfile exists, attempting to remove it."");
        match fs::remove_file(&sock_file_path) {
            Ok(_) => {
                log::debug!(""Removed old socket file"");
            }
            Err(e) => {
                log::error!(""Error removing the socket file!: {}"", e);
                log::error!(""You can manually remove the socket file: {}"", sock_file_path);
                exit(1);
            }
        };
    }

    match fs::write(&pid_file_path, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pid_file_path, e);
            exit(1);
        }
    }

    let listener = UnixListener::bind(sock_file_path)?;
    loop {
        match listener.accept() {
            Ok((mut socket, address)) => {
                let mut response = String::new();
                socket.read_to_string(&mut response)?;
                run_system_command(&response);
                log::debug!(""Socket: {:?} Address: {:?} Response: {}"", socket, address, response);
            }
            Err(e) => log::error!(""accept function failed: {:?}"", e),
        }
    }
}",0,False,False,
https://github.com/waycrate/swhkd.git,0b620a09605afb815c6d8d8953bbb7a10a8c0575,Shinyzenith,2022-03-25 20:38:01+05:18,False,server.rs,Rust,run_system_command command : & str,"fn run_system_command(command: &str) {
    match Command::new(""sh"")
        .arg(""-c"")
        .arg(command)
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
    {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Failed to execute {}"", command);
            log::error!(""Error, {}"", e);
        }
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa,Shinyzenith,2022-03-25 20:43:28+05:18,False,daemon.rs,Rust,main,"async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = set_command_line_args().get_matches();
    env::set_var(""RUST_LOG"", ""swhkd=warn"");

    if args.is_present(""debug"") {
        env::set_var(""RUST_LOG"", ""swhkd=trace"");
    }

    env_logger::init();
    log::trace!(""Logger initialized."");

    let pidfile: String = String::from(""/tmp/swhkd.pid"");
    if Path::new(&pidfile).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pidfile);
        let swhkd_pid = match fs::read_to_string(&pidfile) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Swhkd is already running!"");
                log::error!(""pid of existing swhkd process: {}"", pid.to_string());
                log::error!(""To close the existing swhkd process, run `sudo killall swhkd`"");
                exit(1);
            }
        }
    }

    match fs::write(&pidfile, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pidfile, e);
            exit(1);
        }
    }

    if check_user_permissions().is_err() {
        exit(1);
    }

    let load_config = || {
        seteuid(env::var(""PKEXEC_UID"").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.
        let config_file_path: std::path::PathBuf = if args.is_present(""config"") {
            Path::new(args.value_of(""config"").unwrap()).to_path_buf()
        } else {
            fetch_xdg_config_path()
        };

        log::debug!(""Using config file path: {:#?}"", config_file_path);

        let hotkeys = match config::load(&config_file_path) {
            Err(e) => {
                log::error!(""Config Error: {}"", e);
                exit(1);
            }
            Ok(out) => out,
        };

        for hotkey in &hotkeys {
            log::debug!(""hotkey: {:#?}"", hotkey);
        }

        hotkeys
    };

    let mut hotkeys = load_config();
    seteuid(0); // Escalating back to root after reading config file.
    log::trace!(""Attempting to find all keyboard file descriptors."");
    let keyboard_devices: Vec<Device> =
        evdev::enumerate().filter(check_device_is_keyboard).collect();

    let mut uinput_device = match uinput::create_uinput_device() {
        Ok(dev) => dev,
        Err(e) => {
            log::error!(""Err: {:#?}"", e);
            exit(1);
        }
    };

    if keyboard_devices.is_empty() {
        log::error!(""No valid keyboard device was detected!"");
        exit(1);
    }
    log::debug!(""{} Keyboard device(s) detected."", keyboard_devices.len());

    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTALT, config::Modifier::Alt),
        (Key::KEY_RIGHTALT, config::Modifier::Alt),
        (Key::KEY_LEFTCTRL, config::Modifier::Control),
        (Key::KEY_RIGHTCTRL, config::Modifier::Control),
        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),
        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),
    ]);

    let repeat_cooldown_duration: u64 = if args.is_present(""cooldown"") {
        args.value_of(""cooldown"").unwrap().parse::<u64>().unwrap()
    } else {
        250
    };

    let mut signals = Signals::new(&[
        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,
        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,
    ])?;

    let mut execution_is_paused = false;
    let mut last_hotkey: Option<config::Hotkey> = None;
    let mut pending_release: bool = false;
    let mut keyboard_states: Vec<KeyboardState> = Vec::new();
    let mut keyboard_stream_map = StreamMap::new();

    for (i, mut device) in keyboard_devices.into_iter().enumerate() {
        let _ = device.grab();
        keyboard_stream_map.insert(i, device.into_event_stream()?);
        keyboard_states.push(KeyboardState::new());
    }

    // The initial sleep duration is never read because last_hotkey is initialized to None
    let hotkey_repeat_timer = sleep(Duration::from_millis(0));
    tokio::pin!(hotkey_repeat_timer);

    loop {
        select! {
            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {
                let hotkey = last_hotkey.clone().unwrap();
                if hotkey.keybinding.on_release {
                    continue;
                }
                send_command(hotkey.clone());
                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
            }

            Some(signal) = signals.next() => {
                match signal {
                    SIGUSR1 => {
                        execution_is_paused = true;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                    }

                    SIGUSR2 => {
                        execution_is_paused = false;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.grab();
                        }
                    }

                    SIGHUP => {
                        hotkeys = load_config();
                    }

                    SIGINT => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                        log::warn!(""Received SIGINT signal, exiting..."");
                        exit(1);
                    }

                    _ => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }

                        log::warn!(""Received signal: {:#?}"", signal);
                        log::warn!(""Exiting..."");
                        exit(1);
                    }
                }
            }

            Some((i, Ok(event))) = keyboard_stream_map.next() => {
                let keyboard_state = &mut keyboard_states[i];

                let key = match event.kind() {
                    InputEventKind::Key(keycode) => keycode,
                    _ => continue
                };

                match event.value() {
                    // Key press
                    1 => {
                        if let Some(modifier) = modifiers_map.get(&key) {
                            keyboard_state.state_modifiers.insert(*modifier);
                        } else {
                            keyboard_state.state_keysyms.insert(key);
                        }
                    }

                    // Key release
                    0 => {
                        if last_hotkey.is_some() && pending_release {
                            pending_release = false;
                            send_command(last_hotkey.clone().unwrap());
                            last_hotkey = None;
                        }
                        if let Some(modifier) = modifiers_map.get(&key) {
                            if let Some(hotkey) = &last_hotkey {
                                if hotkey.modifiers().contains(modifier) {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_modifiers.remove(modifier);
                        } else if keyboard_state.state_keysyms.contains(key) {
                            if let Some(hotkey) = &last_hotkey {
                                if key == hotkey.keysym() {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_keysyms.remove(key);
                        }
                    }

                    _ => {}
                }

                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()
                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())
                    .collect();

                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {
                    hotkey.keysym().code() == event.code() &&
                    keyboard_state.state_modifiers
                        .iter()
                        .all(|x| hotkey.modifiers().contains(x)) &&
                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                    && !hotkey.is_send()
                        });

                // Don't emit event to virtual device if it's from a valid hotkey
                if !event_in_hotkeys {
                    uinput_device.emit(&[event]).unwrap();
                }

                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {
                    continue;
                }

                log::debug!(""state_modifiers: {:#?}"", keyboard_state.state_modifiers);
                log::debug!(""state_keysyms: {:#?}"", keyboard_state.state_keysyms);
                log::debug!(""hotkey: {:#?}"", possible_hotkeys);

                for hotkey in possible_hotkeys {
                    // this should check if state_modifiers and hotkey.modifiers have the same elements
                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))
                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                        && keyboard_state.state_keysyms.contains(hotkey.keysym())
                    {
                        last_hotkey = Some(hotkey.clone());
                        if pending_release { break; }
                        if hotkey.is_on_release() {
                            pending_release = true;
                            break;
                        }
                        send_command(hotkey.clone());
                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
                        break;
                    }
                }
            }
        }
    }
}",1,True,False,"11,48"
https://github.com/waycrate/swhkd.git,e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa,Shinyzenith,2022-03-25 20:43:28+05:18,False,daemon.rs,Rust,main,"async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = set_command_line_args().get_matches();
    let invoking_uid = env::var(""PKEXEC_UID"").unwrap().parse::<u32>().unwrap();
    env::set_var(""RUST_LOG"", ""swhkd=warn"");

    if args.is_present(""debug"") {
        env::set_var(""RUST_LOG"", ""swhkd=trace"");
    }

    env_logger::init();
    log::trace!(""Logger initialized."");

    let pidfile: String = String::from(format!(""/etc/swhkd/runtime/swhkd_{}.pid"", invoking_uid));
    if Path::new(&pidfile).exists() {
        log::trace!(""Reading {} file and checking for running instances."", pidfile);
        let swhkd_pid = match fs::read_to_string(&pidfile) {
            Ok(swhkd_pid) => swhkd_pid,
            Err(e) => {
                log::error!(""Unable to read {} to check all running instances"", e);
                exit(1);
            }
        };
        log::debug!(""Previous PID: {}"", swhkd_pid);

        let mut sys = System::new_all();
        sys.refresh_all();
        for (pid, process) in sys.processes() {
            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {
                log::error!(""Swhkd is already running!"");
                log::error!(""pid of existing swhkd process: {}"", pid.to_string());
                log::error!(""To close the existing swhkd process, run `sudo killall swhkd`"");
                exit(1);
            }
        }
    }

    match fs::write(&pidfile, id().to_string()) {
        Ok(_) => {}
        Err(e) => {
            log::error!(""Unable to write to {}: {}"", pidfile, e);
            exit(1);
        }
    }

    if check_user_permissions().is_err() {
        exit(1);
    }

    let load_config = || {
        seteuid(invoking_uid); // Dropping privileges to invoking user.
        let config_file_path: std::path::PathBuf = if args.is_present(""config"") {
            Path::new(args.value_of(""config"").unwrap()).to_path_buf()
        } else {
            fetch_xdg_config_path()
        };

        log::debug!(""Using config file path: {:#?}"", config_file_path);

        let hotkeys = match config::load(&config_file_path) {
            Err(e) => {
                log::error!(""Config Error: {}"", e);
                exit(1);
            }
            Ok(out) => out,
        };

        for hotkey in &hotkeys {
            log::debug!(""hotkey: {:#?}"", hotkey);
        }

        hotkeys
    };

    let mut hotkeys = load_config();
    seteuid(0); // Escalating back to root after reading config file.
    log::trace!(""Attempting to find all keyboard file descriptors."");
    let keyboard_devices: Vec<Device> =
        evdev::enumerate().filter(check_device_is_keyboard).collect();

    let mut uinput_device = match uinput::create_uinput_device() {
        Ok(dev) => dev,
        Err(e) => {
            log::error!(""Err: {:#?}"", e);
            exit(1);
        }
    };

    if keyboard_devices.is_empty() {
        log::error!(""No valid keyboard device was detected!"");
        exit(1);
    }
    log::debug!(""{} Keyboard device(s) detected."", keyboard_devices.len());

    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTMETA, config::Modifier::Super),
        (Key::KEY_RIGHTMETA, config::Modifier::Super),
        (Key::KEY_LEFTALT, config::Modifier::Alt),
        (Key::KEY_RIGHTALT, config::Modifier::Alt),
        (Key::KEY_LEFTCTRL, config::Modifier::Control),
        (Key::KEY_RIGHTCTRL, config::Modifier::Control),
        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),
        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),
    ]);

    let repeat_cooldown_duration: u64 = if args.is_present(""cooldown"") {
        args.value_of(""cooldown"").unwrap().parse::<u64>().unwrap()
    } else {
        250
    };

    let mut signals = Signals::new(&[
        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,
        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,
    ])?;

    let mut execution_is_paused = false;
    let mut last_hotkey: Option<config::Hotkey> = None;
    let mut pending_release: bool = false;
    let mut keyboard_states: Vec<KeyboardState> = Vec::new();
    let mut keyboard_stream_map = StreamMap::new();

    for (i, mut device) in keyboard_devices.into_iter().enumerate() {
        let _ = device.grab();
        keyboard_stream_map.insert(i, device.into_event_stream()?);
        keyboard_states.push(KeyboardState::new());
    }

    // The initial sleep duration is never read because last_hotkey is initialized to None
    let hotkey_repeat_timer = sleep(Duration::from_millis(0));
    tokio::pin!(hotkey_repeat_timer);

    loop {
        select! {
            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {
                let hotkey = last_hotkey.clone().unwrap();
                if hotkey.keybinding.on_release {
                    continue;
                }
                send_command(hotkey.clone());
                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
            }

            Some(signal) = signals.next() => {
                match signal {
                    SIGUSR1 => {
                        execution_is_paused = true;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                    }

                    SIGUSR2 => {
                        execution_is_paused = false;
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.grab();
                        }
                    }

                    SIGHUP => {
                        hotkeys = load_config();
                    }

                    SIGINT => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }
                        log::warn!(""Received SIGINT signal, exiting..."");
                        exit(1);
                    }

                    _ => {
                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {
                            let _ = device.ungrab();
                        }

                        log::warn!(""Received signal: {:#?}"", signal);
                        log::warn!(""Exiting..."");
                        exit(1);
                    }
                }
            }

            Some((i, Ok(event))) = keyboard_stream_map.next() => {
                let keyboard_state = &mut keyboard_states[i];

                let key = match event.kind() {
                    InputEventKind::Key(keycode) => keycode,
                    _ => continue
                };

                match event.value() {
                    // Key press
                    1 => {
                        if let Some(modifier) = modifiers_map.get(&key) {
                            keyboard_state.state_modifiers.insert(*modifier);
                        } else {
                            keyboard_state.state_keysyms.insert(key);
                        }
                    }

                    // Key release
                    0 => {
                        if last_hotkey.is_some() && pending_release {
                            pending_release = false;
                            send_command(last_hotkey.clone().unwrap());
                            last_hotkey = None;
                        }
                        if let Some(modifier) = modifiers_map.get(&key) {
                            if let Some(hotkey) = &last_hotkey {
                                if hotkey.modifiers().contains(modifier) {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_modifiers.remove(modifier);
                        } else if keyboard_state.state_keysyms.contains(key) {
                            if let Some(hotkey) = &last_hotkey {
                                if key == hotkey.keysym() {
                                    last_hotkey = None;
                                }
                            }
                            keyboard_state.state_keysyms.remove(key);
                        }
                    }

                    _ => {}
                }

                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()
                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())
                    .collect();

                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {
                    hotkey.keysym().code() == event.code() &&
                    keyboard_state.state_modifiers
                        .iter()
                        .all(|x| hotkey.modifiers().contains(x)) &&
                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                    && !hotkey.is_send()
                        });

                // Don't emit event to virtual device if it's from a valid hotkey
                if !event_in_hotkeys {
                    uinput_device.emit(&[event]).unwrap();
                }

                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {
                    continue;
                }

                log::debug!(""state_modifiers: {:#?}"", keyboard_state.state_modifiers);
                log::debug!(""state_keysyms: {:#?}"", keyboard_state.state_keysyms);
                log::debug!(""hotkey: {:#?}"", possible_hotkeys);

                for hotkey in possible_hotkeys {
                    // this should check if state_modifiers and hotkey.modifiers have the same elements
                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))
                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()
                        && keyboard_state.state_keysyms.contains(hotkey.keysym())
                    {
                        last_hotkey = Some(hotkey.clone());
                        if pending_release { break; }
                        if hotkey.is_on_release() {
                            pending_release = true;
                            break;
                        }
                        send_command(hotkey.clone());
                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));
                        break;
                    }
                }
            }
        }
    }
}",0,False,False,
https://github.com/waycrate/swhkd.git,e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa,Shinyzenith,2022-03-25 20:43:28+05:18,False,daemon.rs,Rust,new,"    fn new() -> KeyboardState {
        KeyboardState { state_modifiers: HashSet::new(), state_keysyms: AttributeSet::new() }
    }",0,True,False,
https://github.com/waycrate/swhkd.git,e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa,Shinyzenith,2022-03-25 20:43:28+05:18,False,daemon.rs,Rust,sock_send command : & str,"fn sock_send(command: &str) -> std::io::Result<()> {
    let sock_file_path =
        String::from(format!(""/run/user/{}/swhkd.sock"", env::var(""PKEXEC_UID"").unwrap()));
    let mut stream = UnixStream::connect(sock_file_path)?;
    stream.write_all(command.as_bytes())?;
    Ok(())
}",0,True,False,
https://github.com/waycrate/swhkd.git,e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa,Shinyzenith,2022-03-25 20:43:28+05:18,False,daemon.rs,Rust,send_command hotkey : config :: Hotkey,"fn send_command(hotkey: config::Hotkey) {
    log::info!(""Hotkey pressed: {:#?}"", hotkey);
    if let Err(e) = sock_send(&hotkey.command) {
        log::error!(""Failed to send command to swhks through IPC."");
        log::error!(""Please make sure that swhks is running."");
        log::error!(""Err: {:#?}"", e)
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa,Shinyzenith,2022-03-25 20:43:28+05:18,False,daemon.rs,Rust,check_user_permissions,"pub fn check_user_permissions() -> Result<(), ()> {
    if !Uid::current().is_root() {
        let groups = nix::unistd::getgroups();
        for (_, groups) in groups.iter().enumerate() {
            for group in groups {
                let group = Group::from_gid(*group);
                if group.unwrap().unwrap().name == ""input"" {
                    log::error!(""Note: INVOKING USER IS IN INPUT GROUP!!!!"");
                    log::error!(""THIS IS A HUGE SECURITY RISK!!!!"");
                }
            }
        }
        log::error!(""Consider using `pkexec swhkd ...`"");
        Err(())
    } else {
        log::warn!(""Running swhkd as root!"");
        Ok(())
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa,Shinyzenith,2022-03-25 20:43:28+05:18,False,daemon.rs,Rust,check_device_is_keyboard device : & Device,"pub fn check_device_is_keyboard(device: &Device) -> bool {
    if device.supported_keys().map_or(false, |keys| keys.contains(Key::KEY_ENTER)) {
        if device.name() == Some(""swhkd virtual output"") {
            return false;
        }
        log::debug!(""Keyboard: {}"", device.name().unwrap(),);
        true
    } else {
        log::trace!(""Other: {}"", device.name().unwrap(),);
        false
    }
}",0,True,False,
https://github.com/waycrate/swhkd.git,e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa,Shinyzenith,2022-03-25 20:43:28+05:18,False,daemon.rs,Rust,set_command_line_args,"pub fn set_command_line_args() -> Command<'static> {
    let app = Command::new(""swhkd"")
        .version(env!(""CARGO_PKG_VERSION""))
        .author(env!(""CARGO_PKG_AUTHORS""))
        .about(""Simple Wayland HotKey Daemon"")
        .arg(
            arg!(-c --config <CONFIG_FILE_PATH>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom config file path.""),
        )
        .arg(
            arg!(-C --cooldown <COOLDOWN_IN_MS>)
                .required(false)
                .takes_value(true)
                .help(""Set a custom repeat cooldown duration. Default is 250ms.""),
        )
        .arg(arg!(-d - -debug).required(false).help(""Enable debug mode.""));
    app
}",0,True,False,
https://github.com/waycrate/swhkd.git,e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa,Shinyzenith,2022-03-25 20:43:28+05:18,False,daemon.rs,Rust,fetch_xdg_config_path,"pub fn fetch_xdg_config_path() -> std::path::PathBuf {
    let config_file_path: std::path::PathBuf = match env::var(""XDG_CONFIG_HOME"") {
        Ok(val) => {
            log::debug!(""XDG_CONFIG_HOME exists: {:#?}"", val);
            Path::new(&val).join(""swhkd/swhkdrc"")
        }
        Err(_) => {
            log::error!(""XDG_CONFIG_HOME has not been set."");
            Path::new(""/etc/swhkd/swhkdrc"").to_path_buf()
        }
    };
    config_file_path
}",0,True,False,
https://github.com/waycrate/swhkd.git,e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa,Shinyzenith,2022-03-25 20:43:28+05:18,False,daemon.rs,Rust,seteuid uid : u32,"pub fn seteuid(uid: u32) {
    let uid = Uid::from_raw(uid);
    match nix::unistd::seteuid(uid) {
        Ok(_) => log::debug!(""Dropping privileges...""),
        Err(e) => {
            log::error!(""Failed to set EUID: {:#?}"", e);
            exit(1);
        }
    }
}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,"validate_unsigned _source : TransactionSource , call : & Self :: Call","		fn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {
			if let Call::transact(transaction) = call {
				if let Some(chain_id) = transaction.signature.chain_id() {
					if chain_id != T::ChainId::get() {
						return InvalidTransaction::Custom(
							TransactionValidationError::InvalidChainId as u8,
						)
						.into();
					}
				}

				let origin = Self::recover_signer(&transaction).ok_or_else(|| {
					InvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8)
				})?;

				if transaction.gas_limit >= T::BlockGasLimit::get() {
					return InvalidTransaction::Custom(
						TransactionValidationError::InvalidGasLimit as u8,
					)
					.into();
				}

				let account_data = pallet_evm::Pallet::<T>::account_basic(&origin);

				if transaction.nonce < account_data.nonce {
					return InvalidTransaction::Stale.into();
				}

				let fee = transaction.gas_price.saturating_mul(transaction.gas_limit);
				let total_payment = transaction.value.saturating_add(fee);
				if account_data.balance < total_payment {
					return InvalidTransaction::Payment.into();
				}

				let min_gas_price = T::FeeCalculator::min_gas_price();

				if transaction.gas_price < min_gas_price {
					return InvalidTransaction::Payment.into();
				}

				let mut builder = ValidTransactionBuilder::default()
					.and_provides((origin, transaction.nonce))
					.priority(transaction.gas_price.unique_saturated_into());

				if transaction.nonce > account_data.nonce {
					if let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {
						builder = builder.and_requires((origin, prev_nonce))
					}
				}
				builder.build()
			} else {
				Err(InvalidTransaction::Call.into())
			}
		}",1,True,True,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,"validate_unsigned _source : TransactionSource , call : & Self :: Call","		fn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {
			if let Call::transact(transaction) = call {
				// We must ensure a transaction can pay the cost of its data bytes.
				// If it can't it should not be included in a block.
				let mut gasometer = evm::gasometer::Gasometer::new(
					transaction.gas_limit.low_u64(),
					<T as pallet_evm::Config>::config(),
				);
				let transaction_cost = match transaction.action {
					TransactionAction::Call(_) => {
						evm::gasometer::call_transaction_cost(&transaction.input)
					}
					TransactionAction::Create => {
						evm::gasometer::create_transaction_cost(&transaction.input)
					}
				};
				if gasometer.record_transaction(transaction_cost).is_err() {
					return InvalidTransaction::Custom(
						TransactionValidationError::InvalidGasLimit as u8,
					)
					.into();
				}

				if let Some(chain_id) = transaction.signature.chain_id() {
					if chain_id != T::ChainId::get() {
						return InvalidTransaction::Custom(
							TransactionValidationError::InvalidChainId as u8,
						)
						.into();
					}
				}

				let origin = Self::recover_signer(&transaction).ok_or_else(|| {
					InvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8)
				})?;

				if transaction.gas_limit >= T::BlockGasLimit::get() {
					return InvalidTransaction::Custom(
						TransactionValidationError::InvalidGasLimit as u8,
					)
					.into();
				}

				let account_data = pallet_evm::Pallet::<T>::account_basic(&origin);

				if transaction.nonce < account_data.nonce {
					return InvalidTransaction::Stale.into();
				}

				let fee = transaction.gas_price.saturating_mul(transaction.gas_limit);
				let total_payment = transaction.value.saturating_add(fee);
				if account_data.balance < total_payment {
					return InvalidTransaction::Payment.into();
				}

				let min_gas_price = T::FeeCalculator::min_gas_price();

				if transaction.gas_price < min_gas_price {
					return InvalidTransaction::Payment.into();
				}

				let mut builder = ValidTransactionBuilder::default()
					.and_provides((origin, transaction.nonce))
					.priority(transaction.gas_price.unique_saturated_into());

				if transaction.nonce > account_data.nonce {
					if let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {
						builder = builder.and_requires((origin, prev_nonce))
					}
				}
				builder.build()
			} else {
				Err(InvalidTransaction::Call.into())
			}
		}",0,False,True,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,on_finalize n : T :: BlockNumber,"		fn on_finalize(n: T::BlockNumber) {
			<Pallet<T>>::store_block(
				fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
				U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(
					frame_system::Pallet::<T>::block_number(),
				)),
			);
			// move block hash pruning window by one block
			let block_hash_count = T::BlockHashCount::get();
			let to_remove = n
				.saturating_sub(block_hash_count)
				.saturating_sub(One::one());
			// keep genesis hash
			if !to_remove.is_zero() {
				<BlockHash<T>>::remove(U256::from(
					UniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),
				));
			}
		}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,on_initialize _ : T :: BlockNumber,"		fn on_initialize(_: T::BlockNumber) -> Weight {
			Pending::<T>::kill();

			if let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {
				let PreLog::Block(block) = log;

				for transaction in block.transactions {
					Self::do_transact(transaction).expect(
						""pre-block transaction verification failed; the block cannot be built"",
					);
				}
			}

			0
		}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,"transact origin : OriginFor < T > , transaction : Transaction ,","		pub fn transact(
			origin: OriginFor<T>,
			transaction: Transaction,
		) -> DispatchResultWithPostInfo {
			ensure_none(origin)?;

			Self::do_transact(transaction)
		}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,build & self,"		fn build(&self) {
			<Pallet<T>>::store_block(false, U256::zero());
			frame_support::storage::unhashed::put::<EthereumStorageSchema>(
				&PALLET_ETHEREUM_SCHEMA,
				&EthereumStorageSchema::V1,
			);
		}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,recover_signer transaction : & Transaction,"	fn recover_signer(transaction: &Transaction) -> Option<H160> {
		let mut sig = [0u8; 65];
		let mut msg = [0u8; 32];
		sig[0..32].copy_from_slice(&transaction.signature.r()[..]);
		sig[32..64].copy_from_slice(&transaction.signature.s()[..]);
		sig[64] = transaction.signature.standard_v();
		msg.copy_from_slice(&LegacyTransactionMessage::from(transaction.clone()).hash()[..]);

		let pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;
		Some(H160::from(H256::from_slice(
			Keccak256::digest(&pubkey).as_slice(),
		)))
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,"store_block post_log : bool , block_number : U256","	fn store_block(post_log: bool, block_number: U256) {
		let mut transactions = Vec::new();
		let mut statuses = Vec::new();
		let mut receipts = Vec::new();
		let mut logs_bloom = Bloom::default();
		for (transaction, status, receipt) in Pending::<T>::get() {
			transactions.push(transaction);
			statuses.push(status);
			receipts.push(receipt.clone());
			Self::logs_bloom(receipt.logs.clone(), &mut logs_bloom);
		}

		let ommers = Vec::<ethereum::Header>::new();
		let receipts_root =
			ethereum::util::ordered_trie_root(receipts.iter().map(|r| rlp::encode(r)));
		let partial_header = ethereum::PartialHeader {
			parent_hash: Self::current_block_hash().unwrap_or_default(),
			beneficiary: pallet_evm::Pallet::<T>::find_author(),
			state_root: T::StateRoot::get(),
			receipts_root,
			logs_bloom,
			difficulty: U256::zero(),
			number: block_number,
			gas_limit: T::BlockGasLimit::get(),
			gas_used: receipts
				.clone()
				.into_iter()
				.fold(U256::zero(), |acc, r| acc + r.used_gas),
			timestamp: UniqueSaturatedInto::<u64>::unique_saturated_into(
				pallet_timestamp::Pallet::<T>::get(),
			),
			extra_data: Vec::new(),
			mix_hash: H256::default(),
			nonce: H64::default(),
		};
		let block = ethereum::Block::new(partial_header, transactions.clone(), ommers);

		CurrentBlock::<T>::put(block.clone());
		CurrentReceipts::<T>::put(receipts.clone());
		CurrentTransactionStatuses::<T>::put(statuses.clone());
		BlockHash::<T>::insert(block_number, block.header.hash());

		if post_log {
			let digest = DigestItem::<T::Hash>::Consensus(
				FRONTIER_ENGINE_ID,
				PostLog::Hashes(fp_consensus::Hashes::from_block(block)).encode(),
			);
			frame_system::Pallet::<T>::deposit_log(digest.into());
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,"logs_bloom logs : Vec < Log > , bloom : & mut Bloom","	fn logs_bloom(logs: Vec<Log>, bloom: &mut Bloom) {
		for log in logs {
			bloom.accrue(BloomInput::Raw(&log.address[..]));
			for topic in log.topics {
				bloom.accrue(BloomInput::Raw(&topic[..]));
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,do_transact transaction : Transaction,"	fn do_transact(transaction: Transaction) -> DispatchResultWithPostInfo {
		ensure!(
			fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
			Error::<T>::PreLogExists,
		);

		let source =
			Self::recover_signer(&transaction).ok_or_else(|| Error::<T>::InvalidSignature)?;

		let transaction_hash =
			H256::from_slice(Keccak256::digest(&rlp::encode(&transaction)).as_slice());
		let transaction_index = Pending::<T>::get().len() as u32;

		let (to, contract_address, info) = Self::execute(
			source,
			transaction.input.clone(),
			transaction.value,
			transaction.gas_limit,
			Some(transaction.gas_price),
			Some(transaction.nonce),
			transaction.action,
			None,
		)?;

		let (reason, status, used_gas, dest) = match info {
			CallOrCreateInfo::Call(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: None,
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				to,
			),
			CallOrCreateInfo::Create(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: Some(info.value),
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				Some(info.value),
			),
		};

		let receipt = ethereum::Receipt {
			state_root: match reason {
				ExitReason::Succeed(_) => H256::from_low_u64_be(1),
				ExitReason::Error(_) => H256::from_low_u64_le(0),
				ExitReason::Revert(_) => H256::from_low_u64_le(0),
				ExitReason::Fatal(_) => H256::from_low_u64_le(0),
			},
			used_gas,
			logs_bloom: status.clone().logs_bloom,
			logs: status.clone().logs,
		};

		Pending::<T>::append((transaction, status, receipt));

		Self::deposit_event(Event::Executed(
			source,
			dest.unwrap_or_default(),
			transaction_hash,
			reason,
		));
		Ok(PostDispatchInfo {
			actual_weight: Some(T::GasWeightMapping::gas_to_weight(
				used_gas.unique_saturated_into(),
			)),
			pays_fee: Pays::No,
		})
		.into()
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,current_transaction_statuses,"	pub fn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {
		CurrentTransactionStatuses::<T>::get()
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,current_block,"	pub fn current_block() -> Option<ethereum::BlockV0> {
		CurrentBlock::<T>::get()
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,current_block_hash,"	pub fn current_block_hash() -> Option<H256> {
		Self::current_block().map(|block| block.header.hash())
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,current_receipts,"	pub fn current_receipts() -> Option<Vec<ethereum::Receipt>> {
		CurrentReceipts::<T>::get()
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,"execute from : H160 , input : Vec < u8 > , value : U256 , gas_limit : U256 , gas_price : Option < U256 > , nonce : Option < U256 > , action : TransactionAction , config : Option < evm :: Config > ,","	pub fn execute(
		from: H160,
		input: Vec<u8>,
		value: U256,
		gas_limit: U256,
		gas_price: Option<U256>,
		nonce: Option<U256>,
		action: TransactionAction,
		config: Option<evm::Config>,
	) -> Result<(Option<H160>, Option<H160>, CallOrCreateInfo), DispatchError> {
		match action {
			ethereum::TransactionAction::Call(target) => {
				let res = T::Runner::call(
					from,
					target,
					input.clone(),
					value,
					gas_limit.low_u64(),
					gas_price,
					nonce,
					config.as_ref().unwrap_or(T::config()),
				)
				.map_err(Into::into)?;

				Ok((Some(target), None, CallOrCreateInfo::Call(res)))
			}
			ethereum::TransactionAction::Create => {
				let res = T::Runner::create(
					from,
					input.clone(),
					value,
					gas_limit.low_u64(),
					gas_price,
					nonce,
					config.as_ref().unwrap_or(T::config()),
				)
				.map_err(Into::into)?;

				Ok((None, Some(res.value), CallOrCreateInfo::Create(res)))
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,default,"	fn default() -> Self {
		Self::Undefined
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,get,"	fn get() -> H256 {
		H256::decode(&mut &sp_io::storage::root()[..])
			.expect(""Node is configured to use the same hash; qed"")
	}",0,True,False,
https://github.com/paritytech/frontier.git,0b962f218f0cdd796dadfe26c3f09e68f7861b26,GitHub,2021-09-03 17:48:21+02:00,False,lib.rs,Rust,block_hash number : u32,"	fn block_hash(number: u32) -> H256 {
		BlockHash::<T>::get(U256::from(number))
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,ensure_ethereum_transaction o : OuterOrigin,"pub fn ensure_ethereum_transaction<OuterOrigin>(o: OuterOrigin) -> Result<H160, &'static str>
where
	OuterOrigin: Into<Result<RawOrigin, OuterOrigin>>,
{
	match o.into() {
		Ok(RawOrigin::EthereumTransaction(n)) => Ok(n),
		_ => Err(""bad origin: expected to be an Ethereum transaction""),
	}
}

pub struct EnsureEthereumTransaction;
impl<O: Into<Result<RawOrigin, O>> + From<RawOrigin>> EnsureOrigin<O>
	for EnsureEthereumTransaction
{
	type Success = H160;
	fn try_origin(o: O) -> Result<Self::Success, O> {
		o.into().and_then(|o| match o {
			RawOrigin::EthereumTransaction(id) => Ok(id),
		})
	}

	#[cfg(feature = ""runtime-benchmarks"")]
	fn successful_origin() -> O {
		O::from(RawOrigin::EthereumTransaction(Default::default()))
	}
}

impl<T: Config> Call<T>
where
	OriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,
{
	pub fn is_self_contained(&self) -> bool {
		match self {
			Call::transact(_) => true,
			_ => false,
		}
	}

	pub fn check_self_contained(&self) -> Option<Result<H160, TransactionValidityError>> {
		if let Call::transact(transaction) = self {
			let check = || {
				let origin = Pallet::<T>::recover_signer(&transaction).ok_or_else(|| {
					InvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8)
				})?;

				Ok(origin)
			};

			Some(check())
		} else {
			None
		}
	}

	pub fn validate_self_contained(&self, origin: &H160) -> Option<TransactionValidity> {
		if let Call::transact(transaction) = self {
			let validate = || {
				// We must ensure a transaction can pay the cost of its data bytes.
				// If it can't it should not be included in a block.
				let mut gasometer = evm::gasometer::Gasometer::new(
					transaction.gas_limit.low_u64(),
					<T as pallet_evm::Config>::config(),
				);
				let transaction_cost = match transaction.action {
					TransactionAction::Call(_) => {
						evm::gasometer::call_transaction_cost(&transaction.input)
					}
					TransactionAction::Create => {
						evm::gasometer::create_transaction_cost(&transaction.input)
					}
				};",1,True,False,"54,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70"
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,"do_transact source : H160 , transaction : Transaction","	fn do_transact(source: H160, transaction: Transaction) -> DispatchResultWithPostInfo {
		let transaction_hash =
			H256::from_slice(Keccak256::digest(&rlp::encode(&transaction)).as_slice());
		let transaction_index = Pending::<T>::get().len() as u32;

		let (to, _, info) = Self::execute(
			source,
			transaction.input.clone(),
			transaction.value,
			transaction.gas_limit,
			Some(transaction.gas_price),
			Some(transaction.nonce),
			transaction.action,
			None,
		)?;

		let (reason, status, used_gas, dest) = match info {
			CallOrCreateInfo::Call(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: None,
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				to,
			),
			CallOrCreateInfo::Create(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: Some(info.value),
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				Some(info.value),
			),
		};

		let receipt = ethereum::Receipt {
			state_root: match reason {
				ExitReason::Succeed(_) => H256::from_low_u64_be(1),
				ExitReason::Error(_) => H256::from_low_u64_le(0),
				ExitReason::Revert(_) => H256::from_low_u64_le(0),
				ExitReason::Fatal(_) => H256::from_low_u64_le(0),
			},
			used_gas,
			logs_bloom: status.clone().logs_bloom,
			logs: status.clone().logs,
		};

		Pending::<T>::append((transaction, status, receipt));

		Self::deposit_event(Event::Executed(
			source,
			dest.unwrap_or_default(),
			transaction_hash,
			reason,
		));
		Ok(PostDispatchInfo {
			actual_weight: Some(T::GasWeightMapping::gas_to_weight(
				used_gas.unique_saturated_into(),
			)),
			pays_fee: Pays::No,
		})
		.into()
	}",1,True,False,0
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,on_initialize _ : T :: BlockNumber,"		fn on_initialize(_: T::BlockNumber) -> Weight {
			Pending::<T>::kill();

			// If the digest contain an existing ethereum block(encoded as PreLog), If contains,
			// execute the imported block firstly and disable transact dispatch function.
			if let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {
				let PreLog::Block(block) = log;

				for transaction in block.transactions {
					let source = Self::recover_signer(&transaction).expect(
						""pre-block transaction signature invalid; the block cannot be built"",
					);

					Self::do_transact(source, transaction).expect(
						""pre-block transaction verification failed; the block cannot be built"",
					);
				}
			}

			0
		}",1,True,False,13
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,"transact origin : OriginFor < T > , transaction : Transaction ,","		pub fn transact(
			origin: OriginFor<T>,
			transaction: Transaction,
		) -> DispatchResultWithPostInfo {
			let source = ensure_ethereum_transaction(origin)?;
			// Disable transact functionality if PreLog exist.
			ensure!(
				fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
				Error::<T>::PreLogExists,
			);

			Self::do_transact(source, transaction)
		}",1,True,False,11
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,"validate_transaction_common origin : H160 , transaction : & Transaction ,","	fn validate_transaction_common(
		origin: H160,
		transaction: &Transaction,
	) -> Result<U256, TransactionValidityError> {
		// We must ensure a transaction can pay the cost of its data bytes.
		// If it can't it should not be included in a block.
		let mut gasometer = evm::gasometer::Gasometer::new(
			transaction.gas_limit.low_u64(),
			<T as pallet_evm::Config>::config(),
		);
		let transaction_cost = match transaction.action {
			TransactionAction::Call(_) => evm::gasometer::call_transaction_cost(&transaction.input),
			TransactionAction::Create => {
				evm::gasometer::create_transaction_cost(&transaction.input)
			}
		};
		if gasometer.record_transaction(transaction_cost).is_err() {
			return Err(InvalidTransaction::Custom(
				TransactionValidationError::InvalidGasLimit as u8,
			)
			.into());
		}

		if let Some(chain_id) = transaction.signature.chain_id() {
			if chain_id != T::ChainId::get() {
				return Err(InvalidTransaction::Custom(
					TransactionValidationError::InvalidChainId as u8,
				)
				.into());
			}
		}

		if transaction.gas_limit >= T::BlockGasLimit::get() {
			return Err(InvalidTransaction::Custom(
				TransactionValidationError::InvalidGasLimit as u8,
			)
			.into());
		}

		let account_data = pallet_evm::Pallet::<T>::account_basic(&origin);

		let fee = transaction.gas_price.saturating_mul(transaction.gas_limit);
		let total_payment = transaction.value.saturating_add(fee);
		if account_data.balance < total_payment {
			return Err(InvalidTransaction::Payment.into());
		}

		let min_gas_price = T::FeeCalculator::min_gas_price();

		if transaction.gas_price < min_gas_price {
			return Err(InvalidTransaction::Payment.into());
		}

		Ok(account_data.nonce)
	}",0,False,True,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,"apply_validated_transaction source : H160 , transaction : Transaction ,","	fn apply_validated_transaction(
		source: H160,
		transaction: Transaction,
	) -> DispatchResultWithPostInfo {
		let transaction_hash =
			H256::from_slice(Keccak256::digest(&rlp::encode(&transaction)).as_slice());
		let transaction_index = Pending::<T>::get().len() as u32;

		let (to, _, info) = Self::execute(
			source,
			transaction.input.clone(),
			transaction.value,
			transaction.gas_limit,
			Some(transaction.gas_price),
			Some(transaction.nonce),
			transaction.action,
			None,
		)?;

		let (reason, status, used_gas, dest) = match info {
			CallOrCreateInfo::Call(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: None,
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				to,
			),
			CallOrCreateInfo::Create(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: Some(info.value),
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				Some(info.value),
			),
		};

		let receipt = ethereum::Receipt {
			state_root: match reason {
				ExitReason::Succeed(_) => H256::from_low_u64_be(1),
				ExitReason::Error(_) => H256::from_low_u64_le(0),
				ExitReason::Revert(_) => H256::from_low_u64_le(0),
				ExitReason::Fatal(_) => H256::from_low_u64_le(0),
			},
			used_gas,
			logs_bloom: status.clone().logs_bloom,
			logs: status.clone().logs,
		};

		Pending::<T>::append((transaction, status, receipt));

		Self::deposit_event(Event::Executed(
			source,
			dest.unwrap_or_default(),
			transaction_hash,
			reason,
		));
		Ok(PostDispatchInfo {
			actual_weight: Some(T::GasWeightMapping::gas_to_weight(
				used_gas.unique_saturated_into(),
			)),
			pays_fee: Pays::No,
		})
		.into()
	}",0,False,True,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,"validate_transaction_in_pool origin : H160 , transaction : & Transaction ,","	fn validate_transaction_in_pool(
		origin: H160,
		transaction: &Transaction,
	) -> TransactionValidity {
		let account_nonce = Self::validate_transaction_common(origin, transaction)?;

		if transaction.nonce < account_nonce {
			return Err(InvalidTransaction::Stale.into());
		}

		// The tag provides and requires must be filled correctly according to the nonce.
		let mut builder = ValidTransactionBuilder::default()
			.and_provides((origin, transaction.nonce))
			.priority(transaction.gas_price.unique_saturated_into());

		// In the context of the pool, a transaction with
		// too high a nonce is still considered valid
		if transaction.nonce > account_nonce {
			if let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {
				builder = builder.and_requires((origin, prev_nonce))
			}
		}

		builder.build()
	}",0,False,True,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,ensure_ethereum_transaction o : OuterOrigin,"pub fn ensure_ethereum_transaction<OuterOrigin>(o: OuterOrigin) -> Result<H160, &'static str>
where
	OuterOrigin: Into<Result<RawOrigin, OuterOrigin>>,
{
	match o.into() {
		Ok(RawOrigin::EthereumTransaction(n)) => Ok(n),
		_ => Err(""bad origin: expected to be an Ethereum transaction""),
	}
}

pub struct EnsureEthereumTransaction;
impl<O: Into<Result<RawOrigin, O>> + From<RawOrigin>> EnsureOrigin<O>
	for EnsureEthereumTransaction
{
	type Success = H160;
	fn try_origin(o: O) -> Result<Self::Success, O> {
		o.into().and_then(|o| match o {
			RawOrigin::EthereumTransaction(id) => Ok(id),
		})
	}

	#[cfg(feature = ""runtime-benchmarks"")]
	fn successful_origin() -> O {
		O::from(RawOrigin::EthereumTransaction(Default::default()))
	}
}

impl<T: Config> Call<T>
where
	OriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,
{
	pub fn is_self_contained(&self) -> bool {
		match self {
			Call::transact(_) => true,
			_ => false,
		}
	}

	pub fn check_self_contained(&self) -> Option<Result<H160, TransactionValidityError>> {
		if let Call::transact(transaction) = self {
			let check = || {
				let origin = Pallet::<T>::recover_signer(&transaction).ok_or_else(|| {
					InvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8)
				})?;

				Ok(origin)
			};

			Some(check())
		} else {
			None
		}
	}

	pub fn pre_dispatch_self_contained(
		&self,
		origin: &H160,
	) -> Option<Result<(), TransactionValidityError>> {
		if let Call::transact(transaction) = self {
			Some(Pallet::<T>::validate_transaction_in_block(
				*origin,
				&transaction,
			))
		} else {
			None
		}
	}

	pub fn validate_self_contained(&self, origin: &H160) -> Option<TransactionValidity> {
		if let Call::transact(transaction) = self {
			Some(Pallet::<T>::validate_transaction_in_pool(
				*origin,
				transaction,
			))
		} else {
			None
		}
	}
}

pub use pallet::*;

#[frame_support::pallet]
pub mod pallet {
	use super::*;
	use frame_support::pallet_prelude::*;
	use frame_system::pallet_prelude::*;

	#[pallet::config]
	pub trait Config:
		frame_system::Config
		+ pallet_balances::Config
		+ pallet_timestamp::Config
		+ pallet_evm::Config
	{
		/// The overarching event type.
		type Event: From<Event> + IsType<<Self as frame_system::Config>::Event>;
		/// How Ethereum state root is calculated.
		type StateRoot: Get<H256>;
	}

	#[pallet::pallet]
	#[pallet::generate_store(pub(super) trait Store)]
	pub struct Pallet<T>(PhantomData<T>);

	#[pallet::origin]
	pub type Origin = RawOrigin;

	#[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
		fn on_finalize(n: T::BlockNumber) {
			<Pallet<T>>::store_block(
				fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
				U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(
					frame_system::Pallet::<T>::block_number(),
				)),
			);
			// move block hash pruning window by one block
			let block_hash_count = T::BlockHashCount::get();
			let to_remove = n
				.saturating_sub(block_hash_count)
				.saturating_sub(One::one());
			// keep genesis hash
			if !to_remove.is_zero() {
				<BlockHash<T>>::remove(U256::from(
					UniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),
				));
			}
		}

		fn on_initialize(_: T::BlockNumber) -> Weight {
			Pending::<T>::kill();

			// If the digest contain an existing ethereum block(encoded as PreLog), If contains,
			// execute the imported block firstly and disable transact dispatch function.
			if let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {
				let PreLog::Block(block) = log;

				for transaction in block.transactions {
					let source = Self::recover_signer(&transaction).expect(
						""pre-block transaction signature invalid; the block cannot be built"",
					);

					Self::validate_transaction_in_block(source, &transaction).expect(
						""pre-block transaction verification failed; the block cannot be built"",
					);
					Self::apply_validated_transaction(source, transaction).expect(
						""pre-block transaction execution failed; the block cannot be built"",
					);
				}
			}

			0
		}
	}

	#[pallet::call]
	impl<T: Config> Pallet<T>
	where
		OriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,
	{
		/// Transact an Ethereum transaction.
		#[pallet::weight(<T as pallet_evm::Config>::GasWeightMapping::gas_to_weight(transaction.gas_limit.unique_saturated_into()))]
		pub fn transact(
			origin: OriginFor<T>,
			transaction: Transaction,
		) -> DispatchResultWithPostInfo {
			let source = ensure_ethereum_transaction(origin)?;
			// Disable transact functionality if PreLog exist.
			ensure!(
				fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
				Error::<T>::PreLogExists,
			);

			Self::apply_validated_transaction(source, transaction)
		}
	}

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event {
		/// An ethereum transaction was successfully executed. [from, to/contract_address, transaction_hash, exit_reason]
		Executed(H160, H160, H256, ExitReason),
	}

	#[pallet::error]
	pub enum Error<T> {
		/// Signature is invalid.
		InvalidSignature,
		/// Pre-log is present, therefore transact is not allowed.
		PreLogExists,
	}

	/// Current building block's transactions and receipts.
	#[pallet::storage]
	pub(super) type Pending<T: Config> =
		StorageValue<_, Vec<(Transaction, TransactionStatus, ethereum::Receipt)>, ValueQuery>;

	/// The current Ethereum block.
	#[pallet::storage]
	pub(super) type CurrentBlock<T: Config> = StorageValue<_, ethereum::BlockV0>;

	/// The current Ethereum receipts.
	#[pallet::storage]
	pub(super) type CurrentReceipts<T: Config> = StorageValue<_, Vec<ethereum::Receipt>>;

	/// The current transaction statuses.
	#[pallet::storage]
	pub(super) type CurrentTransactionStatuses<T: Config> = StorageValue<_, Vec<TransactionStatus>>;

	// Mapping for block number and hashes.
	#[pallet::storage]
	pub(super) type BlockHash<T: Config> = StorageMap<_, Twox64Concat, U256, H256, ValueQuery>;

	#[pallet::genesis_config]
	#[derive(Default)]
	pub struct GenesisConfig {}",0,False,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,"validate_transaction_in_block origin : H160 , transaction : & ethereum :: TransactionV0 ,","	pub fn validate_transaction_in_block(
		origin: H160,
		transaction: &ethereum::TransactionV0,
	) -> Result<(), TransactionValidityError> {
		let account_nonce = Self::validate_transaction_common(origin, transaction)?;

		// In the context of the block, a transaction with a nonce that is
		// too high should be considered invalid and make the whole block invalid.
		if transaction.nonce > account_nonce {
			Err(TransactionValidityError::Invalid(
				InvalidTransaction::Future,
			))
		} else if transaction.nonce < account_nonce {
			Err(TransactionValidityError::Invalid(InvalidTransaction::Stale))
		} else {
			Ok(())
		}
	}",0,False,True,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,on_finalize n : T :: BlockNumber,"		fn on_finalize(n: T::BlockNumber) {
			<Pallet<T>>::store_block(
				fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
				U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(
					frame_system::Pallet::<T>::block_number(),
				)),
			);
			// move block hash pruning window by one block
			let block_hash_count = T::BlockHashCount::get();
			let to_remove = n
				.saturating_sub(block_hash_count)
				.saturating_sub(One::one());
			// keep genesis hash
			if !to_remove.is_zero() {
				<BlockHash<T>>::remove(U256::from(
					UniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),
				));
			}
		}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,build & self,"		fn build(&self) {
			<Pallet<T>>::store_block(false, U256::zero());
			frame_support::storage::unhashed::put::<EthereumStorageSchema>(
				&PALLET_ETHEREUM_SCHEMA,
				&EthereumStorageSchema::V1,
			);
		}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,recover_signer transaction : & Transaction,"	fn recover_signer(transaction: &Transaction) -> Option<H160> {
		let mut sig = [0u8; 65];
		let mut msg = [0u8; 32];
		sig[0..32].copy_from_slice(&transaction.signature.r()[..]);
		sig[32..64].copy_from_slice(&transaction.signature.s()[..]);
		sig[64] = transaction.signature.standard_v();
		msg.copy_from_slice(&LegacyTransactionMessage::from(transaction.clone()).hash()[..]);

		let pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;
		Some(H160::from(H256::from_slice(
			Keccak256::digest(&pubkey).as_slice(),
		)))
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,"store_block post_log : bool , block_number : U256","	fn store_block(post_log: bool, block_number: U256) {
		let mut transactions = Vec::new();
		let mut statuses = Vec::new();
		let mut receipts = Vec::new();
		let mut logs_bloom = Bloom::default();
		for (transaction, status, receipt) in Pending::<T>::get() {
			transactions.push(transaction);
			statuses.push(status);
			receipts.push(receipt.clone());
			Self::logs_bloom(receipt.logs.clone(), &mut logs_bloom);
		}

		let ommers = Vec::<ethereum::Header>::new();
		let receipts_root =
			ethereum::util::ordered_trie_root(receipts.iter().map(|r| rlp::encode(r)));
		let partial_header = ethereum::PartialHeader {
			parent_hash: Self::current_block_hash().unwrap_or_default(),
			beneficiary: pallet_evm::Pallet::<T>::find_author(),
			state_root: T::StateRoot::get(),
			receipts_root,
			logs_bloom,
			difficulty: U256::zero(),
			number: block_number,
			gas_limit: T::BlockGasLimit::get(),
			gas_used: receipts
				.clone()
				.into_iter()
				.fold(U256::zero(), |acc, r| acc + r.used_gas),
			timestamp: UniqueSaturatedInto::<u64>::unique_saturated_into(
				pallet_timestamp::Pallet::<T>::get(),
			),
			extra_data: Vec::new(),
			mix_hash: H256::default(),
			nonce: H64::default(),
		};
		let block = ethereum::Block::new(partial_header, transactions.clone(), ommers);

		CurrentBlock::<T>::put(block.clone());
		CurrentReceipts::<T>::put(receipts.clone());
		CurrentTransactionStatuses::<T>::put(statuses.clone());
		BlockHash::<T>::insert(block_number, block.header.hash());

		if post_log {
			let digest = DigestItem::<T::Hash>::Consensus(
				FRONTIER_ENGINE_ID,
				PostLog::Hashes(fp_consensus::Hashes::from_block(block)).encode(),
			);
			frame_system::Pallet::<T>::deposit_log(digest.into());
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,"logs_bloom logs : Vec < Log > , bloom : & mut Bloom","	fn logs_bloom(logs: Vec<Log>, bloom: &mut Bloom) {
		for log in logs {
			bloom.accrue(BloomInput::Raw(&log.address[..]));
			for topic in log.topics {
				bloom.accrue(BloomInput::Raw(&topic[..]));
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,current_transaction_statuses,"	pub fn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {
		CurrentTransactionStatuses::<T>::get()
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,current_block,"	pub fn current_block() -> Option<ethereum::BlockV0> {
		CurrentBlock::<T>::get()
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,current_block_hash,"	pub fn current_block_hash() -> Option<H256> {
		Self::current_block().map(|block| block.header.hash())
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,current_receipts,"	pub fn current_receipts() -> Option<Vec<ethereum::Receipt>> {
		CurrentReceipts::<T>::get()
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,"execute from : H160 , input : Vec < u8 > , value : U256 , gas_limit : U256 , gas_price : Option < U256 > , nonce : Option < U256 > , action : TransactionAction , config : Option < evm :: Config > ,","	pub fn execute(
		from: H160,
		input: Vec<u8>,
		value: U256,
		gas_limit: U256,
		gas_price: Option<U256>,
		nonce: Option<U256>,
		action: TransactionAction,
		config: Option<evm::Config>,
	) -> Result<(Option<H160>, Option<H160>, CallOrCreateInfo), DispatchError> {
		match action {
			ethereum::TransactionAction::Call(target) => {
				let res = T::Runner::call(
					from,
					target,
					input.clone(),
					value,
					gas_limit.low_u64(),
					gas_price,
					nonce,
					config.as_ref().unwrap_or(T::config()),
				)
				.map_err(Into::into)?;

				Ok((Some(target), None, CallOrCreateInfo::Call(res)))
			}
			ethereum::TransactionAction::Create => {
				let res = T::Runner::create(
					from,
					input.clone(),
					value,
					gas_limit.low_u64(),
					gas_price,
					nonce,
					config.as_ref().unwrap_or(T::config()),
				)
				.map_err(Into::into)?;

				Ok((None, Some(res.value), CallOrCreateInfo::Create(res)))
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,default,"	fn default() -> Self {
		Self::Undefined
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,get,"	fn get() -> H256 {
		H256::decode(&mut &sp_io::storage::root()[..])
			.expect(""Node is configured to use the same hash; qed"")
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,block_hash number : u32,"	fn block_hash(number: u32) -> H256 {
		BlockHash::<T>::get(U256::from(number))
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,mock.rs,Rust,min_gas_price,"	fn min_gas_price() -> U256 {
		1.into()
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,checked_extrinsic.rs,Rust,"apply self , info : & DispatchInfoOf < Self :: Call > , len : usize ,","	fn apply<U: ValidateUnsigned<Call = Self::Call>>(
		self,
		info: &DispatchInfoOf<Self::Call>,
		len: usize,
	) -> sp_runtime::ApplyExtrinsicResultWithInfo<PostDispatchInfoOf<Self::Call>> {
		match self.signed {
			CheckedSignature::Signed(id, extra) => {
				let pre = Extra::pre_dispatch(extra, &id, &self.function, info, len)?;
				let maybe_who = Some(id);
				let res = self.function.dispatch(Origin::from(maybe_who));
				let post_info = match res {
					Ok(info) => info,
					Err(err) => err.post_info,
				};
				Extra::post_dispatch(
					pre,
					info,
					&post_info,
					len,
					&res.map(|_| ()).map_err(|e| e.error),
				)?;
				Ok(res)
			}
			CheckedSignature::Unsigned => {
				let pre = Extra::pre_dispatch_unsigned(&self.function, info, len)?;
				U::pre_dispatch(&self.function)?;
				let maybe_who = None;
				let res = self.function.dispatch(Origin::from(maybe_who));
				let post_info = match res {
					Ok(info) => info,
					Err(err) => err.post_info,
				};
				Extra::post_dispatch(
					pre,
					info,
					&post_info,
					len,
					&res.map(|_| ()).map_err(|e| e.error),
				)?;
				Ok(res)
			}
			CheckedSignature::SelfContained(signed_info) => {
				Ok(self.function.apply_self_contained(signed_info).ok_or(
					TransactionValidityError::Invalid(InvalidTransaction::BadProof),
				)?)
			}
		}
	}",1,True,True,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,checked_extrinsic.rs,Rust,"apply self , info : & DispatchInfoOf < Self :: Call > , len : usize ,","	fn apply<U: ValidateUnsigned<Call = Self::Call>>(
		self,
		info: &DispatchInfoOf<Self::Call>,
		len: usize,
	) -> sp_runtime::ApplyExtrinsicResultWithInfo<PostDispatchInfoOf<Self::Call>> {
		match self.signed {
			CheckedSignature::Signed(id, extra) => {
				let pre = Extra::pre_dispatch(extra, &id, &self.function, info, len)?;
				let maybe_who = Some(id);
				let res = self.function.dispatch(Origin::from(maybe_who));
				let post_info = match res {
					Ok(info) => info,
					Err(err) => err.post_info,
				};
				Extra::post_dispatch(
					pre,
					info,
					&post_info,
					len,
					&res.map(|_| ()).map_err(|e| e.error),
				)?;
				Ok(res)
			}
			CheckedSignature::Unsigned => {
				let pre = Extra::pre_dispatch_unsigned(&self.function, info, len)?;
				U::pre_dispatch(&self.function)?;
				let maybe_who = None;
				let res = self.function.dispatch(Origin::from(maybe_who));
				let post_info = match res {
					Ok(info) => info,
					Err(err) => err.post_info,
				};
				Extra::post_dispatch(
					pre,
					info,
					&post_info,
					len,
					&res.map(|_| ()).map_err(|e| e.error),
				)?;
				Ok(res)
			}
			CheckedSignature::SelfContained(signed_info) => {
				// If pre-dispatch fail, the block must be considered invalid
				self.function
					.pre_dispatch_self_contained(&signed_info)
					.ok_or(TransactionValidityError::Invalid(
						InvalidTransaction::BadProof,
					))??;
				Ok(self.function.apply_self_contained(signed_info).ok_or(
					TransactionValidityError::Invalid(InvalidTransaction::BadProof),
				)?)
			}
		}
	}",0,False,True,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,checked_extrinsic.rs,Rust,get_dispatch_info & self,"	fn get_dispatch_info(&self) -> DispatchInfo {
		self.function.get_dispatch_info()
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,checked_extrinsic.rs,Rust,"validate & self , source : TransactionSource , info : & DispatchInfoOf < Self :: Call > , len : usize ,","	fn validate<U: ValidateUnsigned<Call = Self::Call>>(
		&self,
		// TODO [#5006;ToDr] should source be passed to `SignedExtension`s?
		// Perhaps a change for 2.0 to avoid breaking too much APIs?
		source: TransactionSource,
		info: &DispatchInfoOf<Self::Call>,
		len: usize,
	) -> TransactionValidity {
		match &self.signed {
			CheckedSignature::Signed(id, extra) => {
				Extra::validate(extra, id, &self.function, info, len)
			}
			CheckedSignature::Unsigned => {
				let valid = Extra::validate_unsigned(&self.function, info, len)?;
				let unsigned_validation = U::validate_unsigned(source, &self.function)?;
				Ok(valid.combine_with(unsigned_validation))
			}
			CheckedSignature::SelfContained(signed_info) => {
				self.function.validate_self_contained(&signed_info).ok_or(
					TransactionValidityError::Invalid(InvalidTransaction::BadProof),
				)?
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,146bb48849e5393004be5c88beefe76fdf009aba,GitHub,2021-10-13 14:48:35+02:00,False,lib.rs,Rust,native_version,"pub fn native_version() -> NativeVersion {
	NativeVersion {
		runtime_version: VERSION,
		can_author_with: Default::default(),
	}
}",0,True,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,"calculate_multiplication_complexity base_length : u64 , mod_length : u64","	fn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {
		let max_length = max(base_length, mod_length);
		let mut words = max_length / 8;
		if max_length % 8 > 0 {
			words += 1;
		}

		// TODO: prevent/handle overflow
		words * words
	}",1,True,False,7
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,"calculate_iteration_count exp_length : u64 , exponent : & BigUint","	fn calculate_iteration_count(exp_length: u64, exponent: &BigUint) -> u64 {
		let mut iteration_count: u64 = 0;

		if exp_length <= 32 && exponent.is_zero() {
			iteration_count = 0;
		} else if exp_length <= 32 {
			iteration_count = exponent.bits() - 1;
		} else if exp_length > 32 {
			// construct BigUint to represent (2^256) - 1
			let bytes: [u8; 32] = [0xFF; 32];
			let max_256_bit_uint = BigUint::from_bytes_be(&bytes);

			iteration_count =
				(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);
		}

		max(iteration_count, 1)
	}",1,True,False,13
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,"execute input : & [ u8 ] , target_gas : Option < u64 > , _context : & Context , _is_static : bool ,","	fn execute(
		input: &[u8],
		target_gas: Option<u64>,
		_context: &Context,
		_is_static: bool,
	) -> PrecompileResult {
		if input.len() < 96 {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""input must contain at least 96 bytes"".into()),
			});
		};

		// reasonable assumption: this must fit within the Ethereum EVM's max stack size
		let max_size_big = BigUint::from_u32(1024).expect(""can't create BigUint"");

		let mut buf = [0; 32];
		buf.copy_from_slice(&input[0..32]);
		let base_len_big = BigUint::from_bytes_be(&buf);
		if base_len_big > max_size_big {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""unreasonably large base length"".into()),
			});
		}

		buf.copy_from_slice(&input[32..64]);
		let exp_len_big = BigUint::from_bytes_be(&buf);
		if exp_len_big > max_size_big {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""unreasonably large exponent length"".into()),
			});
		}

		buf.copy_from_slice(&input[64..96]);
		let mod_len_big = BigUint::from_bytes_be(&buf);
		if mod_len_big > max_size_big {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""unreasonably large exponent length"".into()),
			});
		}

		// bounds check handled above
		let base_len = base_len_big.to_usize().expect(""base_len out of bounds"");
		let exp_len = exp_len_big.to_usize().expect(""exp_len out of bounds"");
		let mod_len = mod_len_big.to_usize().expect(""mod_len out of bounds"");

		// input length should be at least 96 + user-specified length of base + exp + mod
		let total_len = base_len + exp_len + mod_len + 96;
		if input.len() < total_len {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""insufficient input size"".into()),
			});
		}

		// Gas formula allows arbitrary large exp_len when base and modulus are empty, so we need to handle empty base first.
		let (r, gas_cost) = if base_len == 0 && mod_len == 0 {
			(BigUint::zero(), MIN_GAS_COST)
		} else {
			// read the numbers themselves.
			let base_start = 96; // previous 3 32-byte fields
			let base = BigUint::from_bytes_be(&input[base_start..base_start + base_len]);

			let exp_start = base_start + base_len;
			let exponent = BigUint::from_bytes_be(&input[exp_start..exp_start + exp_len]);

			// do our gas accounting
			// TODO: we could technically avoid reading base first...
			let gas_cost =
				calculate_gas_cost(base_len as u64, exp_len as u64, mod_len as u64, &exponent);
			if let Some(gas_left) = target_gas {
				if gas_left < gas_cost {
					return Err(PrecompileFailure::Error {
						exit_status: ExitError::OutOfGas,
					});
				}
			};

			let mod_start = exp_start + exp_len;
			let modulus = BigUint::from_bytes_be(&input[mod_start..mod_start + mod_len]);

			if modulus.is_zero() || modulus.is_one() {
				(BigUint::zero(), gas_cost)
			} else {
				(base.modpow(&exponent, &modulus), gas_cost)
			}
		};

		// write output to given memory, left padded and same length as the modulus.
		let bytes = r.to_bytes_be();

		// always true except in the case of zero-length modulus, which leads to
		// output of length and value 1.
		if bytes.len() == mod_len {
			Ok(PrecompileOutput {
				exit_status: ExitSucceed::Returned,
				cost: gas_cost,
				output: bytes.to_vec(),
				logs: Default::default(),
			})
		} else if bytes.len() < mod_len {
			let mut ret = Vec::with_capacity(mod_len);
			ret.extend(core::iter::repeat(0).take(mod_len - bytes.len()));
			ret.extend_from_slice(&bytes[..]);
			Ok(PrecompileOutput {
				exit_status: ExitSucceed::Returned,
				cost: gas_cost,
				output: ret.to_vec(),
				logs: Default::default(),
			})
		} else {
			Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""failed"".into()),
			})
		}
	}",1,True,False,"36,65"
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,"calculate_gas_cost base_length : u64 , exp_length : u64 , mod_length : u64 , exponent : & BigUint ,","fn calculate_gas_cost(
	base_length: u64,
	exp_length: u64,
	mod_length: u64,
	exponent: &BigUint,
) -> u64 {
	fn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {
		let max_length = max(base_length, mod_length);
		let mut words = max_length / 8;
		if max_length % 8 > 0 {
			words += 1;
		}

		// TODO: prevent/handle overflow
		words * words
	}

	fn calculate_iteration_count(exp_length: u64, exponent: &BigUint) -> u64 {
		let mut iteration_count: u64 = 0;

		if exp_length <= 32 && exponent.is_zero() {
			iteration_count = 0;
		} else if exp_length <= 32 {
			iteration_count = exponent.bits() - 1;
		} else if exp_length > 32 {
			// construct BigUint to represent (2^256) - 1
			let bytes: [u8; 32] = [0xFF; 32];
			let max_256_bit_uint = BigUint::from_bytes_be(&bytes);

			iteration_count =
				(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);
		}

		max(iteration_count, 1)
	}

	let multiplication_complexity = calculate_multiplication_complexity(base_length, mod_length);
	let iteration_count = calculate_iteration_count(exp_length, exponent);
	let gas = max(
		MIN_GAS_COST,
		multiplication_complexity * iteration_count / 3,
	);

	gas
}",1,True,False,"13,30"
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,"calculate_multiplication_complexity base_length : u64 , mod_length : u64","	fn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {
		let max_length = max(base_length, mod_length);
		let mut words = max_length / 8;
		if max_length % 8 > 0 {
			words += 1;
		}

		// Note: can't overflow because we take words to be some u64 value / 8, which is
		// necessarily less than sqrt(u64::MAX).
		// Additionally, both base_length and mod_length are bounded to 1024, so this has
		// an upper bound of roughly (1024 / 8) squared
		words * words
	}",0,False,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,"calculate_gas_cost base_length : u64 , exp_length : u64 , mod_length : u64 , exponent : & BigUint ,","fn calculate_gas_cost(
	base_length: u64,
	exp_length: u64,
	mod_length: u64,
	exponent: &BigUint,
) -> u64 {
	fn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {
		let max_length = max(base_length, mod_length);
		let mut words = max_length / 8;
		if max_length % 8 > 0 {
			words += 1;
		}

		// Note: can't overflow because we take words to be some u64 value / 8, which is
		// necessarily less than sqrt(u64::MAX).
		// Additionally, both base_length and mod_length are bounded to 1024, so this has
		// an upper bound of roughly (1024 / 8) squared
		words * words
	}

	fn calculate_iteration_count(exp_length: u64, exponent: &BigUint) -> u64 {
		let mut iteration_count: u64 = 0;

		if exp_length <= 32 && exponent.is_zero() {
			iteration_count = 0;
		} else if exp_length <= 32 {
			iteration_count = exponent.bits() - 1;
		} else if exp_length > 32 {
			// construct BigUint to represent (2^256) - 1
			let bytes: [u8; 32] = [0xFF; 32];
			let max_256_bit_uint = BigUint::from_bytes_be(&bytes);

			// from the EIP spec:
			// (8 * (exp_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)
			//
			// Notes:
			// * exp_length is bounded to 1024 and is > 32
			// * exponent can be zero, so we subtract 1 after adding the other terms (whose sum
			//   must be > 0)
			// * the addition can't overflow because the terms are both capped at roughly
			//   8 * max size of exp_length (1024)
			iteration_count =
				(8 * (exp_length - 32)) + exponent.bitand(max_256_bit_uint).bits() - 1;
		}

		max(iteration_count, 1)
	}

	let multiplication_complexity = calculate_multiplication_complexity(base_length, mod_length);
	let iteration_count = calculate_iteration_count(exp_length, exponent);
	let gas = max(
		MIN_GAS_COST,
		multiplication_complexity * iteration_count / 3,
	);

	gas
}",0,False,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,"calculate_iteration_count exp_length : u64 , exponent : & BigUint","	fn calculate_iteration_count(exp_length: u64, exponent: &BigUint) -> u64 {
		let mut iteration_count: u64 = 0;

		if exp_length <= 32 && exponent.is_zero() {
			iteration_count = 0;
		} else if exp_length <= 32 {
			iteration_count = exponent.bits() - 1;
		} else if exp_length > 32 {
			// construct BigUint to represent (2^256) - 1
			let bytes: [u8; 32] = [0xFF; 32];
			let max_256_bit_uint = BigUint::from_bytes_be(&bytes);

			// from the EIP spec:
			// (8 * (exp_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)
			//
			// Notes:
			// * exp_length is bounded to 1024 and is > 32
			// * exponent can be zero, so we subtract 1 after adding the other terms (whose sum
			//   must be > 0)
			// * the addition can't overflow because the terms are both capped at roughly
			//   8 * max size of exp_length (1024)
			iteration_count =
				(8 * (exp_length - 32)) + exponent.bitand(max_256_bit_uint).bits() - 1;
		}

		max(iteration_count, 1)
	}",0,False,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,"execute input : & [ u8 ] , target_gas : Option < u64 > , _context : & Context , _is_static : bool ,","	fn execute(
		input: &[u8],
		target_gas: Option<u64>,
		_context: &Context,
		_is_static: bool,
	) -> PrecompileResult {
		if input.len() < 96 {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""input must contain at least 96 bytes"".into()),
			});
		};

		// reasonable assumption: this must fit within the Ethereum EVM's max stack size
		let max_size_big = BigUint::from_u32(1024).expect(""can't create BigUint"");

		let mut buf = [0; 32];
		buf.copy_from_slice(&input[0..32]);
		let base_len_big = BigUint::from_bytes_be(&buf);
		if base_len_big > max_size_big {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""unreasonably large base length"".into()),
			});
		}

		buf.copy_from_slice(&input[32..64]);
		let exp_len_big = BigUint::from_bytes_be(&buf);
		if exp_len_big > max_size_big {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""unreasonably large exponent length"".into()),
			});
		}

		buf.copy_from_slice(&input[64..96]);
		let mod_len_big = BigUint::from_bytes_be(&buf);
		if mod_len_big > max_size_big {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""unreasonably large modulus length"".into()),
			});
		}

		// bounds check handled above
		let base_len = base_len_big.to_usize().expect(""base_len out of bounds"");
		let exp_len = exp_len_big.to_usize().expect(""exp_len out of bounds"");
		let mod_len = mod_len_big.to_usize().expect(""mod_len out of bounds"");

		// input length should be at least 96 + user-specified length of base + exp + mod
		let total_len = base_len + exp_len + mod_len + 96;
		if input.len() < total_len {
			return Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""insufficient input size"".into()),
			});
		}

		// Gas formula allows arbitrary large exp_len when base and modulus are empty, so we need to handle empty base first.
		let (r, gas_cost) = if base_len == 0 && mod_len == 0 {
			(BigUint::zero(), MIN_GAS_COST)
		} else {
			// read the numbers themselves.
			let base_start = 96; // previous 3 32-byte fields
			let base = BigUint::from_bytes_be(&input[base_start..base_start + base_len]);

			let exp_start = base_start + base_len;
			let exponent = BigUint::from_bytes_be(&input[exp_start..exp_start + exp_len]);

			// do our gas accounting
			let gas_cost =
				calculate_gas_cost(base_len as u64, exp_len as u64, mod_len as u64, &exponent);
			if let Some(gas_left) = target_gas {
				if gas_left < gas_cost {
					return Err(PrecompileFailure::Error {
						exit_status: ExitError::OutOfGas,
					});
				}
			};

			let mod_start = exp_start + exp_len;
			let modulus = BigUint::from_bytes_be(&input[mod_start..mod_start + mod_len]);

			if modulus.is_zero() || modulus.is_one() {
				(BigUint::zero(), gas_cost)
			} else {
				(base.modpow(&exponent, &modulus), gas_cost)
			}
		};

		// write output to given memory, left padded and same length as the modulus.
		let bytes = r.to_bytes_be();

		// always true except in the case of zero-length modulus, which leads to
		// output of length and value 1.
		if bytes.len() == mod_len {
			Ok(PrecompileOutput {
				exit_status: ExitSucceed::Returned,
				cost: gas_cost,
				output: bytes.to_vec(),
				logs: Default::default(),
			})
		} else if bytes.len() < mod_len {
			let mut ret = Vec::with_capacity(mod_len);
			ret.extend(core::iter::repeat(0).take(mod_len - bytes.len()));
			ret.extend_from_slice(&bytes[..]);
			Ok(PrecompileOutput {
				exit_status: ExitSucceed::Returned,
				cost: gas_cost,
				output: ret.to_vec(),
				logs: Default::default(),
			})
		} else {
			Err(PrecompileFailure::Error {
				exit_status: ExitError::Other(""failed"".into()),
			})
		}
	}",0,False,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,test_zero_exp_with_33_length,"	fn test_zero_exp_with_33_length() {
		// This is a regression test which ensures that the 'iteration_count' calculation
		// in 'calculate_iteration_count' cannot underflow.
		//
		// In debug mode, this underflow could cause a panic. Otherwise, it causes N**0 to
		// be calculated at more-than-normal expense.
		//
		// TODO: cite security advisory

		let input = vec![
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
		];

		let cost: u64 = 100000;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		let precompile_result = Modexp::execute(&input, Some(cost), &context, false)
			.expect(""Modexp::execute() returned error"");

		assert_eq!(precompile_result.output.len(), 1); // should be same length as mod
		let result = BigUint::from_bytes_be(&precompile_result.output[..]);
		let expected = BigUint::parse_bytes(b""0"", 10).unwrap();
		assert_eq!(result, expected);
	}",0,False,True,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,process_consensus_tests,"	fn process_consensus_tests() -> std::result::Result<(), String> {
		test_precompile_test_vectors::<Modexp>(""../testdata/modexp_eip2565.json"")?;
		Ok(())
	}",0,True,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,test_empty_input,"	fn test_empty_input() -> std::result::Result<(), PrecompileFailure> {
		let input: [u8; 0] = [];

		let cost: u64 = 1;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(_) => {
				panic!(""Test not expected to pass"");
			}
			Err(e) => {
				assert_eq!(
					e,
					PrecompileFailure::Error {
						exit_status: ExitError::Other(
							""input must contain at least 96 bytes"".into()
						)
					}
				);
				Ok(())
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,test_insufficient_input,"	fn test_insufficient_input() -> std::result::Result<(), PrecompileFailure> {
		let input = hex::decode(
			""0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001"",
		)
		.expect(""Decode failed"");

		let cost: u64 = 1;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(_) => {
				panic!(""Test not expected to pass"");
			}
			Err(e) => {
				assert_eq!(
					e,
					PrecompileFailure::Error {
						exit_status: ExitError::Other(""insufficient input size"".into())
					}
				);
				Ok(())
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,test_excessive_input,"	fn test_excessive_input() -> std::result::Result<(), PrecompileFailure> {
		let input = hex::decode(
			""1000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001"",
		)
		.expect(""Decode failed"");

		let cost: u64 = 1;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(_) => {
				panic!(""Test not expected to pass"");
			}
			Err(e) => {
				assert_eq!(
					e,
					PrecompileFailure::Error {
						exit_status: ExitError::Other(""unreasonably large base length"".into())
					}
				);
				Ok(())
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,test_simple_inputs,"	fn test_simple_inputs() {
		let input = hex::decode(
			""0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000001\
			03\
			05\
			07"",
		)
		.expect(""Decode failed"");

		// 3 ^ 5 % 7 == 5

		let cost: u64 = 100000;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(precompile_result) => {
				assert_eq!(precompile_result.output.len(), 1); // should be same length as mod
				let result = BigUint::from_bytes_be(&precompile_result.output[..]);
				let expected = BigUint::parse_bytes(b""5"", 10).unwrap();
				assert_eq!(result, expected);
			}
			Err(_) => {
				panic!(""Modexp::execute() returned error""); // TODO: how to pass error on?
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,test_large_inputs,"	fn test_large_inputs() {
		let input = hex::decode(
			""0000000000000000000000000000000000000000000000000000000000000020\
			0000000000000000000000000000000000000000000000000000000000000020\
			0000000000000000000000000000000000000000000000000000000000000020\
			000000000000000000000000000000000000000000000000000000000000EA5F\
			0000000000000000000000000000000000000000000000000000000000000015\
			0000000000000000000000000000000000000000000000000000000000003874"",
		)
		.expect(""Decode failed"");

		// 59999 ^ 21 % 14452 = 10055

		let cost: u64 = 100000;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(precompile_result) => {
				assert_eq!(precompile_result.output.len(), 32); // should be same length as mod
				let result = BigUint::from_bytes_be(&precompile_result.output[..]);
				let expected = BigUint::parse_bytes(b""10055"", 10).unwrap();
				assert_eq!(result, expected);
			}
			Err(_) => {
				panic!(""Modexp::execute() returned error""); // TODO: how to pass error on?
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664,GitHub,2022-01-13 17:23:07+01:00,False,lib.rs,Rust,test_large_computation,"	fn test_large_computation() {
		let input = hex::decode(
			""0000000000000000000000000000000000000000000000000000000000000001\
			0000000000000000000000000000000000000000000000000000000000000020\
			0000000000000000000000000000000000000000000000000000000000000020\
			03\
			fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e\
			fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"",
		)
		.expect(""Decode failed"");

		let cost: u64 = 100000;

		let context: Context = Context {
			address: Default::default(),
			caller: Default::default(),
			apparent_value: From::from(0),
		};

		match Modexp::execute(&input, Some(cost), &context, false) {
			Ok(precompile_result) => {
				assert_eq!(precompile_result.output.len(), 32); // should be same length as mod
				let result = BigUint::from_bytes_be(&precompile_result.output[..]);
				let expected = BigUint::parse_bytes(b""1"", 10).unwrap();
				assert_eq!(result, expected);
			}
			Err(_) => {
				panic!(""Modexp::execute() returned error""); // TODO: how to pass error on?
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"execute from : H160 , transaction : & Transaction , config : Option < evm :: Config > ,","	pub fn execute(
		from: H160,
		transaction: &Transaction,
		config: Option<evm::Config>,
	) -> Result<
		(Option<H160>, Option<H160>, CallOrCreateInfo),
		DispatchErrorWithPostInfo<PostDispatchInfo>,
	> {
		let (
			input,
			value,
			gas_limit,
			max_fee_per_gas,
			max_priority_fee_per_gas,
			nonce,
			action,
			access_list,
		) = {
			match transaction {
				// max_fee_per_gas and max_priority_fee_per_gas in legacy and 2930 transactions is
				// the provided gas_price.
				Transaction::Legacy(t) => (
					t.input.clone(),
					t.value,
					t.gas_limit,
					Some(t.gas_price),
					Some(t.gas_price),
					Some(t.nonce),
					t.action,
					Vec::new(),
				),
				Transaction::EIP2930(t) => {
					let access_list: Vec<(H160, Vec<H256>)> = t
						.access_list
						.iter()
						.map(|item| (item.address, item.storage_keys.clone()))
						.collect();
					(
						t.input.clone(),
						t.value,
						t.gas_limit,
						Some(t.gas_price),
						Some(t.gas_price),
						Some(t.nonce),
						t.action,
						access_list,
					)
				}
				Transaction::EIP1559(t) => {
					let access_list: Vec<(H160, Vec<H256>)> = t
						.access_list
						.iter()
						.map(|item| (item.address, item.storage_keys.clone()))
						.collect();
					(
						t.input.clone(),
						t.value,
						t.gas_limit,
						Some(t.max_fee_per_gas),
						Some(t.max_priority_fee_per_gas),
						Some(t.nonce),
						t.action,
						access_list,
					)
				}
			}
		};

		let is_transactional = true;
		let validate = false;
		match action {
			ethereum::TransactionAction::Call(target) => {
				let res = match T::Runner::call(
					from,
					target,
					input,
					value,
					gas_limit.low_u64(),
					max_fee_per_gas,
					max_priority_fee_per_gas,
					nonce,
					access_list,
					is_transactional,
					validate,
					config.as_ref().unwrap_or_else(|| T::config()),
				) {
					Ok(res) => res,
					Err(e) => {
						return Err(DispatchErrorWithPostInfo {
							post_info: PostDispatchInfo {
								actual_weight: Some(e.weight),
								pays_fee: Pays::Yes,
							},
							error: e.error.into(),
						})
					}
				};

				Ok((Some(target), None, CallOrCreateInfo::Call(res)))
			}
			ethereum::TransactionAction::Create => {
				let res = match T::Runner::create(
					from,
					input,
					value,
					gas_limit.low_u64(),
					max_fee_per_gas,
					max_priority_fee_per_gas,
					nonce,
					access_list,
					is_transactional,
					validate,
					config.as_ref().unwrap_or_else(|| T::config()),
				) {
					Ok(res) => res,
					Err(e) => {
						return Err(DispatchErrorWithPostInfo {
							post_info: PostDispatchInfo {
								actual_weight: Some(e.weight),
								pays_fee: Pays::Yes,
							},
							error: e.error.into(),
						})
					}
				};

				Ok((None, Some(res.value), CallOrCreateInfo::Create(res)))
			}
		}
	}",1,True,False,"77,105"
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"execute from : H160 , transaction : & Transaction , config : Option < evm :: Config > ,","	pub fn execute(
		from: H160,
		transaction: &Transaction,
		config: Option<evm::Config>,
	) -> Result<
		(Option<H160>, Option<H160>, CallOrCreateInfo),
		DispatchErrorWithPostInfo<PostDispatchInfo>,
	> {
		let (
			input,
			value,
			gas_limit,
			max_fee_per_gas,
			max_priority_fee_per_gas,
			nonce,
			action,
			access_list,
		) = {
			match transaction {
				// max_fee_per_gas and max_priority_fee_per_gas in legacy and 2930 transactions is
				// the provided gas_price.
				Transaction::Legacy(t) => (
					t.input.clone(),
					t.value,
					t.gas_limit,
					Some(t.gas_price),
					Some(t.gas_price),
					Some(t.nonce),
					t.action,
					Vec::new(),
				),
				Transaction::EIP2930(t) => {
					let access_list: Vec<(H160, Vec<H256>)> = t
						.access_list
						.iter()
						.map(|item| (item.address, item.storage_keys.clone()))
						.collect();
					(
						t.input.clone(),
						t.value,
						t.gas_limit,
						Some(t.gas_price),
						Some(t.gas_price),
						Some(t.nonce),
						t.action,
						access_list,
					)
				}
				Transaction::EIP1559(t) => {
					let access_list: Vec<(H160, Vec<H256>)> = t
						.access_list
						.iter()
						.map(|item| (item.address, item.storage_keys.clone()))
						.collect();
					(
						t.input.clone(),
						t.value,
						t.gas_limit,
						Some(t.max_fee_per_gas),
						Some(t.max_priority_fee_per_gas),
						Some(t.nonce),
						t.action,
						access_list,
					)
				}
			}
		};

		let is_transactional = true;
		let validate = false;
		match action {
			ethereum::TransactionAction::Call(target) => {
				let res = match T::Runner::call(
					from,
					target,
					input,
					value,
					gas_limit.unique_saturated_into(),
					max_fee_per_gas,
					max_priority_fee_per_gas,
					nonce,
					access_list,
					is_transactional,
					validate,
					config.as_ref().unwrap_or_else(|| T::config()),
				) {
					Ok(res) => res,
					Err(e) => {
						return Err(DispatchErrorWithPostInfo {
							post_info: PostDispatchInfo {
								actual_weight: Some(e.weight),
								pays_fee: Pays::Yes,
							},
							error: e.error.into(),
						})
					}
				};

				Ok((Some(target), None, CallOrCreateInfo::Call(res)))
			}
			ethereum::TransactionAction::Create => {
				let res = match T::Runner::create(
					from,
					input,
					value,
					gas_limit.unique_saturated_into(),
					max_fee_per_gas,
					max_priority_fee_per_gas,
					nonce,
					access_list,
					is_transactional,
					validate,
					config.as_ref().unwrap_or_else(|| T::config()),
				) {
					Ok(res) => res,
					Err(e) => {
						return Err(DispatchErrorWithPostInfo {
							post_info: PostDispatchInfo {
								actual_weight: Some(e.weight),
								pays_fee: Pays::Yes,
							},
							error: e.error.into(),
						})
					}
				};

				Ok((None, Some(res.value), CallOrCreateInfo::Create(res)))
			}
		}
	}",0,False,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,ensure_ethereum_transaction o : OuterOrigin,"pub fn ensure_ethereum_transaction<OuterOrigin>(o: OuterOrigin) -> Result<H160, &'static str>
where
	OuterOrigin: Into<Result<RawOrigin, OuterOrigin>>,
{
	match o.into() {
		Ok(RawOrigin::EthereumTransaction(n)) => Ok(n),
		_ => Err(""bad origin: expected to be an Ethereum transaction""),
	}
}

pub struct EnsureEthereumTransaction;
impl<O: Into<Result<RawOrigin, O>> + From<RawOrigin>> EnsureOrigin<O>
	for EnsureEthereumTransaction
{
	type Success = H160;
	fn try_origin(o: O) -> Result<Self::Success, O> {
		o.into().map(|o| match o {
			RawOrigin::EthereumTransaction(id) => id,
		})
	}

	#[cfg(feature = ""runtime-benchmarks"")]
	fn successful_origin() -> O {
		O::from(RawOrigin::EthereumTransaction(Default::default()))
	}
}

impl<T> Call<T>
where
	OriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,
	T: Send + Sync + Config,
	T::Call: Dispatchable<Info = DispatchInfo, PostInfo = PostDispatchInfo>,
{
	pub fn is_self_contained(&self) -> bool {
		matches!(self, Call::transact { .. })
	}

	pub fn check_self_contained(&self) -> Option<Result<H160, TransactionValidityError>> {
		if let Call::transact { transaction } = self {
			let check = || {
				let origin = Pallet::<T>::recover_signer(transaction).ok_or(
					InvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8),
				)?;

				Ok(origin)
			};

			Some(check())
		} else {
			None
		}
	}

	pub fn pre_dispatch_self_contained(
		&self,
		origin: &H160,
		dispatch_info: &DispatchInfoOf<T::Call>,
		len: usize,
	) -> Option<Result<(), TransactionValidityError>> {
		if let Call::transact { transaction } = self {
			if let Err(e) = CheckWeight::<T>::do_pre_dispatch(dispatch_info, len) {
				return Some(Err(e));
			}

			Some(Pallet::<T>::validate_transaction_in_block(
				*origin,
				transaction,
			))
		} else {
			None
		}
	}

	pub fn validate_self_contained(
		&self,
		origin: &H160,
		dispatch_info: &DispatchInfoOf<T::Call>,
		len: usize,
	) -> Option<TransactionValidity> {
		if let Call::transact { transaction } = self {
			if let Err(e) = CheckWeight::<T>::do_validate(dispatch_info, len) {
				return Some(Err(e));
			}

			Some(Pallet::<T>::validate_transaction_in_pool(
				*origin,
				transaction,
			))
		} else {
			None
		}
	}
}

pub use self::pallet::*;

#[frame_support::pallet]
pub mod pallet {
	use super::*;
	use frame_support::pallet_prelude::*;
	use frame_system::pallet_prelude::*;

	#[pallet::config]
	pub trait Config: frame_system::Config + pallet_timestamp::Config + pallet_evm::Config {
		/// The overarching event type.
		type Event: From<Event> + IsType<<Self as frame_system::Config>::Event>;
		/// How Ethereum state root is calculated.
		type StateRoot: Get<H256>;
	}

	#[pallet::pallet]
	#[pallet::generate_store(pub(super) trait Store)]
	#[pallet::without_storage_info]
	pub struct Pallet<T>(PhantomData<T>);

	#[pallet::origin]
	pub type Origin = RawOrigin;

	#[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
		fn on_finalize(n: T::BlockNumber) {
			<Pallet<T>>::store_block(
				fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
				U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(
					frame_system::Pallet::<T>::block_number(),
				)),
			);
			// move block hash pruning window by one block
			let block_hash_count = T::BlockHashCount::get();
			let to_remove = n
				.saturating_sub(block_hash_count)
				.saturating_sub(One::one());
			// keep genesis hash
			if !to_remove.is_zero() {
				<BlockHash<T>>::remove(U256::from(
					UniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),
				));
			}
			Pending::<T>::kill();
		}

		fn on_initialize(_: T::BlockNumber) -> Weight {
			let mut weight = T::SystemWeightInfo::kill_storage(1);

			// If the digest contain an existing ethereum block(encoded as PreLog), If contains,
			// execute the imported block firstly and disable transact dispatch function.
			if let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {
				let PreLog::Block(block) = log;

				for transaction in block.transactions {
					let source = Self::recover_signer(&transaction).expect(
						""pre-block transaction signature invalid; the block cannot be built"",
					);

					Self::validate_transaction_in_block(source, &transaction).expect(
						""pre-block transaction verification failed; the block cannot be built"",
					);
					let r = Self::apply_validated_transaction(source, transaction)
						.expect(""pre-block apply transaction failed; the block cannot be built"");

					weight = weight.saturating_add(r.actual_weight.unwrap_or(0));
				}
			}
			// Account for `on_finalize` weight:
			//	- read: frame_system::Pallet::<T>::digest()
			//	- read: frame_system::Pallet::<T>::block_number()
			//	- write: <Pallet<T>>::store_block()
			//	- write: <BlockHash<T>>::remove()
			weight.saturating_add(T::DbWeight::get().reads_writes(2, 2))
		}

		fn on_runtime_upgrade() -> Weight {
			frame_support::storage::unhashed::put::<EthereumStorageSchema>(
				PALLET_ETHEREUM_SCHEMA,
				&EthereumStorageSchema::V3,
			);

			T::DbWeight::get().write
		}
	}

	#[pallet::call]
	impl<T: Config> Pallet<T>
	where
		OriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,
	{
		/// Transact an Ethereum transaction.
		#[pallet::weight(<T as pallet_evm::Config>::GasWeightMapping::gas_to_weight({
			let transaction_data: TransactionData = transaction.into();
			transaction_data.gas_limit.unique_saturated_into()
		}))]
		pub fn transact(
			origin: OriginFor<T>,
			transaction: Transaction,
		) -> DispatchResultWithPostInfo {
			let source = ensure_ethereum_transaction(origin)?;
			// Disable transact functionality if PreLog exist.
			assert!(
				fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),
				""pre log already exists; block is invalid"",
			);

			Self::apply_validated_transaction(source, transaction)
		}
	}

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event {
		/// An ethereum transaction was successfully executed. [from, to/contract_address, transaction_hash, exit_reason]
		Executed(H160, H160, H256, ExitReason),
	}

	#[pallet::error]
	pub enum Error<T> {
		/// Signature is invalid.
		InvalidSignature,
		/// Pre-log is present, therefore transact is not allowed.
		PreLogExists,
	}

	/// Current building block's transactions and receipts.
	#[pallet::storage]
	#[pallet::getter(fn pending)]
	pub(super) type Pending<T: Config> =
		StorageValue<_, Vec<(Transaction, TransactionStatus, Receipt)>, ValueQuery>;

	/// The current Ethereum block.
	#[pallet::storage]
	#[pallet::getter(fn current_block)]
	pub(super) type CurrentBlock<T: Config> = StorageValue<_, ethereum::BlockV2>;

	/// The current Ethereum receipts.
	#[pallet::storage]
	#[pallet::getter(fn current_receipts)]
	pub(super) type CurrentReceipts<T: Config> = StorageValue<_, Vec<Receipt>>;

	/// The current transaction statuses.
	#[pallet::storage]
	#[pallet::getter(fn current_transaction_statuses)]
	pub(super) type CurrentTransactionStatuses<T: Config> = StorageValue<_, Vec<TransactionStatus>>;

	// Mapping for block number and hashes.
	#[pallet::storage]
	#[pallet::getter(fn block_hash)]
	pub(super) type BlockHash<T: Config> = StorageMap<_, Twox64Concat, U256, H256, ValueQuery>;

	#[pallet::genesis_config]
	#[derive(Default)]
	pub struct GenesisConfig {}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,build & self,"		fn build(&self) {
			<Pallet<T>>::store_block(false, U256::zero());
			frame_support::storage::unhashed::put::<EthereumStorageSchema>(
				PALLET_ETHEREUM_SCHEMA,
				&EthereumStorageSchema::V3,
			);
		}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,recover_signer transaction : & Transaction,"	fn recover_signer(transaction: &Transaction) -> Option<H160> {
		let mut sig = [0u8; 65];
		let mut msg = [0u8; 32];
		match transaction {
			Transaction::Legacy(t) => {
				sig[0..32].copy_from_slice(&t.signature.r()[..]);
				sig[32..64].copy_from_slice(&t.signature.s()[..]);
				sig[64] = t.signature.standard_v();
				msg.copy_from_slice(
					&ethereum::LegacyTransactionMessage::from(t.clone()).hash()[..],
				);
			}
			Transaction::EIP2930(t) => {
				sig[0..32].copy_from_slice(&t.r[..]);
				sig[32..64].copy_from_slice(&t.s[..]);
				sig[64] = t.odd_y_parity as u8;
				msg.copy_from_slice(
					&ethereum::EIP2930TransactionMessage::from(t.clone()).hash()[..],
				);
			}
			Transaction::EIP1559(t) => {
				sig[0..32].copy_from_slice(&t.r[..]);
				sig[32..64].copy_from_slice(&t.s[..]);
				sig[64] = t.odd_y_parity as u8;
				msg.copy_from_slice(
					&ethereum::EIP1559TransactionMessage::from(t.clone()).hash()[..],
				);
			}
		}
		let pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;
		Some(H160::from(H256::from(sp_io::hashing::keccak_256(&pubkey))))
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"store_block post_log : bool , block_number : U256","	fn store_block(post_log: bool, block_number: U256) {
		let mut transactions = Vec::new();
		let mut statuses = Vec::new();
		let mut receipts = Vec::new();
		let mut logs_bloom = Bloom::default();
		let mut cumulative_gas_used = U256::zero();
		for (transaction, status, receipt) in Pending::<T>::get() {
			transactions.push(transaction);
			statuses.push(status);
			receipts.push(receipt.clone());
			let (logs, used_gas) = match receipt {
				Receipt::Legacy(d) | Receipt::EIP2930(d) | Receipt::EIP1559(d) => {
					(d.logs.clone(), d.used_gas)
				}
			};
			cumulative_gas_used = used_gas;
			Self::logs_bloom(logs, &mut logs_bloom);
		}

		let ommers = Vec::<ethereum::Header>::new();
		let receipts_root = ethereum::util::ordered_trie_root(receipts.iter().map(rlp::encode));
		let partial_header = ethereum::PartialHeader {
			parent_hash: if block_number > U256::zero() {
				BlockHash::<T>::get(block_number - 1)
			} else {
				H256::default()
			},
			beneficiary: pallet_evm::Pallet::<T>::find_author(),
			state_root: T::StateRoot::get(),
			receipts_root,
			logs_bloom,
			difficulty: U256::zero(),
			number: block_number,
			gas_limit: T::BlockGasLimit::get(),
			gas_used: cumulative_gas_used,
			timestamp: UniqueSaturatedInto::<u64>::unique_saturated_into(
				pallet_timestamp::Pallet::<T>::get(),
			),
			extra_data: Vec::new(),
			mix_hash: H256::default(),
			nonce: H64::default(),
		};
		let block = ethereum::Block::new(partial_header, transactions.clone(), ommers);

		CurrentBlock::<T>::put(block.clone());
		CurrentReceipts::<T>::put(receipts.clone());
		CurrentTransactionStatuses::<T>::put(statuses.clone());
		BlockHash::<T>::insert(block_number, block.header.hash());

		if post_log {
			let digest = DigestItem::Consensus(
				FRONTIER_ENGINE_ID,
				PostLog::Hashes(fp_consensus::Hashes::from_block(block)).encode(),
			);
			frame_system::Pallet::<T>::deposit_log(digest);
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"logs_bloom logs : Vec < Log > , bloom : & mut Bloom","	fn logs_bloom(logs: Vec<Log>, bloom: &mut Bloom) {
		for log in logs {
			bloom.accrue(BloomInput::Raw(&log.address[..]));
			for topic in log.topics {
				bloom.accrue(BloomInput::Raw(&topic[..]));
			}
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"validate_transaction_in_pool origin : H160 , transaction : & Transaction ,","	fn validate_transaction_in_pool(
		origin: H160,
		transaction: &Transaction,
	) -> TransactionValidity {
		let transaction_data: TransactionData = transaction.into();
		let transaction_nonce = transaction_data.nonce;

		let (base_fee, _) = T::FeeCalculator::min_gas_price();
		let (who, _) = pallet_evm::Pallet::<T>::account_basic(&origin);

		let _ = CheckEvmTransaction::<InvalidTransactionWrapper>::new(
			CheckEvmTransactionConfig {
				evm_config: T::config(),
				block_gas_limit: T::BlockGasLimit::get(),
				base_fee,
				chain_id: T::ChainId::get(),
				is_transactional: true,
			},
			transaction_data.clone().into(),
		)
		.validate_in_pool_for(&who)
		.and_then(|v| v.with_chain_id())
		.and_then(|v| v.with_base_fee())
		.and_then(|v| v.with_balance_for(&who))
		.map_err(|e| e.0)?;

		let priority = match (
			transaction_data.gas_price,
			transaction_data.max_fee_per_gas,
			transaction_data.max_priority_fee_per_gas,
		) {
			// Legacy or EIP-2930 transaction.
			// Handle priority here. On legacy transaction everything in gas_price except
			// the current base_fee is considered a tip to the miner and thus the priority.
			(Some(gas_price), None, None) => {
				gas_price.saturating_sub(base_fee).unique_saturated_into()
			}
			// EIP-1559 transaction without tip.
			(None, Some(_), None) => 0,
			// EIP-1559 transaction with tip.
			(None, Some(max_fee_per_gas), Some(max_priority_fee_per_gas)) => max_fee_per_gas
				.saturating_sub(base_fee)
				.min(max_priority_fee_per_gas)
				.unique_saturated_into(),
			// Unreachable because already validated. Gracefully handle.
			_ => return Err(InvalidTransaction::Payment.into()),
		};

		// The tag provides and requires must be filled correctly according to the nonce.
		let mut builder = ValidTransactionBuilder::default()
			.and_provides((origin, transaction_nonce))
			.priority(priority);

		// In the context of the pool, a transaction with
		// too high a nonce is still considered valid
		if transaction_nonce > who.nonce {
			if let Some(prev_nonce) = transaction_nonce.checked_sub(1.into()) {
				builder = builder.and_requires((origin, prev_nonce))
			}
		}

		builder.build()
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"apply_validated_transaction source : H160 , transaction : Transaction ,","	fn apply_validated_transaction(
		source: H160,
		transaction: Transaction,
	) -> DispatchResultWithPostInfo {
		let (to, _, info) = Self::execute(source, &transaction, None)?;

		let pending = Pending::<T>::get();
		let transaction_hash = transaction.hash();
		let transaction_index = pending.len() as u32;

		let (reason, status, used_gas, dest) = match info {
			CallOrCreateInfo::Call(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: None,
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				to,
			),
			CallOrCreateInfo::Create(info) => (
				info.exit_reason,
				TransactionStatus {
					transaction_hash,
					transaction_index,
					from: source,
					to,
					contract_address: Some(info.value),
					logs: info.logs.clone(),
					logs_bloom: {
						let mut bloom: Bloom = Bloom::default();
						Self::logs_bloom(info.logs, &mut bloom);
						bloom
					},
				},
				info.used_gas,
				Some(info.value),
			),
		};

		let receipt = {
			let status_code: u8 = match reason {
				ExitReason::Succeed(_) => 1,
				_ => 0,
			};
			let logs_bloom = status.logs_bloom;
			let logs = status.clone().logs;
			let cumulative_gas_used = if let Some((_, _, receipt)) = pending.last() {
				match receipt {
					Receipt::Legacy(d) | Receipt::EIP2930(d) | Receipt::EIP1559(d) => {
						d.used_gas.saturating_add(used_gas)
					}
				}
			} else {
				used_gas
			};
			match &transaction {
				Transaction::Legacy(_) => Receipt::Legacy(ethereum::EIP658ReceiptData {
					status_code,
					used_gas: cumulative_gas_used,
					logs_bloom,
					logs,
				}),
				Transaction::EIP2930(_) => Receipt::EIP2930(ethereum::EIP2930ReceiptData {
					status_code,
					used_gas: cumulative_gas_used,
					logs_bloom,
					logs,
				}),
				Transaction::EIP1559(_) => Receipt::EIP1559(ethereum::EIP2930ReceiptData {
					status_code,
					used_gas: cumulative_gas_used,
					logs_bloom,
					logs,
				}),
			}
		};

		Pending::<T>::append((transaction, status, receipt));

		Self::deposit_event(Event::Executed(
			source,
			dest.unwrap_or_default(),
			transaction_hash,
			reason,
		));

		Ok(PostDispatchInfo {
			actual_weight: Some(T::GasWeightMapping::gas_to_weight(
				used_gas.unique_saturated_into(),
			)),
			pays_fee: Pays::No,
		})
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,current_block_hash,"	pub fn current_block_hash() -> Option<H256> {
		Self::current_block().map(|block| block.header.hash())
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"validate_transaction_in_block origin : H160 , transaction : & Transaction ,","	pub fn validate_transaction_in_block(
		origin: H160,
		transaction: &Transaction,
	) -> Result<(), TransactionValidityError> {
		let transaction_data: TransactionData = transaction.into();

		let (base_fee, _) = T::FeeCalculator::min_gas_price();
		let (who, _) = pallet_evm::Pallet::<T>::account_basic(&origin);

		let _ = CheckEvmTransaction::<InvalidTransactionWrapper>::new(
			CheckEvmTransactionConfig {
				evm_config: T::config(),
				block_gas_limit: T::BlockGasLimit::get(),
				base_fee,
				chain_id: T::ChainId::get(),
				is_transactional: true,
			},
			transaction_data.into(),
		)
		.validate_in_block_for(&who)
		.and_then(|v| v.with_chain_id())
		.and_then(|v| v.with_base_fee())
		.and_then(|v| v.with_balance_for(&who))
		.map_err(|e| TransactionValidityError::Invalid(e.0))?;

		Ok(())
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,migrate_block_v0_to_v2,"	pub fn migrate_block_v0_to_v2() -> Weight {
		let db_weights = T::DbWeight::get();
		let mut weight: Weight = db_weights.read;
		let item = b""CurrentBlock"";
		let block_v0 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV0>(
			Self::name().as_bytes(),
			item,
			&[],
		);
		if let Some(block_v0) = block_v0 {
			weight = weight.saturating_add(db_weights.write);
			let block_v2: ethereum::BlockV2 = block_v0.into();
			frame_support::storage::migration::put_storage_value::<ethereum::BlockV2>(
				Self::name().as_bytes(),
				item,
				&[],
				block_v2,
			);
		}
		weight
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,pre_migrate_block_v2,"	pub fn pre_migrate_block_v2() -> Result<(), &'static str> {
		let item = b""CurrentBlock"";
		let block_v0 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV0>(
			Self::name().as_bytes(),
			item,
			&[],
		);
		if let Some(block_v0) = block_v0 {
			Self::set_temp_storage(block_v0.header.number, ""number"");
			Self::set_temp_storage(block_v0.header.parent_hash, ""parent_hash"");
			Self::set_temp_storage(block_v0.transactions.len() as u64, ""transaction_len"");
		}
		Ok(())
	}

	#[cfg(feature = ""try-runtime"")]
	pub fn post_migrate_block_v2() -> Result<(), &'static str> {
		let v0_number =
			Self::get_temp_storage(""number"").expect(""We stored a number; it should be there; qed"");
		let v0_parent_hash = Self::get_temp_storage(""parent_hash"")
			.expect(""We stored a parent hash; it should be there; qed"");
		let v0_transaction_len: u64 = Self::get_temp_storage(""transaction_len"")
			.expect(""We stored a transaction count; it should be there; qed"");

		let item = b""CurrentBlock"";
		let block_v2 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV2>(
			Self::name().as_bytes(),
			item,
			&[],
		);

		assert!(block_v2.is_some());

		let block_v2 = block_v2.unwrap();
		assert_eq!(block_v2.header.number, v0_number);
		assert_eq!(block_v2.header.parent_hash, v0_parent_hash);
		assert_eq!(block_v2.transactions.len() as u64, v0_transaction_len);
		Ok(())
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"apply source : H160 , transaction : Transaction","	fn apply(source: H160, transaction: Transaction) -> DispatchResultWithPostInfo {
		Pallet::<T>::apply_validated_transaction(source, transaction)
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,get,"	fn get() -> H256 {
		let version = T::Version::get().state_version();
		H256::decode(&mut &sp_io::storage::root(version)[..])
			.expect(""Node is configured to use the same hash; qed"")
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,block_hash number : u32,"	fn block_hash(number: u32) -> H256 {
		BlockHash::<T>::get(U256::from(number))
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,from validation_error : InvalidEvmTransactionError,"	fn from(validation_error: InvalidEvmTransactionError) -> Self {
		match validation_error {
			InvalidEvmTransactionError::GasLimitTooLow => InvalidTransactionWrapper(
				InvalidTransaction::Custom(TransactionValidationError::InvalidGasLimit as u8),
			),
			InvalidEvmTransactionError::GasLimitTooHigh => InvalidTransactionWrapper(
				InvalidTransaction::Custom(TransactionValidationError::InvalidGasLimit as u8),
			),
			InvalidEvmTransactionError::GasPriceTooLow => {
				InvalidTransactionWrapper(InvalidTransaction::Payment)
			}
			InvalidEvmTransactionError::PriorityFeeTooHigh => InvalidTransactionWrapper(
				InvalidTransaction::Custom(TransactionValidationError::MaxFeePerGasTooLow as u8),
			),
			InvalidEvmTransactionError::BalanceTooLow => {
				InvalidTransactionWrapper(InvalidTransaction::Payment)
			}
			InvalidEvmTransactionError::TxNonceTooLow => {
				InvalidTransactionWrapper(InvalidTransaction::Stale)
			}
			InvalidEvmTransactionError::TxNonceTooHigh => {
				InvalidTransactionWrapper(InvalidTransaction::Future)
			}
			InvalidEvmTransactionError::InvalidPaymentInput => {
				InvalidTransactionWrapper(InvalidTransaction::Payment)
			}
			InvalidEvmTransactionError::InvalidChainId => InvalidTransactionWrapper(
				InvalidTransaction::Custom(TransactionValidationError::InvalidChainId as u8),
			),
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"withdraw_fee who : & H160 , fee : U256","	fn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>> {
		if fee.is_zero() {
			return Ok(None);
		}
		let account_id = T::AddressMapping::into_account_id(*who);
		let imbalance = C::withdraw(
			&account_id,
			fee.low_u128().unique_saturated_into(),
			WithdrawReasons::FEE,
			ExistenceRequirement::AllowDeath,
		)
		.map_err(|_| Error::<T>::BalanceLow)?;
		Ok(Some(imbalance))
	}",1,True,False,7
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"correct_and_deposit_fee who : & H160 , corrected_fee : U256 , base_fee : U256 , already_withdrawn : Self :: LiquidityInfo ,","	fn correct_and_deposit_fee(
		who: &H160,
		corrected_fee: U256,
		base_fee: U256,
		already_withdrawn: Self::LiquidityInfo,
	) -> Self::LiquidityInfo {
		if let Some(paid) = already_withdrawn {
			let account_id = T::AddressMapping::into_account_id(*who);

			// Calculate how much refund we should return
			let refund_amount = paid
				.peek()
				.saturating_sub(corrected_fee.low_u128().unique_saturated_into());
			// refund to the account that paid the fees. If this fails, the
			// account might have dropped below the existential balance. In
			// that case we don't refund anything.
			let refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)
				.unwrap_or_else(|_| C::PositiveImbalance::zero());

			// Make sure this works with 0 ExistentialDeposit
			// https://github.com/paritytech/substrate/issues/10117
			// If we tried to refund something, the account still empty and the ED is set to 0,
			// we call `make_free_balance_be` with the refunded amount.
			let refund_imbalance = if C::minimum_balance().is_zero()
				&& refund_amount > C::Balance::zero()
				&& C::total_balance(&account_id).is_zero()
			{
				// Known bug: Substrate tried to refund to a zeroed AccountData, but
				// interpreted the account to not exist.
				match C::make_free_balance_be(&account_id, refund_amount) {
					SignedImbalance::Positive(p) => p,
					_ => C::PositiveImbalance::zero(),
				}
			} else {
				refund_imbalance
			};

			// merge the imbalance caused by paying the fees and refunding parts of it again.
			let adjusted_paid = paid
				.offset(refund_imbalance)
				.same()
				.unwrap_or_else(|_| C::NegativeImbalance::zero());

			let (base_fee, tip) = adjusted_paid.split(base_fee.low_u128().unique_saturated_into());
			// Handle base fee. Can be either burned, rationed, etc ...
			OU::on_unbalanced(base_fee);
			return Some(tip);
		}
		None
	}",1,True,False,"12,43"
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,config,"		fn config() -> &'static EvmConfig {
			&LONDON_CONFIG
		}
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {
		/// Withdraw balance from EVM into currency/balances pallet.
		#[pallet::weight(0)]
		pub fn withdraw(
			origin: OriginFor<T>,
			address: H160,
			value: BalanceOf<T>,
		) -> DispatchResult {
			let destination = T::WithdrawOrigin::ensure_address_origin(&address, origin)?;
			let address_account_id = T::AddressMapping::into_account_id(address);

			T::Currency::transfer(
				&address_account_id,
				&destination,
				value,
				ExistenceRequirement::AllowDeath,
			)?;

			Ok(())
		}

		/// Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
		#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]
		pub fn call(
			origin: OriginFor<T>,
			source: H160,
			target: H160,
			input: Vec<u8>,
			value: U256,
			gas_limit: u64,
			max_fee_per_gas: U256,
			max_priority_fee_per_gas: Option<U256>,
			nonce: Option<U256>,
			access_list: Vec<(H160, Vec<H256>)>,
		) -> DispatchResultWithPostInfo {
			T::CallOrigin::ensure_address_origin(&source, origin)?;

			let is_transactional = true;
			let validate = true;
			let info = match T::Runner::call(
				source,
				target,
				input,
				value,
				gas_limit,
				Some(max_fee_per_gas),
				max_priority_fee_per_gas,
				nonce,
				access_list,
				is_transactional,
				validate,
				T::config(),
			) {
				Ok(info) => info,
				Err(e) => {
					return Err(DispatchErrorWithPostInfo {
						post_info: PostDispatchInfo {
							actual_weight: Some(e.weight),
							pays_fee: Pays::Yes,
						},
						error: e.error.into(),
					})
				}
			};

			match info.exit_reason {
				ExitReason::Succeed(_) => {
					Pallet::<T>::deposit_event(Event::<T>::Executed(target));
				}
				_ => {
					Pallet::<T>::deposit_event(Event::<T>::ExecutedFailed(target));
				}
			};

			Ok(PostDispatchInfo {
				actual_weight: Some(T::GasWeightMapping::gas_to_weight(
					info.used_gas.unique_saturated_into(),
				)),
				pays_fee: Pays::No,
			})
		}

		/// Issue an EVM create operation. This is similar to a contract creation transaction in
		/// Ethereum.
		#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]
		pub fn create(
			origin: OriginFor<T>,
			source: H160,
			init: Vec<u8>,
			value: U256,
			gas_limit: u64,
			max_fee_per_gas: U256,
			max_priority_fee_per_gas: Option<U256>,
			nonce: Option<U256>,
			access_list: Vec<(H160, Vec<H256>)>,
		) -> DispatchResultWithPostInfo {
			T::CallOrigin::ensure_address_origin(&source, origin)?;

			let is_transactional = true;
			let validate = true;
			let info = match T::Runner::create(
				source,
				init,
				value,
				gas_limit,
				Some(max_fee_per_gas),
				max_priority_fee_per_gas,
				nonce,
				access_list,
				is_transactional,
				validate,
				T::config(),
			) {
				Ok(info) => info,
				Err(e) => {
					return Err(DispatchErrorWithPostInfo {
						post_info: PostDispatchInfo {
							actual_weight: Some(e.weight),
							pays_fee: Pays::Yes,
						},
						error: e.error.into(),
					})
				}
			};

			match info {
				CreateInfo {
					exit_reason: ExitReason::Succeed(_),
					value: create_address,
					..
				} => {
					Pallet::<T>::deposit_event(Event::<T>::Created(create_address));
				}
				CreateInfo {
					exit_reason: _,
					value: create_address,
					..
				} => {
					Pallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));
				}
			}

			Ok(PostDispatchInfo {
				actual_weight: Some(T::GasWeightMapping::gas_to_weight(
					info.used_gas.unique_saturated_into(),
				)),
				pays_fee: Pays::No,
			})
		}

		/// Issue an EVM create2 operation.
		#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]
		pub fn create2(
			origin: OriginFor<T>,
			source: H160,
			init: Vec<u8>,
			salt: H256,
			value: U256,
			gas_limit: u64,
			max_fee_per_gas: U256,
			max_priority_fee_per_gas: Option<U256>,
			nonce: Option<U256>,
			access_list: Vec<(H160, Vec<H256>)>,
		) -> DispatchResultWithPostInfo {
			T::CallOrigin::ensure_address_origin(&source, origin)?;

			let is_transactional = true;
			let validate = true;
			let info = match T::Runner::create2(
				source,
				init,
				salt,
				value,
				gas_limit,
				Some(max_fee_per_gas),
				max_priority_fee_per_gas,
				nonce,
				access_list,
				is_transactional,
				validate,
				T::config(),
			) {
				Ok(info) => info,
				Err(e) => {
					return Err(DispatchErrorWithPostInfo {
						post_info: PostDispatchInfo {
							actual_weight: Some(e.weight),
							pays_fee: Pays::Yes,
						},
						error: e.error.into(),
					})
				}
			};

			match info {
				CreateInfo {
					exit_reason: ExitReason::Succeed(_),
					value: create_address,
					..
				} => {
					Pallet::<T>::deposit_event(Event::<T>::Created(create_address));
				}
				CreateInfo {
					exit_reason: _,
					value: create_address,
					..
				} => {
					Pallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));
				}
			}

			Ok(PostDispatchInfo {
				actual_weight: Some(T::GasWeightMapping::gas_to_weight(
					info.used_gas.unique_saturated_into(),
				)),
				pays_fee: Pays::No,
			})
		}
	}

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		/// Ethereum events from contracts.
		Log(Log),
		/// A contract has been created at given \[address\].
		Created(H160),
		/// A \[contract\] was attempted to be created, but the execution failed.
		CreatedFailed(H160),
		/// A \[contract\] has been executed successfully with states applied.
		Executed(H160),
		/// A \[contract\] has been executed with errors. States are reverted with only gas fees applied.
		ExecutedFailed(H160),
		/// A deposit has been made at a given address. \[sender, address, value\]
		BalanceDeposit(T::AccountId, H160, U256),
		/// A withdrawal has been made from a given address. \[sender, address, value\]
		BalanceWithdraw(T::AccountId, H160, U256),
	}

	#[pallet::error]
	pub enum Error<T> {
		/// Not enough balance to perform action
		BalanceLow,
		/// Calculating total fee overflowed
		FeeOverflow,
		/// Calculating total payment overflowed
		PaymentOverflow,
		/// Withdraw fee failed
		WithdrawFailed,
		/// Gas price is too low.
		GasPriceTooLow,
		/// Nonce is invalid
		InvalidNonce,
		/// Gas limit is too low.
		GasLimitTooLow,
		/// Gas limit is too high.
		GasLimitTooHigh,
		/// Undefined error.
		Undefined,
	}

	impl<T> From<InvalidEvmTransactionError> for Error<T> {
		fn from(validation_error: InvalidEvmTransactionError) -> Self {
			match validation_error {
				InvalidEvmTransactionError::GasLimitTooLow => Error::<T>::GasLimitTooLow,
				InvalidEvmTransactionError::GasLimitTooHigh => Error::<T>::GasLimitTooHigh,
				InvalidEvmTransactionError::GasPriceTooLow => Error::<T>::GasLimitTooLow,
				InvalidEvmTransactionError::PriorityFeeTooHigh => Error::<T>::GasPriceTooLow,
				InvalidEvmTransactionError::BalanceTooLow => Error::<T>::BalanceLow,
				InvalidEvmTransactionError::TxNonceTooLow => Error::<T>::InvalidNonce,
				InvalidEvmTransactionError::TxNonceTooHigh => Error::<T>::InvalidNonce,
				InvalidEvmTransactionError::InvalidPaymentInput => Error::<T>::GasPriceTooLow,
				_ => Error::<T>::Undefined,
			}
		}
	}

	#[pallet::genesis_config]
	#[cfg_attr(feature = ""std"", derive(Default))]
	pub struct GenesisConfig {
		pub accounts: std::collections::BTreeMap<H160, GenesisAccount>,
	}

	#[pallet::genesis_build]
	impl<T: Config> GenesisBuild<T> for GenesisConfig {
		fn build(&self) {
			for (address, account) in &self.accounts {
				let account_id = T::AddressMapping::into_account_id(*address);

				// ASSUME: in one single EVM transaction, the nonce will not increase more than
				// `u128::max_value()`.
				for _ in 0..account.nonce.low_u128() {
					frame_system::Pallet::<T>::inc_account_nonce(&account_id);
				}

				T::Currency::deposit_creating(
					&account_id,
					account.balance.low_u128().unique_saturated_into(),
				);

				Pallet::<T>::create_account(*address, account.code.clone());

				for (index, value) in &account.storage {
					<AccountStorages<T>>::insert(address, index, value);
				}
			}
		}
	}

	#[pallet::storage]
	#[pallet::getter(fn account_codes)]
	pub type AccountCodes<T: Config> = StorageMap<_, Blake2_128Concat, H160, Vec<u8>, ValueQuery>;

	#[pallet::storage]
	#[pallet::getter(fn account_storages)]
	pub type AccountStorages<T: Config> =
		StorageDoubleMap<_, Blake2_128Concat, H160, Blake2_128Concat, H256, H256, ValueQuery>;
}

/// Type alias for currency balance.
pub type BalanceOf<T> =
	<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;

/// Type alias for negative imbalance during fees
type NegativeImbalanceOf<C, T> =
	<C as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance;

pub trait EnsureAddressOrigin<OuterOrigin> {
	/// Success return type.
	type Success;

	/// Perform the origin check.
	fn ensure_address_origin(
		address: &H160,
		origin: OuterOrigin,
	) -> Result<Self::Success, BadOrigin> {
		Self::try_address_origin(address, origin).map_err(|_| BadOrigin)
	}

	/// Try with origin.
	fn try_address_origin(
		address: &H160,
		origin: OuterOrigin,
	) -> Result<Self::Success, OuterOrigin>;
}

/// Ensure that the EVM address is the same as the Substrate address. This only works if the account
/// ID is `H160`.
pub struct EnsureAddressSame;

impl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressSame
where
	OuterOrigin: Into<Result<RawOrigin<H160>, OuterOrigin>> + From<RawOrigin<H160>>,
{
	type Success = H160;

	fn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<H160, OuterOrigin> {
		origin.into().and_then(|o| match o {
			RawOrigin::Signed(who) if &who == address => Ok(who),
			r => Err(OuterOrigin::from(r)),
		})
	}
}

/// Ensure that the origin is root.
pub struct EnsureAddressRoot<AccountId>(sp_std::marker::PhantomData<AccountId>);

impl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressRoot<AccountId>
where
	OuterOrigin: Into<Result<RawOrigin<AccountId>, OuterOrigin>> + From<RawOrigin<AccountId>>,
{
	type Success = ();

	fn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<(), OuterOrigin> {
		origin.into().and_then(|o| match o {
			RawOrigin::Root => Ok(()),
			r => Err(OuterOrigin::from(r)),
		})
	}
}

/// Ensure that the origin never happens.
pub struct EnsureAddressNever<AccountId>(sp_std::marker::PhantomData<AccountId>);

impl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressNever<AccountId> {
	type Success = AccountId;

	fn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<AccountId, OuterOrigin> {
		Err(origin)
	}
}

/// Ensure that the address is truncated hash of the origin. Only works if the account id is
/// `AccountId32`.
pub struct EnsureAddressTruncated;

impl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressTruncated
where
	OuterOrigin: Into<Result<RawOrigin<AccountId32>, OuterOrigin>> + From<RawOrigin<AccountId32>>,
{
	type Success = AccountId32;

	fn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<AccountId32, OuterOrigin> {
		origin.into().and_then(|o| match o {
			RawOrigin::Signed(who) if AsRef::<[u8; 32]>::as_ref(&who)[0..20] == address[0..20] => {
				Ok(who)
			}
			r => Err(OuterOrigin::from(r)),
		})
	}
}

pub trait AddressMapping<A> {
	fn into_account_id(address: H160) -> A;
}

/// Identity address mapping.
pub struct IdentityAddressMapping;

impl AddressMapping<H160> for IdentityAddressMapping {
	fn into_account_id(address: H160) -> H160 {
		address
	}
}

/// Hashed address mapping.
pub struct HashedAddressMapping<H>(sp_std::marker::PhantomData<H>);

impl<H: Hasher<Out = H256>> AddressMapping<AccountId32> for HashedAddressMapping<H> {
	fn into_account_id(address: H160) -> AccountId32 {
		let mut data = [0u8; 24];
		data[0..4].copy_from_slice(b""evm:"");
		data[4..24].copy_from_slice(&address[..]);
		let hash = H::hash(&data);

		AccountId32::from(Into::<[u8; 32]>::into(hash))
	}
}

/// A trait for getting a block hash by number.
pub trait BlockHashMapping {
	fn block_hash(number: u32) -> H256;
}

/// Returns the Substrate block hash by number.
pub struct SubstrateBlockHashMapping<T>(sp_std::marker::PhantomData<T>);
impl<T: Config> BlockHashMapping for SubstrateBlockHashMapping<T> {
	fn block_hash(number: u32) -> H256 {
		let number = T::BlockNumber::from(number);
		H256::from_slice(frame_system::Pallet::<T>::block_hash(number).as_ref())
	}
}

/// A mapping function that converts Ethereum gas to Substrate weight
pub trait GasWeightMapping {
	fn gas_to_weight(gas: u64) -> Weight;
	fn weight_to_gas(weight: Weight) -> u64;
}

impl GasWeightMapping for () {
	fn gas_to_weight(gas: u64) -> Weight {
		gas as Weight
	}
	fn weight_to_gas(weight: Weight) -> u64 {
		weight as u64
	}
}

static LONDON_CONFIG: EvmConfig = EvmConfig::london();

impl<T: Config> Pallet<T> {
	/// Check whether an account is empty.
	pub fn is_account_empty(address: &H160) -> bool {
		let (account, _) = Self::account_basic(address);
		let code_len = <AccountCodes<T>>::decode_len(address).unwrap_or(0);

		account.nonce == U256::zero() && account.balance == U256::zero() && code_len == 0
	}

	/// Remove an account if its empty.
	pub fn remove_account_if_empty(address: &H160) {
		if Self::is_account_empty(address) {
			Self::remove_account(address);
		}
	}

	/// Remove an account.
	pub fn remove_account(address: &H160) {
		if <AccountCodes<T>>::contains_key(address) {
			let account_id = T::AddressMapping::into_account_id(*address);
			let _ = frame_system::Pallet::<T>::dec_sufficients(&account_id);
		}

		<AccountCodes<T>>::remove(address);
		let _ = <AccountStorages<T>>::remove_prefix(address, None);
	}

	/// Create an account.
	pub fn create_account(address: H160, code: Vec<u8>) {
		if code.is_empty() {
			return;
		}

		if !<AccountCodes<T>>::contains_key(&address) {
			let account_id = T::AddressMapping::into_account_id(address);
			let _ = frame_system::Pallet::<T>::inc_sufficients(&account_id);
		}

		<AccountCodes<T>>::insert(address, code);
	}

	/// Get the account basic in EVM format.
	pub fn account_basic(address: &H160) -> (Account, frame_support::weights::Weight) {
		let account_id = T::AddressMapping::into_account_id(*address);

		let nonce = frame_system::Pallet::<T>::account_nonce(&account_id);
		// keepalive `true` takes into account ExistentialDeposit as part of what's considered liquid balance.
		let balance = T::Currency::reducible_balance(&account_id, true);

		(
			Account {
				nonce: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(nonce)),
				balance: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(balance)),
			},",1,True,False,"290,297,301,302,303,304"
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"withdraw_fee who : & H160 , fee : U256","	fn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>>;

	/// After the transaction was executed the actual fee can be calculated.
	/// This function should refund any overpaid fees and optionally deposit
	/// the corrected amount, and handles the base fee rationing using the provided
	/// `OnUnbalanced` implementation.
	/// Returns the `NegativeImbalance` - if any - produced by the priority fee.
	fn correct_and_deposit_fee(
		who: &H160,
		corrected_fee: U256,
		base_fee: U256,
		already_withdrawn: Self::LiquidityInfo,
	) -> Self::LiquidityInfo;

	/// Introduced in EIP1559 to handle the priority tip.
	fn pay_priority_fee(tip: Self::LiquidityInfo);
}

/// Implements the transaction payment for a pallet implementing the `Currency`
/// trait (eg. the pallet_balances) using an unbalance handler (implementing
/// `OnUnbalanced`).
/// Similar to `CurrencyAdapter` of `pallet_transaction_payment`
pub struct EVMCurrencyAdapter<C, OU>(sp_std::marker::PhantomData<(C, OU)>);

impl<T, C, OU> OnChargeEVMTransaction<T> for EVMCurrencyAdapter<C, OU>
where
	T: Config,
	C: Currency<<T as frame_system::Config>::AccountId>,
	C::PositiveImbalance: Imbalance<
		<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,
		Opposite = C::NegativeImbalance,
	>,
	C::NegativeImbalance: Imbalance<
		<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,
		Opposite = C::PositiveImbalance,
	>,
	OU: OnUnbalanced<NegativeImbalanceOf<C, T>>,
	U256: UniqueSaturatedInto<<C as Currency<<T as frame_system::Config>::AccountId>>::Balance>,
{
	// Kept type as Option to satisfy bound of Default
	type LiquidityInfo = Option<NegativeImbalanceOf<C, T>>;

	fn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>> {
		if fee.is_zero() {
			return Ok(None);
		}
		let account_id = T::AddressMapping::into_account_id(*who);
		let imbalance = C::withdraw(
			&account_id,
			fee.unique_saturated_into(),
			WithdrawReasons::FEE,
			ExistenceRequirement::AllowDeath,
		)
		.map_err(|_| Error::<T>::BalanceLow)?;
		Ok(Some(imbalance))
	}

	fn correct_and_deposit_fee(
		who: &H160,
		corrected_fee: U256,
		base_fee: U256,
		already_withdrawn: Self::LiquidityInfo,
	) -> Self::LiquidityInfo {
		if let Some(paid) = already_withdrawn {
			let account_id = T::AddressMapping::into_account_id(*who);

			// Calculate how much refund we should return
			let refund_amount = paid
				.peek()
				.saturating_sub(corrected_fee.unique_saturated_into());
			// refund to the account that paid the fees. If this fails, the
			// account might have dropped below the existential balance. In
			// that case we don't refund anything.
			let refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)
				.unwrap_or_else(|_| C::PositiveImbalance::zero());

			// Make sure this works with 0 ExistentialDeposit
			// https://github.com/paritytech/substrate/issues/10117
			// If we tried to refund something, the account still empty and the ED is set to 0,
			// we call `make_free_balance_be` with the refunded amount.
			let refund_imbalance = if C::minimum_balance().is_zero()
				&& refund_amount > C::Balance::zero()
				&& C::total_balance(&account_id).is_zero()
			{
				// Known bug: Substrate tried to refund to a zeroed AccountData, but
				// interpreted the account to not exist.
				match C::make_free_balance_be(&account_id, refund_amount) {
					SignedImbalance::Positive(p) => p,
					_ => C::PositiveImbalance::zero(),
				}
			} else {
				refund_imbalance
			};

			// merge the imbalance caused by paying the fees and refunding parts of it again.
			let adjusted_paid = paid
				.offset(refund_imbalance)
				.same()
				.unwrap_or_else(|_| C::NegativeImbalance::zero());

			let (base_fee, tip) = adjusted_paid.split(base_fee.unique_saturated_into());
			// Handle base fee. Can be either burned, rationed, etc ...
			OU::on_unbalanced(base_fee);
			return Some(tip);
		}
		None
	}

	fn pay_priority_fee(tip: Self::LiquidityInfo) {
		// Default Ethereum behaviour: issue the tip to the block author.
		if let Some(tip) = tip {
			let account_id = T::AddressMapping::into_account_id(<Pallet<T>>::find_author());
			let _ = C::deposit_into_existing(&account_id, tip.peek());
		}
	}
}",0,False,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"correct_and_deposit_fee who : & H160 , corrected_fee : U256 , base_fee : U256 , already_withdrawn : Self :: LiquidityInfo ,","	fn correct_and_deposit_fee(
		who: &H160,
		corrected_fee: U256,
		base_fee: U256,
		already_withdrawn: Self::LiquidityInfo,
	) -> Self::LiquidityInfo {
		if let Some(paid) = already_withdrawn {
			let account_id = T::AddressMapping::into_account_id(*who);

			// Calculate how much refund we should return
			let refund_amount = paid
				.peek()
				.saturating_sub(corrected_fee.unique_saturated_into());
			// refund to the account that paid the fees. If this fails, the
			// account might have dropped below the existential balance. In
			// that case we don't refund anything.
			let refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)
				.unwrap_or_else(|_| C::PositiveImbalance::zero());

			// Make sure this works with 0 ExistentialDeposit
			// https://github.com/paritytech/substrate/issues/10117
			// If we tried to refund something, the account still empty and the ED is set to 0,
			// we call `make_free_balance_be` with the refunded amount.
			let refund_imbalance = if C::minimum_balance().is_zero()
				&& refund_amount > C::Balance::zero()
				&& C::total_balance(&account_id).is_zero()
			{
				// Known bug: Substrate tried to refund to a zeroed AccountData, but
				// interpreted the account to not exist.
				match C::make_free_balance_be(&account_id, refund_amount) {
					SignedImbalance::Positive(p) => p,
					_ => C::PositiveImbalance::zero(),
				}
			} else {
				refund_imbalance
			};

			// merge the imbalance caused by paying the fees and refunding parts of it again.
			let adjusted_paid = paid
				.offset(refund_imbalance)
				.same()
				.unwrap_or_else(|_| C::NegativeImbalance::zero());

			let (base_fee, tip) = adjusted_paid.split(base_fee.unique_saturated_into());
			// Handle base fee. Can be either burned, rationed, etc ...
			OU::on_unbalanced(base_fee);
			return Some(tip);
		}
		None
	}",0,False,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,config,"		fn config() -> &'static EvmConfig {
			&LONDON_CONFIG
		}
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {
		/// Withdraw balance from EVM into currency/balances pallet.
		#[pallet::weight(0)]
		pub fn withdraw(
			origin: OriginFor<T>,
			address: H160,
			value: BalanceOf<T>,
		) -> DispatchResult {
			let destination = T::WithdrawOrigin::ensure_address_origin(&address, origin)?;
			let address_account_id = T::AddressMapping::into_account_id(address);

			T::Currency::transfer(
				&address_account_id,
				&destination,
				value,
				ExistenceRequirement::AllowDeath,
			)?;

			Ok(())
		}

		/// Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
		#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]
		pub fn call(
			origin: OriginFor<T>,
			source: H160,
			target: H160,
			input: Vec<u8>,
			value: U256,
			gas_limit: u64,
			max_fee_per_gas: U256,
			max_priority_fee_per_gas: Option<U256>,
			nonce: Option<U256>,
			access_list: Vec<(H160, Vec<H256>)>,
		) -> DispatchResultWithPostInfo {
			T::CallOrigin::ensure_address_origin(&source, origin)?;

			let is_transactional = true;
			let validate = true;
			let info = match T::Runner::call(
				source,
				target,
				input,
				value,
				gas_limit,
				Some(max_fee_per_gas),
				max_priority_fee_per_gas,
				nonce,
				access_list,
				is_transactional,
				validate,
				T::config(),
			) {
				Ok(info) => info,
				Err(e) => {
					return Err(DispatchErrorWithPostInfo {
						post_info: PostDispatchInfo {
							actual_weight: Some(e.weight),
							pays_fee: Pays::Yes,
						},
						error: e.error.into(),
					})
				}
			};

			match info.exit_reason {
				ExitReason::Succeed(_) => {
					Pallet::<T>::deposit_event(Event::<T>::Executed(target));
				}
				_ => {
					Pallet::<T>::deposit_event(Event::<T>::ExecutedFailed(target));
				}
			};

			Ok(PostDispatchInfo {
				actual_weight: Some(T::GasWeightMapping::gas_to_weight(
					info.used_gas.unique_saturated_into(),
				)),
				pays_fee: Pays::No,
			})
		}

		/// Issue an EVM create operation. This is similar to a contract creation transaction in
		/// Ethereum.
		#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]
		pub fn create(
			origin: OriginFor<T>,
			source: H160,
			init: Vec<u8>,
			value: U256,
			gas_limit: u64,
			max_fee_per_gas: U256,
			max_priority_fee_per_gas: Option<U256>,
			nonce: Option<U256>,
			access_list: Vec<(H160, Vec<H256>)>,
		) -> DispatchResultWithPostInfo {
			T::CallOrigin::ensure_address_origin(&source, origin)?;

			let is_transactional = true;
			let validate = true;
			let info = match T::Runner::create(
				source,
				init,
				value,
				gas_limit,
				Some(max_fee_per_gas),
				max_priority_fee_per_gas,
				nonce,
				access_list,
				is_transactional,
				validate,
				T::config(),
			) {
				Ok(info) => info,
				Err(e) => {
					return Err(DispatchErrorWithPostInfo {
						post_info: PostDispatchInfo {
							actual_weight: Some(e.weight),
							pays_fee: Pays::Yes,
						},
						error: e.error.into(),
					})
				}
			};

			match info {
				CreateInfo {
					exit_reason: ExitReason::Succeed(_),
					value: create_address,
					..
				} => {
					Pallet::<T>::deposit_event(Event::<T>::Created(create_address));
				}
				CreateInfo {
					exit_reason: _,
					value: create_address,
					..
				} => {
					Pallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));
				}
			}

			Ok(PostDispatchInfo {
				actual_weight: Some(T::GasWeightMapping::gas_to_weight(
					info.used_gas.unique_saturated_into(),
				)),
				pays_fee: Pays::No,
			})
		}

		/// Issue an EVM create2 operation.
		#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]
		pub fn create2(
			origin: OriginFor<T>,
			source: H160,
			init: Vec<u8>,
			salt: H256,
			value: U256,
			gas_limit: u64,
			max_fee_per_gas: U256,
			max_priority_fee_per_gas: Option<U256>,
			nonce: Option<U256>,
			access_list: Vec<(H160, Vec<H256>)>,
		) -> DispatchResultWithPostInfo {
			T::CallOrigin::ensure_address_origin(&source, origin)?;

			let is_transactional = true;
			let validate = true;
			let info = match T::Runner::create2(
				source,
				init,
				salt,
				value,
				gas_limit,
				Some(max_fee_per_gas),
				max_priority_fee_per_gas,
				nonce,
				access_list,
				is_transactional,
				validate,
				T::config(),
			) {
				Ok(info) => info,
				Err(e) => {
					return Err(DispatchErrorWithPostInfo {
						post_info: PostDispatchInfo {
							actual_weight: Some(e.weight),
							pays_fee: Pays::Yes,
						},
						error: e.error.into(),
					})
				}
			};

			match info {
				CreateInfo {
					exit_reason: ExitReason::Succeed(_),
					value: create_address,
					..
				} => {
					Pallet::<T>::deposit_event(Event::<T>::Created(create_address));
				}
				CreateInfo {
					exit_reason: _,
					value: create_address,
					..
				} => {
					Pallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));
				}
			}

			Ok(PostDispatchInfo {
				actual_weight: Some(T::GasWeightMapping::gas_to_weight(
					info.used_gas.unique_saturated_into(),
				)),
				pays_fee: Pays::No,
			})
		}
	}

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		/// Ethereum events from contracts.
		Log(Log),
		/// A contract has been created at given \[address\].
		Created(H160),
		/// A \[contract\] was attempted to be created, but the execution failed.
		CreatedFailed(H160),
		/// A \[contract\] has been executed successfully with states applied.
		Executed(H160),
		/// A \[contract\] has been executed with errors. States are reverted with only gas fees applied.
		ExecutedFailed(H160),
		/// A deposit has been made at a given address. \[sender, address, value\]
		BalanceDeposit(T::AccountId, H160, U256),
		/// A withdrawal has been made from a given address. \[sender, address, value\]
		BalanceWithdraw(T::AccountId, H160, U256),
	}

	#[pallet::error]
	pub enum Error<T> {
		/// Not enough balance to perform action
		BalanceLow,
		/// Calculating total fee overflowed
		FeeOverflow,
		/// Calculating total payment overflowed
		PaymentOverflow,
		/// Withdraw fee failed
		WithdrawFailed,
		/// Gas price is too low.
		GasPriceTooLow,
		/// Nonce is invalid
		InvalidNonce,
		/// Gas limit is too low.
		GasLimitTooLow,
		/// Gas limit is too high.
		GasLimitTooHigh,
		/// Undefined error.
		Undefined,
	}

	impl<T> From<InvalidEvmTransactionError> for Error<T> {
		fn from(validation_error: InvalidEvmTransactionError) -> Self {
			match validation_error {
				InvalidEvmTransactionError::GasLimitTooLow => Error::<T>::GasLimitTooLow,
				InvalidEvmTransactionError::GasLimitTooHigh => Error::<T>::GasLimitTooHigh,
				InvalidEvmTransactionError::GasPriceTooLow => Error::<T>::GasLimitTooLow,
				InvalidEvmTransactionError::PriorityFeeTooHigh => Error::<T>::GasPriceTooLow,
				InvalidEvmTransactionError::BalanceTooLow => Error::<T>::BalanceLow,
				InvalidEvmTransactionError::TxNonceTooLow => Error::<T>::InvalidNonce,
				InvalidEvmTransactionError::TxNonceTooHigh => Error::<T>::InvalidNonce,
				InvalidEvmTransactionError::InvalidPaymentInput => Error::<T>::GasPriceTooLow,
				_ => Error::<T>::Undefined,
			}
		}
	}

	#[pallet::genesis_config]
	#[cfg_attr(feature = ""std"", derive(Default))]
	pub struct GenesisConfig {
		pub accounts: std::collections::BTreeMap<H160, GenesisAccount>,
	}

	#[pallet::genesis_build]
	impl<T: Config> GenesisBuild<T> for GenesisConfig
	where
		U256: UniqueSaturatedInto<BalanceOf<T>>,
	{
		fn build(&self) {
			const MAX_ACCOUNT_NONCE: usize = 100;

			for (address, account) in &self.accounts {
				let account_id = T::AddressMapping::into_account_id(*address);

				// ASSUME: in one single EVM transaction, the nonce will not increase more than
				// `u128::max_value()`.
				for _ in 0..min(
					MAX_ACCOUNT_NONCE,
					UniqueSaturatedInto::<usize>::unique_saturated_into(account.nonce),
				) {
					frame_system::Pallet::<T>::inc_account_nonce(&account_id);
				}

				T::Currency::deposit_creating(&account_id, account.balance.unique_saturated_into());

				Pallet::<T>::create_account(*address, account.code.clone());

				for (index, value) in &account.storage {
					<AccountStorages<T>>::insert(address, index, value);
				}
			}
		}
	}

	#[pallet::storage]
	#[pallet::getter(fn account_codes)]
	pub type AccountCodes<T: Config> = StorageMap<_, Blake2_128Concat, H160, Vec<u8>, ValueQuery>;

	#[pallet::storage]
	#[pallet::getter(fn account_storages)]
	pub type AccountStorages<T: Config> =
		StorageDoubleMap<_, Blake2_128Concat, H160, Blake2_128Concat, H256, H256, ValueQuery>;
}

/// Type alias for currency balance.
pub type BalanceOf<T> =
	<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;

/// Type alias for negative imbalance during fees
type NegativeImbalanceOf<C, T> =
	<C as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance;

pub trait EnsureAddressOrigin<OuterOrigin> {
	/// Success return type.
	type Success;

	/// Perform the origin check.
	fn ensure_address_origin(
		address: &H160,
		origin: OuterOrigin,
	) -> Result<Self::Success, BadOrigin> {
		Self::try_address_origin(address, origin).map_err(|_| BadOrigin)
	}

	/// Try with origin.
	fn try_address_origin(
		address: &H160,
		origin: OuterOrigin,
	) -> Result<Self::Success, OuterOrigin>;
}

/// Ensure that the EVM address is the same as the Substrate address. This only works if the account
/// ID is `H160`.
pub struct EnsureAddressSame;

impl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressSame
where
	OuterOrigin: Into<Result<RawOrigin<H160>, OuterOrigin>> + From<RawOrigin<H160>>,
{
	type Success = H160;

	fn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<H160, OuterOrigin> {
		origin.into().and_then(|o| match o {
			RawOrigin::Signed(who) if &who == address => Ok(who),
			r => Err(OuterOrigin::from(r)),
		})
	}
}

/// Ensure that the origin is root.
pub struct EnsureAddressRoot<AccountId>(sp_std::marker::PhantomData<AccountId>);

impl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressRoot<AccountId>
where
	OuterOrigin: Into<Result<RawOrigin<AccountId>, OuterOrigin>> + From<RawOrigin<AccountId>>,
{
	type Success = ();

	fn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<(), OuterOrigin> {
		origin.into().and_then(|o| match o {
			RawOrigin::Root => Ok(()),
			r => Err(OuterOrigin::from(r)),
		})
	}
}

/// Ensure that the origin never happens.
pub struct EnsureAddressNever<AccountId>(sp_std::marker::PhantomData<AccountId>);

impl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressNever<AccountId> {
	type Success = AccountId;

	fn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<AccountId, OuterOrigin> {
		Err(origin)
	}
}

/// Ensure that the address is truncated hash of the origin. Only works if the account id is
/// `AccountId32`.
pub struct EnsureAddressTruncated;

impl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressTruncated
where
	OuterOrigin: Into<Result<RawOrigin<AccountId32>, OuterOrigin>> + From<RawOrigin<AccountId32>>,
{
	type Success = AccountId32;

	fn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<AccountId32, OuterOrigin> {
		origin.into().and_then(|o| match o {
			RawOrigin::Signed(who) if AsRef::<[u8; 32]>::as_ref(&who)[0..20] == address[0..20] => {
				Ok(who)
			}
			r => Err(OuterOrigin::from(r)),
		})
	}
}

pub trait AddressMapping<A> {
	fn into_account_id(address: H160) -> A;
}

/// Identity address mapping.
pub struct IdentityAddressMapping;

impl AddressMapping<H160> for IdentityAddressMapping {
	fn into_account_id(address: H160) -> H160 {
		address
	}
}

/// Hashed address mapping.
pub struct HashedAddressMapping<H>(sp_std::marker::PhantomData<H>);

impl<H: Hasher<Out = H256>> AddressMapping<AccountId32> for HashedAddressMapping<H> {
	fn into_account_id(address: H160) -> AccountId32 {
		let mut data = [0u8; 24];
		data[0..4].copy_from_slice(b""evm:"");
		data[4..24].copy_from_slice(&address[..]);
		let hash = H::hash(&data);

		AccountId32::from(Into::<[u8; 32]>::into(hash))
	}
}

/// A trait for getting a block hash by number.
pub trait BlockHashMapping {
	fn block_hash(number: u32) -> H256;
}

/// Returns the Substrate block hash by number.
pub struct SubstrateBlockHashMapping<T>(sp_std::marker::PhantomData<T>);
impl<T: Config> BlockHashMapping for SubstrateBlockHashMapping<T> {
	fn block_hash(number: u32) -> H256 {
		let number = T::BlockNumber::from(number);
		H256::from_slice(frame_system::Pallet::<T>::block_hash(number).as_ref())
	}
}

/// A mapping function that converts Ethereum gas to Substrate weight
pub trait GasWeightMapping {
	fn gas_to_weight(gas: u64) -> Weight;
	fn weight_to_gas(weight: Weight) -> u64;
}

impl GasWeightMapping for () {
	fn gas_to_weight(gas: u64) -> Weight {
		gas as Weight
	}
	fn weight_to_gas(weight: Weight) -> u64 {
		weight as u64
	}
}

static LONDON_CONFIG: EvmConfig = EvmConfig::london();

impl<T: Config> Pallet<T> {
	/// Check whether an account is empty.
	pub fn is_account_empty(address: &H160) -> bool {
		let (account, _) = Self::account_basic(address);
		let code_len = <AccountCodes<T>>::decode_len(address).unwrap_or(0);

		account.nonce == U256::zero() && account.balance == U256::zero() && code_len == 0
	}

	/// Remove an account if its empty.
	pub fn remove_account_if_empty(address: &H160) {
		if Self::is_account_empty(address) {
			Self::remove_account(address);
		}
	}

	/// Remove an account.
	pub fn remove_account(address: &H160) {
		if <AccountCodes<T>>::contains_key(address) {
			let account_id = T::AddressMapping::into_account_id(*address);
			let _ = frame_system::Pallet::<T>::dec_sufficients(&account_id);
		}

		<AccountCodes<T>>::remove(address);
		let _ = <AccountStorages<T>>::remove_prefix(address, None);
	}

	/// Create an account.
	pub fn create_account(address: H160, code: Vec<u8>) {
		if code.is_empty() {
			return;
		}

		if !<AccountCodes<T>>::contains_key(&address) {
			let account_id = T::AddressMapping::into_account_id(address);
			let _ = frame_system::Pallet::<T>::inc_sufficients(&account_id);
		}

		<AccountCodes<T>>::insert(address, code);
	}

	/// Get the account basic in EVM format.
	pub fn account_basic(address: &H160) -> (Account, frame_support::weights::Weight) {
		let account_id = T::AddressMapping::into_account_id(*address);

		let nonce = frame_system::Pallet::<T>::account_nonce(&account_id);
		// keepalive `true` takes into account ExistentialDeposit as part of what's considered liquid balance.
		let balance = T::Currency::reducible_balance(&account_id, true);

		(
			Account {
				nonce: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(nonce)),
				balance: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(balance)),
			},",0,False,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,find_author,"	pub fn find_author() -> H160 {
		let digest = <frame_system::Pallet<T>>::digest();
		let pre_runtime_digests = digest.logs.iter().filter_map(|d| d.as_pre_runtime());

		T::FindAuthor::find_author(pre_runtime_digests).unwrap_or_default()
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,pay_priority_fee tip : Self :: LiquidityInfo,"	fn pay_priority_fee(tip: Self::LiquidityInfo) {
		// Default Ethereum behaviour: issue the tip to the block author.
		if let Some(tip) = tip {
			let account_id = T::AddressMapping::into_account_id(<Pallet<T>>::find_author());
			let _ = C::deposit_into_existing(&account_id, tip.peek());
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,"withdraw_fee who : & H160 , fee : U256 ,","	fn withdraw_fee(
		who: &H160,
		fee: U256,
	) -> Result<Self::LiquidityInfo, Error<T>> {
		EVMCurrencyAdapter::<<T as Config>::Currency, ()>::withdraw_fee(who, fee)
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,pay_priority_fee tip : Self :: LiquidityInfo,"	fn pay_priority_fee(tip: Self::LiquidityInfo) {
		<EVMCurrencyAdapter::<<T as Config>::Currency, ()> as OnChargeEVMTransaction<T>>::pay_priority_fee(tip);
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"transfer & mut self , transfer : Transfer","	fn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {
		let source = T::AddressMapping::into_account_id(transfer.source);
		let target = T::AddressMapping::into_account_id(transfer.target);

		T::Currency::transfer(
			&source,
			&target,
			transfer.value.low_u128().unique_saturated_into(),
			ExistenceRequirement::AllowDeath,
		)
		.map_err(|_| ExitError::OutOfFund)
	}",1,True,False,7
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,metadata_mut & mut self,"	pub fn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {
		&mut self.metadata
	}

	pub fn enter(&mut self, gas_limit: u64, is_static: bool) {
		let mut entering = Self {
			metadata: self.metadata.spit_child(gas_limit, is_static),
			parent: None,
			deletes: BTreeSet::new(),
			logs: Vec::new(),
		};
		mem::swap(&mut entering, self);

		self.parent = Some(Box::new(entering));

		sp_io::storage::start_transaction();
	}

	pub fn exit_commit(&mut self) -> Result<(), ExitError> {
		let mut exited = *self.parent.take().expect(""Cannot commit on root substate"");
		mem::swap(&mut exited, self);

		self.metadata.swallow_commit(exited.metadata)?;
		self.logs.append(&mut exited.logs);
		self.deletes.append(&mut exited.deletes);

		sp_io::storage::commit_transaction();
		Ok(())
	}

	pub fn exit_revert(&mut self) -> Result<(), ExitError> {
		let mut exited = *self.parent.take().expect(""Cannot discard on root substate"");
		mem::swap(&mut exited, self);
		self.metadata.swallow_revert(exited.metadata)?;

		sp_io::storage::rollback_transaction();
		Ok(())
	}

	pub fn exit_discard(&mut self) -> Result<(), ExitError> {
		let mut exited = *self.parent.take().expect(""Cannot discard on root substate"");
		mem::swap(&mut exited, self);
		self.metadata.swallow_discard(exited.metadata)?;

		sp_io::storage::rollback_transaction();
		Ok(())
	}

	pub fn deleted(&self, address: H160) -> bool {
		if self.deletes.contains(&address) {
			return true;
		}

		if let Some(parent) = self.parent.as_ref() {
			return parent.deleted(address);
		}

		false
	}

	pub fn set_deleted(&mut self, address: H160) {
		self.deletes.insert(address);
	}

	pub fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {
		self.logs.push(Log {
			address,
			topics,
			data,
		});
	}

	fn recursive_is_cold<F: Fn(&Accessed) -> bool>(&self, f: &F) -> bool {
		let local_is_accessed = self.metadata.accessed().as_ref().map(f).unwrap_or(false);
		if local_is_accessed {
			false
		} else {
			self.parent
				.as_ref()
				.map(|p| p.recursive_is_cold(f))
				.unwrap_or(true)
		}
	}
}

/// Substrate backend for EVM.
pub struct SubstrateStackState<'vicinity, 'config, T> {
	vicinity: &'vicinity Vicinity,
	substate: SubstrateStackSubstate<'config>,
	_marker: PhantomData<T>,
}

impl<'vicinity, 'config, T: Config> SubstrateStackState<'vicinity, 'config, T> {
	/// Create a new backend with given vicinity.
	pub fn new(vicinity: &'vicinity Vicinity, metadata: StackSubstateMetadata<'config>) -> Self {
		Self {
			vicinity,
			substate: SubstrateStackSubstate {
				metadata,
				deletes: BTreeSet::new(),
				logs: Vec::new(),
				parent: None,
			},
			_marker: PhantomData,
		}
	}
}

impl<'vicinity, 'config, T: Config> BackendT for SubstrateStackState<'vicinity, 'config, T> {
	fn gas_price(&self) -> U256 {
		self.vicinity.gas_price
	}
	fn origin(&self) -> H160 {
		self.vicinity.origin
	}

	fn block_hash(&self, number: U256) -> H256 {
		if number > U256::from(u32::max_value()) {
			H256::default()
		} else {
			T::BlockHashMapping::block_hash(number.as_u32())
		}
	}

	fn block_number(&self) -> U256 {
		let number: u128 = frame_system::Pallet::<T>::block_number().unique_saturated_into();
		U256::from(number)
	}

	fn block_coinbase(&self) -> H160 {
		Pallet::<T>::find_author()
	}

	fn block_timestamp(&self) -> U256 {
		let now: u128 = pallet_timestamp::Pallet::<T>::get().unique_saturated_into();
		U256::from(now / 1000)
	}

	fn block_difficulty(&self) -> U256 {
		U256::zero()
	}

	fn block_gas_limit(&self) -> U256 {
		T::BlockGasLimit::get()
	}

	fn chain_id(&self) -> U256 {
		U256::from(T::ChainId::get())
	}

	fn exists(&self, _address: H160) -> bool {
		true
	}

	fn basic(&self, address: H160) -> evm::backend::Basic {
		let (account, _) = Pallet::<T>::account_basic(&address);

		evm::backend::Basic {
			balance: account.balance,
			nonce: account.nonce,
		}
	}

	fn code(&self, address: H160) -> Vec<u8> {
		<AccountCodes<T>>::get(&address)
	}

	fn storage(&self, address: H160, index: H256) -> H256 {
		<AccountStorages<T>>::get(address, index)
	}

	fn original_storage(&self, _address: H160, _index: H256) -> Option<H256> {
		None
	}

	fn block_base_fee_per_gas(&self) -> sp_core::U256 {
		let (base_fee, _) = T::FeeCalculator::min_gas_price();
		base_fee
	}
}

impl<'vicinity, 'config, T: Config> StackStateT<'config>
	for SubstrateStackState<'vicinity, 'config, T>
{
	fn metadata(&self) -> &StackSubstateMetadata<'config> {
		self.substate.metadata()
	}

	fn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {
		self.substate.metadata_mut()
	}

	fn enter(&mut self, gas_limit: u64, is_static: bool) {
		self.substate.enter(gas_limit, is_static)
	}

	fn exit_commit(&mut self) -> Result<(), ExitError> {
		self.substate.exit_commit()
	}

	fn exit_revert(&mut self) -> Result<(), ExitError> {
		self.substate.exit_revert()
	}

	fn exit_discard(&mut self) -> Result<(), ExitError> {
		self.substate.exit_discard()
	}

	fn is_empty(&self, address: H160) -> bool {
		Pallet::<T>::is_account_empty(&address)
	}

	fn deleted(&self, address: H160) -> bool {
		self.substate.deleted(address)
	}

	fn inc_nonce(&mut self, address: H160) {
		let account_id = T::AddressMapping::into_account_id(address);
		frame_system::Pallet::<T>::inc_account_nonce(&account_id);
	}

	fn set_storage(&mut self, address: H160, index: H256, value: H256) {
		if value == H256::default() {
			log::debug!(
				target: ""evm"",
				""Removing storage for {:?} [index: {:?}]"",
				address,
				index,
			);
			<AccountStorages<T>>::remove(address, index);
		} else {
			log::debug!(
				target: ""evm"",
				""Updating storage for {:?} [index: {:?}, value: {:?}]"",
				address,
				index,
				value,
			);
			<AccountStorages<T>>::insert(address, index, value);
		}
	}

	fn reset_storage(&mut self, address: H160) {
		let _ = <AccountStorages<T>>::remove_prefix(address, None);
	}

	fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {
		self.substate.log(address, topics, data)
	}

	fn set_deleted(&mut self, address: H160) {
		self.substate.set_deleted(address)
	}

	fn set_code(&mut self, address: H160, code: Vec<u8>) {
		log::debug!(
			target: ""evm"",
			""Inserting code ({} bytes) at {:?}"",
			code.len(),
			address
		);
		Pallet::<T>::create_account(address, code);
	}

	fn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {
		let source = T::AddressMapping::into_account_id(transfer.source);
		let target = T::AddressMapping::into_account_id(transfer.target);

		T::Currency::transfer(
			&source,
			&target,
			transfer.value.low_u128().unique_saturated_into(),
			ExistenceRequirement::AllowDeath,
		)
		.map_err(|_| ExitError::OutOfFund)
	}

	fn reset_balance(&mut self, _address: H160) {
		// Do nothing on reset balance in Substrate.
		//
		// This function exists in EVM because a design issue
		// (arguably a bug) in SELFDESTRUCT that can cause total
		// issurance to be reduced. We do not need to replicate this.
	}

	fn touch(&mut self, _address: H160) {
		// Do nothing on touch in Substrate.
		//
		// EVM pallet considers all accounts to exist, and distinguish
		// only empty and non-empty accounts. This avoids many of the
		// subtle issues in EIP-161.
	}

	fn is_cold(&self, address: H160) -> bool {
		self.substate
			.recursive_is_cold(&|a| a.accessed_addresses.contains(&address))
	}

	fn is_storage_cold(&self, address: H160, key: H256) -> bool {
		self.substate
			.recursive_is_cold(&|a: &Accessed| a.accessed_storage.contains(&(address, key)))
	}
}",1,True,False,271
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"transfer & mut self , transfer : Transfer","	fn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {
		let source = T::AddressMapping::into_account_id(transfer.source);
		let target = T::AddressMapping::into_account_id(transfer.target);

		T::Currency::transfer(
			&source,
			&target,
			transfer
				.value
				.try_into()
				.map_err(|_| ExitError::OutOfFund)?,
			ExistenceRequirement::AllowDeath,
		)
		.map_err(|_| ExitError::OutOfFund)
	}",0,False,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,metadata_mut & mut self,"	pub fn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {
		&mut self.metadata
	}

	pub fn enter(&mut self, gas_limit: u64, is_static: bool) {
		let mut entering = Self {
			metadata: self.metadata.spit_child(gas_limit, is_static),
			parent: None,
			deletes: BTreeSet::new(),
			logs: Vec::new(),
		};
		mem::swap(&mut entering, self);

		self.parent = Some(Box::new(entering));

		sp_io::storage::start_transaction();
	}

	pub fn exit_commit(&mut self) -> Result<(), ExitError> {
		let mut exited = *self.parent.take().expect(""Cannot commit on root substate"");
		mem::swap(&mut exited, self);

		self.metadata.swallow_commit(exited.metadata)?;
		self.logs.append(&mut exited.logs);
		self.deletes.append(&mut exited.deletes);

		sp_io::storage::commit_transaction();
		Ok(())
	}

	pub fn exit_revert(&mut self) -> Result<(), ExitError> {
		let mut exited = *self.parent.take().expect(""Cannot discard on root substate"");
		mem::swap(&mut exited, self);
		self.metadata.swallow_revert(exited.metadata)?;

		sp_io::storage::rollback_transaction();
		Ok(())
	}

	pub fn exit_discard(&mut self) -> Result<(), ExitError> {
		let mut exited = *self.parent.take().expect(""Cannot discard on root substate"");
		mem::swap(&mut exited, self);
		self.metadata.swallow_discard(exited.metadata)?;

		sp_io::storage::rollback_transaction();
		Ok(())
	}

	pub fn deleted(&self, address: H160) -> bool {
		if self.deletes.contains(&address) {
			return true;
		}

		if let Some(parent) = self.parent.as_ref() {
			return parent.deleted(address);
		}

		false
	}

	pub fn set_deleted(&mut self, address: H160) {
		self.deletes.insert(address);
	}

	pub fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {
		self.logs.push(Log {
			address,
			topics,
			data,
		});
	}

	fn recursive_is_cold<F: Fn(&Accessed) -> bool>(&self, f: &F) -> bool {
		let local_is_accessed = self.metadata.accessed().as_ref().map(f).unwrap_or(false);
		if local_is_accessed {
			false
		} else {
			self.parent
				.as_ref()
				.map(|p| p.recursive_is_cold(f))
				.unwrap_or(true)
		}
	}
}

/// Substrate backend for EVM.
pub struct SubstrateStackState<'vicinity, 'config, T> {
	vicinity: &'vicinity Vicinity,
	substate: SubstrateStackSubstate<'config>,
	_marker: PhantomData<T>,
}

impl<'vicinity, 'config, T: Config> SubstrateStackState<'vicinity, 'config, T> {
	/// Create a new backend with given vicinity.
	pub fn new(vicinity: &'vicinity Vicinity, metadata: StackSubstateMetadata<'config>) -> Self {
		Self {
			vicinity,
			substate: SubstrateStackSubstate {
				metadata,
				deletes: BTreeSet::new(),
				logs: Vec::new(),
				parent: None,
			},
			_marker: PhantomData,
		}
	}
}

impl<'vicinity, 'config, T: Config> BackendT for SubstrateStackState<'vicinity, 'config, T> {
	fn gas_price(&self) -> U256 {
		self.vicinity.gas_price
	}
	fn origin(&self) -> H160 {
		self.vicinity.origin
	}

	fn block_hash(&self, number: U256) -> H256 {
		if number > U256::from(u32::max_value()) {
			H256::default()
		} else {
			T::BlockHashMapping::block_hash(number.as_u32())
		}
	}

	fn block_number(&self) -> U256 {
		let number: u128 = frame_system::Pallet::<T>::block_number().unique_saturated_into();
		U256::from(number)
	}

	fn block_coinbase(&self) -> H160 {
		Pallet::<T>::find_author()
	}

	fn block_timestamp(&self) -> U256 {
		let now: u128 = pallet_timestamp::Pallet::<T>::get().unique_saturated_into();
		U256::from(now / 1000)
	}

	fn block_difficulty(&self) -> U256 {
		U256::zero()
	}

	fn block_gas_limit(&self) -> U256 {
		T::BlockGasLimit::get()
	}

	fn chain_id(&self) -> U256 {
		U256::from(T::ChainId::get())
	}

	fn exists(&self, _address: H160) -> bool {
		true
	}

	fn basic(&self, address: H160) -> evm::backend::Basic {
		let (account, _) = Pallet::<T>::account_basic(&address);

		evm::backend::Basic {
			balance: account.balance,
			nonce: account.nonce,
		}
	}

	fn code(&self, address: H160) -> Vec<u8> {
		<AccountCodes<T>>::get(&address)
	}

	fn storage(&self, address: H160, index: H256) -> H256 {
		<AccountStorages<T>>::get(address, index)
	}

	fn original_storage(&self, _address: H160, _index: H256) -> Option<H256> {
		None
	}

	fn block_base_fee_per_gas(&self) -> sp_core::U256 {
		let (base_fee, _) = T::FeeCalculator::min_gas_price();
		base_fee
	}
}

impl<'vicinity, 'config, T: Config> StackStateT<'config>
	for SubstrateStackState<'vicinity, 'config, T>
where
	BalanceOf<T>: TryFrom<U256> + Into<U256>,
{
	fn metadata(&self) -> &StackSubstateMetadata<'config> {
		self.substate.metadata()
	}

	fn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {
		self.substate.metadata_mut()
	}

	fn enter(&mut self, gas_limit: u64, is_static: bool) {
		self.substate.enter(gas_limit, is_static)
	}

	fn exit_commit(&mut self) -> Result<(), ExitError> {
		self.substate.exit_commit()
	}

	fn exit_revert(&mut self) -> Result<(), ExitError> {
		self.substate.exit_revert()
	}

	fn exit_discard(&mut self) -> Result<(), ExitError> {
		self.substate.exit_discard()
	}

	fn is_empty(&self, address: H160) -> bool {
		Pallet::<T>::is_account_empty(&address)
	}

	fn deleted(&self, address: H160) -> bool {
		self.substate.deleted(address)
	}

	fn inc_nonce(&mut self, address: H160) {
		let account_id = T::AddressMapping::into_account_id(address);
		frame_system::Pallet::<T>::inc_account_nonce(&account_id);
	}

	fn set_storage(&mut self, address: H160, index: H256, value: H256) {
		if value == H256::default() {
			log::debug!(
				target: ""evm"",
				""Removing storage for {:?} [index: {:?}]"",
				address,
				index,
			);
			<AccountStorages<T>>::remove(address, index);
		} else {
			log::debug!(
				target: ""evm"",
				""Updating storage for {:?} [index: {:?}, value: {:?}]"",
				address,
				index,
				value,
			);
			<AccountStorages<T>>::insert(address, index, value);
		}
	}

	fn reset_storage(&mut self, address: H160) {
		let _ = <AccountStorages<T>>::remove_prefix(address, None);
	}

	fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {
		self.substate.log(address, topics, data)
	}

	fn set_deleted(&mut self, address: H160) {
		self.substate.set_deleted(address)
	}

	fn set_code(&mut self, address: H160, code: Vec<u8>) {
		log::debug!(
			target: ""evm"",
			""Inserting code ({} bytes) at {:?}"",
			code.len(),
			address
		);
		Pallet::<T>::create_account(address, code);
	}

	fn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {
		let source = T::AddressMapping::into_account_id(transfer.source);
		let target = T::AddressMapping::into_account_id(transfer.target);

		T::Currency::transfer(
			&source,
			&target,
			transfer
				.value
				.try_into()
				.map_err(|_| ExitError::OutOfFund)?,
			ExistenceRequirement::AllowDeath,
		)
		.map_err(|_| ExitError::OutOfFund)
	}

	fn reset_balance(&mut self, _address: H160) {
		// Do nothing on reset balance in Substrate.
		//
		// This function exists in EVM because a design issue
		// (arguably a bug) in SELFDESTRUCT that can cause total
		// issurance to be reduced. We do not need to replicate this.
	}

	fn touch(&mut self, _address: H160) {
		// Do nothing on touch in Substrate.
		//
		// EVM pallet considers all accounts to exist, and distinguish
		// only empty and non-empty accounts. This avoids many of the
		// subtle issues in EIP-161.
	}

	fn is_cold(&self, address: H160) -> bool {
		self.substate
			.recursive_is_cold(&|a| a.accessed_addresses.contains(&address))
	}

	fn is_storage_cold(&self, address: H160, key: H256) -> bool {
		self.substate
			.recursive_is_cold(&|a: &Accessed| a.accessed_storage.contains(&(address, key)))
	}
}",0,False,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"execute source : H160 , value : U256 , gas_limit : u64 , max_fee_per_gas : Option < U256 > , max_priority_fee_per_gas : Option < U256 > , config : & 'config evm::Config,
		precompiles: &' precompiles T :: PrecompilesType , is_transactional : bool , f : F ,","	fn execute<'config, 'precompiles, F, R>(
		source: H160,
		value: U256,
		gas_limit: u64,
		max_fee_per_gas: Option<U256>,
		max_priority_fee_per_gas: Option<U256>,
		config: &'config evm::Config,
		precompiles: &'precompiles T::PrecompilesType,
		is_transactional: bool,
		f: F,
	) -> Result<ExecutionInfo<R>, RunnerError<Error<T>>>
	where
		F: FnOnce(
			&mut StackExecutor<
				'config,
				'precompiles,
				SubstrateStackState<'_, 'config, T>,
				T::PrecompilesType,
			>,
		) -> (ExitReason, R),
	{
		let (base_fee, weight) = T::FeeCalculator::min_gas_price();
		let max_fee_per_gas = match (max_fee_per_gas, is_transactional) {
			(Some(max_fee_per_gas), _) => max_fee_per_gas,
			// Gas price check is skipped for non-transactional calls that don't
			// define a `max_fee_per_gas` input.
			(None, false) => Default::default(),
			// Unreachable, previously validated. Handle gracefully.
			_ => {
				return Err(RunnerError {
					error: Error::<T>::GasPriceTooLow,
					weight,
				})
			}
		};

		// After eip-1559 we make sure the account can pay both the evm execution and priority fees.
		let total_fee = max_fee_per_gas
			.checked_mul(U256::from(gas_limit))
			.ok_or(RunnerError {
				error: Error::<T>::FeeOverflow,
				weight,
			})?;

		// Deduct fee from the `source` account. Returns `None` if `total_fee` is Zero.
		let fee = T::OnChargeTransaction::withdraw_fee(&source, total_fee)
			.map_err(|e| RunnerError { error: e, weight })?;

		// Execute the EVM call.
		let vicinity = Vicinity {
			gas_price: base_fee,
			origin: source,
		};

		let metadata = StackSubstateMetadata::new(gas_limit, config);
		let state = SubstrateStackState::new(&vicinity, metadata);
		let mut executor = StackExecutor::new_with_precompiles(state, config, precompiles);

		let (reason, retv) = f(&mut executor);

		// Post execution.
		let used_gas = U256::from(executor.used_gas());
		let actual_fee = if let Some(max_priority_fee) = max_priority_fee_per_gas {
			let actual_priority_fee = max_fee_per_gas
				.saturating_sub(base_fee)
				.min(max_priority_fee)
				.saturating_mul(used_gas);
			executor
				.fee(base_fee)
				.checked_add(actual_priority_fee)
				.unwrap_or_else(U256::max_value)
		} else {
			executor.fee(base_fee)
		};
		log::debug!(
			target: ""evm"",
			""Execution {:?} [source: {:?}, value: {}, gas_limit: {}, actual_fee: {}, is_transactional: {}]"",
			reason,
			source,
			value,
			gas_limit,
			actual_fee,
			is_transactional
		);
		// The difference between initially withdrawn and the actual cost is refunded.
		//
		// Considered the following request:
		// +-----------+---------+--------------+
		// | Gas_limit | Max_Fee | Max_Priority |
		// +-----------+---------+--------------+
		// |        20 |      10 |            6 |
		// +-----------+---------+--------------+
		//
		// And execution:
		// +----------+----------+
		// | Gas_used | Base_Fee |
		// +----------+----------+
		// |        5 |        2 |
		// +----------+----------+
		//
		// Initially withdrawn 10 * 20 = 200.
		// Actual cost (2 + 6) * 5 = 40.
		// Refunded 200 - 40 = 160.
		// Tip 5 * 6 = 30.
		// Burned 200 - (160 + 30) = 10. Which is equivalent to gas_used * base_fee.
		let actual_priority_fee = T::OnChargeTransaction::correct_and_deposit_fee(
			&source,
			// Actual fee after evm execution, including tip.
			actual_fee,
			// Base fee.
			executor.fee(base_fee),
			// Fee initially withdrawn.
			fee,
		);
		T::OnChargeTransaction::pay_priority_fee(actual_priority_fee);

		let state = executor.into_state();

		for address in state.substate.deletes {
			log::debug!(
				target: ""evm"",
				""Deleting account at {:?}"",
				address
			);
			Pallet::<T>::remove_account(&address)
		}

		for log in &state.substate.logs {
			log::trace!(
				target: ""evm"",
				""Inserting log for {:?}, topics ({}) {:?}, data ({}): {:?}]"",
				log.address,
				log.topics.len(),
				log.topics,
				log.data.len(),
				log.data
			);
			Pallet::<T>::deposit_event(Event::<T>::Log(Log {
				address: log.address,
				topics: log.topics.clone(),
				data: log.data.clone(),
			}));
		}

		Ok(ExecutionInfo {
			value: retv,
			exit_reason: reason,
			used_gas,
			logs: state.substate.logs,
		})
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"validate source : H160 , target : Option < H160 > , input : Vec < u8 > , value : U256 , gas_limit : u64 , max_fee_per_gas : Option < U256 > , max_priority_fee_per_gas : Option < U256 > , nonce : Option < U256 > , access_list : Vec < H160 , Vec < H256 > > , is_transactional : bool , evm_config : & evm :: Config ,","	fn validate(
		source: H160,
		target: Option<H160>,
		input: Vec<u8>,
		value: U256,
		gas_limit: u64,
		max_fee_per_gas: Option<U256>,
		max_priority_fee_per_gas: Option<U256>,
		nonce: Option<U256>,
		access_list: Vec<(H160, Vec<H256>)>,
		is_transactional: bool,
		evm_config: &evm::Config,
	) -> Result<(), RunnerError<Self::Error>> {
		let (base_fee, mut weight) = T::FeeCalculator::min_gas_price();
		let (source_account, inner_weight) = Pallet::<T>::account_basic(&source);
		weight = weight.saturating_add(inner_weight);

		let _ = fp_evm::CheckEvmTransaction::<Self::Error>::new(
			fp_evm::CheckEvmTransactionConfig {
				evm_config,
				block_gas_limit: T::BlockGasLimit::get(),
				base_fee,
				chain_id: T::ChainId::get(),
				is_transactional,
			},
			fp_evm::CheckEvmTransactionInput {
				chain_id: Some(T::ChainId::get()),
				to: target,
				input,
				nonce: nonce.unwrap_or(source_account.nonce),
				gas_limit: gas_limit.into(),
				gas_price: None,
				max_fee_per_gas,
				max_priority_fee_per_gas,
				value,
				access_list,
			},
		)
		.validate_in_block_for(&source_account)
		.and_then(|v| v.with_base_fee())
		.and_then(|v| v.with_balance_for(&source_account))
		.map_err(|error| RunnerError { error, weight })?;
		Ok(())
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"call source : H160 , target : H160 , input : Vec < u8 > , value : U256 , gas_limit : u64 , max_fee_per_gas : Option < U256 > , max_priority_fee_per_gas : Option < U256 > , nonce : Option < U256 > , access_list : Vec < H160 , Vec < H256 > > , is_transactional : bool , validate : bool , config : & evm :: Config ,","	fn call(
		source: H160,
		target: H160,
		input: Vec<u8>,
		value: U256,
		gas_limit: u64,
		max_fee_per_gas: Option<U256>,
		max_priority_fee_per_gas: Option<U256>,
		nonce: Option<U256>,
		access_list: Vec<(H160, Vec<H256>)>,
		is_transactional: bool,
		validate: bool,
		config: &evm::Config,
	) -> Result<CallInfo, RunnerError<Self::Error>> {
		if validate {
			let _ = Self::validate(
				source,
				Some(target),
				input.clone(),
				value,
				gas_limit,
				max_fee_per_gas,
				max_priority_fee_per_gas,
				nonce,
				access_list.clone(),
				is_transactional,
				config,
			)?;
		}
		let precompiles = T::PrecompilesValue::get();
		Self::execute(
			source,
			value,
			gas_limit,
			max_fee_per_gas,
			max_priority_fee_per_gas,
			config,
			&precompiles,
			is_transactional,
			|executor| executor.transact_call(source, target, value, input, gas_limit, access_list),
		)
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"create source : H160 , init : Vec < u8 > , value : U256 , gas_limit : u64 , max_fee_per_gas : Option < U256 > , max_priority_fee_per_gas : Option < U256 > , nonce : Option < U256 > , access_list : Vec < H160 , Vec < H256 > > , is_transactional : bool , validate : bool , config : & evm :: Config ,","	fn create(
		source: H160,
		init: Vec<u8>,
		value: U256,
		gas_limit: u64,
		max_fee_per_gas: Option<U256>,
		max_priority_fee_per_gas: Option<U256>,
		nonce: Option<U256>,
		access_list: Vec<(H160, Vec<H256>)>,
		is_transactional: bool,
		validate: bool,
		config: &evm::Config,
	) -> Result<CreateInfo, RunnerError<Self::Error>> {
		if validate {
			let _ = Self::validate(
				source,
				None,
				init.clone(),
				value,
				gas_limit,
				max_fee_per_gas,
				max_priority_fee_per_gas,
				nonce,
				access_list.clone(),
				is_transactional,
				config,
			)?;
		}
		let precompiles = T::PrecompilesValue::get();
		Self::execute(
			source,
			value,
			gas_limit,
			max_fee_per_gas,
			max_priority_fee_per_gas,
			config,
			&precompiles,
			is_transactional,
			|executor| {
				let address = executor.create_address(evm::CreateScheme::Legacy { caller: source });
				let (reason, _) =
					executor.transact_create(source, value, init, gas_limit, access_list);
				(reason, address)
			},
		)
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"create2 source : H160 , init : Vec < u8 > , salt : H256 , value : U256 , gas_limit : u64 , max_fee_per_gas : Option < U256 > , max_priority_fee_per_gas : Option < U256 > , nonce : Option < U256 > , access_list : Vec < H160 , Vec < H256 > > , is_transactional : bool , validate : bool , config : & evm :: Config ,","	fn create2(
		source: H160,
		init: Vec<u8>,
		salt: H256,
		value: U256,
		gas_limit: u64,
		max_fee_per_gas: Option<U256>,
		max_priority_fee_per_gas: Option<U256>,
		nonce: Option<U256>,
		access_list: Vec<(H160, Vec<H256>)>,
		is_transactional: bool,
		validate: bool,
		config: &evm::Config,
	) -> Result<CreateInfo, RunnerError<Self::Error>> {
		if validate {
			let _ = Self::validate(
				source,
				None,
				init.clone(),
				value,
				gas_limit,
				max_fee_per_gas,
				max_priority_fee_per_gas,
				nonce,
				access_list.clone(),
				is_transactional,
				config,
			)?;
		}
		let precompiles = T::PrecompilesValue::get();
		let code_hash = H256::from(sp_io::hashing::keccak_256(&init));
		Self::execute(
			source,
			value,
			gas_limit,
			max_fee_per_gas,
			max_priority_fee_per_gas,
			config,
			&precompiles,
			is_transactional,
			|executor| {
				let address = executor.create_address(evm::CreateScheme::Create2 {
					caller: source,
					code_hash,
					salt,
				});
				let (reason, _) =
					executor.transact_create2(source, value, init, salt, gas_limit, access_list);
				(reason, address)
			},
		)
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,metadata & self,"	fn metadata(&self) -> &StackSubstateMetadata<'config> {
		self.substate.metadata()
	}

	fn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {
		self.substate.metadata_mut()
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"enter & mut self , gas_limit : u64 , is_static : bool","	fn enter(&mut self, gas_limit: u64, is_static: bool) {
		self.substate.enter(gas_limit, is_static)
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,exit_commit & mut self,"	fn exit_commit(&mut self) -> Result<(), ExitError> {
		self.substate.exit_commit()
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,exit_revert & mut self,"	fn exit_revert(&mut self) -> Result<(), ExitError> {
		self.substate.exit_revert()
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,exit_discard & mut self,"	fn exit_discard(&mut self) -> Result<(), ExitError> {
		self.substate.exit_discard()
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"is_empty & self , address : H160","	fn is_empty(&self, address: H160) -> bool {
		Pallet::<T>::is_account_empty(&address)
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"deleted & self , address : H160","	fn deleted(&self, address: H160) -> bool {
		self.substate.deleted(address)
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"inc_nonce & mut self , address : H160","	fn inc_nonce(&mut self, address: H160) {
		let account_id = T::AddressMapping::into_account_id(address);
		frame_system::Pallet::<T>::inc_account_nonce(&account_id);
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"set_storage & mut self , address : H160 , index : H256 , value : H256","	fn set_storage(&mut self, address: H160, index: H256, value: H256) {
		if value == H256::default() {
			log::debug!(
				target: ""evm"",
				""Removing storage for {:?} [index: {:?}]"",
				address,
				index,
			);
			<AccountStorages<T>>::remove(address, index);
		} else {
			log::debug!(
				target: ""evm"",
				""Updating storage for {:?} [index: {:?}, value: {:?}]"",
				address,
				index,
				value,
			);
			<AccountStorages<T>>::insert(address, index, value);
		}
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"reset_storage & mut self , address : H160","	fn reset_storage(&mut self, address: H160) {
		let _ = <AccountStorages<T>>::remove_prefix(address, None);
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"log & mut self , address : H160 , topics : Vec < H256 > , data : Vec < u8 >","	fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {
		self.substate.log(address, topics, data)
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"set_deleted & mut self , address : H160","	fn set_deleted(&mut self, address: H160) {
		self.substate.set_deleted(address)
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"set_code & mut self , address : H160 , code : Vec < u8 >","	fn set_code(&mut self, address: H160, code: Vec<u8>) {
		log::debug!(
			target: ""evm"",
			""Inserting code ({} bytes) at {:?}"",
			code.len(),
			address
		);
		Pallet::<T>::create_account(address, code);
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"reset_balance & mut self , _address : H160","	fn reset_balance(&mut self, _address: H160) {
		// Do nothing on reset balance in Substrate.
		//
		// This function exists in EVM because a design issue
		// (arguably a bug) in SELFDESTRUCT that can cause total
		// issurance to be reduced. We do not need to replicate this.
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"touch & mut self , _address : H160","	fn touch(&mut self, _address: H160) {
		// Do nothing on touch in Substrate.
		//
		// EVM pallet considers all accounts to exist, and distinguish
		// only empty and non-empty accounts. This avoids many of the
		// subtle issues in EIP-161.
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"is_cold & self , address : H160","	fn is_cold(&self, address: H160) -> bool {
		self.substate
			.recursive_is_cold(&|a| a.accessed_addresses.contains(&address))
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,stack.rs,Rust,"is_storage_cold & self , address : H160 , key : H256","	fn is_storage_cold(&self, address: H160, key: H256) -> bool {
		self.substate
			.recursive_is_cold(&|a: &Accessed| a.accessed_storage.contains(&(address, key)))
	}",0,True,False,
https://github.com/paritytech/frontier.git,fed5e0a9577c10bea021721e8c2c5c378e16bf66,GitHub,2022-06-29 11:28:33+02:00,False,lib.rs,Rust,native_version,"pub fn native_version() -> NativeVersion {
	NativeVersion {
		runtime_version: VERSION,
		can_author_with: Default::default(),
	}
}",0,True,False,
